{"version":3,"file":"index.dev.js","sources":["../../src/functions.ts","../../src/resource.ts","../../src/di.ts","../../src/platform.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/logger.ts","../../src/module-loader.ts","../../src/eventaggregator.ts"],"sourcesContent":["import { emptyArray } from './platform.js';\nimport { Constructable, Overwrite } from './interfaces.js';\n\nconst isNumericLookup: Record<string, boolean> = {};\n\n/**\n * Efficiently determine whether the provided property key is numeric\n * (and thus could be an array indexer) or not.\n *\n * Always returns true for values of type `'number'`.\n *\n * Otherwise, only returns true for strings that consist only of positive integers.\n *\n * Results are cached.\n */\nexport function isArrayIndex(value: unknown): value is number | string {\n  switch (typeof value) {\n    case 'number':\n      return value >= 0 && (value | 0) === value;\n    case 'string': {\n      const result = isNumericLookup[value];\n      if (result !== void 0) {\n        return result;\n      }\n      const length = value.length;\n      if (length === 0) {\n        return isNumericLookup[value] = false;\n      }\n      let ch = 0;\n      for (let i = 0; i < length; ++i) {\n        ch = value.charCodeAt(i);\n        if (i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ || ch < 0x30 /* 0 */ || ch > 0x39/* 9 */) {\n          return isNumericLookup[value] = false;\n        }\n      }\n      return isNumericLookup[value] = true;\n    }\n    default:\n      return false;\n  }\n}\n\n/**\n * Determines if the value passed is a number or bigint for parsing purposes\n *\n * @param value - Value to evaluate\n */\nexport function isNumberOrBigInt(value: unknown): value is number | bigint {\n  switch (typeof value) {\n    case 'number':\n    case 'bigint':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determines if the value passed is a number or bigint for parsing purposes\n *\n * @param value - Value to evaluate\n */\nexport function isStringOrDate(value: unknown): value is string | Date {\n  switch (typeof value) {\n    case 'string':\n      return true;\n    case 'object':\n      return value instanceof Date;\n    default:\n      return false;\n  }\n}\n\n/**\n * Base implementation of camel and kebab cases\n */\nconst baseCase = (function () {\n  const enum CharKind {\n    none  = 0,\n    digit = 1,\n    upper = 2,\n    lower = 3,\n  }\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const isDigit = Object.assign(Object.create(null) as {}, {\n    '0': true,\n    '1': true,\n    '2': true,\n    '3': true,\n    '4': true,\n    '5': true,\n    '6': true,\n    '7': true,\n    '8': true,\n    '9': true,\n  } as Record<string, true | undefined>);\n\n  function charToKind(char: string): CharKind {\n    if (char === '') {\n      // We get this if we do charAt() with an index out of range\n      return CharKind.none;\n    }\n\n    if (char !== char.toUpperCase()) {\n      return CharKind.lower;\n    }\n\n    if (char !== char.toLowerCase()) {\n      return CharKind.upper;\n    }\n\n    if (isDigit[char] === true) {\n      return CharKind.digit;\n    }\n\n    return CharKind.none;\n  }\n\n  return function (input: string, cb: (char: string, sep: boolean) => string): string {\n    const len = input.length;\n    if (len === 0) {\n      return input;\n    }\n\n    let sep = false;\n    let output = '';\n\n    let prevKind: CharKind;\n\n    let curChar = '';\n    let curKind = CharKind.none;\n\n    let nextChar = input.charAt(0);\n    let nextKind = charToKind(nextChar);\n\n    for (let i = 0; i < len; ++i) {\n      prevKind = curKind;\n\n      curChar = nextChar;\n      curKind = nextKind;\n\n      nextChar = input.charAt(i + 1);\n      nextKind = charToKind(nextChar);\n\n      if (curKind === CharKind.none) {\n        if (output.length > 0) {\n          // Only set sep to true if it's not at the beginning of output.\n          sep = true;\n        }\n      } else {\n        if (!sep && output.length > 0 && curKind === CharKind.upper) {\n          // Separate UAFoo into UA Foo.\n          // Separate uaFOO into ua FOO.\n          sep = prevKind === CharKind.lower || nextKind === CharKind.lower;\n        }\n\n        output += cb(curChar, sep);\n        sep = false;\n      }\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to camelCase.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.\n *\n * Results are cached.\n */\nexport const camelCase = (function () {\n  const cache = Object.create(null) as Record<string, string | undefined>;\n\n  function callback(char: string, sep: boolean): string {\n    return sep ? char.toUpperCase() : char.toLowerCase();\n  }\n\n  return function (input: string): string {\n    let output = cache[input];\n    if (output === void 0) {\n      output = cache[input] = baseCase(input, callback);\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to PascalCase.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert element names to class names for synthetic types.\n *\n * Results are cached.\n */\nexport const pascalCase = (function () {\n  const cache = Object.create(null) as Record<string, string | undefined>;\n\n  return function (input: string): string {\n    let output = cache[input];\n    if (output === void 0) {\n      output = camelCase(input);\n      if (output.length > 0) {\n        output = output[0].toUpperCase() + output.slice(1);\n      }\n      cache[input] = output;\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to kebab-case.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.\n *\n * Results are cached.\n */\nexport const kebabCase = (function () {\n  const cache = Object.create(null) as Record<string, string | undefined>;\n\n  function callback(char: string, sep: boolean): string {\n    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();\n  }\n\n  return function (input: string): string {\n    let output = cache[input];\n    if (output === void 0) {\n      output = cache[input] = baseCase(input, callback);\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.\n *\n * Primarily used by Aurelia to convert DOM node lists to arrays.\n */\nexport function toArray<T = unknown>(input: ArrayLike<T>): T[] {\n  // benchmark: http://jsben.ch/xjsyF\n  const { length } = input;\n  const arr = Array(length);\n  for (let i = 0; i < length; ++i) {\n    arr[i] = input[i];\n  }\n  return arr;\n}\n\nconst ids: Record<string, number> = {};\n\n/**\n * Retrieve the next ID in a sequence for a given string, starting with `1`.\n *\n * Used by Aurelia to assign unique ID's to controllers and resources.\n *\n * Aurelia will always prepend the context name with `au$`, so as long as you avoid\n * using that convention you should be safe from collisions.\n */\nexport function nextId(context: string): number {\n  if (ids[context] === void 0) {\n    ids[context] = 0;\n  }\n  return ++ids[context];\n}\n\n/**\n * Reset the ID for the given string, so that `nextId` will return `1` again for the next call.\n *\n * Used by Aurelia to reset ID's in between unit tests.\n */\nexport function resetId(context: string): void {\n  ids[context] = 0;\n}\n\n/**\n * A compare function to pass to `Array.prototype.sort` for sorting numbers.\n * This is needed for numeric sort, since the default sorts them as strings.\n */\nexport function compareNumber(a: number, b: number): number {\n  return a - b;\n}\n\n/**\n * Efficiently merge and deduplicate the (primitive) values in two arrays.\n *\n * Does not deduplicate existing values in the first array.\n *\n * Guards against null or undefined arrays.\n *\n * Returns `emptyArray` if both arrays are either `null`, `undefined` or `emptyArray`\n *\n * @param slice - If `true`, always returns a new array copy (unless neither array is/has a value)\n */\nexport function mergeDistinct<T>(\n  arr1: readonly T[] | T[] | null | undefined,\n  arr2: readonly T[] | T[] | null | undefined,\n  slice: boolean,\n): T[] {\n  if (arr1 === void 0 || arr1 === null || arr1 === emptyArray) {\n    if (arr2 === void 0 || arr2 === null || arr2 === emptyArray) {\n      return emptyArray;\n    } else {\n      return slice ? arr2.slice(0) : arr2 as T[];\n    }\n  } else if (arr2 === void 0 || arr2 === null || arr2 === emptyArray) {\n    return slice ? arr1.slice(0) : arr1 as T[];\n  }\n\n  const lookup: Record<string, true | undefined> = {};\n  const arr3 = slice ? arr1.slice(0) : arr1 as (readonly T[]) & T[];\n\n  let len1 = arr1.length;\n  let len2 = arr2.length;\n\n  while (len1-- > 0) {\n    lookup[arr1[len1] as unknown as string] = true;\n  }\n\n  let item;\n  while (len2-- > 0) {\n    item = arr2[len2];\n    if (lookup[item as unknown as string] === void 0) {\n      arr3.push(item);\n      lookup[item as unknown as string] = true;\n    }\n  }\n\n  return arr3;\n}\n\n/**\n * Decorator. (lazily) bind the method to the class instance on first call.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function bound<T extends Function>(target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> {\n  return {\n    configurable: true,\n    enumerable: descriptor.enumerable,\n    get(): T {\n      const boundFn = descriptor.value!.bind(this);\n      Reflect.defineProperty(this, key, {\n        value: boundFn,\n        writable: true,\n        configurable: true,\n        enumerable: descriptor.enumerable,\n      });\n      return boundFn;\n    },\n  };\n}\n\nexport function mergeArrays<T>(...arrays: (readonly T[] | undefined)[]): T[] {\n  const result: T[] = [];\n  let k = 0;\n  const arraysLen = arrays.length;\n  let arrayLen = 0;\n  let array: readonly T[] | undefined;\n  for (let i = 0; i < arraysLen; ++i) {\n    array = arrays[i];\n    if (array !== void 0) {\n      arrayLen = array.length;\n      for (let j = 0; j < arrayLen; ++j) {\n        result[k++] = array[j];\n      }\n    }\n  }\n  return result;\n}\n\nexport function mergeObjects<T extends object>(...objects: readonly (T | undefined)[]): T {\n  const result: T = {} as unknown as T;\n  const objectsLen = objects.length;\n  let object: T | undefined;\n  let key: keyof T;\n  for (let i = 0; i < objectsLen; ++i) {\n    object = objects[i];\n    if (object !== void 0) {\n      for (key in object) {\n        result[key] = object[key];\n      }\n    }\n  }\n  return result;\n}\n\nexport function firstDefined<T>(...values: readonly (T | undefined)[]): T {\n  const len = values.length;\n  let value: T | undefined;\n  for (let i = 0; i < len; ++i) {\n    value = values[i];\n    if (value !== void 0) {\n      return value;\n    }\n  }\n  throw new Error(`No default value found`);\n}\n\nexport const getPrototypeChain = (function () {\n  const functionPrototype = Function.prototype;\n  const getPrototypeOf = Object.getPrototypeOf;\n\n  const cache = new WeakMap<Constructable, [Constructable, ...Constructable[]]>();\n  let proto = functionPrototype as Constructable;\n  let i = 0;\n  let chain: [Constructable, ...Constructable[]] | undefined = void 0;\n\n  return function <T extends Constructable> (Type: T): readonly [T, ...Constructable[]] {\n    chain = cache.get(Type);\n    if (chain === void 0) {\n      cache.set(Type, chain = [proto = Type]);\n      i = 0;\n      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {\n        chain[++i] = proto;\n      }\n    }\n    return chain as [T, ...Constructable[]];\n  };\n})();\n\nexport function toLookup<\n  T1 extends {},\n>(\n  obj1: T1,\n): T1;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n): Overwrite<T1, T2>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n): Overwrite<T1, Overwrite<T1, T2>>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n  T4 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n  obj4: T4,\n): Readonly<T1 & T2 & T3 & T4>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n  T4 extends {},\n  T5 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n  obj4: T4,\n  obj5: T5,\n): Readonly<T1 & T2 & T3 & T4 & T5>;\nexport function toLookup(...objs: {}[]): Readonly<{}> {\n  return Object.assign(Object.create(null) as {}, ...objs);\n}\n\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\nexport const isNativeFunction = (function () {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const lookup: WeakMap<Function, boolean> = new WeakMap();\n\n  let isNative = false as boolean | undefined;\n  let sourceText = '';\n  let i = 0;\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return function (fn: Function) {\n    isNative = lookup.get(fn);\n    if (isNative === void 0) {\n      sourceText = fn.toString();\n      i = sourceText.length;\n\n      // http://www.ecma-international.org/ecma-262/#prod-NativeFunction\n      isNative = (\n        // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string\n        i >= 29 &&\n        // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.\n        i <= 100 &&\n        // This whole heuristic *could* be tricked by a comment. Do we need to care about that?\n        sourceText.charCodeAt(i -  1) === 0x7D && // }\n        // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.\n        sourceText.charCodeAt(i -  2)  <= 0x20 && // whitespace\n        sourceText.charCodeAt(i -  3) === 0x5D && // ]\n        sourceText.charCodeAt(i -  4) === 0x65 && // e\n        sourceText.charCodeAt(i -  5) === 0x64 && // d\n        sourceText.charCodeAt(i -  6) === 0x6F && // o\n        sourceText.charCodeAt(i -  7) === 0x63 && // c\n        sourceText.charCodeAt(i -  8) === 0x20 && //\n        sourceText.charCodeAt(i -  9) === 0x65 && // e\n        sourceText.charCodeAt(i - 10) === 0x76 && // v\n        sourceText.charCodeAt(i - 11) === 0x69 && // i\n        sourceText.charCodeAt(i - 12) === 0x74 && // t\n        sourceText.charCodeAt(i - 13) === 0x61 && // a\n        sourceText.charCodeAt(i - 14) === 0x6E && // n\n        sourceText.charCodeAt(i - 15) === 0x58    // [\n      );\n\n      lookup.set(fn, isNative);\n    }\n    return isNative;\n  };\n})();\n\ntype UnwrapPromise<T> = T extends Promise<infer R> ? R : T;\ntype MaybePromise<T> = T extends Promise<infer R> ? (T | R) : (T | Promise<T>);\n\n/**\n * Normalize a potential promise via a callback, to ensure things stay synchronous when they can.\n *\n * If the value is a promise, it is `then`ed before the callback is invoked. Otherwise the callback is invoked synchronously.\n */\nexport function onResolve<TValue, TRet>(\n  maybePromise: TValue,\n  resolveCallback: (value: UnwrapPromise<TValue>) => TRet,\n): MaybePromise<TRet> {\n  if (maybePromise instanceof Promise) {\n    return maybePromise.then(resolveCallback) as MaybePromise<TRet>;\n  }\n  return resolveCallback(maybePromise as UnwrapPromise<TValue>) as MaybePromise<TRet>;\n}\n\n/**\n * Normalize an array of potential promises, to ensure things stay synchronous when they can.\n *\n * If exactly one value is a promise, then that promise is returned.\n *\n * If more than one value is a promise, a new `Promise.all` is returned.\n *\n * If none of the values is a promise, nothing is returned, to indicate that things can stay synchronous.\n */\nexport function resolveAll(\n  ...maybePromises: (void | Promise<void>)[]\n): void | Promise<void> {\n  let maybePromise: Promise<void> | void = void 0;\n  let firstPromise: Promise<void> | void = void 0;\n  let promises: Promise<void>[] | undefined = void 0;\n  for (let i = 0, ii = maybePromises.length; i < ii; ++i) {\n    maybePromise = maybePromises[i];\n    if ((maybePromise = maybePromises[i]) instanceof Promise) {\n      if (firstPromise === void 0) {\n        firstPromise = maybePromise;\n      } else if (promises === void 0) {\n        promises = [firstPromise, maybePromise];\n      } else {\n        promises.push(maybePromise);\n      }\n    }\n  }\n\n  if (promises === void 0) {\n    return firstPromise;\n  }\n  return Promise.all(promises) as unknown as Promise<void>;\n}\n","import { Metadata } from '@aurelia/metadata';\n\nimport { IContainer } from './di.js';\nimport { Constructable } from './interfaces.js';\nimport { emptyArray } from './platform.js';\n\nexport type ResourceType<\n  TUserType extends Constructable = Constructable,\n  TResInstance extends {} = {},\n  TResType extends {} = {},\n  TUserInstance extends InstanceType<TUserType> = InstanceType<TUserType>,\n> = (\n  new (...args: any[]) => TResInstance & TUserInstance\n) & {\n  readonly aliases?: readonly string[];\n} & TResType & TUserType;\n\nexport type ResourceDefinition<\n  TUserType extends Constructable = Constructable,\n  TResInstance extends {} = {},\n  TDef extends {} = {},\n  TResType extends {} = {},\n  TUserInstance extends InstanceType<TUserType> = InstanceType<TUserType>,\n> = {\n  readonly name: string;\n  readonly Type: ResourceType<TUserType, TResInstance, TResType, TUserInstance>;\n  readonly aliases?: readonly string[];\n\n  register(container: IContainer): void;\n} & TDef;\n\nexport type PartialResourceDefinition<TDef extends {} = {}> = {\n  readonly name: string;\n  readonly aliases?: readonly string[];\n} & TDef;\n\nexport interface IResourceKind<TType extends ResourceType, TDef extends ResourceDefinition> {\n  readonly name: string;\n  keyFrom(name: string): string;\n}\n\nconst annotation = {\n  name: 'au:annotation',\n  appendTo(target: Constructable, key: string): void {\n    const keys = Metadata.getOwn(annotation.name, target) as string[];\n    if (keys === void 0) {\n      Metadata.define(annotation.name, [key], target);\n    } else {\n      keys.push(key);\n    }\n  },\n  set(target: Constructable, prop: string, value: unknown): void {\n    Metadata.define(annotation.keyFor(prop), value, target);\n  },\n  get(target: Constructable, prop: string): unknown {\n    return Metadata.getOwn(annotation.keyFor(prop), target);\n  },\n  getKeys(target: Constructable): readonly string[] {\n    let keys = Metadata.getOwn(annotation.name, target) as string[];\n    if (keys === void 0) {\n      Metadata.define(annotation.name, keys = [], target);\n    }\n    return keys;\n  },\n  isKey(key: string): boolean {\n    return key.startsWith(annotation.name);\n  },\n  keyFor(name: string, context?: string): string {\n    if (context === void 0) {\n      return `${annotation.name}:${name}`;\n    }\n\n    return `${annotation.name}:${name}:${context}`;\n  },\n};\n\nconst resource = {\n  name: 'au:resource',\n  appendTo(target: Constructable, key: string): void {\n    const keys = Metadata.getOwn(resource.name, target) as string[];\n    if (keys === void 0) {\n      Metadata.define(resource.name, [key], target);\n    } else {\n      keys.push(key);\n    }\n  },\n  has(target: unknown): target is Constructable {\n    return Metadata.hasOwn(resource.name, target);\n  },\n  getAll(target: Constructable): readonly ResourceDefinition[] {\n    const keys = Metadata.getOwn(resource.name, target) as string[];\n    if (keys === void 0) {\n      return emptyArray;\n    } else {\n      return keys.map(k => Metadata.getOwn(k, target));\n    }\n  },\n  getKeys(target: Constructable): readonly string[] {\n    let keys = Metadata.getOwn(resource.name, target) as string[];\n    if (keys === void 0) {\n      Metadata.define(resource.name, keys = [], target);\n    }\n    return keys;\n  },\n  isKey(key: string): boolean {\n    return key.startsWith(resource.name);\n  },\n  keyFor(name: string, context?: string): string {\n    if (context === void 0) {\n      return `${resource.name}:${name}`;\n    }\n\n    return `${resource.name}:${name}:${context}`;\n  },\n};\n\nexport const Protocol = {\n  annotation,\n  resource,\n};\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * The order in which the values are checked:\n * 1. Annotations (usually set by decorators) have the highest priority; they override the definition as well as static properties on the type.\n * 2. Definition properties (usually set by the customElement decorator object literal) come next. They override static properties on the type.\n * 3. Static properties on the type come last. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)\n * 4. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromAnnotationOrDefinitionOrTypeOrDefault<\n  TDef extends PartialResourceDefinition,\n  K extends keyof TDef,\n>(\n  name: K,\n  def: TDef,\n  Type: Constructable,\n  getDefault: () => Required<TDef>[K],\n): Required<TDef>[K] {\n  let value = Metadata.getOwn(Protocol.annotation.keyFor(name as string), Type) as TDef[K] | undefined;\n  if (value === void 0) {\n    value = def[name];\n    if (value === void 0) {\n      value = (Type as Constructable & TDef)[name] as TDef[K] | undefined;\n      if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain\n        return getDefault();\n      }\n      return value;\n    }\n    return value;\n  }\n  return value;\n}\n\n/**\n * The order in which the values are checked:\n * 1. Annotations (usually set by decorators) have the highest priority; they override static properties on the type.\n * 2. Static properties on the typ. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)\n * 3. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromAnnotationOrTypeOrDefault<T, K extends keyof T, V>(\n  name: K,\n  Type: T,\n  getDefault: () => V,\n): V {\n  let value = Metadata.getOwn(Protocol.annotation.keyFor(name as string), Type) as V;\n  if (value === void 0) {\n    value = Type[name] as unknown as V;\n    if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain\n      return getDefault();\n    }\n    return value;\n  }\n  return value;\n}\n\n/**\n * The order in which the values are checked:\n * 1. Definition properties.\n * 2. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromDefinitionOrDefault<\n  TDef extends PartialResourceDefinition,\n  K extends keyof TDef,\n>(\n  name: K,\n  def: TDef,\n  getDefault: () => Required<TDef>[K],\n): Required<TDef>[K] {\n  const value = def[name];\n  if (value === void 0) {\n    return getDefault();\n  }\n  return value;\n}\n","import { Metadata, isObject, applyMetadataPolyfill } from '@aurelia/metadata';\n\napplyMetadataPolyfill(Reflect, false, false);\n\nimport { isArrayIndex, isNativeFunction } from './functions.js';\nimport { Class, Constructable, IDisposable } from './interfaces.js';\nimport { emptyArray } from './platform.js';\nimport { IResourceKind, Protocol, ResourceDefinition, ResourceType } from './resource.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type ResolveCallback<T = any> = (handler: IContainer, requestor: IContainer, resolver: IResolver<T>) => T;\n\nexport type InterfaceSymbol<K = any> = (target: Injectable<K>, property: string, index: number) => void;\n\n// This interface exists only to break a circular type referencing issue in the IServiceLocator interface.\n// Otherwise IServiceLocator references IResolver, which references IContainer, which extends IServiceLocator.\ninterface IResolverLike<C, K = any> {\n  readonly $isResolver: true;\n  resolve(handler: C, requestor: C): Resolved<K>;\n  getFactory?(container: C): (K extends Constructable ? IFactory<K> : never) | null;\n}\n\nexport interface IResolver<K = any> extends IResolverLike<IContainer, K> { }\nexport interface IDisposableResolver<K = any> extends IResolver<K> {\n  dispose(): void;\n}\n\nexport interface IRegistration<K = any> {\n  register(container: IContainer, key?: Key): IResolver<K>;\n}\n\nexport type Transformer<K> = (instance: Resolved<K>) => Resolved<K>;\n\nexport interface IFactory<T extends Constructable = any> {\n  readonly Type: T;\n  registerTransformer(transformer: Transformer<T>): void;\n  construct(container: IContainer, dynamicDependencies?: unknown[]): Resolved<T>;\n}\n\nexport interface IServiceLocator {\n  has<K extends Key>(key: K | Key, searchAncestors: boolean): boolean;\n  get<K extends Key>(key: INewInstanceResolver<K>): Resolved<K>;\n  get<K extends Key>(key: ILazyResolver<K>): IResolvedLazy<K>;\n  get<K extends Key>(key: IFactoryResolver<K>): IResolvedFactory<K>;\n  get<K extends Key>(key: IResolver<K>): Resolved<K>;\n  get<K extends Key>(key: K): Resolved<K>;\n  get<K extends Key>(key: Key): Resolved<K>;\n  get<K extends Key>(key: K | Key): Resolved<K>;\n  getAll<K extends Key>(key: K, searchAncestors?: boolean): readonly Resolved<K>[];\n  getAll<K extends Key>(key: Key, searchAncestors?: boolean): readonly Resolved<K>[];\n  getAll<K extends Key>(key: K | Key, searchAncestors?: boolean): readonly Resolved<K>[];\n}\n\nexport interface IRegistry {\n  register(container: IContainer, ...params: unknown[]): void | IResolver | IContainer;\n}\n\nexport interface IContainer extends IServiceLocator, IDisposable {\n  readonly id: number;\n  readonly root: IContainer;\n  register(...params: any[]): IContainer;\n  registerResolver<K extends Key, T = K>(key: K, resolver: IResolver<T>, isDisposable?: boolean): IResolver<T>;\n  registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean;\n  getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): IResolver<T> | null;\n  registerFactory<T extends Constructable>(key: T, factory: IFactory<T>): void;\n  invoke<T, TDeps extends unknown[] = unknown[]>(key: Constructable<T>, dynamicDependencies?: TDeps): T;\n  getFactory<T extends Constructable>(key: T): IFactory<T>;\n  createChild(config?: IContainerConfiguration): IContainer;\n  disposeResolvers(): void;\n  find<TType extends ResourceType, TDef extends ResourceDefinition>(kind: IResourceKind<TType, TDef>, name: string): TDef | null;\n  create<TType extends ResourceType, TDef extends ResourceDefinition>(kind: IResourceKind<TType, TDef>, name: string): InstanceType<TType> | null;\n}\n\nexport class ResolverBuilder<K> {\n  public constructor(\n    private container: IContainer,\n    private key: Key,\n  ) {}\n\n  public instance(value: K): IResolver<K> {\n    return this.registerResolver(ResolverStrategy.instance, value);\n  }\n\n  public singleton(value: Constructable): IResolver<K> {\n    return this.registerResolver(ResolverStrategy.singleton, value);\n  }\n\n  public transient(value: Constructable): IResolver<K> {\n    return this.registerResolver(ResolverStrategy.transient, value);\n  }\n\n  public callback(value: ResolveCallback<K>): IResolver<K> {\n    return this.registerResolver(ResolverStrategy.callback, value);\n  }\n\n  public cachedCallback(value: ResolveCallback<K>): IResolver<K> {\n    return this.registerResolver(ResolverStrategy.callback, cacheCallbackResult(value));\n  }\n\n  public aliasTo(destinationKey: Key): IResolver<K> {\n    return this.registerResolver(ResolverStrategy.alias, destinationKey);\n  }\n\n  private registerResolver(strategy: ResolverStrategy, state: unknown): IResolver<K> {\n    const { container, key } = this;\n    this.container = this.key = (void 0)!;\n    return container.registerResolver(key, new Resolver(key, strategy, state));\n  }\n}\n\nexport type RegisterSelf<T extends Constructable> = {\n  register(container: IContainer): IResolver<InstanceType<T>>;\n  registerInRequestor: boolean;\n};\n\nexport type Key = PropertyKey | object | InterfaceSymbol | Constructable | IResolver;\n\nexport type Resolved<K> = (\n  K extends InterfaceSymbol<infer T>\n    ? T\n    : K extends Constructable\n      ? InstanceType<K>\n      : K extends IResolverLike<any, infer T1>\n        ? T1 extends Constructable\n          ? InstanceType<T1>\n          : T1\n        : K\n);\n\nexport type Injectable<T = {}> = Constructable<T> & { inject?: Key[] };\n\nfunction cloneArrayWithPossibleProps<T>(source: readonly T[]): T[] {\n  const clone = source.slice();\n  const keys = Object.keys(source);\n  const len = keys.length;\n  let key: string;\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (!isArrayIndex(key)) {\n      clone[key] = source[key];\n    }\n  }\n  return clone;\n}\n\nexport interface IContainerConfiguration {\n  /**\n   * If `true`, `createChild` will inherit the resource resolvers from its parent container\n   * instead of only from the root container.\n   *\n   * Setting this flag will not implicitly perpetuate it in the child container hierarchy.\n   * It must be explicitly set on each call to `createChild`.\n   */\n  inheritParentResources?: boolean;\n  defaultResolver?(key: Key, handler: IContainer): IResolver;\n}\n\nexport const DefaultResolver = {\n  none(key: Key): IResolver {\n    if (__DEV__) {\n      throw Error(`${key.toString()} not registered, did you forget to add @singleton()?`);\n    } else {\n      throw Error(`AUR0002:${key.toString()}`);\n    }\n  },\n  singleton(key: Key): IResolver {return new Resolver(key, ResolverStrategy.singleton, key);},\n  transient(key: Key): IResolver {return new Resolver(key, ResolverStrategy.transient, key);},\n};\n\nexport class ContainerConfiguration implements IContainerConfiguration {\n  public static readonly DEFAULT: ContainerConfiguration = ContainerConfiguration.from({});\n\n  private constructor(\n    public readonly inheritParentResources: boolean,\n    public readonly defaultResolver: (key: Key, handler: IContainer) => IResolver,\n  ) {}\n\n  public static from(config?: IContainerConfiguration): ContainerConfiguration {\n    if (\n      config === void 0 ||\n      config === ContainerConfiguration.DEFAULT\n    ) {\n      return ContainerConfiguration.DEFAULT;\n    }\n    return new ContainerConfiguration(\n      config.inheritParentResources ?? false,\n      config.defaultResolver ?? DefaultResolver.singleton,\n    );\n  }\n}\n\nexport const DI = {\n  createContainer(config?: Partial<IContainerConfiguration>): IContainer {\n    return new Container(null, ContainerConfiguration.from(config));\n  },\n  getDesignParamtypes(Type: Constructable | Injectable): readonly Key[] | undefined {\n    return Metadata.getOwn('design:paramtypes', Type);\n  },\n  getAnnotationParamtypes(Type: Constructable | Injectable): readonly Key[] | undefined {\n    const key = Protocol.annotation.keyFor('di:paramtypes');\n    return Metadata.getOwn(key, Type);\n  },\n  getOrCreateAnnotationParamTypes: getOrCreateAnnotationParamTypes,\n  getDependencies: getDependencies,\n  /**\n   * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.\n   * ```ts\n   * const ILogger = DI.createInterface<Logger>('Logger');\n   * container.register(Registration.singleton(ILogger, getSomeLogger()));\n   * const log = container.get(ILogger);\n   * log.info('hello world');\n   * class Foo {\n   *   constructor( @ILogger log: ILogger ) {\n   *     log.info('hello world');\n   *   }\n   * }\n   * ```\n   * you can also build default registrations into your interface.\n   * ```ts\n   * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));\n   * const log = container.get(ILogger);\n   * log.info('hello world');\n   * class Foo {\n   *   constructor( @ILogger log: ILogger ) {\n   *     log.info('hello world');\n   *   }\n   * }\n   * ```\n   * but these default registrations won't work the same with other decorators that take keys, for example\n   * ```ts\n   * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));\n   * class Foo {\n   *   constructor( @optional(MyStr) public readonly str: string ) {\n   *   }\n   * }\n   * container.get(Foo).str; // returns undefined\n   * ```\n   * to fix this add this line somewhere before you do a `get`\n   * ```ts\n   * container.register(MyStr);\n   * container.get(Foo).str; // returns 'somestring'\n   * ```\n   *\n   * - @param friendlyName used to improve error messaging\n   */\n  createInterface<K extends Key>(configureOrName?: string | ((builder: ResolverBuilder<K>) => IResolver<K>), configuror?: (builder: ResolverBuilder<K>) => IResolver<K>): InterfaceSymbol<K> {\n    const configure = typeof configureOrName === 'function' ? configureOrName : configuror;\n    const friendlyName = typeof configureOrName === 'string' ? configureOrName : undefined;\n\n    const Interface = function (target: Injectable<K>, property: string, index: number): void {\n      if (target == null || new.target !== undefined) {\n        if (__DEV__) {\n          throw new Error(`No registration for interface: '${Interface.friendlyName}'`);\n        } else {\n          throw new Error(`AUR0001:${Interface.friendlyName}`);\n        }\n      }\n      const annotationParamtypes = getOrCreateAnnotationParamTypes(target);\n      annotationParamtypes[index] = Interface;\n    };\n    Interface.$isInterface = true;\n    Interface.friendlyName = friendlyName == null ? '(anonymous)' : friendlyName;\n\n    if (configure != null) {\n      Interface.register = function (container: IContainer, key?: Key): IResolver<K> {\n          return configure(new ResolverBuilder(container, key ?? Interface));\n      };\n    }\n\n    Interface.toString = function toString(): string {\n      return `InterfaceSymbol<${Interface.friendlyName}>`;\n    };\n\n    return Interface;\n  },\n  inject(...dependencies: Key[]): (target: Injectable, key?: string | number, descriptor?: PropertyDescriptor | number) => void {\n    return function (target: Injectable, key?: string | number, descriptor?: PropertyDescriptor | number): void {\n      if (typeof descriptor === 'number') { // It's a parameter decorator.\n        const annotationParamtypes = getOrCreateAnnotationParamTypes(target);\n        const dep = dependencies[0];\n        if (dep !== void 0) {\n          annotationParamtypes[descriptor] = dep;\n        }\n      } else if (key) { // It's a property decorator. Not supported by the container without plugins.\n        const annotationParamtypes = getOrCreateAnnotationParamTypes((target as unknown as { constructor: Injectable }).constructor);\n        const dep = dependencies[0];\n        if (dep !== void 0) {\n          annotationParamtypes[key as number] = dep;\n        }\n      } else if (descriptor) { // It's a function decorator (not a Class constructor)\n        const fn = descriptor.value;\n        const annotationParamtypes = getOrCreateAnnotationParamTypes(fn);\n        let dep: Key;\n        for (let i = 0; i < dependencies.length; ++i) {\n          dep = dependencies[i];\n          if (dep !== void 0) {\n            annotationParamtypes[i] = dep;\n          }\n        }\n      } else { // It's a class decorator.\n        const annotationParamtypes = getOrCreateAnnotationParamTypes(target);\n        let dep: Key;\n        for (let i = 0; i < dependencies.length; ++i) {\n          dep = dependencies[i];\n          if (dep !== void 0) {\n            annotationParamtypes[i] = dep;\n          }\n        }\n      }\n    };\n  },\n  /**\n   * Registers the `target` class as a transient dependency; each time the dependency is resolved\n   * a new instance will be created.\n   *\n   * @param target - The class / constructor function to register as transient.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   *\n   * @example ```ts\n   * // On an existing class\n   * class Foo { }\n   * DI.transient(Foo);\n   *\n   * // Inline declaration\n   * const Foo = DI.transient(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   */\n  transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n    target.register = function register(container: IContainer): IResolver<InstanceType<T>> {\n      const registration = Registration.transient(target as T, target as T);\n      return registration.register(container, target);\n    };\n    target.registerInRequestor = false;\n    return target as T & RegisterSelf<T>;\n  },\n  /**\n   * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n   * consecutive time the dependency is resolved, the same instance will be returned.\n   *\n   * @param target - The class / constructor function to register as a singleton.\n   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n   * @example ```ts\n   * // On an existing class\n   * class Foo { }\n   * DI.singleton(Foo);\n   *\n   * // Inline declaration\n   * const Foo = DI.singleton(class { });\n   * // Foo is now strongly typed with register\n   * Foo.register(container);\n   * ```\n   */\n  singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, options: SingletonOptions = defaultSingletonOptions):\n    T & RegisterSelf<T> {\n    target.register = function register(container: IContainer): IResolver<InstanceType<T>> {\n      const registration = Registration.singleton(target, target);\n      return registration.register(container, target);\n    };\n    target.registerInRequestor = options.scoped;\n    return target as T & RegisterSelf<T>;\n  },\n};\n\nfunction getDependencies(Type: Constructable | Injectable): Key[] {\n  // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n  // so be careful with making changes here as it can have a huge impact on complex end user apps.\n  // Preferably, only make changes to the dependency resolution process via a RFC.\n\n  const key = Protocol.annotation.keyFor('di:dependencies');\n  let dependencies = Metadata.getOwn(key, Type) as Key[] | undefined;\n  if (dependencies === void 0) {\n    // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n    // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n\n    // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n    // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n\n    const inject = (Type as Injectable).inject;\n    if (inject === void 0) {\n      // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n      const designParamtypes = DI.getDesignParamtypes(Type);\n      // au:annotation:di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n      const annotationParamtypes = DI.getAnnotationParamtypes(Type);\n      if (designParamtypes === void 0) {\n        if (annotationParamtypes === void 0) {\n          // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n          // there is no sound way to merge a type's deps with its prototype's deps\n          const Proto = Object.getPrototypeOf(Type);\n          if (typeof Proto === 'function' && Proto !== Function.prototype) {\n            dependencies = cloneArrayWithPossibleProps(getDependencies(Proto));\n          } else {\n            dependencies = [];\n          }\n        } else {\n          // No design:paramtypes so just use the au:annotation:di:paramtypes\n          dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n        }\n      } else if (annotationParamtypes === void 0) {\n        // No au:annotation:di:paramtypes so just use the design:paramtypes\n        dependencies = cloneArrayWithPossibleProps(designParamtypes);\n      } else {\n        // We've got both, so merge them (in case of conflict on same index, au:annotation:di:paramtypes take precedence)\n        dependencies = cloneArrayWithPossibleProps(designParamtypes);\n        let len = annotationParamtypes.length;\n        let auAnnotationParamtype: Key;\n        let i = 0;\n        for (; i < len; ++i) {\n          auAnnotationParamtype = annotationParamtypes[i];\n          if (auAnnotationParamtype !== void 0) {\n            dependencies[i] = auAnnotationParamtype;\n          }\n        }\n\n        const keys = Object.keys(annotationParamtypes);\n        let key: string;\n        i = 0;\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          key = keys[i];\n          if (!isArrayIndex(key)) {\n            dependencies[key] = annotationParamtypes[key];\n          }\n        }\n      }\n    } else {\n      // Ignore paramtypes if we have static inject\n      dependencies = cloneArrayWithPossibleProps(inject);\n    }\n\n    Metadata.define(key, dependencies, Type);\n    Protocol.annotation.appendTo(Type, key);\n  }\n\n  return dependencies;\n}\n\nfunction getOrCreateAnnotationParamTypes(Type: Constructable | Injectable): Key[] {\n  const key = Protocol.annotation.keyFor('di:paramtypes');\n  let annotationParamtypes = Metadata.getOwn(key, Type);\n  if (annotationParamtypes === void 0) {\n    Metadata.define(key, annotationParamtypes = [], Type);\n    Protocol.annotation.appendTo(Type, key);\n  }\n  return annotationParamtypes;\n}\n\nexport const IContainer = DI.createInterface<IContainer>('IContainer');\nexport const IServiceLocator = IContainer as unknown as InterfaceSymbol<IServiceLocator>;\n\nfunction createResolver(getter: (key: any, handler: IContainer, requestor: IContainer) => any): (key: any) => any {\n  return function (key: any): ReturnType<typeof DI.inject> {\n    const resolver: ReturnType<typeof DI.inject> & Partial<Pick<IResolver, 'resolve'>> & { $isResolver: true} = function (target: Injectable, property?: string | number, descriptor?: PropertyDescriptor | number): void {\n      DI.inject(resolver)(target, property, descriptor);\n    };\n\n    resolver.$isResolver = true;\n    resolver.resolve = function (handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor);\n    };\n\n    return resolver;\n  };\n}\n\nexport const inject = DI.inject;\n\nfunction transientDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>):\n  T & RegisterSelf<T> {\n  return DI.transient(target);\n}\n/**\n * Registers the decorated class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @example ```ts\n * &#64;transient()\n * class Foo { }\n * ```\n */\nexport function transient<T extends Constructable>(): typeof transientDecorator;\n/**\n * Registers the `target` class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @param target - The class / constructor function to register as transient.\n *\n * @example ```ts\n * &#64;transient()\n * class Foo { }\n * ```\n */\nexport function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;\nexport function transient<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> | typeof transientDecorator {\n  return target == null ? transientDecorator : transientDecorator(target);\n}\n\ntype SingletonOptions = { scoped: boolean };\nconst defaultSingletonOptions = { scoped: false };\n\nfunction singletonDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n  return DI.singleton(target);\n}\n/**\n * Registers the decorated class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @example ```ts\n * &#64;singleton()\n * class Foo { }\n * ```\n */\nexport function singleton<T extends Constructable>(): typeof singletonDecorator;\nexport function singleton<T extends Constructable>(options?: SingletonOptions): typeof singletonDecorator;\n/**\n * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @param target - The class / constructor function to register as a singleton.\n *\n * @example ```ts\n * &#64;singleton()\n * class Foo { }\n * ```\n */\nexport function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;\nexport function singleton<T extends Constructable>(targetOrOptions?: (T & Partial<RegisterSelf<T>>) | SingletonOptions): T & RegisterSelf<T> | typeof singletonDecorator {\n  if (typeof targetOrOptions === 'function') {\n    return DI.singleton(targetOrOptions);\n  }\n  return function <T extends Constructable>($target: T) {\n    return DI.singleton($target, targetOrOptions as SingletonOptions | undefined);\n  };\n}\n\nfunction createAllResolver(\n  getter: (key: any, handler: IContainer, requestor: IContainer, searchAncestors: boolean) => readonly any[]\n): (key: any, searchAncestors?: boolean) => ReturnType<typeof DI.inject> {\n  return function (key: any, searchAncestors?: boolean): ReturnType<typeof DI.inject> {\n    searchAncestors = !!searchAncestors;\n    const resolver: ReturnType<typeof DI.inject>\n      & Required<Pick<IResolver, 'resolve'>>\n      & { $isResolver: true}\n      = function (\n          target: Injectable,\n          property?: string | number,\n          descriptor?: PropertyDescriptor | number\n        ): void {\n          DI.inject(resolver)(target, property, descriptor);\n        };\n\n    resolver.$isResolver = true;\n    resolver.resolve = function (handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor, searchAncestors!);\n    };\n\n    return resolver;\n  };\n}\n\nexport const all = createAllResolver(\n  (key: any,\n    handler: IContainer,\n    requestor: IContainer,\n    searchAncestors: boolean\n  ) => requestor.getAll(key, searchAncestors)\n);\n\n/**\n * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.\n *\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a\n * new [['Math.random()']] number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * - @param key [[`Key`]]\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const lazy = createResolver((key: Key, handler: IContainer, requestor: IContainer) =>  {\n  return () => requestor.get(key);\n});\nexport type ILazyResolver<K = any> = IResolver<K>\n  // type only hack\n  & { __isLazy: undefined }\n  // any is needed for decorator usages\n  & ((...args: unknown[]) => any);\nexport type IResolvedLazy<K> = () => Resolved<K>;\n\n/**\n * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so rember to mark your input type as\n * possibly `undefined`!\n *\n * - @param key: [[`Key`]]\n *\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const optional = createResolver((key: Key, handler: IContainer, requestor: IContainer) =>  {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return undefined;\n  }\n});\n/**\n * ignore tells the container not to try to inject a dependency\n */\nexport function ignore(target: Injectable, property?: string | number, descriptor?: PropertyDescriptor | number): void {\n  DI.inject(ignore)(target, property, descriptor);\n}\nignore.$isResolver = true;\nignore.resolve = () => undefined;\n\n/**\n * Inject a function that will return a resolved instance of the [[key]] given.\n * Also supports passing extra parameters to the invocation of the resolved constructor of [[key]]\n *\n * For typings, it's a function that take 0 or more arguments and return an instance. Example:\n * ```ts\n * class Foo {\n *   constructor( @factory(MyService) public createService: (...args: unknown[]) => MyService)\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * const myService_1 = foo.createService('user service')\n * const myService_2 = foo.createService('content service')\n * ```\n *\n * ```ts\n * class Foo {\n *   constructor( @factory('random') public createRandomizer: () => Randomizer)\n * }\n * container.get(Foo).createRandomizer(); // create a randomizer\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a\n * new instance of Randomizer each time.\n *\n * `@factory` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * - @param key [[`Key`]]\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const factory = createResolver((key: any, handler: IContainer, requestor: IContainer) => {\n  return (...args: unknown[]) => handler.getFactory(key).construct(requestor, args);\n}) as <K>(key: K) => IFactoryResolver<K>;\nexport type IFactoryResolver<K = any> = IResolver<K>\n  // type only hack\n  & { __isFactory: undefined }\n  // any is needed for decorator usage\n  & ((...args: unknown[]) => any);\nexport type IResolvedFactory<K> = (...args: unknown[]) => Resolved<K>;\n\nexport const newInstanceForScope = createResolver((key: any, handler: IContainer, requestor: IContainer) => {\n  const instance = createNewInstance(key, handler, requestor);\n  const instanceProvider: InstanceProvider<any> = new InstanceProvider<any>(String(key), instance);\n  requestor.registerResolver(key, instanceProvider);\n\n  return instance;\n}) as <K>(key: K) => INewInstanceResolver<K>;\n\nexport const newInstanceOf = createResolver(\n  (key: any, handler: IContainer, requestor: IContainer) => createNewInstance(key, handler, requestor)\n) as <K>(key: K) => INewInstanceResolver<K>;\n\nexport type INewInstanceResolver<T> = {\n  __newInstance: undefined;\n  // any is needed for decorator usage\n  (...args: unknown[]): any;\n};\n\nfunction createNewInstance(key: any, handler: IContainer, requestor: IContainer) {\n  return handler.getFactory(key).construct(requestor);\n}\n\n/** @internal */\nexport const enum ResolverStrategy {\n  instance = 0,\n  singleton = 1,\n  transient = 2,\n  callback = 3,\n  array = 4,\n  alias = 5\n}\n\n/** @internal */\nexport class Resolver implements IResolver, IRegistration {\n  public constructor(\n    public key: Key,\n    public strategy: ResolverStrategy,\n    public state: any,\n  ) {}\n\n  public get $isResolver(): true { return true; }\n\n  private resolving: boolean = false;\n\n  public register(container: IContainer, key?: Key): IResolver {\n    return container.registerResolver(key || this.key, this);\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): any {\n    switch (this.strategy) {\n      case ResolverStrategy.instance:\n        return this.state;\n      case ResolverStrategy.singleton: {\n        if (this.resolving) {\n          if (__DEV__) {\n            throw new Error(`Cyclic dependency found: ${this.state.name}`);\n          } else {\n            throw new Error(`AUR0003:${this.state.name}`);\n          }\n        }\n        this.resolving = true;\n        this.state = handler.getFactory(this.state as Constructable).construct(requestor);\n        this.strategy = ResolverStrategy.instance;\n        this.resolving = false;\n        return this.state;\n      }\n      case ResolverStrategy.transient: {\n        // Always create transients from the requesting container\n        const factory = handler.getFactory(this.state as Constructable);\n        if (factory === null) {\n          if (__DEV__) {\n            throw new Error(`Resolver for ${String(this.key)} returned a null factory`);\n          } else {\n            throw new Error(`AUR0004:${String(this.key)}`);\n          }\n        }\n        return factory.construct(requestor);\n      }\n      case ResolverStrategy.callback:\n        return (this.state as ResolveCallback)(handler, requestor, this);\n      case ResolverStrategy.array:\n        return (this.state as IResolver[])[0].resolve(handler, requestor);\n      case ResolverStrategy.alias:\n        return requestor.get(this.state);\n      default:\n        if (__DEV__) {\n          throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);\n        } else {\n          throw new Error(`AUR0005:${this.strategy}`);\n        }\n    }\n  }\n\n  public getFactory(container: IContainer): IFactory | null {\n    switch (this.strategy) {\n      case ResolverStrategy.singleton:\n      case ResolverStrategy.transient:\n        return container.getFactory(this.state as Constructable);\n      case ResolverStrategy.alias:\n        return container.getResolver(this.state)?.getFactory?.(container) ?? null;\n      default:\n        return null;\n    }\n  }\n}\n\n/** @internal */\nexport interface IInvoker<T extends Constructable = any> {\n  invoke(container: IContainer, fn: T, dependencies: Key[]): Resolved<T>;\n  invokeWithDynamicDependencies(\n    container: IContainer,\n    fn: T,\n    staticDependencies: Key[],\n    dynamicDependencies: Key[]\n  ): Resolved<T>;\n}\n\nfunction containerGetKey(this: IContainer, d: Key) {\n  return this.get(d);\n}\n\nfunction transformInstance<T>(inst: Resolved<T>, transform: (instance: any) => any) {\n  return transform(inst);\n}\n\n/** @internal */\nexport class Factory<T extends Constructable = any> implements IFactory<T> {\n  private transformers: ((instance: any) => any)[] | null = null;\n  public constructor(\n    public Type: T,\n    private readonly dependencies: Key[],\n  ) {}\n\n  public construct(container: IContainer, dynamicDependencies?: unknown[]): Resolved<T> {\n    let instance: Resolved<T>;\n    if (dynamicDependencies === void 0) {\n      instance = new this.Type(...this.dependencies.map(containerGetKey, container)) as Resolved<T>;\n    } else {\n      instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies) as Resolved<T>;\n    }\n\n    if (this.transformers == null) {\n      return instance;\n    }\n\n    return this.transformers.reduce(transformInstance, instance);\n  }\n\n  public registerTransformer(transformer: (instance: any) => any): void {\n    (this.transformers ??= []).push(transformer);\n  }\n}\n\nconst containerResolver: IResolver = {\n  $isResolver: true,\n  resolve(handler: IContainer, requestor: IContainer): IContainer {\n    return requestor;\n  }\n};\n\nfunction isRegistry(obj: IRegistry | Record<string, IRegistry>): obj is IRegistry {\n  return typeof obj.register === 'function';\n}\n\nfunction isSelfRegistry<T extends Constructable>(obj: RegisterSelf<T>): obj is RegisterSelf<T> {\n  return isRegistry(obj) && typeof obj.registerInRequestor === 'boolean';\n}\n\nfunction isRegisterInRequester<T extends Constructable>(obj: RegisterSelf<T>): obj is RegisterSelf<T> {\n  return isSelfRegistry(obj) && obj.registerInRequestor;\n}\n\nfunction isClass<T extends { prototype?: any }>(obj: T): obj is Class<any, T> {\n  return obj.prototype !== void 0;\n}\n\nfunction isResourceKey(key: Key): key is string {\n  return typeof key === 'string' && key.indexOf(':') > 0;\n}\n\nconst InstrinsicTypeNames = new Set<string>([\n  'Array',\n  'ArrayBuffer',\n  'Boolean',\n  'DataView',\n  'Date',\n  'Error',\n  'EvalError',\n  'Float32Array',\n  'Float64Array',\n  'Function',\n  'Int8Array',\n  'Int16Array',\n  'Int32Array',\n  'Map',\n  'Number',\n  'Object',\n  'Promise',\n  'RangeError',\n  'ReferenceError',\n  'RegExp',\n  'Set',\n  'SharedArrayBuffer',\n  'String',\n  'SyntaxError',\n  'TypeError',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Uint16Array',\n  'Uint32Array',\n  'URIError',\n  'WeakMap',\n  'WeakSet',\n]);\n\nconst factoryKey = 'di:factory';\nconst factoryAnnotationKey = Protocol.annotation.keyFor(factoryKey);\nlet containerId = 0;\n/** @internal */\nexport class Container implements IContainer {\n  public readonly id: number = ++containerId;\n  private registerDepth: number = 0;\n\n  public get depth(): number {\n    return this.parent === null ? 0 : this.parent.depth + 1;\n  }\n  public readonly root: Container;\n\n  private readonly resolvers: Map<Key, IResolver | IDisposableResolver>;\n  // Factories are \"global\" per container tree\n  private readonly factories: Map<Constructable, Factory>;\n\n  private resourceResolvers: Record<string, IResolver | IDisposableResolver | undefined>;\n\n  private readonly disposableResolvers: Set<IDisposableResolver> = new Set<IDisposableResolver>();\n\n  public constructor(\n    private readonly parent: Container | null,\n    private readonly config: ContainerConfiguration,\n  ) {\n    if (parent === null) {\n      this.root = this;\n\n      this.resolvers = new Map();\n      this.factories = new Map<Constructable, Factory>();\n\n      this.resourceResolvers = Object.create(null);\n    } else {\n      this.root = parent.root;\n\n      this.resolvers = new Map();\n      this.factories = parent.factories;\n\n      if (config.inheritParentResources) {\n        this.resourceResolvers = Object.assign(\n          Object.create(null),\n          parent.resourceResolvers,\n          this.root.resourceResolvers,\n        );\n      } else {\n        this.resourceResolvers = Object.create(null);\n      }\n    }\n\n    this.resolvers.set(IContainer, containerResolver);\n  }\n\n  public register(...params: any[]): IContainer {\n    if (++this.registerDepth === 100) {\n      // TODO: change to reporter.error and add various possible causes in description.\n      // Most likely cause is trying to register a plain object that does not have a\n      // register method and is not a class constructor\n      if (__DEV__) {\n        throw new Error(`Unable to autoregister dependency: [${params.map(String)}]`);\n      } else {\n        throw new Error(`AUR0006:${params.map(String)}`);\n      }\n    }\n    let current: IRegistry | Record<string, IRegistry>;\n    let keys: string[];\n    let value: IRegistry;\n    let j: number;\n    let jj: number;\n    let i = 0;\n    // eslint-disable-next-line\n    let ii = params.length;\n    for (; i < ii; ++i) {\n      current = params[i];\n      if (!isObject(current)) {\n        continue;\n      }\n      if (isRegistry(current)) {\n        current.register(this);\n      } else if (Protocol.resource.has(current)) {\n        const defs = Protocol.resource.getAll(current);\n        if (defs.length === 1) {\n          // Fast path for the very common case\n          defs[0].register(this);\n        } else {\n          j = 0;\n          jj = defs.length;\n          while (jj > j) {\n            defs[j].register(this);\n            ++j;\n          }\n        }\n      } else if (isClass(current)) {\n        Registration.singleton(current, current as Constructable).register(this);\n      } else {\n        keys = Object.keys(current);\n        j = 0;\n        jj = keys.length;\n        for (; j < jj; ++j) {\n          value = current[keys[j]];\n          if (!isObject(value)) {\n            continue;\n          }\n          // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n          if (isRegistry(value)) {\n            value.register(this);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n    --this.registerDepth;\n    return this;\n  }\n\n  public registerResolver<K extends Key, T = K>(key: K, resolver: IResolver<T>, isDisposable: boolean = false): IResolver<T> {\n    validateKey(key);\n\n    const resolvers = this.resolvers;\n    const result = resolvers.get(key);\n\n    if (result == null) {\n      resolvers.set(key, resolver);\n      if (isResourceKey(key)) {\n        if (this.resourceResolvers[key] !== void 0) {\n          if (__DEV__) {\n            throw new Error(`Resource key \"${key}\" already registered`);\n          } else {\n            throw new Error(`AUR0007:${key}`);\n          }\n        }\n        this.resourceResolvers[key] = resolver;\n      }\n    } else if (result instanceof Resolver && result.strategy === ResolverStrategy.array) {\n      (result.state as IResolver[]).push(resolver);\n    } else {\n      resolvers.set(key, new Resolver(key, ResolverStrategy.array, [result, resolver]));\n    }\n\n    if (isDisposable) {\n      this.disposableResolvers.add(resolver as IDisposableResolver<T>);\n    }\n\n    return resolver;\n  }\n\n  // public deregisterResolverFor<K extends Key, T = K>(key: K): void {\n  //   // const console =  (globalThis as any).console;\n  //   // console.group(\"deregisterResolverFor\");\n  //   validateKey(key);\n\n  //   let current: Container = this;\n  //   let resolver: IResolver | undefined;\n\n  //   while (current != null) {\n  //     resolver = current.resolvers.get(key);\n\n  //     if (resolver != null) { break; }\n  //     if (current.parent == null) { return; }\n  //     current = current.parent;\n  //   }\n\n  //   if (resolver === void 0) { return; }\n  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n  //     throw new Error('Cannot deregister a resolver with array strategy');\n  //   }\n  //   if (this.disposableResolvers.has(resolver as IDisposableResolver<T>)) {\n  //     (resolver as IDisposableResolver<T>).dispose();\n  //   }\n  //   if (isResourceKey(key)) {\n  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  //     delete this.resourceResolvers[key];\n  //   }\n  //   // console.log(`BEFORE delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);\n  //   current.resolvers.delete(key);\n  //   // console.log(`AFTER delete ${Array.from(current.resolvers.keys()).map((k) => k.toString())}`);\n  //   // console.groupEnd();\n  // }\n\n  public registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean {\n    const resolver = this.getResolver(key);\n\n    if (resolver == null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const factory = resolver.getFactory(this);\n\n      if (factory == null) {\n        return false;\n      }\n\n      // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n      // type Constructable. So the return type of that optional method has this additional constraint, which\n      // seems to confuse the type checker.\n      factory.registerTransformer(transformer as unknown as Transformer<Constructable>);\n      return true;\n    }\n\n    return false;\n  }\n\n  public getResolver<K extends Key, T = K>(key: K | Key, autoRegister: boolean = true): IResolver<T> | null {\n    validateKey(key);\n\n    if ((key as unknown as IResolver).resolve !== void 0) {\n      return key as unknown as IResolver;\n    }\n\n    let current: Container = this;\n    let resolver: IResolver | undefined;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          const handler = (isRegisterInRequester(key as unknown as RegisterSelf<Constructable>)) ? this : current;\n          return autoRegister ? this.jitRegister(key, handler) : null;\n        }\n\n        current = current.parent;\n      } else {\n        return resolver;\n      }\n    }\n\n    return null;\n  }\n\n  public has<K extends Key>(key: K, searchAncestors: boolean = false): boolean {\n    return this.resolvers.has(key)\n      ? true\n      : searchAncestors && this.parent != null\n        ? this.parent.has(key, true)\n        : false;\n  }\n\n  public get<K extends Key>(key: K): Resolved<K> {\n    validateKey(key);\n\n    if ((key as IResolver).$isResolver) {\n      return (key as IResolver).resolve(this, this);\n    }\n\n    let current: Container = this;\n    let resolver: IResolver | undefined;\n\n    while (current != null) {\n      resolver = current.resolvers.get(key);\n\n      if (resolver == null) {\n        if (current.parent == null) {\n          const handler = (isRegisterInRequester(key as unknown as RegisterSelf<Constructable>)) ? this : current;\n          resolver = this.jitRegister(key, handler);\n          return resolver.resolve(current, this);\n        }\n\n        current = current.parent;\n      } else {\n        return resolver.resolve(current, this);\n      }\n    }\n\n    if (__DEV__) {\n      throw new Error(`Unable to resolve key: ${key}`);\n    } else {\n      throw new Error(`AUR0008:${key}`);\n    }\n  }\n\n  public getAll<K extends Key>(key: K, searchAncestors: boolean = false): readonly Resolved<K>[] {\n    validateKey(key);\n\n    const requestor = this;\n    let current: Container | null = requestor;\n    let resolver: IResolver | undefined;\n\n    if (searchAncestors) {\n      let resolutions: any[] = emptyArray;\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n        if (resolver != null) {\n          resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));\n        }\n        current = current.parent;\n      }\n      return resolutions;\n    } else {\n      while (current != null) {\n        resolver = current.resolvers.get(key);\n\n        if (resolver == null) {\n          current = current.parent;\n\n          if (current == null) {\n            return emptyArray;\n          }\n        } else {\n          return buildAllResponse(resolver, current, requestor);\n        }\n      }\n    }\n\n    return emptyArray;\n  }\n\n  public invoke<T, TDeps extends unknown[] = unknown[]>(Type: Constructable<T>, dynamicDependencies?: TDeps): T {\n    if (isNativeFunction(Type)) {\n      throw createNativeInvocationError(Type);\n    }\n    if (dynamicDependencies === void 0) {\n      return new Type(...getDependencies(Type).map(containerGetKey, this));\n    } else {\n      return new Type(...getDependencies(Type).map(containerGetKey, this), ...dynamicDependencies);\n    }\n  }\n\n  public getFactory<K extends Constructable>(Type: K): IFactory<K> {\n    let factory = this.factories.get(Type);\n    if (factory === void 0) {\n      if (isNativeFunction(Type)) {\n        throw createNativeInvocationError(Type);\n      }\n      this.factories.set(Type, factory = new Factory<K>(Type, getDependencies(Type)));\n    }\n    return factory;\n  }\n\n  public registerFactory<K extends Constructable>(key: K, factory: IFactory<K>): void {\n    this.factories.set(key, factory as Factory);\n  }\n\n  public createChild(config?: Partial<IContainerConfiguration>): IContainer {\n    if (config === void 0 && this.config.inheritParentResources) {\n      if (this.config === ContainerConfiguration.DEFAULT) {\n        return new Container(this, this.config);\n      }\n      return new Container(\n        this,\n        ContainerConfiguration.from({\n          ...this.config,\n          inheritParentResources: false,\n        }),\n      );\n    }\n    return new Container(this, ContainerConfiguration.from(config ?? this.config));\n  }\n\n  public disposeResolvers() {\n    let disposeable: IDisposable;\n    for (disposeable of this.disposableResolvers) {\n      disposeable.dispose();\n    }\n  }\n\n  public find<TType extends ResourceType, TDef extends ResourceDefinition>(kind: IResourceKind<TType, TDef>, name: string): TDef | null {\n    const key = kind.keyFrom(name);\n    let resolver = this.resourceResolvers[key];\n    if (resolver === void 0) {\n      resolver = this.root.resourceResolvers[key];\n      if (resolver === void 0) {\n        return null;\n      }\n    }\n\n    if (resolver === null) {\n      return null;\n    }\n\n    if (typeof resolver.getFactory === 'function') {\n      const factory = resolver.getFactory(this);\n      if (factory === null || factory === void 0) {\n        return null;\n      }\n\n      const definition = Metadata.getOwn(kind.name, factory.Type);\n      if (definition === void 0) {\n        // TODO: we may want to log a warning here, or even throw. This would happen if a dependency is registered with a resource-like key\n        // but does not actually have a definition associated via the type's metadata. That *should* generally not happen.\n        return null;\n      }\n\n      return definition;\n    }\n\n    return null;\n  }\n\n  public create<TType extends ResourceType, TDef extends ResourceDefinition>(kind: IResourceKind<TType, TDef>, name: string): InstanceType<TType> | null {\n    const key = kind.keyFrom(name);\n    let resolver = this.resourceResolvers[key];\n    if (resolver === void 0) {\n      resolver = this.root.resourceResolvers[key];\n      if (resolver === void 0) {\n        return null;\n      }\n      return resolver.resolve(this.root, this) ?? null;\n    }\n    return resolver.resolve(this, this) ?? null;\n  }\n\n  public dispose(): void {\n    if (this.disposableResolvers.size > 0) {\n      this.disposeResolvers();\n    }\n    this.resolvers.clear();\n  }\n\n  private jitRegister(keyAsValue: any, handler: Container): IResolver {\n    if (typeof keyAsValue !== 'function') {\n      if (__DEV__) {\n        throw new Error(`Attempted to jitRegister something that is not a constructor: '${keyAsValue}'. Did you forget to register this resource?`);\n      } else {\n        throw new Error(`AUR0009:${keyAsValue}`);\n      }\n    }\n    if (InstrinsicTypeNames.has(keyAsValue.name)) {\n      if (__DEV__) {\n        throw new Error(`Attempted to jitRegister an intrinsic type: ${keyAsValue.name}. Did you forget to add @inject(Key)`);\n      } else {\n        throw new Error(`AUR0010:${keyAsValue.name}`);\n      }\n    }\n\n    if (isRegistry(keyAsValue)) {\n      const registrationResolver = keyAsValue.register(handler, keyAsValue);\n      if (!(registrationResolver instanceof Object) || (registrationResolver as IResolver).resolve == null) {\n        const newResolver = handler.resolvers.get(keyAsValue);\n        if (newResolver != void 0) {\n          return newResolver;\n        }\n        if (__DEV__) {\n          throw new Error(`Invalid resolver returned from the static register method`);\n        } else {\n          throw new Error(`AUR0011`);\n        }\n      }\n      return registrationResolver as IResolver;\n    } else if (Protocol.resource.has(keyAsValue)) {\n      const defs = Protocol.resource.getAll(keyAsValue);\n      if (defs.length === 1) {\n        // Fast path for the very common case\n        defs[0].register(handler);\n      } else {\n        const len = defs.length;\n        for (let d = 0; d < len; ++d) {\n          defs[d].register(handler);\n        }\n      }\n      const newResolver = handler.resolvers.get(keyAsValue);\n      if (newResolver != void 0) {\n        return newResolver;\n      }\n      if (__DEV__) {\n        throw new Error(`Invalid resolver returned from the static register method`);\n      } else {\n        throw new Error(`AUR0011`);\n      }\n    } else if (keyAsValue.$isInterface) {\n      if (__DEV__) {\n        throw new Error(`Attempted to jitRegister an interface: ${keyAsValue.friendlyName}`);\n      } else {\n        throw new Error(`AUR0012:${keyAsValue.friendlyName}`);\n      }\n    } else {\n      const resolver = this.config.defaultResolver(keyAsValue, handler);\n      handler.resolvers.set(keyAsValue, resolver);\n      return resolver;\n    }\n  }\n}\n\n/**\n * An implementation of IRegistry that delegates registration to a\n * separately registered class. The ParameterizedRegistry facilitates the\n * passing of parameters to the final registry.\n */\nexport class ParameterizedRegistry implements IRegistry {\n  public constructor(\n    private readonly key: Key,\n    private readonly params: unknown[]\n  ) {}\n\n  public register(container: IContainer): void {\n    if (container.has(this.key, true)) {\n      const registry = container.get<IRegistry>(this.key);\n      registry.register(container, ...this.params);\n    } else {\n      container.register(...this.params.filter(x => typeof x === 'object'));\n    }\n  }\n}\n\ntype ResolverLookup = WeakMap<IResolver, unknown>;\nconst containerLookup = new WeakMap<IContainer, ResolverLookup>();\n\nfunction cacheCallbackResult<T>(fun: ResolveCallback<T>): ResolveCallback<T> {\n  return function (handler: IContainer, requestor: IContainer, resolver: IResolver): T {\n    let resolverLookup = containerLookup.get(handler);\n    if (resolverLookup === void 0) {\n      containerLookup.set(handler, resolverLookup = new WeakMap());\n    }\n    if (resolverLookup.has(resolver)) {\n      return resolverLookup.get(resolver) as T;\n    }\n    const t = fun(handler, requestor, resolver);\n    resolverLookup.set(resolver, t);\n    return t;\n  };\n}\n\n/**\n * you can use the resulting {@linkcode IRegistration} of any of the factory methods\n * to register with the container, e.g.\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n */\nexport const Registration = {\n  /**\n   * allows you to pass an instance.\n   * Every time you request this {@linkcode Key} you will get this instance back.\n   * ```\n   * Registration.instance(Foo, new Foo()));\n   * ```\n   *\n   * @param key\n   * @param value\n   */\n  instance<T>(key: Key, value: T): IRegistration<T> {\n    return new Resolver(key, ResolverStrategy.instance, value);\n  },\n  /**\n   * Creates an instance from the class.\n   * Every time you request this {@linkcode Key} you will get the same one back.\n   * ```\n   * Registration.singleton(Foo, Foo);\n   * ```\n   *\n   * @param key\n   * @param value\n   */\n  singleton<T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> {\n    return new Resolver(key, ResolverStrategy.singleton, value);\n  },\n  /**\n   * Creates an instance from a class.\n   * Every time you request this {@linkcode Key} you will get a new instance.\n   * ```\n   * Registration.instance(Foo, Foo);\n   * ```\n   *\n   * @param key\n   * @param value\n   */\n  transient<T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> {\n    return new Resolver(key, ResolverStrategy.transient, value);\n  },\n  /**\n   * Creates an instance from the method passed.\n   * Every time you request this {@linkcode Key} you will get a new instance.\n   * ```\n   * Registration.callback(Foo, () => new Foo());\n   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key\n   * @param callback\n   */\n  callback<T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> {\n    return new Resolver(key, ResolverStrategy.callback, callback);\n  },\n  /**\n   * Creates an instance from the method passed.\n   * On the first request for the {@linkcode Key} your callback is called and returns an instance.\n   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.\n   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.\n   * Should all references to the resolver returned be removed, the cache will expire.\n   * ```\n   * Registration.cachedCallback(Foo, () => new Foo());\n   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key\n   * @param callback\n   */\n  cachedCallback<T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> {\n    return new Resolver(key, ResolverStrategy.callback, cacheCallbackResult(callback));\n  },\n  /**\n   * creates an alternate {@linkcode Key} to retrieve an instance by.\n   * Returns the same scope as the original {@linkcode Key}.\n   * ```\n   * Register.singleton(Foo, Foo)\n   * Register.aliasTo(Foo, MyFoos);\n   *\n   * container.getAll(MyFoos) // contains an instance of Foo\n   * ```\n   *\n   * @param originalKey\n   * @param aliasKey\n   */\n  aliasTo<T>(originalKey: T, aliasKey: Key): IRegistration<Resolved<T>> {\n    return new Resolver(aliasKey, ResolverStrategy.alias, originalKey);\n  },\n  /**\n   * @internal\n   * @param key\n   * @param params\n   */\n  defer(key: Key, ...params: unknown[]): IRegistry {\n    return new ParameterizedRegistry(key, params);\n  }\n};\n\nexport class InstanceProvider<K extends Key> implements IDisposableResolver<K | null> {\n  private instance: Resolved<K> | null = null;\n\n  public constructor(\n    public readonly friendlyName?: string,\n    /**\n     * if not undefined, then this is the value this provider will resolve to\n     * until overridden by explicit prepare call\n     */\n    instance?: Resolved<K> | null,\n  ) {\n    if (instance !== void 0) {\n      this.instance = instance;\n    }\n  }\n\n  public prepare(instance: Resolved<K>): void {\n    this.instance = instance;\n  }\n\n  public get $isResolver(): true {return true;}\n\n  public resolve(): Resolved<K> | null {\n    if (this.instance == null) {\n      if (__DEV__) {\n        throw new Error(`Cannot call resolve ${this.friendlyName} before calling prepare or after calling dispose.`);\n      } else {\n        throw new Error(`AUR0013:${this.friendlyName}`);\n      }\n    }\n    return this.instance;\n  }\n\n  public dispose(): void {\n    this.instance = null;\n  }\n}\n\n/** @internal */\nexport function validateKey(key: any): void {\n  if (key === null || key === void 0) {\n    if (__DEV__) {\n      throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\\'t exist with DI?');\n    } else {\n      throw new Error(`AUR0014`);\n    }\n  }\n}\n\nfunction buildAllResponse(resolver: IResolver, handler: IContainer, requestor: IContainer): any[] {\n  if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n    const state = resolver.state as IResolver[];\n    let i = state.length;\n    const results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\nfunction createNativeInvocationError(Type: Constructable): Error {\n  if (__DEV__) {\n    return new Error(`${Type.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);\n  }\n  return new Error(`AUR0015:${Type.name}`);\n}\n","import { Platform } from '@aurelia/platform';\nimport { DI } from './di.js';\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */\nexport const emptyArray: any[] = Object.freeze<any>([]) as any;\nexport const emptyObject: any = Object.freeze({}) as any;\n/* eslint-enable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop(): void {}\n\nexport interface IPlatform extends Platform {}\nexport const IPlatform = DI.createInterface<IPlatform>('IPlatform');\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { all, DI, IContainer, ignore, IRegistry, optional, Registration } from './di.js';\nimport { bound, toLookup } from './functions.js';\nimport { Class, Constructable } from './interfaces.js';\nimport { Protocol } from './resource.js';\nimport { Metadata } from '@aurelia/metadata';\nimport { IPlatform } from './platform.js';\n\nexport const enum LogLevel {\n  /**\n   * The most detailed information about internal app state.\n   *\n   * Disabled by default and should never be enabled in a production environment.\n   */\n  trace = 0,\n  /**\n   * Information that is useful for debugging during development and has no long-term value.\n   */\n  debug = 1,\n  /**\n   * Information about the general flow of the application that has long-term value.\n   */\n  info = 2,\n  /**\n   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   */\n  warn = 3,\n  /**\n   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   */\n  error = 4,\n  /**\n   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   */\n  fatal = 5,\n  /**\n   * No messages should be written.\n   */\n  none = 6,\n}\n\n/**\n * Flags to enable/disable color usage in the logging output.\n */\nexport const enum ColorOptions {\n  /**\n   * Do not use ASCII color codes in logging output.\n   */\n  noColors = 0,\n  /**\n   * Use ASCII color codes in logging output. By default, timestamps and the TRC and DBG prefix are colored grey. INF white, WRN yellow, and ERR and FTL red.\n   */\n  colors = 1,\n}\n\n/**\n * The global logger configuration.\n *\n * Properties on this object can be changed during runtime and will affect logging of all components that are housed under the same root DI container as the logger.\n */\nexport interface ILogConfig {\n  /**\n   * The global color options.\n   */\n  colorOptions: ColorOptions;\n  /**\n   * The global log level. Only log calls with the same level or higher are emitted.\n   */\n  level: LogLevel;\n}\n\ninterface ILoggingConfigurationOptions extends ILogConfig {\n  $console: IConsoleLike;\n  sinks: (Class<ISink> | IRegistry)[];\n}\n\n/**\n * Component that creates log event objects based on raw inputs sent to `ILogger`.\n *\n * To customize what data is sent to the sinks, replace the implementation for this interface with your own.\n *\n * @example\n *\n * ```ts\n * export class MyLogEventFactory {\n *   public createLogEvent(logger: ILogger, logLevel: LogLevel, message: string, optionalParams: unknown[]): ILogEvent {\n *     return {\n *       logLevel,\n *       optionalParams,\n *       toString() {\n *         return `[${logger.scope.join('.')}] ${message} ${optionalParams.join(', ')}`;\n *       }\n *     };\n *   }\n * }\n *\n * container.register(Registration.singleton(ILogEventFactory, MyLogEventFactory));\n * ```\n */\nexport interface ILogEventFactory {\n  /**\n   * Create a log event object based on the input parameters sent to `ILogger`.\n   *\n   * @param logger - The `ILogger` that received the message.\n   * @param logLevel - The `LogLevel` associated with the `ILogger` method that the message was passed into. E.g. `logger.debug` will result in `LogLevel.debug`\n   * @param message - The message (first parameter) that was passed into the logger. If a function was passed into the logger, this will be the return value of that function.\n   * @param optionalParams - Additional optional parameters there were passed into the logger, if any.\n   *\n   * @returns An `ILogEvent` object that, by default, only has a `.toString()` method.\n   *\n   * This is called by the default console sink to get the message to emit to the console.\n   * It could be any object of any shape, as long as the registered sinks understand that shape.\n   */\n  createLogEvent(logger: ILogger, logLevel: LogLevel, message: string, optionalParams: unknown[]): ILogEvent;\n}\n\n/**\n * A logging sink that emits `ILogEvent` objects to any kind of output. This can be the console, a database, a web api, a file, etc.\n *\n * Multiple sinks can be registered, and all events will be emitted to all of them.\n *\n * @example\n * // A buffered file sink that writes once per second:\n *\n * ```ts\n * export class BufferedFileSink {\n *   private readonly buffer: ILogEvent[] = [];\n *\n *   constructor() {\n *     setInterval(() => {\n *       const events = this.buffer.splice(0);\n *       if (events.length > 0) {\n *         fs.appendFileSync('my-log.txt', events.map(e => e.toString()).join('\\n'));\n *       }\n *     }, 1000);\n *   }\n *\n *   public emit(event: ILogEvent): void {\n *     this.buffer.push(event);\n *   }\n * }\n *\n * container.register(Registration.singleton(ISink, BufferedFileSink));\n * ```\n */\nexport interface ISink {\n  /**\n   * Handle the provided `ILogEvent` to the output interface wrapped by this sink.\n   *\n   * @param event - The event object to emit. Built-in sinks will call `.toString()` on the event object but custom sinks can do anything they like with the event.\n   */\n  handleEvent(event: ILogEvent): void;\n}\n\n/**\n * The main interface to the logging API.\n *\n * Inject this as a dependency in your components to add centralized, configurable logging capabilities to your application.\n */\nexport interface ILogger extends DefaultLogger {}\n\nexport const ILogConfig = DI.createInterface<ILogConfig>('ILogConfig', x => x.instance(new LogConfig(ColorOptions.noColors, LogLevel.warn)));\nexport const ISink = DI.createInterface<ISink>('ISink');\nexport const ILogEventFactory = DI.createInterface<ILogEventFactory>('ILogEventFactory', x => x.singleton(DefaultLogEventFactory));\nexport const ILogger = DI.createInterface<ILogger>('ILogger', x => x.singleton(DefaultLogger));\nexport const ILogScopes = DI.createInterface<string[]>('ILogScope');\n\ninterface SinkDefinition {\n  handles: Exclude<LogLevel, LogLevel.none>[];\n}\n\nexport const LoggerSink = Object.freeze({\n  key: Protocol.annotation.keyFor('logger-sink-handles'),\n  define<TSink extends ISink>(target: Constructable<TSink>, definition: SinkDefinition) {\n    Metadata.define(this.key, definition.handles, target.prototype);\n    return target;\n  },\n  getHandles<TSink extends ISink>(target: Constructable<TSink> | TSink) {\n    return Metadata.get(this.key, target) as LogLevel[] | undefined;\n  },\n});\nexport function sink(definition: SinkDefinition) {\n  return function <TSink extends ISink>(target: Constructable<TSink>): Constructable<TSink> {\n    return LoggerSink.define(target, definition);\n  };\n}\n\nexport interface IConsoleLike {\n  debug(message: string, ...optionalParams: unknown[]): void;\n  info(message: string, ...optionalParams: unknown[]): void;\n  warn(message: string, ...optionalParams: unknown[]): void;\n  error(message: string, ...optionalParams: unknown[]): void;\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nexport const format = toLookup({\n  red<T extends string>(str: T): T {\n    return `\\u001b[31m${str}\\u001b[39m` as T;\n  },\n  green<T extends string>(str: T): T {\n    return `\\u001b[32m${str}\\u001b[39m` as T;\n  },\n  yellow<T extends string>(str: T): T {\n    return `\\u001b[33m${str}\\u001b[39m` as T;\n  },\n  blue<T extends string>(str: T): T {\n    return `\\u001b[34m${str}\\u001b[39m` as T;\n  },\n  magenta<T extends string>(str: T): T {\n    return `\\u001b[35m${str}\\u001b[39m` as T;\n  },\n  cyan<T extends string>(str: T): T {\n    return `\\u001b[36m${str}\\u001b[39m` as T;\n  },\n  white<T extends string>(str: T): T {\n    return `\\u001b[37m${str}\\u001b[39m` as T;\n  },\n  grey<T extends string>(str: T): T {\n    return `\\u001b[90m${str}\\u001b[39m` as T;\n  },\n} as const);\n\nexport interface ILogEvent {\n  readonly severity: LogLevel;\n  readonly optionalParams?: readonly unknown[];\n  toString(): string;\n}\n\nexport class LogConfig implements ILogConfig {\n  public constructor(\n    public readonly colorOptions: ColorOptions,\n    public readonly level: LogLevel,\n  ) {}\n}\n\nconst getLogLevelString = (function () {\n  const logLevelString = [\n    toLookup({\n      TRC: 'TRC',\n      DBG: 'DBG',\n      INF: 'INF',\n      WRN: 'WRN',\n      ERR: 'ERR',\n      FTL: 'FTL',\n      QQQ: '???',\n    } as const),\n    toLookup({\n      TRC: format.grey('TRC'),\n      DBG: format.grey('DBG'),\n      INF: format.white('INF'),\n      WRN: format.yellow('WRN'),\n      ERR: format.red('ERR'),\n      FTL: format.red('FTL'),\n      QQQ: format.grey('???'),\n    } as const),\n  ] as const;\n\n  return function (level: LogLevel, colorOptions: ColorOptions): string {\n    if (level <= LogLevel.trace) {\n      return logLevelString[colorOptions].TRC;\n    }\n    if (level <= LogLevel.debug) {\n      return logLevelString[colorOptions].DBG;\n    }\n    if (level <= LogLevel.info) {\n      return logLevelString[colorOptions].INF;\n    }\n    if (level <= LogLevel.warn) {\n      return logLevelString[colorOptions].WRN;\n    }\n    if (level <= LogLevel.error) {\n      return logLevelString[colorOptions].ERR;\n    }\n    if (level <= LogLevel.fatal) {\n      return logLevelString[colorOptions].FTL;\n    }\n    return logLevelString[colorOptions].QQQ;\n  };\n})();\n\nfunction getScopeString(scope: readonly string[], colorOptions: ColorOptions): string {\n  if (colorOptions === ColorOptions.noColors) {\n    return scope.join('.');\n  }\n  return scope.map(format.cyan).join('.');\n}\n\nfunction getIsoString(timestamp: number, colorOptions: ColorOptions): string {\n  if (colorOptions === ColorOptions.noColors) {\n    return new Date(timestamp).toISOString();\n  }\n  return format.grey(new Date(timestamp).toISOString());\n}\n\nexport class DefaultLogEvent implements ILogEvent {\n  public constructor(\n    public readonly severity: LogLevel,\n    public readonly message: string,\n    public readonly optionalParams: unknown[],\n    public readonly scope: readonly string[],\n    public readonly colorOptions: ColorOptions,\n    public readonly timestamp: number,\n  ) {}\n\n  public toString(): string {\n    const { severity, message, scope, colorOptions, timestamp } = this;\n\n    if (scope.length === 0) {\n      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;\n    }\n    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;\n  }\n}\n\nexport class DefaultLogEventFactory implements ILogEventFactory {\n  public constructor(\n    @ILogConfig public readonly config: ILogConfig,\n  ) {}\n\n  public createLogEvent(logger: ILogger, level: LogLevel, message: string, optionalParams: unknown[]): ILogEvent {\n    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());\n  }\n}\n\nexport class ConsoleSink implements ISink {\n  public static register(container: IContainer) {\n    Registration.singleton(ISink, ConsoleSink).register(container);\n  }\n\n  public readonly handleEvent: (event: ILogEvent) => void;\n\n  public constructor(\n    @IPlatform p: IPlatform,\n  ) {\n    const $console = p.console as {\n      debug(...args: unknown[]): void;\n      info(...args: unknown[]): void;\n      warn(...args: unknown[]): void;\n      error(...args: unknown[]): void;\n    };\n    this.handleEvent = function emit(event: ILogEvent): void {\n      const optionalParams = event.optionalParams;\n      if (optionalParams === void 0 || optionalParams.length === 0) {\n        const msg = event.toString();\n        switch (event.severity) {\n          case LogLevel.trace:\n          case LogLevel.debug:\n            return $console.debug(msg);\n          case LogLevel.info:\n            return $console.info(msg);\n          case LogLevel.warn:\n            return $console.warn(msg);\n          case LogLevel.error:\n          case LogLevel.fatal:\n            return $console.error(msg);\n        }\n      } else {\n        let msg = event.toString();\n        let offset = 0;\n        // console.log in chrome doesn't call .toString() on object inputs (https://bugs.chromium.org/p/chromium/issues/detail?id=1146817)\n        while (msg.includes('%s')) {\n          msg = msg.replace('%s', String(optionalParams[offset++]));\n        }\n        switch (event.severity) {\n          case LogLevel.trace:\n          case LogLevel.debug:\n            return $console.debug(msg, ...optionalParams.slice(offset));\n          case LogLevel.info:\n            return $console.info(msg, ...optionalParams.slice(offset));\n          case LogLevel.warn:\n            return $console.warn(msg, ...optionalParams.slice(offset));\n          case LogLevel.error:\n          case LogLevel.fatal:\n            return $console.error(msg, ...optionalParams.slice(offset));\n        }\n      }\n    };\n  }\n}\n\nexport class DefaultLogger {\n  /**\n   * The root `ILogger` instance. On the root logger itself, this property circularly references the root. It is never null.\n   *\n   * When using `.scopeTo`, a new `ILogger` is created. That new logger will have the `root` property set to the global (non-scoped) logger.\n   */\n  public readonly root: ILogger;\n  /**\n   * The parent `ILogger` instance. On the root logger itself, this property circularly references the root. It is never null.\n   *\n   * When using `.scopeTo`, a new `ILogger` is created. That new logger will have the `parent` property set to the logger that it was created from.\n   */\n  public readonly parent: ILogger;\n  /** @internal */\n  public readonly traceSinks: ISink[];\n  /** @internal */\n  public readonly debugSinks: ISink[];\n  /** @internal */\n  public readonly infoSinks: ISink[];\n  /** @internal */\n  public readonly warnSinks: ISink[];\n  /** @internal */\n  public readonly errorSinks: ISink[];\n  /** @internal */\n  public readonly fatalSinks: ISink[];\n\n  private readonly scopedLoggers: { [key: string]: ILogger | undefined } = Object.create(null);\n\n  public constructor(\n    /**\n     * The global logger configuration.\n     */\n    @ILogConfig public readonly config: ILogConfig,\n    @ILogEventFactory private readonly factory: ILogEventFactory,\n    @all(ISink) sinks: readonly ISink[],\n    /**\n     * The scopes that this logger was created for, if any.\n     */\n    @optional(ILogScopes) public readonly scope: string[] = [],\n    @ignore parent: DefaultLogger | null = null,\n  ) {\n    let traceSinks: ISink[];\n    let debugSinks: ISink[];\n    let infoSinks: ISink[];\n    let warnSinks: ISink[];\n    let errorSinks: ISink[];\n    let fatalSinks: ISink[];\n    if (parent === null) {\n      this.root = this;\n      this.parent = this;\n\n      traceSinks = this.traceSinks = [];\n      debugSinks = this.debugSinks = [];\n      infoSinks = this.infoSinks = [];\n      warnSinks = this.warnSinks = [];\n      errorSinks = this.errorSinks = [];\n      fatalSinks = this.fatalSinks = [];\n      for (const $sink of sinks) {\n        const handles = LoggerSink.getHandles($sink);\n        if (handles?.includes(LogLevel.trace) ?? true) {\n          traceSinks.push($sink);\n        }\n        if (handles?.includes(LogLevel.debug) ?? true) {\n          debugSinks.push($sink);\n        }\n        if (handles?.includes(LogLevel.info) ?? true) {\n          infoSinks.push($sink);\n        }\n        if (handles?.includes(LogLevel.warn) ?? true) {\n          warnSinks.push($sink);\n        }\n        if (handles?.includes(LogLevel.error) ?? true) {\n          errorSinks.push($sink);\n        }\n        if (handles?.includes(LogLevel.fatal) ?? true) {\n          fatalSinks.push($sink);\n        }\n      }\n    } else {\n      this.root = parent.root;\n      this.parent = parent;\n\n      traceSinks = this.traceSinks = parent.traceSinks;\n      debugSinks = this.debugSinks = parent.debugSinks;\n      infoSinks = this.infoSinks = parent.infoSinks;\n      warnSinks = this.warnSinks = parent.warnSinks;\n      errorSinks = this.errorSinks = parent.errorSinks;\n      fatalSinks = this.fatalSinks = parent.fatalSinks;\n    }\n  }\n\n  /**\n   * Write to TRC output, if the configured `LogLevel` is set to `trace`.\n   *\n   * Intended for the most detailed information about internal app state.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public trace(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to TRC output, if the configured `LogLevel` is set to `trace`.\n   *\n   * Intended for the most detailed information about internal app state.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public trace(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public trace(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= LogLevel.trace) {\n      this.emit(this.traceSinks, LogLevel.trace, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to DBG output, if the configured `LogLevel` is set to `debug` or lower.\n   *\n   * Intended for information that is useful for debugging during development and has no long-term value.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public debug(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to DBG output, if the configured `LogLevel` is set to `debug` or lower.\n   *\n   * Intended for information that is useful for debugging during development and has no long-term value.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public debug(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public debug(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= LogLevel.debug) {\n      this.emit(this.debugSinks, LogLevel.debug, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to trace UBF, if the configured `LogLevel` is set to `info` or lower.\n   *\n   * Intended for information about the general flow of the application that has long-term value.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public info(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to trace UBF, if the configured `LogLevel` is set to `info` or lower.\n   *\n   * Intended for information about the general flow of the application that has long-term value.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public info(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public info(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= LogLevel.info) {\n      this.emit(this.infoSinks, LogLevel.info, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to WRN output, if the configured `LogLevel` is set to `warn` or lower.\n   *\n   * Intended for unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public warn(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to WRN output, if the configured `LogLevel` is set to `warn` or lower.\n   *\n   * Intended for unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public warn(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public warn(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= LogLevel.warn) {\n      this.emit(this.warnSinks, LogLevel.warn, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to ERR output, if the configured `LogLevel` is set to `error` or lower.\n   *\n   * Intended for unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public error(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to ERR output, if the configured `LogLevel` is set to `error` or lower.\n   *\n   * Intended for unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public error(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public error(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= LogLevel.error) {\n      this.emit(this.errorSinks, LogLevel.error, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to FTL output, if the configured `LogLevel` is set to `fatal` or lower.\n   *\n   * Intended for unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public fatal(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to FTL output, if the configured `LogLevel` is set to `fatal` or lower.\n   *\n   * Intended for unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public fatal(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public fatal(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= LogLevel.fatal) {\n      this.emit(this.fatalSinks, LogLevel.fatal, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Create a new logger with an additional permanent prefix added to the logging outputs.\n   * When chained, multiple scopes are separated by a dot.\n   *\n   * This is preliminary API and subject to change before alpha release.\n   *\n   * @example\n   *\n   * ```ts\n   * export class MyComponent {\n   *   constructor(@ILogger private logger: ILogger) {\n   *     this.logger.debug('before scoping');\n   *     // console output: '[DBG] before scoping'\n   *     this.logger = logger.scopeTo('MyComponent');\n   *     this.logger.debug('after scoping');\n   *     // console output: '[DBG MyComponent] after scoping'\n   *   }\n   *\n   *   public doStuff(): void {\n   *     const logger = this.logger.scopeTo('doStuff()');\n   *     logger.debug('doing stuff');\n   *     // console output: '[DBG MyComponent.doStuff()] doing stuff'\n   *   }\n   * }\n   * ```\n   */\n  public scopeTo(name: string): ILogger {\n    const scopedLoggers = this.scopedLoggers;\n    let scopedLogger = scopedLoggers[name];\n    if (scopedLogger === void 0) {\n      scopedLogger = scopedLoggers[name] = new DefaultLogger(this.config, this.factory, (void 0)!, this.scope.concat(name), this);\n    }\n    return scopedLogger;\n  }\n\n  private emit(sinks: ISink[], level: LogLevel, msgOrGetMsg: unknown, optionalParams: unknown[]): void {\n    const message = typeof msgOrGetMsg === 'function' ? msgOrGetMsg() : msgOrGetMsg;\n    const event = this.factory.createLogEvent(this, level, message, optionalParams);\n    for (let i = 0, ii = sinks.length; i < ii; ++i) {\n      sinks[i].handleEvent(event);\n    }\n  }\n}\n\n/**\n * A basic `ILogger` configuration that configures a single `console` sink based on provided options.\n *\n * NOTE: You *must* register the return value of `.create` with the container / au instance, not this `LoggerConfiguration` object itself.\n *\n * @example\n * ```ts\n * container.register(LoggerConfiguration.create());\n *\n * container.register(LoggerConfiguration.create({sinks: [ConsoleSink]}))\n *\n * container.register(LoggerConfiguration.create({sinks: [ConsoleSink], level: LogLevel.debug}))\n *\n * ```\n */\nexport const LoggerConfiguration = toLookup({\n  /**\n   * @param $console - The `console` object to use. Can be the native `window.console` / `global.console`, but can also be a wrapper or mock that implements the same interface.\n   * @param level - The global `LogLevel` to configure. Defaults to `warn` or higher.\n   * @param colorOptions - Whether to use colors or not. Defaults to `noColors`. Colors are especially nice in nodejs environments but don't necessarily work (well) in all environments, such as browsers.\n   */\n  create(\n    {\n      level = LogLevel.warn,\n      colorOptions = ColorOptions.noColors,\n      sinks = [],\n    }: Partial<ILoggingConfigurationOptions> = {}\n  ): IRegistry {\n    return toLookup({\n      register(container: IContainer): IContainer {\n        container.register(\n          Registration.instance(ILogConfig, new LogConfig(colorOptions, level)),\n        );\n        for (const $sink of sinks) {\n          if (typeof $sink === 'function') {\n            container.register(Registration.singleton(ISink, $sink));\n          } else {\n            container.register($sink);\n          }\n        }\n        return container;\n      },\n    });\n  },\n});\n","import { DI } from './di.js';\nimport { emptyArray } from './platform.js';\nimport { Protocol } from './resource.js';\n\nimport type { IRegistry } from './di.js';\nimport type { Constructable, IDisposable, IIndexable } from './interfaces.js';\nimport type { ResourceDefinition } from './resource.js';\n\nexport interface IModule {\n  [key: string]: unknown;\n  default?: unknown;\n}\n\nexport interface IModuleLoader extends ModuleLoader {}\nexport const IModuleLoader = DI.createInterface<IModuleLoader>(x => x.singleton(ModuleLoader));\n\nfunction noTransform<TRet = AnalyzedModule>(m: AnalyzedModule): TRet {\n  return m as unknown as TRet;\n}\n\ntype TransformFn<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>> = (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>;\n\nclass ModuleTransformer<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>> {\n  private readonly promiseCache: Map<Promise<IModule>, unknown> = new Map<Promise<IModule>, unknown>();\n  private readonly objectCache: Map<IModule, unknown> = new Map<IModule, unknown>();\n\n  public constructor(\n    private readonly $transform: TransformFn<TMod, TRet>,\n  ) {}\n\n  public transform(objOrPromise: TMod | Promise<TMod>): Promise<TRet> | TRet {\n    if (objOrPromise instanceof Promise) {\n      return this.transformPromise(objOrPromise);\n    } else if (typeof objOrPromise === 'object' && objOrPromise !== null) {\n      return this.transformObject(objOrPromise);\n    } else {\n      throw new Error(`Invalid input: ${String(objOrPromise)}. Expected Promise or Object.`);\n    }\n  }\n\n  private transformPromise(promise: Promise<TMod>): TRet | Promise<TRet> {\n    if (this.promiseCache.has(promise)) {\n      return this.promiseCache.get(promise) as TRet | Promise<TRet>;\n    }\n\n    const ret = promise.then(obj => {\n      return this.transformObject(obj);\n    });\n    this.promiseCache.set(promise, ret);\n    void ret.then(value => {\n      // make it synchronous for future requests\n      this.promiseCache.set(promise, value);\n    });\n    return ret;\n  }\n\n  private transformObject(obj: TMod): TRet | Promise<TRet> {\n    if (this.objectCache.has(obj)) {\n      return this.objectCache.get(obj) as TRet | Promise<TRet>;\n    }\n\n    const ret = this.$transform(this.analyze(obj));\n    this.objectCache.set(obj, ret);\n    if (ret instanceof Promise) {\n      void ret.then(value => {\n        // make it synchronous for future requests\n        this.objectCache.set(obj, value);\n      });\n    }\n    return ret;\n  }\n\n  private analyze(m: TMod): AnalyzedModule<TMod> {\n    let value: unknown;\n    let isRegistry: boolean;\n    let isConstructable: boolean;\n    let definitions: readonly ResourceDefinition[];\n    const items: ModuleItem[] = [];\n\n    for (const key in m) {\n      switch (typeof (value = m[key])) {\n        case 'object':\n          if (value === null) {\n            continue;\n          }\n          isRegistry = typeof (value as IIndexable).register === 'function';\n          isConstructable = false;\n          definitions = emptyArray;\n          break;\n        case 'function':\n          isRegistry = typeof (value as Constructable & IIndexable).register === 'function';\n          isConstructable = (value as Constructable).prototype !== void 0;\n          definitions = Protocol.resource.getAll(value as Constructable);\n          break;\n        default:\n          continue;\n      }\n\n      items.push(new ModuleItem(\n        key,\n        value,\n        isRegistry,\n        isConstructable,\n        definitions,\n      ));\n    }\n\n    return new AnalyzedModule(m, items as ITypedModuleItem_T[]);\n  }\n}\n\nexport class ModuleLoader implements IDisposable {\n  private readonly transformers: Map<TransformFn, ModuleTransformer> = new Map<TransformFn, ModuleTransformer>();\n\n  /**\n   * Await a module promise and then analyzes and transforms it. The result is cached, using the transform function + promise as the cache key.\n   *\n   * @param promise - A promise (returning a module, or an object resembling a module), e.g. the return value of a dynamic `import()` or `require()` call.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(promise: Promise<TMod>, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  /**\n   * Await a module promise and then analyzes it. The result is cached, using the transform function + promise as the cache key.\n   *\n   * @param promise - A promise (returning a module, or an object resembling a module), e.g. the return value of a dynamic `import()` or `require()` call.\n   *\n   * @returns The analyzed module. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule>(promise: Promise<TMod>): Promise<AnalyzedModule<TMod>> | AnalyzedModule<TMod>;\n  /**\n   * Analyzes and transforms a module-like object. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object, e.g. the awaited return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(obj: TMod, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  /**\n   * Analyzes a module-like object. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object, e.g. the awaited return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   *\n   * @returns The analyzed module. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule>(obj: TMod): AnalyzedModule<TMod>;\n  /**\n   * Analyzes and transforms a module-like object or a promise thereof. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object or a promise thereof, e.g. the (awaited) return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(objOrPromise: TMod | Promise<TMod>, transform?: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(objOrPromise: TMod | Promise<TMod>, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet> = noTransform): Promise<TRet> | TRet {\n    const transformers = this.transformers as Map<TransformFn, ModuleTransformer> & Map<TransformFn<TMod, TRet>, ModuleTransformer<TMod, TRet>>;\n    let transformer = transformers.get(transform);\n    if (transformer === void 0) {\n      transformers.set(transform, transformer = new ModuleTransformer(transform));\n    }\n\n    return transformer.transform(objOrPromise);\n  }\n\n  public dispose(): void {\n    this.transformers.clear();\n  }\n}\n\nexport class AnalyzedModule<TMod extends IModule = IModule> {\n  public constructor(\n    public readonly raw: TMod,\n    public readonly items: readonly ITypedModuleItem_T[],\n  ) {}\n}\n\nexport interface ITypedModuleItem<\n  TisRegistry extends boolean,\n  TisConstructable extends boolean,\n  TValue\n> {\n  readonly key: string;\n  readonly value: TValue;\n  readonly isRegistry: TisRegistry;\n  readonly isConstructable: TisConstructable;\n  readonly definitions: readonly ResourceDefinition[];\n}\nexport interface ITypedModuleItem_Unknown extends ITypedModuleItem<false, false, unknown> {}\nexport interface ITypedModuleItem_Registry extends ITypedModuleItem<true, false, IRegistry> {}\nexport interface ITypedModuleItem_Constructable extends ITypedModuleItem<false, true, Constructable> {}\nexport interface ITypedModuleItem_ConstructableRegistry extends ITypedModuleItem<true, true, Constructable & IRegistry> {}\nexport type ITypedModuleItem_T = (\n  ITypedModuleItem_Unknown |\n  ITypedModuleItem_Registry |\n  ITypedModuleItem_Constructable |\n  ITypedModuleItem_ConstructableRegistry\n);\nexport class ModuleItem {\n  public constructor(\n    public readonly key: string,\n    public readonly value: unknown,\n    public readonly isRegistry: boolean,\n    public readonly isConstructable: boolean,\n    public readonly definitions: readonly ResourceDefinition[],\n  ) {}\n}\n","/* eslint-disable @typescript-eslint/restrict-template-expressions */\nimport { DI } from './di.js';\nimport { Constructable, IDisposable } from './interfaces.js';\n\n/**\n * Represents a handler for an EventAggregator event.\n */\nclass Handler<T extends Constructable> {\n  public constructor(\n    public readonly messageType: T,\n    public readonly callback: (message: InstanceType<T>) => void,\n  ) {}\n\n  public handle(message: InstanceType<T>): void {\n    if (message instanceof this.messageType) {\n      this.callback.call(null, message);\n    }\n  }\n}\n\nexport const IEventAggregator = DI.createInterface<IEventAggregator>('IEventAggregator', x => x.singleton(EventAggregator));\nexport interface IEventAggregator extends EventAggregator {}\n\n/**\n * Enables loosely coupled publish/subscribe messaging.\n */\nexport class EventAggregator {\n  /** @internal */\n  public readonly eventLookup: Record<string, ((message: unknown, channel: string) => void)[]> = {};\n  /** @internal */\n  public readonly messageHandlers: Handler<Constructable>[] = [];\n\n  /**\n   * Publishes a message.\n   *\n   * @param channel - The channel to publish to.\n   * @param message - The message to publish on the channel.\n   */\n  public publish<T, C extends string>(\n    channel: C,\n    message: T,\n  ): void;\n  /**\n   * Publishes a message.\n   *\n   * @param instance - The instance to publish.\n   */\n  public publish<T extends Constructable>(\n    instance: InstanceType<T>,\n  ): void;\n  public publish<T extends Constructable | string>(\n    channelOrInstance: T extends Constructable ? InstanceType<T> : T,\n    message?: unknown,\n  ): void {\n    if (!channelOrInstance) {\n      throw new Error(`Invalid channel name or instance: ${channelOrInstance}.`);\n    }\n\n    if (typeof channelOrInstance === 'string') {\n      let subscribers = this.eventLookup[channelOrInstance];\n      if (subscribers !== void 0) {\n        subscribers = subscribers.slice();\n        let i = subscribers.length;\n\n        while (i-- > 0) {\n          subscribers[i](message, channelOrInstance);\n        }\n      }\n    } else {\n      const subscribers = this.messageHandlers.slice();\n      let i = subscribers.length;\n\n      while (i-- > 0) {\n        subscribers[i].handle(channelOrInstance);\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a message channel.\n   *\n   * @param channel - The event channel.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T, C extends string>(\n    channel: C,\n    callback: (message: T, channel: C) => void,\n  ): IDisposable;\n  /**\n   * Subscribes to a message type.\n   *\n   * @param type - The event message type.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T extends Constructable>(\n    type: T,\n    callback: (message: InstanceType<T>) => void,\n  ): IDisposable;\n  public subscribe(\n    channelOrType: string | Constructable,\n    callback: (...args: unknown[]) => void,\n  ): IDisposable {\n    if (!channelOrType) {\n      throw new Error(`Invalid channel name or type: ${channelOrType}.`);\n    }\n\n    let handler: unknown;\n    let subscribers: unknown[];\n\n    if (typeof channelOrType === 'string') {\n      if (this.eventLookup[channelOrType] === void 0) {\n        this.eventLookup[channelOrType] = [];\n      }\n      handler = callback;\n      subscribers = this.eventLookup[channelOrType];\n    } else {\n      handler = new Handler(channelOrType, callback);\n\n      subscribers = this.messageHandlers;\n    }\n\n    subscribers.push(handler);\n\n    return {\n      dispose(): void {\n        const idx = subscribers.indexOf(handler);\n        if (idx !== -1) {\n          subscribers.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a message channel, then disposes the subscription automatically after the first message is received.\n   *\n   * @param channel - The event channel.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T, C extends string>(\n    channel: C,\n    callback: (message: T, channel: C) => void,\n  ): IDisposable;\n  /**\n   * Subscribes to a message type, then disposes the subscription automatically after the first message is received.\n   *\n   * @param type - The event message type.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T extends Constructable>(\n    type: T,\n    callback: (message: InstanceType<T>) => void,\n  ): IDisposable;\n  public subscribeOnce(\n    channelOrType: string | Constructable,\n    callback: (...args: unknown[]) => void,\n  ): IDisposable {\n    const sub = this.subscribe(channelOrType as string, function (message, event) {\n      sub.dispose();\n      callback(message, event);\n    });\n\n    return sub;\n  }\n}\n"],"names":["Metadata","applyMetadataPolyfill","isObject","LogLevel","ColorOptions","DefaultLogEventFactory","DefaultLogger","ConsoleSink"],"mappings":"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"}