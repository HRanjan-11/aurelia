{"version":3,"file":"index.dev.js","sources":["../../src/index.ts"],"sourcesContent":["/**\n * Determine whether a value is an object.\n *\n * Uses `typeof` to guarantee this works cross-realm, which is where `instanceof Object` might fail.\n *\n * Some environments where these issues are known to arise:\n * - same-origin iframes (accessing the other realm via `window.top`)\n * - `jest`.\n *\n * The exact test is:\n * ```ts\n * typeof value === 'object' && value !== null || typeof value === 'function'\n * ```\n *\n * @param value - The value to test.\n * @returns `true` if the value is an object, otherwise `false`.\n * Also performs a type assertion that defaults to `value is Object | Function` which, if the input type is a union with an object type, will infer the correct type.\n * This can be overridden with the generic type argument.\n *\n * @example\n *\n * ```ts\n * class Foo {\n *   bar = 42;\n * }\n *\n * function doStuff(input?: Foo | null) {\n *   input.bar; // Object is possibly 'null' or 'undefined'\n *\n *   // input has an object type in its union (Foo) so that type will be extracted for the 'true' condition\n *   if (isObject(input)) {\n *     input.bar; // OK (input is now typed as Foo)\n *   }\n * }\n *\n * function doOtherStuff(input: unknown) {\n *   input.bar; // Object is of type 'unknown'\n *\n *   // input is 'unknown' so there is no union type to match and it will default to 'Object | Function'\n *   if (isObject(input)) {\n *     input.bar; // Property 'bar' does not exist on type 'Object | Function'\n *   }\n *\n *   // if we know for sure that, if input is an object, it must be a specific type, we can explicitly tell the function to assert that for us\n *   if (isObject<Foo>(input)) {\n *    input.bar; // OK (input is now typed as Foo)\n *   }\n * }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isObject<T extends object = Object | Function>(value: unknown): value is T {\n  return typeof value === 'object' && value !== null || typeof value === 'function';\n}\n\n/**\n * Determine whether a value is `null` or `undefined`.\n *\n * @param value - The value to test.\n * @returns `true` if the value is `null` or `undefined`, otherwise `false`.\n * Also performs a type assertion that ensures TypeScript treats the value appropriately in the `if` and `else` branches after this check.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === void 0;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\n\nconst metadataInternalSlot = new WeakMap<any, Map<string | symbol | undefined, Map<any, any>>>();\n\nfunction $typeError(operation: string, args: unknown[], paramName: string, actualValue: unknown, expectedType: string): TypeError {\n  return new TypeError(`${operation}(${args.map(String).join(',')}) - Expected '${paramName}' to be of type ${expectedType}, but got: ${Object.prototype.toString.call(actualValue)} (${String(actualValue)})`);\n}\n\nfunction toPropertyKeyOrUndefined(propertyKey: any): undefined | string | symbol {\n  switch (typeof propertyKey) {\n    case 'undefined':\n    case 'string':\n    case 'symbol':\n      return propertyKey;\n    default:\n      return `${propertyKey}`;\n  }\n}\n\nfunction toPropertyKey(propertyKey: any): string | symbol {\n  switch (typeof propertyKey) {\n    case 'string':\n    case 'symbol':\n      return propertyKey;\n    default:\n      return `${propertyKey}`;\n  }\n}\n\nfunction ensurePropertyKeyOrUndefined(propertyKey: any): undefined | string | symbol {\n  switch (typeof propertyKey) {\n    case 'undefined':\n    case 'string':\n    case 'symbol':\n      return propertyKey;\n    default:\n      throw new TypeError(`Invalid metadata propertyKey: ${propertyKey}.`);\n  }\n}\n\n// 2.1.1 GetOrCreateMetadataMap(O, P, Create)\n// https://rbuckton.github.io/reflect-metadata/#getorcreatemetadatamap\nfunction GetOrCreateMetadataMap(O: any, P: string | symbol | undefined, Create: true): Map<any, any>;\nfunction GetOrCreateMetadataMap(O: any, P: string | symbol | undefined, Create: false): Map<any, any> | undefined;\nfunction GetOrCreateMetadataMap(O: any, P: string | symbol | undefined, Create: boolean): Map<any, any> | undefined {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let targetMetadata be the value of O's [[Metadata]] internal slot.\n  let targetMetadata = metadataInternalSlot.get(O);\n\n  // 3. If targetMetadata is undefined, then\n  if (targetMetadata === void 0) {\n    // 3. a. If Create is false, return undefined.\n    if (!Create) {\n      return void 0;\n    }\n\n    // 3. b. Set targetMetadata to be a newly created Map object.\n    targetMetadata = new Map<string | symbol | undefined, Map<any, any>>();\n\n    // 3. c. Set the [[Metadata]] internal slot of O to targetMetadata.\n    metadataInternalSlot.set(O, targetMetadata);\n  }\n\n  // 4. Let metadataMap be ? Invoke(targetMetadata, \"get\", P).\n  let metadataMap = targetMetadata.get(P);\n\n  // 5. If metadataMap is undefined, then\n  if (metadataMap === void 0) {\n    // 5. a. If Create is false, return undefined.\n    if (!Create) {\n      return void 0;\n    }\n\n    // 5. b. Set metadataMap to be a newly created Map object.\n    metadataMap = new Map<any, any>();\n\n    // 5. c. Perform ? Invoke(targetMetadata, \"set\", P, metadataMap).\n    targetMetadata.set(P, metadataMap);\n  }\n\n  // 6. Return metadataMap.\n  return metadataMap;\n}\n\n// 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\nfunction OrdinaryHasOwnMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): boolean {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).\n  const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);\n\n  // 3. If metadataMap is undefined, return false.\n  if (metadataMap === void 0) {\n    return false;\n  }\n\n  // 4. Return ? ToBoolean(? Invoke(metadataMap, \"has\", MetadataKey)).\n  return metadataMap.has(MetadataKey);\n}\n\n// 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\nfunction OrdinaryHasMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): boolean {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).\n  // 3. If hasOwn is true, return true.\n  if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {\n    return true;\n  }\n\n  // 4. Let parent be ? O.[[GetPrototypeOf]]().\n  const parent = Object.getPrototypeOf(O);\n\n  // 5. If parent is not null, Return ? parent.[[HasMetadata]](MetadataKey, P).\n  if (parent !== null) {\n    return OrdinaryHasMetadata(MetadataKey, parent, P);\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\nfunction OrdinaryGetOwnMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): any {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).\n  const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);\n\n  // 3. If metadataMap is undefined, return undefined.\n  if (metadataMap === void 0) {\n    return void 0;\n  }\n\n  // 4. Return ? Invoke(metadataMap, \"get\", MetadataKey).\n  return metadataMap.get(MetadataKey);\n}\n\n// 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\nfunction OrdinaryGetMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): any {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let hasOwn be ? OrdinaryHasOwnMetadata(MetadataKey, O, P).\n  // 3. If hasOwn is true, return ? OrdinaryGetOwnMetadata(MetadataKey, O, P).\n  if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) {\n    return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n  }\n\n  // 4. Let parent be ? O.[[GetPrototypeOf]]().\n  const parent = Object.getPrototypeOf(O);\n\n  // 5. If parent is not null, return ? parent.[[GetMetadata]](MetadataKey, P).\n  if (parent !== null) {\n    return OrdinaryGetMetadata(MetadataKey, parent, P);\n  }\n\n  // 6. Return undefined.\n  return void 0;\n}\n\n// 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\nfunction OrdinaryDefineOwnMetadata(MetadataKey: any, MetadataValue: any, O: any, P: string | symbol | undefined): void {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, true).\n  const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ true);\n\n  // 3. Return ? Invoke(metadataMap, \"set\", MetadataKey, MetadataValue).\n  metadataMap.set(MetadataKey, MetadataValue);\n}\n\n// 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\nfunction OrdinaryOwnMetadataKeys(O: any, P: string | symbol | undefined): any[] {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let keys be ? ArrayCreate(0).\n  const keys: any[] = [];\n\n  // 3. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).\n  const metadataMap = GetOrCreateMetadataMap(O, P, /* Create */ false);\n\n  // 4. If metadataMap is undefined, return keys.\n  if (metadataMap === void 0) {\n    return keys;\n  }\n\n  // 5. Let keysObj be ? Invoke(metadataMap, \"keys\").\n  const keysObj = metadataMap.keys();\n\n  // 6. Let iterator be ? GetIterator(keysObj).\n\n  // 7. Let k be 0.\n  let k = 0;\n\n  // 8. Repeat\n  for (const key of keysObj) {\n    // 8. a. Let Pk be ! ToString(k).\n    // 8. b. Let next be ? IteratorStep(iterator).\n    // 8. c. If next is false, then\n    // 8. c. i. Let setStatus be ? Set(keys, \"length\", k, true).\n    // 8. c. ii. Assert: setStatus is true.\n    // 8. c. iii. Return keys.\n    // 8. d. Let nextValue be ? IteratorValue(next).\n\n    // 8. e. Let defineStatus be CreateDataPropertyOrThrow(keys, Pk, nextValue).\n    keys[k] = key;\n\n    // 8. f. If defineStatus is an abrupt completion, return ? IteratorClose(iterator, defineStatus).\n\n    // 8. g. Increase k by 1.\n    ++k;\n  }\n\n  return keys;\n}\n\n// 3.1.6.1 OrdinaryMetadataKeys(O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\nfunction OrdinaryMetadataKeys(O: any, P: string | symbol | undefined): any[] {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let ownKeys be ? OrdinaryOwnMetadataKeys(O, P).\n  const ownKeys = OrdinaryOwnMetadataKeys(O, P);\n\n  // 3. Let parent be ? O.[[GetPrototypeOf]]().\n  const parent = Object.getPrototypeOf(O);\n\n  // 4. If parent is null, then return ownKeys.\n  if (parent === null) {\n    return ownKeys;\n  }\n\n  // 5. Let parentKeys be ? O.[[OrdinaryMetadataKeys]](P).\n  const parentKeys = OrdinaryMetadataKeys(parent, P);\n\n  // 6. Let ownKeysLen = ? Get(ownKeys, \"length\").\n  const ownKeysLen = ownKeys.length;\n\n  // 7. If ownKeysLen is 0, return parentKeys.\n  if (ownKeysLen === 0) {\n    return parentKeys;\n  }\n\n  // 8. Let parentKeysLen = ? Get(parentKeys, \"length\").\n  const parentKeysLen = parentKeys.length;\n\n  // 9. If parentKeysLen is 0, return ownKeys.\n  if (parentKeysLen === 0) {\n    return ownKeys;\n  }\n\n  // 10. Let set be a newly created Set object.\n  const set = new Set<any>();\n\n  // 11. Let keys be ? ArrayCreate(0).\n  const keys: any[] = [];\n\n  // 12. Let k be 0.\n  let k = 0;\n\n  // 13. For each element key of ownKeys\n  let key: any;\n  for (let i = 0; i < ownKeysLen; ++i) {\n    key = ownKeys[i];\n\n    // 13. a. Let hasKey be ? Invoke(set, \"has\", key).\n    // 13. b. If hasKey is false, then\n    if (!set.has(key)) {\n      // 13. b. i. Let Pk be ! ToString(k).\n      // 13. b. ii. Perform ? Invoke(set, \"add\", key).\n      set.add(key);\n\n      // 13. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).\n      // 13. b. iv. Assert: defineStatus is true.\n      keys[k] = key;\n\n      // 13. b. v. Increase k by 1.\n      ++k;\n    }\n  }\n\n  // 14. For each element key of parentKeys\n  for (let i = 0; i < parentKeysLen; ++i) {\n    key = parentKeys[i];\n\n    // 14. a. Let hasKey be ? Invoke(set, \"has\", key).\n    // 14. b. If hasKey is false, then\n    if (!set.has(key)) {\n      // 14. b. i. Let Pk be ! ToString(k).\n      // 14. b. ii. Perform ? Invoke(set, \"add\", key).\n      set.add(key);\n\n      // 14. b. iii. Let defineStatus be CreateDataProperty(keys, Pk, key).\n      // 14. b. iv. Assert: defineStatus is true.\n      keys[k] = key;\n\n      // 14. b. v. Increase k by 1.\n      ++k;\n    }\n  }\n\n  // 15. Perform ? Set(keys, \"length\", k).\n\n  // 16. return keys.\n  return keys;\n}\n\n// 3.1.8 DeleteMetadata(MetadataKey, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots-deletemetadata\nfunction OrdinaryDeleteMetadata(O: any, MetadataKey: any, P: string | symbol | undefined): boolean {\n  // 1. Assert: P is undefined or IsPropertyKey(P) is true.\n\n  // 2. Let metadataMap be ? GetOrCreateMetadataMap(O, P, false).\n  const metadataMap = GetOrCreateMetadataMap(O, P, false);\n\n  // 3. If metadataMap is undefined, return false.\n  if (metadataMap === void 0) {\n    return false;\n  }\n\n  // 4. Return ? Invoke(metadataMap, \"delete\", MetadataKey).\n  return metadataMap.delete(MetadataKey);\n}\n\n// 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n// https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n\n/**\n * A default metadata decorator factory that can be used on a class, class member, or parameter.\n *\n * @param metadataKey - The key for the metadata entry.\n * If `metadataKey` is already defined for the target and target key, the\n * metadataValue for that key will be overwritten.\n * @param metadataValue - The value for the metadata entry.\n * @returns A decorator function.\n */\nexport function metadata(metadataKey: any, metadataValue: any) {\n  function decorator(target: Function): void;\n  function decorator(target: any, propertyKey: string | symbol): void;\n  function decorator(target: any, propertyKey?: string | symbol): void {\n    // 1. Assert: F has a [[MetadataKey]] internal slot whose value is an ECMAScript language value, or undefined.\n    // 2. Assert: F has a [[MetadataValue]] internal slot whose value is an ECMAScript language value, or undefined.\n    // 3. If Type(target) is not Object, throw a TypeError exception.\n    if (!isObject(target)) {\n      throw $typeError('@metadata', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');\n    }\n    // 4. If key is not undefined and IsPropertyKey(key) is false, throw a TypeError exception.\n    // 5. Let metadataKey be the value of F's [[MetadataKey]] internal slot.\n    // 6. Let metadataValue be the value of F's [[MetadataValue]] internal slot.\n    // 7. Perform ? target.[[DefineMetadata]](metadataKey, metadataValue, target, key).\n\n    OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, ensurePropertyKeyOrUndefined(propertyKey));\n\n    // 8. Return undefined.\n  }\n\n  return decorator;\n}\n\nfunction decorate(\n  decorators: (ClassDecorator | PropertyDecorator | MethodDecorator)[],\n  target: any,\n  propertyKey?: string | symbol,\n  attributes?: PropertyDescriptor | null,\n): PropertyDescriptor | Function | undefined {\n  if (propertyKey !== void 0) {\n    if (!Array.isArray(decorators)) {\n      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');\n    }\n    if (!isObject(target)) {\n      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Object or Function');\n    }\n    if (!isObject(attributes) && !isNullOrUndefined(attributes)) {\n      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'attributes', attributes, 'Object, Function, null, or undefined');\n    }\n    if (attributes === null) {\n      attributes = void 0;\n    }\n    propertyKey = toPropertyKey(propertyKey);\n    return DecorateProperty(decorators as (MethodDecorator | PropertyDecorator)[], target, propertyKey, attributes);\n  } else {\n    if (!Array.isArray(decorators)) {\n      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'decorators', decorators, 'Array');\n    }\n    if (typeof target !== 'function') {\n      throw $typeError('Metadata.decorate', [decorators, target, propertyKey, attributes], 'target', target, 'Function');\n    }\n    return DecorateConstructor(decorators as ClassDecorator[], target);\n  }\n}\n\nfunction DecorateConstructor(\n  decorators: ClassDecorator[],\n  target: Function,\n): Function {\n  for (let i = decorators.length - 1; i >= 0; --i) {\n    const decorator = decorators[i];\n    const decorated = decorator(target);\n    if (!isNullOrUndefined(decorated)) {\n      if (typeof decorated !== 'function') {\n        throw $typeError('DecorateConstructor', [decorators, target], 'decorated', decorated, 'Function, null, or undefined');\n      }\n      target = decorated;\n    }\n  }\n  return target;\n}\n\nfunction DecorateProperty(\n  decorators: (MethodDecorator | PropertyDecorator)[],\n  target: any,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor | undefined,\n): PropertyDescriptor | undefined {\n  for (let i = decorators.length - 1; i >= 0; --i) {\n    const decorator = decorators[i];\n    const decorated = decorator(target, propertyKey, descriptor!);\n    if (!isNullOrUndefined(decorated)) {\n      if (!isObject(decorated)) {\n        throw $typeError('DecorateProperty', [decorators, target, propertyKey, descriptor], 'decorated', decorated, 'Object, Function, null, or undefined');\n      }\n      descriptor = decorated;\n    }\n  }\n  return descriptor;\n}\n\n// 4.1.3 Reflect.defineMetadata(metadataKey, metadataValue, target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect.definemetadata\n/**\n * Define a unique metadata entry on the target.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param metadataValue - A value that contains attached metadata.\n * @param target - The target object on which to define metadata.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     Metadata.define(\"custom:annotation\", options, Example);\n *\n *     // decorator factory as metadata-producing annotation.\n *     function MyAnnotation(options): ClassDecorator {\n *         return target => Metadata.define(\"custom:annotation\", options, target);\n *     }\n *\n */\nfunction $define(metadataKey: any, metadataValue: any, target: any): void;\n/**\n * Define a unique metadata entry on the target.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param metadataValue - A value that contains attached metadata.\n * @param target - The target object on which to define metadata.\n * @param propertyKey - The property key for the target.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     Metadata.define(\"custom:annotation\", Number, Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     Metadata.define(\"custom:annotation\", Number, Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     Metadata.define(\"custom:annotation\", Number, Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     Metadata.define(\"custom:annotation\", Number, Example.prototype, \"method\");\n *\n *     // decorator factory as metadata-producing annotation.\n *     function MyAnnotation(options): PropertyDecorator {\n *         return (target, key) => Metadata.define(\"custom:annotation\", options, target, key);\n *     }\n *\n */\nfunction $define(metadataKey: any, metadataValue: any, target: any, propertyKey: string | symbol): void;\nfunction $define(metadataKey: any, metadataValue: any, target: any, propertyKey?: string | symbol): void {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.define', [metadataKey, metadataValue, target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[DefineMetadata]](metadataKey, metadataValue, propertyKey).\n  return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.4 Reflect.hasMetadata(metadataKey, target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect.hasmetadata\n\n/**\n * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.has(\"custom:annotation\", Example);\n *\n */\nfunction $has(metadataKey: any, target: any): boolean;\n/**\n * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns `true` - if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.has(\"custom:annotation\", Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.has(\"custom:annotation\", Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.has(\"custom:annotation\", Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.has(\"custom:annotation\", Example.prototype, \"method\");\n *\n */\nfunction $has(metadataKey: any, target: any, propertyKey: string | symbol): boolean;\nfunction $has(metadataKey: any, target: any, propertyKey?: string | symbol): boolean {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.has', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[HasMetadata]](metadataKey, propertyKey).\n  return OrdinaryHasMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.5 Reflect.hasOwnMetadata(metadataKey, target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect-hasownmetadata\n\n/**\n * Gets a value indicating whether the target object has the provided metadata key defined.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.hasOwn(\"custom:annotation\", Example);\n *\n */\nfunction $hasOwn(metadataKey: any, target: any): boolean;\n/**\n * Gets a value indicating whether the target object has the provided metadata key defined.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.hasOwn(\"custom:annotation\", Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.hasOwn(\"custom:annotation\", Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.hasOwn(\"custom:annotation\", Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.hasOwn(\"custom:annotation\", Example.prototype, \"method\");\n *\n */\nfunction $hasOwn(metadataKey: any, target: any, propertyKey: string | symbol): boolean;\nfunction $hasOwn(metadataKey: any, target: any, propertyKey?: string | symbol): boolean {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.hasOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[HasOwn]](metadataKey, propertyKey).\n  return OrdinaryHasOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.6 Reflect.getMetadata(metadataKey, target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect-getmetadata\n\n/**\n * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.get(\"custom:annotation\", Example);\n *\n */\nfunction $get(metadataKey: any, target: any): any;\n/**\n * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.get(\"custom:annotation\", Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.get(\"custom:annotation\", Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.get(\"custom:annotation\", Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.get(\"custom:annotation\", Example.prototype, \"method\");\n *\n */\nfunction $get(metadataKey: any, target: any, propertyKey: string | symbol): any;\nfunction $get(metadataKey: any, target: any, propertyKey?: string | symbol): any {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.get', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[GetMetadata]](metadataKey, propertyKey).\n  return OrdinaryGetMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.7 Reflect.getOwnMetadata(metadataKey, target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect-getownmetadata\n\n/**\n * Gets the metadata value for the provided metadata key on the target object.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.getOwn(\"custom:annotation\", Example);\n *\n */\nfunction $getOwn(metadataKey: any, target: any): any;\n/**\n * Gets the metadata value for the provided metadata key on the target object.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.getOwn(\"custom:annotation\", Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.getOwn(\"custom:annotation\", Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.getOwn(\"custom:annotation\", Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.getOwn(\"custom:annotation\", Example.prototype, \"method\");\n *\n */\nfunction $getOwn(metadataKey: any, target: any, propertyKey: string | symbol): any;\nfunction $getOwn(metadataKey: any, target: any, propertyKey?: string | symbol): any {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.getOwn', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[GetOwnMetadata]](metadataKey, propertyKey).\n  return OrdinaryGetOwnMetadata(metadataKey, target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.8 Reflect.getMetadataKeys(target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect-getmetadatakeys\n\n/**\n * Gets the metadata keys defined on the target object or its prototype chain.\n *\n * @param target - The target object on which the metadata is defined.\n * @returns An array of unique metadata keys.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.getKeys(Example);\n *\n */\nfunction $getKeys(target: any): any[];\n/**\n * Gets the metadata keys defined on the target object or its prototype chain.\n *\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns An array of unique metadata keys.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.getKeys(Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.getKeys(Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.getKeys(Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.getKeys(Example.prototype, \"method\");\n *\n */\nfunction $getKeys(target: any, propertyKey: string | symbol): any[];\nfunction $getKeys(target: any, propertyKey?: string | symbol): any[] {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.getKeys', [target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[GetMetadataKeys]](propertyKey).\n  return OrdinaryMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.9 Reflect.getOwnMetadataKeys(target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect-getownmetadata\n\n/**\n * Gets the unique metadata keys defined on the target object.\n *\n * @param target - The target object on which the metadata is defined.\n * @returns An array of unique metadata keys.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.getOwnKeys(Example);\n *\n */\nfunction $getOwnKeys(target: any): any[];\n/**\n * Gets the unique metadata keys defined on the target object.\n *\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns An array of unique metadata keys.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.getOwnKeys(Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.getOwnKeys(Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.getOwnKeys(Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.getOwnKeys(Example.prototype, \"method\");\n *\n */\nfunction $getOwnKeys(target: any, propertyKey: string | symbol): any[];\nfunction $getOwnKeys(target: any, propertyKey?: string | symbol): any[] {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.getOwnKeys', [target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[GetOwnMetadataKeys]](propertyKey).\n  return OrdinaryOwnMetadataKeys(target, toPropertyKeyOrUndefined(propertyKey));\n}\n\n// 4.1.10 Reflect.deleteMetadata(metadataKey, target [, propertyKey])\n// https://rbuckton.github.io/reflect-metadata/#reflect-deletemetadata\n\n/**\n * Deletes the metadata entry from the target object with the provided key.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n * @example\n *\n *     class Example {\n *     }\n *\n *     // constructor\n *     result = Metadata.delete(\"custom:annotation\", Example);\n *\n */\nfunction $delete(metadataKey: any, target: any): boolean;\n/**\n * Deletes the metadata entry from the target object with the provided key.\n *\n * @param metadataKey - A key used to store and retrieve metadata.\n * @param target - The target object on which the metadata is defined.\n * @param propertyKey - The property key for the target.\n * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n * @example\n *\n *     class Example {\n *         // property declarations are not part of ES6, though they are valid in TypeScript:\n *         // static staticProperty;\n *         // property;\n *\n *         static staticMethod(p) { }\n *         method(p) { }\n *     }\n *\n *     // property (on constructor)\n *     result = Metadata.delete(\"custom:annotation\", Example, \"staticProperty\");\n *\n *     // property (on prototype)\n *     result = Metadata.delete(\"custom:annotation\", Example.prototype, \"property\");\n *\n *     // method (on constructor)\n *     result = Metadata.delete(\"custom:annotation\", Example, \"staticMethod\");\n *\n *     // method (on prototype)\n *     result = Metadata.delete(\"custom:annotation\", Example.prototype, \"method\");\n *\n */\nfunction $delete(metadataKey: any, target: any, propertyKey: string | symbol): boolean;\nfunction $delete(metadataKey: any, target: any, propertyKey?: string | symbol): boolean {\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!isObject(target)) {\n    throw $typeError('Metadata.delete', [metadataKey, target, propertyKey], 'target', target, 'Object or Function');\n  }\n  // 2. Return ? target.[[DeleteMetadata]](metadataKey, propertyKey).\n  return OrdinaryDeleteMetadata(target, metadataKey, toPropertyKeyOrUndefined(propertyKey));\n}\n\nexport const Metadata = {\n  define: $define,\n  has: $has,\n  hasOwn: $hasOwn,\n  get: $get,\n  getOwn: $getOwn,\n  getKeys: $getKeys,\n  getOwnKeys: $getOwnKeys,\n  delete: $delete,\n};\n\nfunction def(\n  obj: object,\n  key: string,\n  value: unknown,\n  writable: boolean,\n  configurable: boolean,\n): void {\n  if (!Reflect.defineProperty(obj, key, {\n    writable,\n    enumerable: false,\n    configurable,\n    value,\n  })) {\n    throw new Error(`Unable to apply metadata polyfill: could not add property '${key}' to the global Reflect object`);\n  }\n}\n\nconst internalSlotName = '[[$au]]';\nfunction hasInternalSlot(reflect: typeof Reflect): reflect is typeof Reflect & { [internalSlotName]: typeof metadataInternalSlot } {\n  return internalSlotName in reflect;\n}\n\nfunction $applyMetadataPolyfill(\n  reflect: typeof Reflect,\n  writable: boolean,\n  configurable: boolean,\n): void {\n  def(reflect, internalSlotName, metadataInternalSlot, writable, configurable);\n\n  def(reflect, 'metadata', metadata, writable, configurable);\n  def(reflect, 'decorate', decorate, writable, configurable);\n  def(reflect, 'defineMetadata', $define, writable, configurable);\n  def(reflect, 'hasMetadata', $has, writable, configurable);\n  def(reflect, 'hasOwnMetadata', $hasOwn, writable, configurable);\n  def(reflect, 'getMetadata', $get, writable, configurable);\n  def(reflect, 'getOwnMetadata', $getOwn, writable, configurable);\n  def(reflect, 'getMetadataKeys', $getKeys, writable, configurable);\n  def(reflect, 'getOwnMetadataKeys', $getOwnKeys, writable, configurable);\n  def(reflect, 'deleteMetadata', $delete, writable, configurable);\n}\n\nexport function applyMetadataPolyfill(\n  reflect: typeof Reflect,\n  throwIfConflict: boolean = true,\n  forceOverwrite: boolean = false,\n  writable: boolean = true,\n  configurable: boolean = true,\n): void {\n  if (hasInternalSlot(reflect)) {\n    if (reflect[internalSlotName] === metadataInternalSlot) {\n      return;\n    }\n    throw new Error(`Conflicting @aurelia/metadata module import detected. Please make sure you have the same version of all Aurelia packages in your dependency tree.`);\n  }\n\n  const presentProps = [\n    'metadata',\n    'decorate',\n    'defineMetadata',\n    'hasMetadata',\n    'hasOwnMetadata',\n    'getMetadata',\n    'getOwnMetadata',\n    'getMetadataKeys',\n    'getOwnMetadataKeys',\n    'deleteMetadata',\n  ].filter(function (p) {\n    return p in Reflect;\n  });\n\n  if (presentProps.length > 0) {\n    if (throwIfConflict) {\n      const implementationSummary = presentProps.map(function (p) {\n        const impl = `${(Reflect as { [k: string]: Function })[p].toString().slice(0, 100)}...`;\n        return `${p}:\\n${impl}`;\n      }).join('\\n\\n');\n      throw new Error(`Conflicting reflect.metadata polyfill found. If you have 'reflect-metadata' or any other reflect polyfill imported, please remove it, if not (or if you must use a specific polyfill) please file an issue at https://github.com/aurelia/aurelia/issues so that we can look into compatibility options for this scenario. Implementation summary:\\n\\n${implementationSummary}`);\n    } else if (forceOverwrite) {\n      $applyMetadataPolyfill(reflect, writable, configurable);\n    }\n  } else {\n    $applyMetadataPolyfill(reflect, writable, configurable);\n  }\n}\n"],"names":[],"mappings":"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"}