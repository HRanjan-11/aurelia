{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["export interface IConfigurableRoute<T> {\n  readonly path: string;\n  readonly caseSensitive?: boolean;\n  readonly handler: T;\n}\n\nexport class ConfigurableRoute<T> implements IConfigurableRoute<T> {\n  public constructor(\n    public readonly path: string,\n    public readonly caseSensitive: boolean,\n    public handler: T,\n  ) {}\n}\n\nexport class Endpoint<T> {\n  public constructor(\n    public readonly route: ConfigurableRoute<T>,\n    public readonly paramNames: readonly string[],\n  ) {}\n}\n\nexport class RecognizedRoute<T> {\n  public constructor(\n    public readonly endpoint: Endpoint<T>,\n    public readonly params: Readonly<Record<string, string | undefined>>,\n  ) {}\n}\n\nclass Candidate<T> {\n  public head: AnyState<T>;\n  public endpoint: Endpoint<T>;\n\n  public constructor(\n    private readonly chars: string[],\n    private readonly states: AnyState<T>[],\n    private readonly skippedStates: DynamicState<T>[],\n    private readonly result: RecognizeResult<T>,\n  ) {\n    this.head = states[states.length - 1];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n    this.endpoint = this.head?.endpoint!;\n  }\n\n  public advance(ch: string): void {\n    const { chars, states, skippedStates, result } = this;\n    let stateToAdd: AnyState<T> | null = null;\n\n    let matchCount = 0;\n    const state = states[states.length - 1];\n\n    function $process(\n      nextState: AnyState<T>,\n      skippedState: DynamicState<T> | null,\n    ): void {\n      if (nextState.isMatch(ch)) {\n        if (++matchCount === 1) {\n          stateToAdd = nextState;\n        } else {\n          result.add(\n            new Candidate(\n              chars.concat(ch),\n              states.concat(nextState),\n              skippedState === null ? skippedStates : skippedStates.concat(skippedState),\n              result,\n            ),\n          );\n        }\n      }\n\n      if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {\n        if (nextState.nextStates.length > 1) {\n          throw new Error(`${nextState.nextStates.length} nextStates`);\n        }\n        const separator = nextState.nextStates[0];\n        if (!separator.isSeparator) {\n          throw new Error(`Not a separator`);\n        }\n        if (separator.nextStates !== null) {\n          for (const $nextState of separator.nextStates) {\n            $process($nextState, nextState);\n          }\n        }\n      }\n    }\n\n    if (state.isDynamic) {\n      $process(state, null);\n    }\n    if (state.nextStates !== null) {\n      for (const nextState of state.nextStates) {\n        $process(nextState, null);\n      }\n    }\n\n    if (stateToAdd !== null) {\n      states.push(this.head = stateToAdd);\n      chars.push(ch);\n      if ((stateToAdd as AnyState<T>).endpoint !== null) {\n        this.endpoint = (stateToAdd as AnyState<T>).endpoint!;\n      }\n    }\n\n    if (matchCount === 0) {\n      result.remove(this);\n    }\n  }\n\n  public finalize(): void {\n    function collectSkippedStates(\n      skippedStates: DynamicState<T>[],\n      state: AnyState<T>,\n    ): void {\n      const nextStates = state.nextStates;\n      if (nextStates !== null) {\n        if (nextStates.length === 1 && nextStates[0].segment === null) {\n          collectSkippedStates(skippedStates, nextStates[0]);\n        } else {\n          for (const nextState of nextStates) {\n            if (nextState.isOptional && nextState.endpoint !== null) {\n              skippedStates.push(nextState);\n              if (nextState.nextStates !== null) {\n                for (const $nextState of nextState.nextStates) {\n                  collectSkippedStates(skippedStates, $nextState);\n                }\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    collectSkippedStates(this.skippedStates, this.head);\n  }\n\n  public getParams(): Record<string, string | undefined> {\n    const { states, chars, endpoint } = this;\n\n    const params: Record<string, string | undefined> = {};\n    // First initialize all properties with undefined so they all exist (even if they're not filled, e.g. non-matched optional params)\n    for (const name of endpoint.paramNames) {\n      params[name] = void 0;\n    }\n\n    for (let i = 0, ii = states.length; i < ii; ++i) {\n      const state = states[i];\n      if (state.isDynamic) {\n        const name = state.segment.name;\n        if (params[name] === void 0) {\n          params[name] = chars[i];\n        } else {\n          params[name] += chars[i];\n        }\n      }\n    }\n\n    return params;\n  }\n\n  /**\n   * Compares this candidate to another candidate to determine the correct sorting order.\n   *\n   * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares\n   * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types\n   *\n   * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the\n   * same sorting value because they both consist of two static segments and one dynamic segment.\n   *\n   * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,\n   * and static wins over dynamic.\n   *\n   * ### NOTE\n   * This algorithm violates some of the invariants of v1's algorithm,\n   * but those invariants were arguably not very sound to begin with. Example:\n   *\n   * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`\n   * - in v1, the first would win because that match has fewer stars\n   * - in v2, the second will win because there is a bigger static match at the start of the pattern\n   *\n   * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of\n   * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,\n   * intentionally or unintentionally.\n   *\n   * @param b - The candidate to compare this to.\n   * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.\n   * This will bring the candidate with the highest score to the first position of the array.\n   */\n  public compareTo(b: Candidate<T>): -1 | 1 | 0 {\n    const statesA = this.states;\n    const statesB = b.states;\n\n    for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {\n      let stateA = statesA[iA];\n      if (stateA === void 0) {\n        return 1;\n      }\n\n      let stateB = statesB[iB];\n      if (stateB === void 0) {\n        return -1;\n      }\n\n      let segmentA = stateA.segment;\n      let segmentB = stateB.segment;\n      if (segmentA === null) {\n        if (segmentB === null) {\n          ++iB;\n          continue;\n        }\n\n        if ((stateA = statesA[++iA]) === void 0) {\n          return 1;\n        }\n\n        segmentA = stateA.segment!;\n      } else if (segmentB === null) {\n        if ((stateB = statesB[++iB]) === void 0) {\n          return -1;\n        }\n\n        segmentB = stateB.segment!;\n      }\n\n      if (segmentA.kind < segmentB.kind) {\n        return 1;\n      }\n\n      if (segmentA.kind > segmentB.kind) {\n        return -1;\n      }\n\n      ++iB;\n    }\n\n    const skippedStatesA = this.skippedStates;\n    const skippedStatesB = b.skippedStates;\n\n    const skippedStatesALen = skippedStatesA.length;\n    const skippedStatesBLen = skippedStatesB.length;\n\n    if (skippedStatesALen < skippedStatesBLen) {\n      return 1;\n    }\n\n    if (skippedStatesALen > skippedStatesBLen) {\n      return -1;\n    }\n\n    for (let i = 0; i < skippedStatesALen; ++i) {\n      const skippedStateA = skippedStatesA[i];\n      const skippedStateB = skippedStatesB[i];\n\n      if (skippedStateA.length < skippedStateB.length) {\n        return 1;\n      }\n\n      if (skippedStateA.length > skippedStateB.length) {\n        return -1;\n      }\n    }\n\n    // This should only be possible with a single pattern with multiple consecutive star segments.\n    // TODO: probably want to warn or even throw here, but leave it be for now.\n    return 0;\n  }\n}\n\nfunction hasEndpoint<T>(candidate: Candidate<T>): boolean {\n  return candidate.head.endpoint !== null;\n}\n\nfunction compareChains<T>(a: Candidate<T>, b: Candidate<T>): -1 | 1 | 0 {\n  return a.compareTo(b);\n}\n\nclass RecognizeResult<T> {\n  private readonly candidates: Candidate<T>[] = [];\n\n  public get isEmpty(): boolean {\n    return this.candidates.length === 0;\n  }\n\n  public constructor(rootState: SeparatorState<T>) {\n    this.candidates = [new Candidate([''], [rootState], [], this)];\n  }\n\n  public getSolution(): Candidate<T> | null {\n    const candidates = this.candidates.filter(hasEndpoint);\n    if (candidates.length === 0) {\n      return null;\n    }\n\n    for (const candidate of candidates) {\n      candidate.finalize();\n    }\n\n    candidates.sort(compareChains);\n\n    return candidates[0];\n  }\n\n  public add(candidate: Candidate<T>): void {\n    this.candidates.push(candidate);\n  }\n\n  public remove(candidate: Candidate<T>): void {\n    this.candidates.splice(this.candidates.indexOf(candidate), 1);\n  }\n\n  public advance(ch: string): void {\n    const candidates = this.candidates.slice();\n\n    for (const candidate of candidates) {\n      candidate.advance(ch);\n    }\n  }\n}\n\nexport class RouteRecognizer<T> {\n  private readonly rootState: SeparatorState<T> = new State(null, null, '') as SeparatorState<T>;\n  private readonly cache: Map<string, RecognizedRoute<T> | null> = new Map<string, RecognizedRoute<T> | null>();\n\n  public add(routeOrRoutes: IConfigurableRoute<T> | readonly IConfigurableRoute<T>[]): void {\n    if (routeOrRoutes instanceof Array) {\n      for (const route of routeOrRoutes) {\n        this.$add(route);\n      }\n    } else {\n      this.$add(routeOrRoutes as IConfigurableRoute<T>);\n    }\n\n    // Clear the cache whenever there are state changes, because the recognizeResults could be arbitrarily different as a result\n    this.cache.clear();\n  }\n\n  private $add(route: IConfigurableRoute<T>): void {\n    const path = route.path;\n    const $route = new ConfigurableRoute(route.path, route.caseSensitive === true, route.handler);\n\n    // Normalize leading, trailing and double slashes by ignoring empty segments\n    const parts = path === '' ? [''] : path.split('/').filter(isNotEmpty);\n    const paramNames: string[] = [];\n\n    let state = this.rootState as AnyState<T>;\n\n    for (const part of parts) {\n      // Each segment always begins with a slash, so we represent this with a non-segment state\n      state = state.append(null, '/');\n\n      switch (part.charAt(0)) {\n        case ':': { // route parameter\n          const isOptional = part.endsWith('?');\n          const name = isOptional ? part.slice(1, -1) : part.slice(1);\n          paramNames.push(name);\n          state = new DynamicSegment<T>(name, isOptional).appendTo(state);\n          break;\n        }\n        case '*': { // dynamic route\n          const name = part.slice(1);\n          paramNames.push(name);\n          state = new StarSegment<T>(name).appendTo(state);\n          break;\n        }\n        default: { // standard path route\n          state = new StaticSegment<T>(part, $route.caseSensitive).appendTo(state);\n          break;\n        }\n      }\n    }\n\n    const endpoint = new Endpoint<T>($route, paramNames);\n\n    state.setEndpoint(endpoint);\n  }\n\n  public recognize(path: string): RecognizedRoute<T> | null {\n    let result = this.cache.get(path);\n    if (result === void 0) {\n      this.cache.set(path, result = this.$recognize(path));\n    }\n    return result;\n  }\n\n  private $recognize(path: string): RecognizedRoute<T> | null {\n    path = decodeURI(path);\n\n    if (!path.startsWith('/')) {\n      path = `/${path}`;\n    }\n\n    if (path.length > 1 && path.endsWith('/')) {\n      path = path.slice(0, -1);\n    }\n\n    const result = new RecognizeResult(this.rootState);\n    for (let i = 0, ii = path.length; i < ii; ++i) {\n      const ch = path.charAt(i);\n      result.advance(ch);\n\n      if (result.isEmpty) {\n        return null;\n      }\n    }\n\n    const candidate = result.getSolution();\n    if (candidate === null) {\n      return null;\n    }\n\n    const { endpoint } = candidate;\n    const params = candidate.getParams();\n\n    return new RecognizedRoute<T>(endpoint, params);\n  }\n}\n\ntype StaticState<T> = State<T> & {\n  readonly isSeparator: false;\n  readonly isDynamic: false;\n  readonly isOptional: false;\n\n  readonly prevState: StaticState<T> | SeparatorState<T>;\n  readonly segment: StaticSegment<T>;\n};\n\ntype DynamicState<T> = State<T> & {\n  readonly isSeparator: false;\n  readonly isDynamic: true;\n  readonly isOptional: true | false;\n\n  readonly prevState: SeparatorState<T>;\n  readonly segment: DynamicSegment<T>;\n};\n\ntype StarState<T> = State<T> & {\n  readonly isSeparator: false;\n  readonly isDynamic: true;\n  readonly isOptional: false;\n\n  readonly prevState: SeparatorState<T>;\n  readonly segment: StarSegment<T>;\n};\n\ntype SeparatorState<T> = State<T> & {\n  readonly isSeparator: true;\n  readonly isDynamic: false;\n  readonly isOptional: false;\n\n  readonly path: null;\n  readonly segment: null;\n};\n\ntype AnyState<T> = (\n  StaticState<T> |\n  DynamicState<T> |\n  StarState<T> |\n  SeparatorState<T>\n);\n\ntype SegmentToState<S, T> = (\n  S extends StaticSegment<T> ? StaticState<T> :\n  S extends DynamicSegment<T> ? DynamicState<T> :\n  S extends StarSegment<T> ? StarState<T> :\n  S extends null ? SeparatorState<T> :\n  never\n);\n\nclass State<T> {\n  public nextStates: AnyState<T>[] | null = null;\n  public readonly isSeparator: boolean;\n  public readonly isDynamic: boolean;\n  public readonly isOptional: boolean;\n\n  public endpoint: Endpoint<T> | null = null;\n  public readonly length: number;\n\n  public constructor(\n    public readonly prevState: AnyState<T> | null,\n    public readonly segment: AnySegment<T> | null,\n    public readonly value: string,\n  ) {\n    switch (segment?.kind) {\n      case SegmentKind.dynamic:\n        this.length = prevState!.length + 1;\n        this.isSeparator = false;\n        this.isDynamic = true;\n        this.isOptional = segment.optional;\n        break;\n      case SegmentKind.star:\n        this.length = prevState!.length + 1;\n        this.isSeparator = false;\n        this.isDynamic = true;\n        this.isOptional = false;\n        break;\n      case SegmentKind.static:\n        this.length = prevState!.length + 1;\n        this.isSeparator = false;\n        this.isDynamic = false;\n        this.isOptional = false;\n        break;\n      case undefined:\n        this.length = prevState === null ? 0 : prevState.length;\n        this.isSeparator = true;\n        this.isDynamic = false;\n        this.isOptional = false;\n        break;\n    }\n  }\n\n  public append<S extends AnySegment<T> | null>(segment: S, value: string): SegmentToState<S, T> {\n    let state: AnyState<T> | undefined;\n    let nextStates = this.nextStates;\n    if (nextStates === null) {\n      state = void 0;\n      nextStates = this.nextStates = [];\n    } else if (segment === null) {\n      state = nextStates.find(s => s.value === value);\n    } else {\n      state = nextStates.find(s => s.segment?.equals(segment!));\n    }\n\n    if (state === void 0) {\n      nextStates.push(state = new State(this as AnyState<T>, segment, value) as AnyState<T>);\n    }\n\n    return state as SegmentToState<S, T>;\n  }\n\n  public setEndpoint(this: AnyState<T>, endpoint: Endpoint<T>): void {\n    if (this.endpoint !== null) {\n      throw new Error(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);\n    }\n    this.endpoint = endpoint;\n    if (this.isOptional) {\n      this.prevState.setEndpoint(endpoint);\n      if (this.prevState.isSeparator && this.prevState.prevState !== null) {\n        this.prevState.prevState.setEndpoint(endpoint);\n      }\n    }\n  }\n\n  public isMatch(ch: string): boolean {\n    const segment = this.segment;\n    switch (segment?.kind) {\n      case SegmentKind.dynamic:\n        return !this.value.includes(ch);\n      case SegmentKind.star:\n        return true;\n      case SegmentKind.static:\n      case undefined:\n        // segment separators (slashes) are non-segments. We could say return ch === '/' as well, technically.\n        return this.value.includes(ch);\n    }\n  }\n}\n\nfunction isNotEmpty(segment: string): boolean {\n  return segment.length > 0;\n}\n\ntype AnySegment<T> = (\n  StaticSegment<T> |\n  DynamicSegment<T> |\n  StarSegment<T>\n);\n\nconst enum SegmentKind {\n  star    = 1,\n  dynamic = 2,\n  static  = 3,\n}\n\nclass StaticSegment<T> {\n  public get kind(): SegmentKind.static { return SegmentKind.static; }\n\n  public constructor(\n    public readonly value: string,\n    public readonly caseSensitive: boolean,\n  ) {}\n\n  public appendTo(state: AnyState<T>): StaticState<T> {\n    const { value, value: { length } } = this;\n\n    if (this.caseSensitive) {\n      for (let i = 0; i < length; ++i) {\n        state = state.append(\n          /* segment */this,\n          /* value   */value.charAt(i),\n        );\n      }\n    } else {\n      for (let i = 0; i < length; ++i) {\n        const ch = value.charAt(i);\n        state = state.append(\n          /* segment */this,\n          /* value   */ch.toUpperCase() + ch.toLowerCase(),\n        );\n      }\n    }\n\n    return state as StaticState<T>;\n  }\n\n  public equals(b: AnySegment<T>): boolean {\n    return (\n      b.kind === SegmentKind.static &&\n      b.caseSensitive === this.caseSensitive &&\n      b.value === this.value\n    );\n  }\n}\n\nclass DynamicSegment<T> {\n  public get kind(): SegmentKind.dynamic { return SegmentKind.dynamic; }\n\n  public constructor(\n    public readonly name: string,\n    public readonly optional: boolean,\n  ) {}\n\n  public appendTo(state: AnyState<T>): DynamicState<T> {\n    state = state.append(\n      /* segment */this,\n      /* value   */'/',\n    );\n\n    return state;\n  }\n\n  public equals(b: AnySegment<T>): boolean {\n    return (\n      b.kind === SegmentKind.dynamic &&\n      b.optional === this.optional &&\n      b.name === this.name\n    );\n  }\n}\n\nclass StarSegment<T> {\n  public get kind(): SegmentKind.star { return SegmentKind.star; }\n\n  public constructor(\n    public readonly name: string,\n  ) {}\n\n  public appendTo(state: AnyState<T>): StarState<T> {\n    state = state.append(\n      /* segment */this,\n      /* value   */'',\n    );\n\n    return state;\n  }\n\n  public equals(b: AnySegment<T>): boolean {\n    return (\n      b.kind === SegmentKind.star &&\n      b.name === this.name\n    );\n  }\n}\n"],"names":[],"mappings":"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"}