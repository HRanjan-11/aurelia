import{DI as t,IServiceLocator as e,optional as r,Registration as s,noop as i}from"../../../kernel/dist/native-modules/index.js";import{parsePropertyName as o,ValidationResult as n,ValidateInstruction as l,PropertyRule as a,IValidator as c,getDefaultValidationConfiguration as u,ValidationConfiguration as d}from"../../../validation/dist/native-modules/index.js";import{IPlatform as h,bindable as g,INode as p,BindingMode as v,customAttribute as f,BindingInterceptor as b,BindingMediator as m,bindingBehavior as y,PropertyBinding as w,CustomElement as E}from"../../../runtime-html/dist/native-modules/index.js";import{IExpressionParser as C}from"../../../runtime/dist/native-modules/index.js";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function R(t,e,r,s){var i,o=arguments.length,n=o<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(t,e,r,s);else for(var l=t.length-1;l>=0;l--)(i=t[l])&&(n=(o<3?i(n):o>3?i(e,r,n):i(e,r))||n);return o>3&&n&&Object.defineProperty(e,r,n),n}function B(t,e){return function(r,s){e(r,s,t)}}var T;!function(t){t.validate="validate",t.reset="reset"}(T||(T={}));class j{constructor(t,e,r){this.valid=t,this.results=e,this.instruction=r}}class I{constructor(t,e){this.result=t,this.targets=e}}class k{constructor(t,e,r){this.kind=t,this.addedResults=e,this.removedResults=r}}class O{constructor(t,e,r,s){this.target=t,this.scope=e,this.rules=r,this.propertyInfo=s}}class S{constructor(t,e){this.object=t,this.propertyName=e}}function $(t,e,r=0){let s=e.propertyInfo;if(void 0!==s)return s;const i=e.scope;let o=t.sourceExpression.expression;const n=t.locator;let l,a=!0,c="";for(;void 0!==o&&10082!==(null==o?void 0:o.$kind);){let t;switch(o.$kind){case 38962:case 36913:o=o.expression;continue;case 9323:t=o.name;break;case 9324:{const e=o.key;a&&(a=17925===e.$kind),t=`[${e.evaluate(r,i,n,null).toString()}]`;break}default:throw new Error(`Unknown expression of type ${o.constructor.name}`)}const e=c.startsWith("[")?"":".";c=0===c.length?t:`${t}${e}${c}`,o=o.object}if(void 0===o)throw new Error(`Unable to parse binding expression: ${t.sourceExpression.expression}`);return 0===c.length?(c=o.name,l=i.bindingContext):l=o.evaluate(r,i,n,null),null!=l?(s=new S(l,c),a&&(e.propertyInfo=s),s):void 0}const x=t.createInterface("IValidationController");let D=class{constructor(t,e,r,s){this.validator=t,this.parser=e,this.platform=r,this.locator=s,this.bindings=new Map,this.subscribers=new Set,this.results=[],this.validating=!1,this.elements=new WeakMap,this.objects=new Map}addObject(t,e){this.objects.set(t,e)}removeObject(t){this.objects.delete(t),this.processResultDelta("reset",this.results.filter((e=>e.object===t)),[])}addError(t,e,r){let s;void 0!==r&&([s]=o(r,this.parser));const i=new n(!1,t,s,e,void 0,void 0,!0);return this.processResultDelta("validate",[],[i]),i}removeError(t){this.results.includes(t)&&this.processResultDelta("reset",[t],[])}addSubscriber(t){this.subscribers.add(t)}removeSubscriber(t){this.subscribers.delete(t)}registerBinding(t,e){this.bindings.set(t,e)}unregisterBinding(t){this.resetBinding(t),this.bindings.delete(t)}async validate(t){var e;const{object:r,objectTag:s,flags:i}=null!=t?t:{};let o;o=void 0!==r?[new l(r,t.propertyName,null!==(e=t.rules)&&void 0!==e?e:this.objects.get(r),s,t.propertyTag)]:[...Array.from(this.objects.entries()).map((([t,e])=>new l(t,void 0,e,s))),...(s?[]:Array.from(this.bindings.entries())).reduce(((t,[e,r])=>{const s=$(e,r,i);return void 0===s||this.objects.has(s.object)||t.push(new l(s.object,s.propertyName,r.rules)),t}),[])],this.validating=!0;return this.platform.domReadQueue.queueTask((async()=>{try{const e=(await Promise.all(o.map((async t=>this.validator.validate(t))))).reduce(((t,e)=>(t.push(...e),t)),[]),r=this.getInstructionPredicate(t),s=this.results.filter(r);return this.processResultDelta("validate",s,e),new j(void 0===e.find((t=>!t.valid)),e,t)}finally{this.validating=!1}})).result}reset(t){const e=this.getInstructionPredicate(t),r=this.results.filter(e);this.processResultDelta("reset",r,[])}async validateBinding(t){if(!t.isBound)return;const e=this.bindings.get(t);if(void 0===e)return;const r=$(t,e),s=e.rules;if(void 0===r)return;const{object:i,propertyName:o}=r;await this.validate(new l(i,o,s))}resetBinding(t){const e=this.bindings.get(t);if(void 0===e)return;const r=$(t,e);if(void 0===r)return;e.propertyInfo=void 0;const{object:s,propertyName:i}=r;this.reset(new l(s,i))}async revalidateErrors(){const t=this.results.reduce(((t,{isManual:e,object:r,propertyRule:s,rule:i,valid:o})=>{if(!o&&!e&&void 0!==s&&void 0!==r&&void 0!==i){let e=t.get(r);void 0===e&&t.set(r,e=new Map);let o=e.get(s);void 0===o&&e.set(s,o=[]),o.push(i)}return t}),new Map),e=[];for(const[r,s]of t)e.push(this.validate(new l(r,void 0,Array.from(s).map((([{validationRules:t,messageProvider:e,property:r},s])=>new a(this.locator,t,e,r,[s]))))));await Promise.all(e)}getInstructionPredicate(t){if(void 0===t)return()=>!0;const e=t.propertyName,r=t.rules;return s=>!s.isManual&&s.object===t.object&&(void 0===e||s.propertyName===e)&&(void 0===r||r.includes(s.propertyRule)||r.some((t=>void 0===s.propertyRule||t.$rules.flat().every((t=>s.propertyRule.$rules.flat().includes(t))))))}getAssociatedElements({object:t,propertyName:e}){const r=[];for(const[s,i]of this.bindings.entries()){const o=$(s,i);void 0!==o&&o.object===t&&o.propertyName===e&&r.push(i.target)}return r}processResultDelta(t,e,r){const s=new k(t,[],[]);r=r.slice(0);const i=this.elements;for(const t of e){const e=i.get(t);i.delete(t),s.removedResults.push(new I(t,e));const o=r.findIndex((e=>e.rule===t.rule&&e.object===t.object&&e.propertyName===t.propertyName));if(-1===o)this.results.splice(this.results.indexOf(t),1);else{const e=r.splice(o,1)[0],n=this.getAssociatedElements(e);i.set(e,n),s.addedResults.push(new I(e,n)),this.results.splice(this.results.indexOf(t),1,e)}}for(const t of r){const e=this.getAssociatedElements(t);s.addedResults.push(new I(t,e)),i.set(t,e),this.results.push(t)}for(const t of this.subscribers)t.handleValidationEvent(s)}};D=R([B(0,c),B(1,C),B(2,h),B(3,e)],D);class M{constructor(){this.Type=void 0}registerTransformer(t){return!1}construct(t,e){return void 0!==e?Reflect.construct(D,e):new D(t.get(c),t.get(C),t.get(h),t)}}function A(t,e){switch(2&t.compareDocumentPosition(e)){case 0:return 0;case 2:return 1;default:return-1}}const N="\n<slot></slot>\n<slot name='secondary'>\n  <span repeat.for=\"error of errors\">\n    ${error.result.message}\n  </span>\n</slot>\n",P={name:"validation-container",shadowOptions:{mode:"open"},hasSlots:!0};let V=class{constructor(t,e){this.host=t,this.scopedController=e,this.errors=[]}handleValidationEvent(t){for(const{result:e}of t.removedResults){const t=this.errors.findIndex((t=>t.result===e));-1!==t&&this.errors.splice(t,1)}for(const{result:e,targets:r}of t.addedResults){if(e.valid)continue;const t=r.filter((t=>this.host.contains(t)));t.length>0&&this.errors.push(new I(e,t))}this.errors.sort(((t,e)=>t.targets[0]===e.targets[0]?0:A(t.targets[0],e.targets[0])))}binding(){var t;this.controller=null!==(t=this.controller)&&void 0!==t?t:this.scopedController,this.controller.addSubscriber(this)}unbinding(){this.controller.removeSubscriber(this)}};R([g],V.prototype,"controller",void 0),R([g],V.prototype,"errors",void 0),V=R([B(0,p),B(1,r(x))],V);let F=class{constructor(t,e){this.host=t,this.scopedController=e,this.errors=[],this.errorsInternal=[]}handleValidationEvent(t){for(const{result:e}of t.removedResults){const t=this.errorsInternal.findIndex((t=>t.result===e));-1!==t&&this.errorsInternal.splice(t,1)}for(const{result:e,targets:r}of t.addedResults){if(e.valid)continue;const t=r.filter((t=>this.host.contains(t)));t.length>0&&this.errorsInternal.push(new I(e,t))}this.errorsInternal.sort(((t,e)=>t.targets[0]===e.targets[0]?0:A(t.targets[0],e.targets[0]))),this.errors=this.errorsInternal}binding(){var t;this.controller=null!==(t=this.controller)&&void 0!==t?t:this.scopedController,this.controller.addSubscriber(this)}unbinding(){this.controller.removeSubscriber(this)}};var L;R([g],F.prototype,"controller",void 0),R([g({primary:!0,mode:v.twoWay})],F.prototype,"errors",void 0),F=R([f("validation-errors"),B(0,p),B(1,r(x))],F),function(t){t.manual="manual",t.blur="blur",t.focusout="focusout",t.change="change",t.changeOrBlur="changeOrBlur",t.changeOrFocusout="changeOrFocusout"}(L||(L={}));const U=t.createInterface("IDefaultTrigger");let q=class extends b{constructor(t,e){super(t,e),this.binding=t,this.propertyBinding=void 0,this.target=void 0,this.isChangeTrigger=!1,this.triggerMediator=new m("handleTriggerChange",this,this.observerLocator,this.locator),this.controllerMediator=new m("handleControllerChange",this,this.observerLocator,this.locator),this.rulesMediator=new m("handleRulesChange",this,this.observerLocator,this.locator),this.isDirty=!1,this.validatedOnce=!1,this.triggerEvent=null,this.task=null;const r=this.locator;this.platform=r.get(h),this.defaultTrigger=r.get(U),r.has(x,!0)&&(this.scopedController=r.get(x)),this.setPropertyBinding()}updateSource(t,e){this.interceptor!==this?this.interceptor.updateSource(t,e):this.propertyBinding.updateSource(t,e),this.isDirty=!0;const r=this.triggerEvent;this.isChangeTrigger&&(null===r||null!==r&&this.validatedOnce)&&this.validateBinding()}handleEvent(t){(!this.isChangeTrigger||this.isChangeTrigger&&this.isDirty)&&this.validateBinding()}$bind(t,e){this.scope=e,this.binding.$bind(t,e),this.setTarget();const r=this.processBindingExpressionArgs(t);this.processDelta(r)}$unbind(t){var e,r,s,i;null===(e=this.task)||void 0===e||e.cancel(),this.task=null;const o=this.triggerEvent;null!==o&&(null===(r=this.target)||void 0===r||r.removeEventListener(o,this)),null===(s=this.controller)||void 0===s||s.removeSubscriber(this),null===(i=this.controller)||void 0===i||i.unregisterBinding(this.propertyBinding),this.binding.$unbind(t)}handleTriggerChange(t,e,r){this.processDelta(new W(void 0,this.ensureTrigger(t),void 0))}handleControllerChange(t,e,r){this.processDelta(new W(this.ensureController(t),void 0,void 0))}handleRulesChange(t,e,r){this.processDelta(new W(void 0,void 0,this.ensureRules(t)))}handleValidationEvent(t){var e;const r=null===(e=this.bindingInfo.propertyInfo)||void 0===e?void 0:e.propertyName;void 0!==r&&null!==this.triggerEvent&&this.isChangeTrigger&&(this.validatedOnce=void 0!==t.addedResults.find((t=>t.result.propertyName===r)))}processBindingExpressionArgs(t){const e=this.scope,r=this.locator;let s,i,o,n=this.propertyBinding.sourceExpression;for(;"validate"!==n.name&&void 0!==n;)n=n.expression;const l=1|t,a=n.args;for(let t=0,n=a.length;t<n;t++){const n=a[t];switch(t){case 0:i=this.ensureTrigger(n.evaluate(l,e,r,this.triggerMediator));break;case 1:o=this.ensureController(n.evaluate(l,e,r,this.controllerMediator));break;case 2:s=this.ensureRules(n.evaluate(l,e,r,this.rulesMediator));break;default:throw new Error(`Unconsumed argument#${t+1} for validate binding behavior: ${n.evaluate(l,e,r,null)}`)}}return new W(this.ensureController(o),this.ensureTrigger(i),s)}validateBinding(){const t=this.task;this.task=this.platform.domReadQueue.queueTask((()=>this.controller.validateBinding(this.propertyBinding))),t!==this.task&&(null==t||t.cancel())}processDelta(t){var e,r,s,i;const o=null!==(e=t.trigger)&&void 0!==e?e:this.trigger,n=null!==(r=t.controller)&&void 0!==r?r:this.controller,l=t.rules;if(this.trigger!==o){let t=this.triggerEvent;null!==t&&this.target.removeEventListener(t,this),this.validatedOnce=!1,this.isDirty=!1,this.trigger=o,this.isChangeTrigger=o===L.change||o===L.changeOrBlur||o===L.changeOrFocusout,t=this.setTriggerEvent(this.trigger),null!==t&&this.target.addEventListener(t,this)}this.controller===n&&void 0===l||(null===(s=this.controller)||void 0===s||s.removeSubscriber(this),null===(i=this.controller)||void 0===i||i.unregisterBinding(this.propertyBinding),this.controller=n,n.registerBinding(this.propertyBinding,this.setBindingInfo(l)),n.addSubscriber(this))}ensureTrigger(t){if(null==t)t=this.defaultTrigger;else if(!Object.values(L).includes(t))throw new Error(`${t} is not a supported validation trigger`);return t}ensureController(t){if(null==t)t=this.scopedController;else if(!(t instanceof D))throw new Error(`${t} is not of type ValidationController`);return t}ensureRules(t){if(Array.isArray(t)&&t.every((t=>t instanceof a)))return t}setPropertyBinding(){let t=this.binding;for(;!(t instanceof w)&&void 0!==t;)t=t.binding;if(void 0===t)throw new Error("Unable to set property binding");this.propertyBinding=t}setTarget(){var t;const e=this.propertyBinding.target;if(e instanceof this.platform.Node)this.target=e;else{const r=null===(t=e)||void 0===t?void 0:t.$controller;if(void 0===r)throw new Error("Invalid binding target");this.target=r.host}}setTriggerEvent(t){let e=null;switch(t){case L.blur:case L.changeOrBlur:e="blur";break;case L.focusout:case L.changeOrFocusout:e="focusout"}return this.triggerEvent=e}setBindingInfo(t){return this.bindingInfo=new O(this.target,this.scope,t)}};q=R([y("validate")],q);class W{constructor(t,e,r){this.controller=t,this.trigger=e,this.rules=r}}function z(){return{...u(),ValidationControllerFactoryType:M,DefaultTrigger:L.focusout,UseSubscriberCustomAttribute:!0,SubscriberCustomElementTemplate:N}}const Q=function t(e){return{optionsProvider:e,register(t){const r=z();e(r),t.registerFactory(x,new r.ValidationControllerFactoryType),t.register(d.customize((t=>{for(const e of Object.keys(t))e in r&&(t[e]=r[e])})),s.instance(U,r.DefaultTrigger),q),r.UseSubscriberCustomAttribute&&t.register(F);const i=r.SubscriberCustomElementTemplate;return i&&t.register(E.define({...P,template:i},V)),t},customize:r=>t(null!=r?r:e)}}(i);let G=class{constructor(t){this.platform=t}handleValidationEvent(t){for(const[e,r]of this.reverseMap(t.removedResults))this.remove(e,r);for(const[e,r]of this.reverseMap(t.addedResults))this.add(e,r)}remove(t,e){const r=this.getValidationMessageContainer(t);null!==r&&this.removeResults(r,e)}add(t,e){const r=this.getValidationMessageContainer(t);null!==r&&this.showResults(r,e)}getValidationMessageContainer(t){const e=t.parentElement;if(null===e)return null;let r=e.querySelector("[validation-result-container]");return null===r&&(r=this.platform.document.createElement("div"),r.setAttribute("validation-result-container",""),e.appendChild(r)),r}showResults(t,e){t.append(...e.reduce(((t,e)=>{if(!e.valid){const r=this.platform.document.createElement("span");r.setAttribute("validation-result-id",e.id.toString()),r.textContent=e.message,t.push(r)}return t}),[]))}removeResults(t,e){var r;for(const s of e)s.valid||null===(r=t.querySelector(`[validation-result-id="${s.id}"]`))||void 0===r||r.remove()}reverseMap(t){const e=new Map;for(const{result:r,targets:s}of t)for(const t of s){let s=e.get(t);void 0===s&&e.set(t,s=[]),s.push(r)}return e}};G=R([B(0,h)],G);export{O as BindingInfo,j as ControllerValidateResult,U as IDefaultTrigger,x as IValidationController,q as ValidateBindingBehavior,T as ValidateEventKind,V as ValidationContainerCustomElement,D as ValidationController,M as ValidationControllerFactory,F as ValidationErrorsCustomAttribute,k as ValidationEvent,Q as ValidationHtmlConfiguration,G as ValidationResultPresenterService,I as ValidationResultTarget,L as ValidationTrigger,P as defaultContainerDefinition,N as defaultContainerTemplate,z as getDefaultValidationHtmlConfiguration,$ as getPropertyInfo};
