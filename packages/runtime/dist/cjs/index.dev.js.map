{"version":3,"file":"index.dev.js","sources":["../../src/alias.ts","../../src/observation/binding-context.ts","../../src/observation/signaler.ts","../../src/binding-behavior.ts","../../src/value-converter.ts","../../src/binding/ast.ts","../../src/utilities-objects.ts","../../src/observation.ts","../../src/observation/subscriber-collection.ts","../../src/observation/flush-queue.ts","../../src/observation/collection-length-observer.ts","../../src/observation/array-observer.ts","../../src/observation/set-observer.ts","../../src/observation/map-observer.ts","../../src/binding/connectable.ts","../../src/binding/expression-parser.ts","../../src/observation/connectable-switcher.ts","../../src/observation/proxy-observation.ts","../../src/observation/computed-observer.ts","../../src/observation/dirty-checker.ts","../../src/observation/primitive-observer.ts","../../src/observation/property-accessor.ts","../../src/observation/setter-observer.ts","../../src/observation/observer-locator.ts","../../src/observation/observation.ts","../../src/observation/observable.ts"],"sourcesContent":["import { Protocol, Metadata, Registration } from '@aurelia/kernel';\nimport type { Constructable, IResourceKind, ResourceDefinition, IContainer } from '@aurelia/kernel';\n\nexport function alias(...aliases: readonly string[]) {\n  return function (target: Constructable) {\n    const key = Protocol.annotation.keyFor('aliases');\n    const existing = Metadata.getOwn(key, target);\n    if (existing === void 0) {\n      Metadata.define(key, aliases, target);\n    } else {\n      existing.push(...aliases);\n    }\n  };\n}\n\nexport function registerAliases(aliases: readonly string[], resource: IResourceKind<Constructable, ResourceDefinition>, key: string, container: IContainer) {\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    Registration.aliasTo(key, resource.keyFrom(aliases[i])).register(container);\n  }\n}\n","/* eslint-disable @typescript-eslint/restrict-template-expressions */\nimport { LifecycleFlags } from '../observation.js';\n\nimport type { IIndexable } from '@aurelia/kernel';\nimport type { IBinding, IBindingContext, IOverrideContext } from '../observation.js';\n\nconst marker = Object.freeze({});\n\nexport class BindingContext implements IBindingContext {\n  [key: string]: unknown;\n\n  private constructor(keyOrObj?: string | IIndexable, value?: unknown) {\n    if (keyOrObj !== void 0) {\n      if (value !== void 0) {\n        // if value is defined then it's just a property and a value to initialize with\n        this[keyOrObj as string] = value;\n      } else {\n        // can either be some random object or another bindingContext to clone from\n        for (const prop in keyOrObj as IIndexable) {\n          if (Object.prototype.hasOwnProperty.call(keyOrObj, prop) as boolean) {\n            this[prop] = (keyOrObj as IIndexable)[prop];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   *\n   * @param obj - Optional. An existing object or `BindingContext` to (shallow) clone (own) properties from.\n   */\n  public static create(obj?: IIndexable): BindingContext;\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   *\n   * @param key - The name of the only property to initialize this `BindingContext` with.\n   * @param value - The value of the only property to initialize this `BindingContext` with.\n   */\n  public static create(key: string, value: unknown): BindingContext;\n  /**\n   * Create a new synthetic `BindingContext` for use in a `Scope`.\n   *\n   * This overload signature is simply the combined signatures of the other two, and can be used\n   * to keep strong typing in situations where the arguments are dynamic.\n   */\n  public static create(keyOrObj?: string | IIndexable, value?: unknown): BindingContext;\n  public static create(keyOrObj?: string | IIndexable, value?: unknown): BindingContext {\n    return new BindingContext(keyOrObj, value);\n  }\n\n  public static get(scope: Scope, name: string, ancestor: number, flags: LifecycleFlags): IBindingContext | IOverrideContext | IBinding | undefined | null {\n    if (scope == null) {\n      throw new Error(`Scope is ${scope}.`);\n    }\n    let overrideContext: IOverrideContext | null = scope.overrideContext;\n    let currentScope: Scope | null = scope;\n\n    if (ancestor > 0) {\n      // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n      while (ancestor > 0) {\n        ancestor--;\n        currentScope = currentScope.parentScope;\n        if (currentScope?.overrideContext == null) {\n          return void 0;\n        }\n      }\n\n      overrideContext = currentScope.overrideContext;\n      // Here we are giving benefit of doubt considering the dev has used one or more `$parent` token, and thus should know what s/he is targeting.\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // traverse the context and it's ancestors, searching for a context that has the name.\n    while (\n      !currentScope?.isBoundary\n      && overrideContext != null\n      && !(name in overrideContext)\n      && !(\n        overrideContext.bindingContext\n        && name in overrideContext.bindingContext\n      )\n    ) {\n      currentScope = currentScope!.parentScope ?? null;\n      overrideContext = currentScope?.overrideContext ?? null;\n    }\n\n    if (overrideContext) {\n      return name in overrideContext ? overrideContext : overrideContext.bindingContext;\n    }\n\n    // still nothing found. return the root binding context (or null\n    // if this is a parent scope traversal, to ensure we fall back to the\n    // correct level)\n    if (flags & LifecycleFlags.isTraversingParentScope) {\n      return marker;\n    }\n    return scope.bindingContext || scope.overrideContext;\n  }\n}\n\nexport class Scope {\n  private constructor(\n    public parentScope: Scope | null,\n    public bindingContext: IBindingContext,\n    public overrideContext: IOverrideContext,\n    public readonly isBoundary: boolean,\n  ) { }\n\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and a new standalone `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   *\n   * @param bc - The `BindingContext` to back the `Scope` with.\n   */\n  public static create(bc: object): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * @param bc - The `BindingContext` to back the `Scope` with.\n   * @param oc - The `OverrideContext` to back the `Scope` with.\n   * If a binding expression attempts to access a property that does not exist on the `BindingContext`\n   * during binding, it will traverse up via the `parentScope` of the scope until\n   * it finds the property.\n   */\n  public static create(bc: object, oc: IOverrideContext, isBoundary?: boolean): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   *\n   * @param bc - The `BindingContext` to back the `Scope` with.\n   * @param oc - null. This overload is functionally equivalent to not passing this argument at all.\n   */\n  public static create(bc: object, oc: null, isBoundary?: boolean): Scope;\n  public static create(bc: object, oc?: IOverrideContext | null, isBoundary?: boolean): Scope {\n    return new Scope(null, bc as IBindingContext, oc == null ? OverrideContext.create(bc) : oc, isBoundary ?? false);\n  }\n\n  public static fromOverride(oc: IOverrideContext): Scope {\n    if (oc == null) {\n      throw new Error(`OverrideContext is ${oc}`);\n    }\n    return new Scope(null, oc.bindingContext, oc, false);\n  }\n\n  public static fromParent(ps: Scope | null, bc: object): Scope {\n    if (ps == null) {\n      throw new Error(`ParentScope is ${ps}`);\n    }\n    return new Scope(ps, bc as IBindingContext, OverrideContext.create(bc), false);\n  }\n}\n\nexport class OverrideContext implements IOverrideContext {\n  [key: string]: unknown;\n\n  public bindingContext: IBindingContext;\n\n  private constructor(bindingContext: IBindingContext) {\n    this.bindingContext = bindingContext;\n  }\n\n  public static create(bc: object): OverrideContext {\n    return new OverrideContext(bc as IBindingContext);\n  }\n}\n","import { DI } from '@aurelia/kernel';\nimport { LifecycleFlags } from '../observation.js';\nimport type { ISubscriber } from '../observation.js';\n\ntype Signal = string;\n\nexport interface ISignaler extends Signaler {}\nexport const ISignaler = DI.createInterface<ISignaler>('ISignaler', x => x.singleton(Signaler));\n\nexport class Signaler {\n  public signals: Record<string, Set<ISubscriber>> = Object.create(null);\n\n  public dispatchSignal(name: Signal, flags?: LifecycleFlags): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    for (const listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined, flags!);\n    }\n  }\n\n  public addSignalListener(name: Signal, listener: ISubscriber): void {\n    const signals = this.signals;\n    const listeners = signals[name];\n    if (listeners === undefined) {\n      signals[name] = new Set([listener]);\n    } else {\n      listeners.add(listener);\n    }\n  }\n\n  public removeSignalListener(name: Signal, listener: ISubscriber): void {\n    const listeners = this.signals[name];\n    if (listeners) {\n      listeners.delete(listener);\n    }\n  }\n}\n","import {\n  ResourceType,\n  Registration,\n  Metadata,\n  Protocol,\n  mergeArrays,\n  firstDefined,\n  DI,\n  fromAnnotationOrDefinitionOrTypeOrDefault,\n} from '@aurelia/kernel';\nimport { Collection, IndexMap, LifecycleFlags } from './observation.js';\nimport { registerAliases } from './alias.js';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceDefinition,\n  IResourceKind,\n  PartialResourceDefinition,\n  IServiceLocator,\n  Key,\n} from '@aurelia/kernel';\nimport type { BindingObserverRecord, IConnectableBinding } from './binding/connectable.js';\nimport type { BindingBehaviorExpression, ForOfStatement, IBindingBehaviorExpression, IsBindingBehavior } from './binding/ast.js';\nimport type { IObserverLocator } from './observation/observer-locator.js';\nimport type { IBinding } from './observation.js';\nimport type { Scope } from './observation/binding-context.js';\n\nexport type PartialBindingBehaviorDefinition = PartialResourceDefinition<{\n  strategy?: BindingBehaviorStrategy;\n}>;\n\nexport type BindingBehaviorInstance<T extends {} = {}> = {\n  bind(flags: LifecycleFlags, scope: Scope, binding: IBinding, ...args: T[]): void;\n  unbind(flags: LifecycleFlags, scope: Scope, binding: IBinding, ...args: T[]): void;\n} & T;\n\nexport const enum BindingBehaviorStrategy {\n  singleton = 1,\n  interceptor = 2,\n}\n\nexport type BindingBehaviorType<T extends Constructable = Constructable> = ResourceType<T, BindingBehaviorInstance>;\nexport type BindingBehaviorKind = IResourceKind<BindingBehaviorType, BindingBehaviorDefinition> & {\n  isType<T>(value: T): value is (T extends Constructable ? BindingBehaviorType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): BindingBehaviorType<T>;\n  define<T extends Constructable>(def: PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T>;\n  getDefinition<T extends Constructable>(Type: T): BindingBehaviorDefinition<T>;\n  annotate<K extends keyof PartialBindingBehaviorDefinition>(Type: Constructable, prop: K, value: PartialBindingBehaviorDefinition[K]): void;\n  getAnnotation<K extends keyof PartialBindingBehaviorDefinition>(Type: Constructable, prop: K): PartialBindingBehaviorDefinition[K];\n};\n\nexport type BindingBehaviorDecorator = <T extends Constructable>(Type: T) => BindingBehaviorType<T>;\n\nexport function bindingBehavior(definition: PartialBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(name: string): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDef: string | PartialBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDef: string | PartialBindingBehaviorDefinition): BindingBehaviorDecorator {\n  return function (target) {\n    return BindingBehavior.define(nameOrDef, target);\n  };\n}\n\nexport class BindingBehaviorDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, BindingBehaviorInstance> {\n  private constructor(\n    public readonly Type: BindingBehaviorType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n    public readonly strategy: BindingBehaviorStrategy,\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialBindingBehaviorDefinition,\n    Type: BindingBehaviorType<T>,\n  ): BindingBehaviorDefinition<T> {\n\n    let name: string;\n    let def: PartialBindingBehaviorDefinition;\n    if (typeof nameOrDef === 'string') {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    const inheritsFromInterceptor = Object.getPrototypeOf(Type) === BindingInterceptor;\n\n    return new BindingBehaviorDefinition(\n      Type,\n      firstDefined(BindingBehavior.getAnnotation(Type, 'name'), name),\n      mergeArrays(BindingBehavior.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      BindingBehavior.keyFrom(name),\n      fromAnnotationOrDefinitionOrTypeOrDefault('strategy', def, Type, () => inheritsFromInterceptor ? BindingBehaviorStrategy.interceptor : BindingBehaviorStrategy.singleton),\n    );\n  }\n\n  public register(container: IContainer): void {\n    const { Type, key, aliases, strategy } = this;\n    switch (strategy) {\n      case BindingBehaviorStrategy.singleton:\n        Registration.singleton(key, Type).register(container);\n        break;\n      case BindingBehaviorStrategy.interceptor:\n        Registration.instance(key, new BindingBehaviorFactory(container, Type)).register(container);\n        break;\n    }\n    Registration.aliasTo(key, Type).register(container);\n    registerAliases(aliases, BindingBehavior, key, container);\n  }\n}\n\nexport class BindingBehaviorFactory<T extends Constructable = Constructable> {\n  private readonly deps: readonly Key[];\n\n  public constructor(\n    private readonly container: IContainer,\n    private readonly Type: BindingBehaviorType<T>,\n  ) {\n    this.deps = DI.getDependencies(Type);\n  }\n\n  public construct(\n    binding: IInterceptableBinding,\n    expr: BindingBehaviorExpression,\n  ): IInterceptableBinding {\n    const container = this.container;\n    const deps = this.deps;\n    switch (deps.length) {\n      case 0:\n      case 1:\n      case 2:\n        // TODO(fkleuver): fix this cast\n        return new this.Type(binding, expr) as unknown as IInterceptableBinding;\n      case 3:\n        return new this.Type(container.get(deps[0]), binding, expr) as unknown as IInterceptableBinding;\n      case 4:\n        return new this.Type(container.get(deps[0]), container.get(deps[1]), binding, expr) as unknown as IInterceptableBinding;\n      default:\n        return new this.Type(...deps.map(d => container.get(d) as unknown), binding, expr) as unknown as IInterceptableBinding;\n    }\n  }\n}\n\nexport type IInterceptableBinding = Exclude<IConnectableBinding, 'updateTarget' | 'updateSource' | 'callSource' | 'handleChange'> & {\n  updateTarget?(value: unknown, flags: LifecycleFlags): void;\n  updateSource?(value: unknown, flags: LifecycleFlags): void;\n\n  callSource?(args: object): unknown;\n  handleChange?(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void;\n};\n\nexport interface BindingInterceptor extends IConnectableBinding {}\n\nexport class BindingInterceptor implements IInterceptableBinding {\n  public interceptor: this = this;\n  public get observerLocator(): IObserverLocator {\n    return this.binding.observerLocator;\n  }\n  public get locator(): IServiceLocator {\n    return this.binding.locator;\n  }\n  public get $scope(): Scope | undefined {\n    return this.binding.$scope;\n  }\n  public get isBound(): boolean {\n    return this.binding.isBound;\n  }\n  public get obs(): BindingObserverRecord {\n    return this.binding.obs;\n  }\n  public get sourceExpression(): IsBindingBehavior | ForOfStatement {\n    return (this.binding as unknown as { sourceExpression: IsBindingBehavior | ForOfStatement }).sourceExpression;\n  }\n\n  public constructor(\n    public readonly binding: IInterceptableBinding,\n    public readonly expr: IBindingBehaviorExpression,\n  ) {\n    let interceptor: IBinding;\n    while (binding.interceptor !== this) {\n      interceptor = binding.interceptor;\n      binding.interceptor = this;\n      binding = interceptor as IInterceptableBinding;\n    }\n  }\n\n  public updateTarget(value: unknown, flags: LifecycleFlags): void {\n    this.binding.updateTarget!(value, flags);\n  }\n  public updateSource(value: unknown, flags: LifecycleFlags): void {\n    this.binding.updateSource!(value, flags);\n  }\n  public callSource(args: object): unknown {\n    return this.binding.callSource!(args);\n  }\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    this.binding.handleChange(newValue, previousValue, flags);\n  }\n  public handleCollectionChange(indexMap: IndexMap, flags: LifecycleFlags): void {\n    this.binding.handleCollectionChange(indexMap, flags);\n  }\n  public observeProperty(obj: object, key: string): void {\n    this.binding.observeProperty(obj, key);\n  }\n  public observeCollection(observer: Collection): void {\n    this.binding.observeCollection(observer);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: Scope): void {\n    this.binding.$bind(flags, scope);\n  }\n  public $unbind(flags: LifecycleFlags): void {\n    this.binding.$unbind(flags);\n  }\n}\n\nexport const BindingBehavior: BindingBehaviorKind = {\n  name: Protocol.resource.keyFor('binding-behavior'),\n  keyFrom(name: string): string {\n    return `${BindingBehavior.name}:${name}`;\n  },\n  isType<T>(value: T): value is (T extends Constructable ? BindingBehaviorType<T> : never) {\n    return typeof value === 'function' && Metadata.hasOwn(BindingBehavior.name, value);\n  },\n  define<T extends Constructable<BindingBehaviorInstance>>(nameOrDef: string | PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T> {\n    const definition = BindingBehaviorDefinition.create(nameOrDef, Type as Constructable<BindingBehaviorInstance>);\n    Metadata.define(BindingBehavior.name, definition, definition.Type);\n    Metadata.define(BindingBehavior.name, definition, definition);\n    Protocol.resource.appendTo(Type, BindingBehavior.name);\n\n    return definition.Type as BindingBehaviorType<T>;\n  },\n  getDefinition<T extends Constructable>(Type: T): BindingBehaviorDefinition<T> {\n    const def = Metadata.getOwn(BindingBehavior.name, Type) as BindingBehaviorDefinition<T>;\n    if (def === void 0) {\n      throw new Error(`No definition found for type ${Type.name}`);\n    }\n\n    return def;\n  },\n  annotate<K extends keyof PartialBindingBehaviorDefinition>(Type: Constructable, prop: K, value: PartialBindingBehaviorDefinition[K]): void {\n    Metadata.define(Protocol.annotation.keyFor(prop), value, Type);\n  },\n  getAnnotation<K extends keyof PartialBindingBehaviorDefinition>(Type: Constructable, prop: K): PartialBindingBehaviorDefinition[K] {\n    return Metadata.getOwn(Protocol.annotation.keyFor(prop), Type) as PartialBindingBehaviorDefinition[K];\n  },\n};\n","import {\n  Registration,\n  Metadata,\n  Protocol,\n  mergeArrays,\n  firstDefined,\n} from '@aurelia/kernel';\nimport { registerAliases } from './alias.js';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceDefinition,\n  IResourceKind,\n  ResourceType,\n  PartialResourceDefinition,\n} from '@aurelia/kernel';\n\nexport type PartialValueConverterDefinition = PartialResourceDefinition;\n\nexport type ValueConverterInstance<T extends {} = {}> = {\n  toView(input: unknown, ...args: unknown[]): unknown;\n  fromView?(input: unknown, ...args: unknown[]): unknown;\n} & T;\n\nexport type ValueConverterType<T extends Constructable = Constructable> = ResourceType<T, ValueConverterInstance>;\nexport type ValueConverterKind = IResourceKind<ValueConverterType, ValueConverterDefinition> & {\n  isType<T>(value: T): value is (T extends Constructable ? ValueConverterType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): ValueConverterType<T>;\n  define<T extends Constructable>(def: PartialValueConverterDefinition, Type: T): ValueConverterType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialValueConverterDefinition, Type: T): ValueConverterType<T>;\n  getDefinition<T extends Constructable>(Type: T): ValueConverterDefinition<T>;\n  annotate<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, value: PartialValueConverterDefinition[K]): void;\n  getAnnotation<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K): PartialValueConverterDefinition[K];\n};\n\nexport type ValueConverterDecorator = <T extends Constructable>(Type: T) => ValueConverterType<T>;\n\nexport function valueConverter(definition: PartialValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(name: string): ValueConverterDecorator;\nexport function valueConverter(nameOrDef: string | PartialValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(nameOrDef: string | PartialValueConverterDefinition): ValueConverterDecorator {\n  return function (target) {\n    return ValueConverter.define(nameOrDef, target);\n  };\n}\n\nexport class ValueConverterDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, ValueConverterInstance> {\n  private constructor(\n    public readonly Type: ValueConverterType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialValueConverterDefinition,\n    Type: ValueConverterType<T>,\n  ): ValueConverterDefinition<T> {\n\n    let name: string;\n    let def: PartialValueConverterDefinition;\n    if (typeof nameOrDef === 'string') {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    return new ValueConverterDefinition(\n      Type,\n      firstDefined(ValueConverter.getAnnotation(Type, 'name'), name),\n      mergeArrays(ValueConverter.getAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      ValueConverter.keyFrom(name),\n    );\n  }\n\n  public register(container: IContainer): void {\n    const { Type, key, aliases } = this;\n    Registration.singleton(key, Type).register(container);\n    Registration.aliasTo(key, Type).register(container);\n    registerAliases(aliases, ValueConverter, key, container);\n  }\n}\n\nexport const ValueConverter: ValueConverterKind = {\n  name: Protocol.resource.keyFor('value-converter'),\n  keyFrom(name: string): string {\n    return `${ValueConverter.name}:${name}`;\n  },\n  isType<T>(value: T): value is (T extends Constructable ? ValueConverterType<T> : never) {\n    return typeof value === 'function' && Metadata.hasOwn(ValueConverter.name, value);\n  },\n  define<T extends Constructable<ValueConverterInstance>>(nameOrDef: string | PartialValueConverterDefinition, Type: T): ValueConverterType<T> {\n    const definition = ValueConverterDefinition.create(nameOrDef, Type as Constructable<ValueConverterInstance>);\n    Metadata.define(ValueConverter.name, definition, definition.Type);\n    Metadata.define(ValueConverter.name, definition, definition);\n    Protocol.resource.appendTo(Type, ValueConverter.name);\n\n    return definition.Type as ValueConverterType<T>;\n  },\n  getDefinition<T extends Constructable>(Type: T): ValueConverterDefinition<T> {\n    const def = Metadata.getOwn(ValueConverter.name, Type);\n    if (def === void 0) {\n      throw new Error(`No definition found for type ${Type.name}`);\n    }\n\n    return def;\n  },\n  annotate<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, value: PartialValueConverterDefinition[K]): void {\n    Metadata.define(Protocol.annotation.keyFor(prop), value, Type);\n  },\n  getAnnotation<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K): PartialValueConverterDefinition[K] {\n    return Metadata.getOwn(Protocol.annotation.keyFor(prop), Type);\n  },\n};\n","/* eslint-disable eqeqeq */\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nimport { emptyArray, isNumberOrBigInt, isStringOrDate } from '@aurelia/kernel';\nimport { LifecycleFlags as LF } from '../observation.js';\nimport { BindingContext } from '../observation/binding-context.js';\nimport { ISignaler } from '../observation/signaler.js';\nimport { BindingBehavior, BindingBehaviorInstance, BindingBehaviorFactory } from '../binding-behavior.js';\nimport { ValueConverter, ValueConverterInstance } from '../value-converter.js';\n\nimport type { IIndexable, IServiceLocator, ResourceDefinition } from '@aurelia/kernel';\nimport type {\n  Collection,\n  IBindingContext,\n  IObservable,\n  IOverrideContext,\n  IConnectable,\n  ISubscriber,\n} from '../observation.js';\nimport type { Scope } from '../observation/binding-context.js';\nimport { IConnectableBinding } from './connectable.js';\n\nexport const enum ExpressionKind {\n  Connects             = 0b000000000001_00000, // The expression's connect() function calls observeProperty and/or calls connect() on another expression that it wraps (all expressions except for AccessThis, PrimitiveLiteral, CallMember/Function and Assign)\n  Observes             = 0b000000000010_00000, // The expression's connect() function calls observeProperty (only AccessScope, AccessMember and AccessKeyed do this)\n  CallsFunction        = 0b000000000100_00000, // Calls a function (CallFunction, CallScope, CallMember, TaggedTemplate) -> needs a valid function object returning from its lefthandside's evaluate()\n  HasAncestor          = 0b000000001000_00000, // Has an \"ancestor\" property, meaning the expression could climb up the context (only AccessThis, AccessScope and CallScope)\n  IsPrimary            = 0b000000010000_00000, // Is a primary expression according to ES parsing rules\n  IsLeftHandSide       = 0b000000100000_00000, // Is a left-hand side expression according to ES parsing rules, includes IsPrimary\n  HasBind              = 0b000001000000_00000, // Has a bind() method (currently only BindingBehavior)\n  HasUnbind            = 0b000010000000_00000, // Has an unbind() method (currentl only BindingBehavior and ValueConverter)\n  IsAssignable         = 0b000100000000_00000, // Is an assignable expression according to ES parsing rules (only AccessScope, AccessMember, AccessKeyed ans Assign)\n  IsLiteral            = 0b001000000000_00000, // Is an Aurelia resource (ValueConverter or BindingBehavior)\n  IsResource           = 0b010000000000_00000, // Is literal expression (Primitive, Array, Object or Template)\n  IsForDeclaration     = 0b100000000000_00000, // Is a For declaration (for..of, for..in -> currently only ForOfStatement)\n  Type                 = 0b000000000000_11111, // Type mask to uniquely identify each AST class (concrete types start below)\n  // ---------------------------------------------------------------------------------------------------------------------------\n  AccessThis           = 0b000000111000_00001, //               HasAncestor\n  AccessScope          = 0b000100111011_00010, // IsAssignable  HasAncestor       Observes  Connects\n  ArrayLiteral         = 0b001000110001_00011, //                                           Connects\n  ObjectLiteral        = 0b001000110001_00100, //                                           Connects\n  PrimitiveLiteral     = 0b001000110000_00101, //\n  Template             = 0b001000110001_00110, //                                           Connects\n  Unary                = 0b000000000001_00111, //                                           Connects\n  CallScope            = 0b000000101101_01000, //               HasAncestor  CallsFunction  Connects\n  CallMember           = 0b000000100100_01001, //                            CallsFunction\n  CallFunction         = 0b000000100100_01010, //                            CallsFunction\n  AccessMember         = 0b000100100011_01011, // IsAssignable                    Observes  Connects\n  AccessKeyed          = 0b000100100011_01100, // IsAssignable                    Observes  Connects\n  TaggedTemplate       = 0b000000100101_01101, //                            CallsFunction  Connects\n  Binary               = 0b000000000001_01110, //                                           Connects\n  Conditional          = 0b000000000001_11111, //                                           Connects\n  Assign               = 0b000100000000_10000, // IsAssignable\n  ValueConverter       = 0b010010000001_10001, //                                           Connects\n  BindingBehavior      = 0b010011000001_10010, //                                           Connects\n  HtmlLiteral          = 0b000000000001_10011, //                                           Connects\n  ArrayBindingPattern  = 0b100000000000_10100, //\n  ObjectBindingPattern = 0b100000000000_10101, //\n  BindingIdentifier    = 0b100000000000_10110, //\n  ForOfStatement       = 0b000011000001_10111, //                                           Connects\n  Interpolation        = 0b000000000000_11000  //\n}\n\nexport type UnaryOperator = 'void' | 'typeof' | '!' | '-' | '+';\n\nexport type BinaryOperator = '&&' | '||' | '==' | '===' | '!=' | '!==' | 'instanceof' | 'in' | '+' | '-' | '*' | '/' | '%' | '<' | '>' | '<=' | '>=';\n\nexport type IsPrimary = AccessThisExpression | AccessScopeExpression | ArrayLiteralExpression | ObjectLiteralExpression | PrimitiveLiteralExpression | TemplateExpression;\nexport type IsLiteral = ArrayLiteralExpression | ObjectLiteralExpression | PrimitiveLiteralExpression | TemplateExpression;\nexport type IsLeftHandSide = IsPrimary | CallFunctionExpression | CallMemberExpression | CallScopeExpression | AccessMemberExpression | AccessKeyedExpression | TaggedTemplateExpression;\nexport type IsUnary = IsLeftHandSide | UnaryExpression;\nexport type IsBinary = IsUnary | BinaryExpression;\nexport type IsConditional = IsBinary | ConditionalExpression;\nexport type IsAssign = IsConditional | AssignExpression;\nexport type IsValueConverter = IsAssign | ValueConverterExpression;\nexport type IsBindingBehavior = IsValueConverter | BindingBehaviorExpression;\nexport type IsAssignable = AccessScopeExpression | AccessKeyedExpression | AccessMemberExpression | AssignExpression;\nexport type IsExpression = IsBindingBehavior | Interpolation;\nexport type BindingIdentifierOrPattern = BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern;\nexport type IsExpressionOrStatement = IsExpression | ForOfStatement | BindingIdentifierOrPattern | HtmlLiteralExpression;\nexport type AnyBindingExpression = Interpolation | ForOfStatement | IsBindingBehavior;\n\nexport interface IExpressionHydrator {\n  hydrate(jsonExpr: any): any;\n}\nexport interface IVisitor<T = unknown> {\n  visitAccessKeyed(expr: AccessKeyedExpression): T;\n  visitAccessMember(expr: AccessMemberExpression): T;\n  visitAccessScope(expr: AccessScopeExpression): T;\n  visitAccessThis(expr: AccessThisExpression): T;\n  visitArrayBindingPattern(expr: ArrayBindingPattern): T;\n  visitArrayLiteral(expr: ArrayLiteralExpression): T;\n  visitAssign(expr: AssignExpression): T;\n  visitBinary(expr: BinaryExpression): T;\n  visitBindingBehavior(expr: BindingBehaviorExpression): T;\n  visitBindingIdentifier(expr: BindingIdentifier): T;\n  visitCallFunction(expr: CallFunctionExpression): T;\n  visitCallMember(expr: CallMemberExpression): T;\n  visitCallScope(expr: CallScopeExpression): T;\n  visitConditional(expr: ConditionalExpression): T;\n  visitForOfStatement(expr: ForOfStatement): T;\n  visitHtmlLiteral(expr: HtmlLiteralExpression): T;\n  visitInterpolation(expr: Interpolation): T;\n  visitObjectBindingPattern(expr: ObjectBindingPattern): T;\n  visitObjectLiteral(expr: ObjectLiteralExpression): T;\n  visitPrimitiveLiteral(expr: PrimitiveLiteralExpression): T;\n  visitTaggedTemplate(expr: TaggedTemplateExpression): T;\n  visitTemplate(expr: TemplateExpression): T;\n  visitUnary(expr: UnaryExpression): T;\n  visitValueConverter(expr: ValueConverterExpression): T;\n}\n\nexport class Unparser implements IVisitor<void> {\n  public text: string = '';\n\n  public static unparse(expr: IsExpressionOrStatement): string {\n    const visitor = new Unparser();\n    expr.accept(visitor);\n    return visitor.text;\n  }\n\n  public visitAccessMember(expr: AccessMemberExpression): void {\n    expr.object.accept(this);\n    this.text += `.${expr.name}`;\n  }\n\n  public visitAccessKeyed(expr: AccessKeyedExpression): void {\n    expr.object.accept(this);\n    this.text += '[';\n    expr.key.accept(this);\n    this.text += ']';\n  }\n\n  public visitAccessThis(expr: AccessThisExpression): void {\n    if (expr.ancestor === 0) {\n      this.text += '$this';\n      return;\n    }\n    this.text += '$parent';\n    let i = expr.ancestor - 1;\n    while (i--) {\n      this.text += '.$parent';\n    }\n  }\n\n  public visitAccessScope(expr: AccessScopeExpression): void {\n    let i = expr.ancestor;\n    while (i--) {\n      this.text += '$parent.';\n    }\n    this.text += expr.name;\n  }\n\n  public visitArrayLiteral(expr: ArrayLiteralExpression): void {\n    const elements = expr.elements;\n    this.text += '[';\n    for (let i = 0, length = elements.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      elements[i].accept(this);\n    }\n    this.text += ']';\n  }\n\n  public visitObjectLiteral(expr: ObjectLiteralExpression): void {\n    const keys = expr.keys;\n    const values = expr.values;\n    this.text += '{';\n    for (let i = 0, length = keys.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      this.text += `'${keys[i]}':`;\n      values[i].accept(this);\n    }\n    this.text += '}';\n  }\n\n  public visitPrimitiveLiteral(expr: PrimitiveLiteralExpression): void {\n    this.text += '(';\n    if (typeof expr.value === 'string') {\n      const escaped = expr.value.replace(/'/g, '\\\\\\'');\n      this.text += `'${escaped}'`;\n    } else {\n      this.text += `${expr.value}`;\n    }\n    this.text += ')';\n  }\n\n  public visitCallFunction(expr: CallFunctionExpression): void {\n    this.text += '(';\n    expr.func.accept(this);\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitCallMember(expr: CallMemberExpression): void {\n    this.text += '(';\n    expr.object.accept(this);\n    this.text += `.${expr.name}`;\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitCallScope(expr: CallScopeExpression): void {\n    this.text += '(';\n    let i = expr.ancestor;\n    while (i--) {\n      this.text += '$parent.';\n    }\n    this.text += expr.name;\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitTemplate(expr: TemplateExpression): void {\n    const { cooked, expressions } = expr;\n    const length = expressions.length;\n    this.text += '`';\n    this.text += cooked[0];\n    for (let i = 0; i < length; i++) {\n      expressions[i].accept(this);\n      this.text += cooked[i + 1];\n    }\n    this.text += '`';\n  }\n\n  public visitTaggedTemplate(expr: TaggedTemplateExpression): void {\n    const { cooked, expressions } = expr;\n    const length = expressions.length;\n    expr.func.accept(this);\n    this.text += '`';\n    this.text += cooked[0];\n    for (let i = 0; i < length; i++) {\n      expressions[i].accept(this);\n      this.text += cooked[i + 1];\n    }\n    this.text += '`';\n  }\n\n  public visitUnary(expr: UnaryExpression): void {\n    this.text += `(${expr.operation}`;\n    if (expr.operation.charCodeAt(0) >= /* a */97) {\n      this.text += ' ';\n    }\n    expr.expression.accept(this);\n    this.text += ')';\n  }\n\n  public visitBinary(expr: BinaryExpression): void {\n    this.text += '(';\n    expr.left.accept(this);\n    if (expr.operation.charCodeAt(0) === /* i */105) {\n      this.text += ` ${expr.operation} `;\n    } else {\n      this.text += expr.operation;\n    }\n    expr.right.accept(this);\n    this.text += ')';\n  }\n\n  public visitConditional(expr: ConditionalExpression): void {\n    this.text += '(';\n    expr.condition.accept(this);\n    this.text += '?';\n    expr.yes.accept(this);\n    this.text += ':';\n    expr.no.accept(this);\n    this.text += ')';\n  }\n\n  public visitAssign(expr: AssignExpression): void {\n    this.text += '(';\n    expr.target.accept(this);\n    this.text += '=';\n    expr.value.accept(this);\n    this.text += ')';\n  }\n\n  public visitValueConverter(expr: ValueConverterExpression): void {\n    const args = expr.args;\n    expr.expression.accept(this);\n    this.text += `|${expr.name}`;\n    for (let i = 0, length = args.length; i < length; ++i) {\n      this.text += ':';\n      args[i].accept(this);\n    }\n  }\n\n  public visitBindingBehavior(expr: BindingBehaviorExpression): void {\n    const args = expr.args;\n    expr.expression.accept(this);\n    this.text += `&${expr.name}`;\n    for (let i = 0, length = args.length; i < length; ++i) {\n      this.text += ':';\n      args[i].accept(this);\n    }\n  }\n\n  public visitArrayBindingPattern(expr: ArrayBindingPattern): void {\n    const elements = expr.elements;\n    this.text += '[';\n    for (let i = 0, length = elements.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      elements[i].accept(this);\n    }\n    this.text += ']';\n  }\n\n  public visitObjectBindingPattern(expr: ObjectBindingPattern): void {\n    const keys = expr.keys;\n    const values = expr.values;\n    this.text += '{';\n    for (let i = 0, length = keys.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      this.text += `'${keys[i]}':`;\n      values[i].accept(this);\n    }\n    this.text += '}';\n  }\n\n  public visitBindingIdentifier(expr: BindingIdentifier): void {\n    this.text += expr.name;\n  }\n\n  public visitHtmlLiteral(expr: HtmlLiteralExpression): void { throw new Error('visitHtmlLiteral'); }\n\n  public visitForOfStatement(expr: ForOfStatement): void {\n    expr.declaration.accept(this);\n    this.text += ' of ';\n    expr.iterable.accept(this);\n  }\n\n  public visitInterpolation(expr: Interpolation): void {\n    const { parts, expressions } = expr;\n    const length = expressions.length;\n    this.text += '${';\n    this.text += parts[0];\n    for (let i = 0; i < length; i++) {\n      expressions[i].accept(this);\n      this.text += parts[i + 1];\n    }\n    this.text += '}';\n  }\n\n  private writeArgs(args: readonly IsBindingBehavior[]): void {\n    this.text += '(';\n    for (let i = 0, length = args.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      args[i].accept(this);\n    }\n    this.text += ')';\n  }\n}\n\ntype BindingWithBehavior = IConnectableBinding & { [key: string]: BindingBehaviorInstance | undefined };\n\nexport class CustomExpression {\n  public constructor(\n    public readonly value: string,\n  ) {}\n\n  public evaluate(_f: LF, _s: Scope, _l: IServiceLocator, _c: IConnectable | null): string {\n    return this.value;\n  }\n}\n\n/** @internal - only exists to workaround circular reference caused by emitted metadata */\nexport interface IBindingBehaviorExpression extends BindingBehaviorExpression {}\nexport class BindingBehaviorExpression {\n  public get $kind(): ExpressionKind.BindingBehavior { return ExpressionKind.BindingBehavior; }\n  public get hasBind(): true { return true; }\n  public get hasUnbind(): true { return true; }\n  public readonly behaviorKey: string;\n\n  public constructor(\n    public readonly expression: IsBindingBehavior,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {\n    this.behaviorKey = BindingBehavior.keyFrom(name);\n  }\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    return this.expression.evaluate(f, s, l, c);\n  }\n\n  public assign(f: LF, s: Scope, l: IServiceLocator, val: unknown): unknown {\n    return this.expression.assign(f, s, l, val);\n  }\n\n  public bind(f: LF, s: Scope, b: IConnectableBinding): void {\n    if (this.expression.hasBind) {\n      this.expression.bind(f, s, b);\n    }\n    const behavior = b.locator.get<BindingBehaviorInstance>(this.behaviorKey);\n    if (behavior == null) {\n      throw new Error(`BindingBehavior named '${this.name}' could not be found. Did you forget to register it as a dependency?`);\n    }\n    if (!(behavior instanceof BindingBehaviorFactory)) {\n      if ((b as BindingWithBehavior)[this.behaviorKey] === void 0) {\n        (b as BindingWithBehavior)[this.behaviorKey] = behavior;\n        (behavior.bind.call as (...args: unknown[]) => void)(behavior, f, s, b, ...this.args.map(a => a.evaluate(f, s, b.locator, null)));\n      } else {\n        throw new Error(`BindingBehavior named '${this.name}' already applied.`);\n      }\n    }\n  }\n\n  public unbind(f: LF, s: Scope, b: IConnectableBinding): void {\n    const key = this.behaviorKey;\n    const $b = b as BindingWithBehavior;\n    if ($b[key] !== void 0) {\n      if (typeof $b[key]!.unbind === 'function') {\n        $b[key]!.unbind(f, s, b);\n      }\n      $b[key] = void 0;\n    }\n    if (this.expression.hasUnbind) {\n      this.expression.unbind(f, s, b);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingBehavior(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class ValueConverterExpression {\n  public get $kind(): ExpressionKind.ValueConverter { return ExpressionKind.ValueConverter; }\n  public readonly converterKey: string;\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): true { return true; }\n\n  public constructor(\n    public readonly expression: IsValueConverter,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {\n    this.converterKey = ValueConverter.keyFrom(name);\n  }\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    const vc = l.get<ValueConverterExpression & ValueConverterInstance & { signals?: string[] }>(this.converterKey);\n    if (vc == null) {\n      throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);\n    }\n    // note: the cast is expected. To connect, it just needs to be a IConnectable\n    // though to work with signal, it needs to have `handleChange`\n    // so having `handleChange` as a guard in the connectable as a safe measure is needed\n    // to make sure signaler works\n    if (c !== null && ('handleChange' in (c  as unknown as ISubscriber))) {\n      const signals = vc.signals;\n      if (signals != null) {\n        const signaler = l.get(ISignaler);\n        for (let i = 0, ii = signals.length; i < ii; ++i) {\n          signaler.addSignalListener(signals[i], c as unknown as ISubscriber);\n        }\n      }\n    }\n    if ('toView' in vc) {\n      return vc.toView(this.expression.evaluate(f, s, l, c), ...this.args.map(a => a.evaluate(f, s, l, c)));\n    }\n    return this.expression.evaluate(f, s, l, c);\n  }\n\n  public assign(f: LF, s: Scope, l: IServiceLocator, val: unknown): unknown {\n    const vc = l.get<ValueConverterExpression & ValueConverterInstance>(this.converterKey);\n    if (vc == null) {\n      throw new Error(`ValueConverter named '${this.name}' could not be found. Did you forget to register it as a dependency?`);\n    }\n    if ('fromView' in vc) {\n      val = vc.fromView!(val, ...this.args.map(a => a.evaluate(f, s, l, null)));\n    }\n    return this.expression.assign(f, s, l, val);\n  }\n\n  public unbind(_f: LF, _s: Scope, b: IConnectableBinding): void {\n    const vc = b.locator.get(this.converterKey) as { signals?: string[] };\n    if (vc.signals === void 0) {\n      return;\n    }\n    const signaler = b.locator.get(ISignaler);\n    for (let i = 0; i < vc.signals.length; ++i) {\n      // the cast is correct, as the value converter expression would only add\n      // a IConnectable that also implements `ISubscriber` interface to the signaler\n      signaler.removeSignalListener(vc.signals[i], b as unknown as ISubscriber);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitValueConverter(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class AssignExpression {\n  public get $kind(): ExpressionKind.Assign { return ExpressionKind.Assign; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly target: IsAssignable,\n    public readonly value: IsAssign,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    return this.target.assign(f, s, l, this.value.evaluate(f, s, l, c));\n  }\n\n  public assign(f: LF, s: Scope, l: IServiceLocator, val: unknown): unknown {\n    this.value.assign(f, s, l, val);\n    return this.target.assign(f, s, l, val);\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAssign(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class ConditionalExpression {\n  public get $kind(): ExpressionKind.Conditional { return ExpressionKind.Conditional; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly condition: IsBinary,\n    public readonly yes: IsAssign,\n    public readonly no: IsAssign,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    return this.condition.evaluate(f, s, l, c) ? this.yes.evaluate(f, s, l, c) : this.no.evaluate(f, s, l, c);\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitConditional(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class AccessThisExpression {\n  public static readonly $this: AccessThisExpression = new AccessThisExpression(0);\n  public static readonly $parent: AccessThisExpression = new AccessThisExpression(1);\n  public get $kind(): ExpressionKind.AccessThis { return ExpressionKind.AccessThis; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly ancestor: number = 0,\n  ) {}\n\n  public evaluate(_f: LF, s: Scope, _l: IServiceLocator, _c: IConnectable | null): IBindingContext | undefined {\n    // if (this === AccessThisExpression.$host) {\n    //   s = chooseScope(true, s, hs);\n    // }\n    let oc: IOverrideContext | null = s.overrideContext;\n    let currentScope: Scope | null = s;\n    let i = this.ancestor;\n    while (i-- && oc) {\n      currentScope = currentScope!.parentScope;\n      oc = currentScope?.overrideContext ?? null;\n    }\n    return i < 1 && oc ? oc.bindingContext : void 0;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessThis(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class AccessScopeExpression {\n  public get $kind(): ExpressionKind.AccessScope { return ExpressionKind.AccessScope; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly name: string,\n    public readonly ancestor: number = 0,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, _l: IServiceLocator, c: IConnectable | null): IBindingContext | IOverrideContext {\n    const obj = BindingContext.get(s, this.name, this.ancestor, f) as IBindingContext;\n    if (c !== null) {\n      c.observeProperty(obj, this.name);\n    }\n    const evaluatedValue = obj[this.name] as ReturnType<AccessScopeExpression['evaluate']>;\n    if (evaluatedValue == null && this.name === '$host') {\n      throw new Error('Unable to find $host context. Did you forget [au-slot] attribute?');\n    }\n    if (f & LF.isStrictBindingStrategy) {\n      return evaluatedValue;\n    }\n    return evaluatedValue == null ? '' as unknown as ReturnType<AccessScopeExpression['evaluate']> : evaluatedValue;\n  }\n\n  public assign(f: LF, s: Scope, _l: IServiceLocator, val: unknown): unknown {\n    if (this.name === '$host') {\n      throw new Error('Invalid assignment. $host is a reserved keyword.');\n    }\n    const obj = BindingContext.get(s, this.name, this.ancestor, f) as IObservable;\n    if (obj instanceof Object) {\n      if (obj.$observers?.[this.name] !== void 0) {\n        obj.$observers[this.name].setValue(val, f);\n        return val;\n      } else {\n        return obj[this.name] = val;\n      }\n    }\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessScope(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class AccessMemberExpression {\n  public get $kind(): ExpressionKind.AccessMember { return ExpressionKind.AccessMember; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    const instance = this.object.evaluate(f, s, l, (f & LF.observeLeafPropertiesOnly) > 0 ? null : c) as IIndexable;\n    if (f & LF.isStrictBindingStrategy) {\n      if (instance == null) {\n        return instance;\n      }\n      if (c !== null) {\n        c.observeProperty(instance, this.name);\n      }\n      return instance[this.name];\n    }\n    if (c !== null && instance instanceof Object) {\n      c.observeProperty(instance, this.name);\n    }\n    return instance ? instance[this.name] : '';\n  }\n\n  public assign(f: LF, s: Scope, l: IServiceLocator, val: unknown): unknown {\n    const obj = this.object.evaluate(f, s, l, null) as IObservable;\n    if (obj instanceof Object) {\n      if (obj.$observers !== void 0 && obj.$observers[this.name] !== void 0) {\n        obj.$observers[this.name].setValue(val, f);\n      } else {\n        obj[this.name] = val;\n      }\n    } else {\n      this.object.assign(f, s, l, { [this.name]: val });\n    }\n    return val;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessMember(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class AccessKeyedExpression {\n  public get $kind(): ExpressionKind.AccessKeyed { return ExpressionKind.AccessKeyed; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly key: IsAssign,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    const instance = this.object.evaluate(f, s, l, (f & LF.observeLeafPropertiesOnly) > 0 ? null : c) as IIndexable;\n    if (instance instanceof Object) {\n      const key = this.key.evaluate(f, s, l, (f & LF.observeLeafPropertiesOnly) > 0 ? null : c) as string;\n      if (c !== null) {\n        c.observeProperty(instance, key);\n      }\n      return instance[key];\n    }\n    return void 0;\n  }\n\n  public assign(f: LF, s: Scope, l: IServiceLocator, val: unknown): unknown {\n    const instance = this.object.evaluate(f, s, l, null) as IIndexable;\n    const key = this.key.evaluate(f, s, l, null) as string;\n    return instance[key] = val;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitAccessKeyed(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class CallScopeExpression {\n  public get $kind(): ExpressionKind.CallScope { return ExpressionKind.CallScope; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n    public readonly ancestor: number = 0,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    const args = this.args.map(a => a.evaluate(f, s, l, c));\n    const context = BindingContext.get(s, this.name, this.ancestor, f)!;\n    // ideally, should observe property represents by this.name as well\n    // because it could be changed\n    // todo: did it ever surprise anyone?\n    const func = getFunction(f, context, this.name);\n    if (func) {\n      return func.apply(context, args as unknown[]);\n    }\n    return void 0;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallScope(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class CallMemberExpression {\n  public get $kind(): ExpressionKind.CallMember { return ExpressionKind.CallMember; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    const instance = this.object.evaluate(f, s, l, (f & LF.observeLeafPropertiesOnly) > 0 ? null : c) as IIndexable;\n\n    const args = this.args.map(a => a.evaluate(f, s, l, c));\n    const func = getFunction(f, instance, this.name);\n    if (func) {\n      return func.apply(instance, args as unknown[]);\n    }\n    return void 0;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallMember(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class CallFunctionExpression {\n  public get $kind(): ExpressionKind.CallFunction { return ExpressionKind.CallFunction; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly func: IsLeftHandSide,\n    public readonly args: readonly IsAssign[],\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    const func = this.func.evaluate(f, s, l, c);\n    if (typeof func === 'function') {\n      return func(...this.args.map(a => a.evaluate(f, s, l, c)));\n    }\n    if (!(f & LF.mustEvaluate) && (func == null)) {\n      return void 0;\n    }\n    throw new Error(`Expression is not a function.`);\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitCallFunction(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class BinaryExpression {\n  public get $kind(): ExpressionKind.Binary { return ExpressionKind.Binary; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly operation: BinaryOperator,\n    public readonly left: IsBinary,\n    public readonly right: IsBinary,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    switch (this.operation) {\n      case '&&':\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        return this.left.evaluate(f, s, l, c) && this.right.evaluate(f, s, l, c);\n      case '||':\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        return this.left.evaluate(f, s, l, c) || this.right.evaluate(f, s, l, c);\n      case '==':\n        return this.left.evaluate(f, s, l, c) == this.right.evaluate(f, s, l, c);\n      case '===':\n        return this.left.evaluate(f, s, l, c) === this.right.evaluate(f, s, l, c);\n      case '!=':\n        return this.left.evaluate(f, s, l, c) != this.right.evaluate(f, s, l, c);\n      case '!==':\n        return this.left.evaluate(f, s, l, c) !== this.right.evaluate(f, s, l, c);\n      case 'instanceof': {\n        const right = this.right.evaluate(f, s, l, c);\n        if (typeof right === 'function') {\n          return this.left.evaluate(f, s, l, c) instanceof right;\n        }\n        return false;\n      }\n      case 'in': {\n        const right = this.right.evaluate(f, s, l, c);\n        if (right instanceof Object) {\n          return this.left.evaluate(f, s, l, c) as string in right;\n        }\n        return false;\n      }\n      // note: autoConvertAdd (and the null check) is removed because the default spec behavior is already largely similar\n      // and where it isn't, you kind of want it to behave like the spec anyway (e.g. return NaN when adding a number to undefined)\n      // this makes bugs in user code easier to track down for end users\n      // also, skipping these checks and leaving it to the runtime is a nice little perf boost and simplifies our code\n      case '+': {\n        const left: any = this.left.evaluate(f, s, l, c);\n        const right: any = this.right.evaluate(f, s, l, c);\n\n        if ((f & LF.isStrictBindingStrategy) > 0) {\n          return (left as number) + (right as number);\n        }\n\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!left || !right) {\n          if (isNumberOrBigInt(left) || isNumberOrBigInt(right)) {\n            return (left as number || 0) + (right as number || 0);\n          }\n          if (isStringOrDate(left) || isStringOrDate(right)) {\n            return (left as string || '') + (right as string || '');\n          }\n        }\n        return (left as number) + (right as number);\n      }\n      case '-':\n        return (this.left.evaluate(f, s, l, c) as number) - (this.right.evaluate(f, s, l, c) as number);\n      case '*':\n        return (this.left.evaluate(f, s, l, c) as number) * (this.right.evaluate(f, s, l, c) as number);\n      case '/':\n        return (this.left.evaluate(f, s, l, c) as number) / (this.right.evaluate(f, s, l, c) as number);\n      case '%':\n        return (this.left.evaluate(f, s, l, c) as number) % (this.right.evaluate(f, s, l, c) as number);\n      case '<':\n        return (this.left.evaluate(f, s, l, c) as number) < (this.right.evaluate(f, s, l, c) as number);\n      case '>':\n        return (this.left.evaluate(f, s, l, c) as number) > (this.right.evaluate(f, s, l, c) as number);\n      case '<=':\n        return (this.left.evaluate(f, s, l, c) as number) <= (this.right.evaluate(f, s, l, c) as number);\n      case '>=':\n        return (this.left.evaluate(f, s, l, c) as number) >= (this.right.evaluate(f, s, l, c) as number);\n      default:\n        throw new Error(`Unknown binary operator: '${this.operation}'`);\n    }\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBinary(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class UnaryExpression {\n  public get $kind(): ExpressionKind.Unary { return ExpressionKind.Unary; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly operation: UnaryOperator,\n    public readonly expression: IsLeftHandSide,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    switch (this.operation) {\n      case 'void':\n        return void this.expression.evaluate(f, s, l, c);\n      case 'typeof':\n        return typeof this.expression.evaluate(f | LF.isStrictBindingStrategy, s, l, c);\n      case '!':\n        return !(this.expression.evaluate(f, s, l, c) as boolean);\n      case '-':\n        return -(this.expression.evaluate(f, s, l, c) as number);\n      case '+':\n        return +(this.expression.evaluate(f, s, l, c) as number);\n      default:\n        throw new Error(`Unknown unary operator: '${this.operation}'`);\n    }\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitUnary(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\nexport class PrimitiveLiteralExpression<TValue extends null | undefined | number | boolean | string = null | undefined | number | boolean | string> {\n  public static readonly $undefined: PrimitiveLiteralExpression<undefined> = new PrimitiveLiteralExpression<undefined>(void 0);\n  public static readonly $null: PrimitiveLiteralExpression<null> = new PrimitiveLiteralExpression<null>(null);\n  public static readonly $true: PrimitiveLiteralExpression<true> = new PrimitiveLiteralExpression<true>(true);\n  public static readonly $false: PrimitiveLiteralExpression<false> = new PrimitiveLiteralExpression<false>(false);\n  public static readonly $empty: PrimitiveLiteralExpression<string> = new PrimitiveLiteralExpression<''>('');\n  public get $kind(): ExpressionKind.PrimitiveLiteral { return ExpressionKind.PrimitiveLiteral; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly value: TValue,\n  ) {}\n\n  public evaluate(_f: LF, _s: Scope, _l: IServiceLocator, _c: IConnectable | null): TValue {\n    return this.value;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitPrimitiveLiteral(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class HtmlLiteralExpression {\n  public get $kind(): ExpressionKind.HtmlLiteral { return ExpressionKind.HtmlLiteral; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly parts: readonly HtmlLiteralExpression[],\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): string {\n    let result = '';\n    for (let i = 0; i < this.parts.length; ++i) {\n      const v = this.parts[i].evaluate(f, s, l, c);\n      if (v == null) {\n        continue;\n      }\n      result += v;\n    }\n    return result;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown, _projection?: ResourceDefinition): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitHtmlLiteral(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class ArrayLiteralExpression {\n  public static readonly $empty: ArrayLiteralExpression = new ArrayLiteralExpression(emptyArray);\n  public get $kind(): ExpressionKind.ArrayLiteral { return ExpressionKind.ArrayLiteral; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly elements: readonly IsAssign[],\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): readonly unknown[] {\n    return this.elements.map(e => e.evaluate(f, s, l, c));\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayLiteral(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class ObjectLiteralExpression {\n  public static readonly $empty: ObjectLiteralExpression = new ObjectLiteralExpression(emptyArray, emptyArray);\n  public get $kind(): ExpressionKind.ObjectLiteral { return ExpressionKind.ObjectLiteral; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly keys: readonly (number | string)[],\n    public readonly values: readonly IsAssign[],\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): Record<string, unknown> {\n    const instance: Record<string, unknown> = {};\n    for (let i = 0; i < this.keys.length; ++i) {\n      instance[this.keys[i]] = this.values[i].evaluate(f, s, l, c);\n    }\n    return instance;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectLiteral(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class TemplateExpression {\n  public static readonly $empty: TemplateExpression = new TemplateExpression(['']);\n  public get $kind(): ExpressionKind.Template { return ExpressionKind.Template; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly cooked: readonly string[],\n    public readonly expressions: readonly IsAssign[] = emptyArray,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): string {\n    let result = this.cooked[0];\n    for (let i = 0; i < this.expressions.length; ++i) {\n      result += String(this.expressions[i].evaluate(f, s, l, c));\n      result += this.cooked[i + 1];\n    }\n    return result;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTemplate(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class TaggedTemplateExpression {\n  public get $kind(): ExpressionKind.TaggedTemplate { return ExpressionKind.TaggedTemplate; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly cooked: readonly string[] & { raw?: readonly string[] },\n    raw: readonly string[],\n    public readonly func: IsLeftHandSide,\n    public readonly expressions: readonly IsAssign[] = emptyArray,\n  ) {\n    cooked.raw = raw;\n  }\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): string {\n    const results = this.expressions.map(e => e.evaluate(f, s, l, c));\n    const func = this.func.evaluate(f, s, l, c);\n    if (typeof func !== 'function') {\n      throw new Error(`Left-hand side of tagged template expression is not a function.`);\n    }\n    return func(this.cooked, ...results);\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitTaggedTemplate(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class ArrayBindingPattern {\n  public get $kind(): ExpressionKind.ArrayBindingPattern { return ExpressionKind.ArrayBindingPattern; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  // We'll either have elements, or keys+values, but never all 3\n  public constructor(\n    public readonly elements: readonly IsAssign[],\n  ) {}\n\n  public evaluate(_f: LF, _s: Scope, _l: IServiceLocator, _c: IConnectable | null): unknown {\n    // TODO: this should come after batch\n    // as a destructuring expression like [x, y] = value\n    //\n    // should only trigger change only once:\n    // batch(() => {\n    //   object.x = value[0]\n    //   object.y = value[1]\n    // })\n    //\n    // instead of twice:\n    // object.x = value[0]\n    // object.y = value[1]\n    return void 0;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    // TODO\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitArrayBindingPattern(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class ObjectBindingPattern {\n  public get $kind(): ExpressionKind.ObjectBindingPattern { return ExpressionKind.ObjectBindingPattern; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  // We'll either have elements, or keys+values, but never all 3\n  public constructor(\n    public readonly keys: readonly (string | number)[],\n    public readonly values: readonly IsAssign[],\n  ) {}\n\n  public evaluate(_f: LF, _s: Scope, _l: IServiceLocator, _c: IConnectable | null): unknown {\n    // TODO\n    // similar to array binding ast, this should only come after batch\n    // for a single notification per destructing,\n    // regardless number of property assignments on the scope binding context\n    return void 0;\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    // TODO\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitObjectBindingPattern(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nexport class BindingIdentifier {\n  public get $kind(): ExpressionKind.BindingIdentifier { return ExpressionKind.BindingIdentifier; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly name: string,\n  ) {}\n\n  public evaluate(_f: LF, _s: Scope, _l: IServiceLocator | null, _c: IConnectable | null): string {\n    return this.name;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitBindingIdentifier(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nconst toStringTag = Object.prototype.toString as {\n  call(obj: unknown): keyof '[object Array]' | '[object Map]' | '[object Set]' | '[object Number]' | '[object Null]' | '[object Undefined]';\n};\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement {\n  public get $kind(): ExpressionKind.ForOfStatement { return ExpressionKind.ForOfStatement; }\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly declaration: BindingIdentifierOrPattern,\n    public readonly iterable: IsBindingBehavior,\n  ) {}\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): unknown {\n    return this.iterable.evaluate(f, s, l, c);\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public count(_f: LF, result: Collection | number | null | undefined): number {\n    switch (toStringTag.call(result)) {\n      case '[object Array]': return (result as unknown[]).length;\n      case '[object Map]': return (result as Map<unknown, unknown>).size;\n      case '[object Set]': return (result as Set<unknown>).size;\n      case '[object Number]': return result as number;\n      case '[object Null]': return 0;\n      case '[object Undefined]': return 0;\n      default: throw new Error(`Cannot count ${toStringTag.call(result)}`);\n    }\n  }\n\n  // deepscan-disable-next-line\n  public iterate(f: LF, result: Collection | number | null | undefined, func: (arr: Collection, index: number, item: unknown) => void): void {\n    switch (toStringTag.call(result)) {\n      case '[object Array]': return $array(result as unknown[], func);\n      case '[object Map]': return $map(result as Map<unknown, unknown>, func);\n      case '[object Set]': return $set(result as Set<unknown>, func);\n      case '[object Number]': return $number(result as number, func);\n      case '[object Null]': return;\n      case '[object Undefined]': return;\n      default: throw new Error(`Cannot iterate over ${toStringTag.call(result)}`);\n    }\n  }\n\n  public bind(f: LF, s: Scope, b: IConnectableBinding): void {\n    if (this.iterable.hasBind) {\n      this.iterable.bind(f, s, b);\n    }\n  }\n\n  public unbind(f: LF, s: Scope, b: IConnectableBinding): void {\n    if (this.iterable.hasUnbind) {\n      this.iterable.unbind(f, s, b);\n    }\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitForOfStatement(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation {\n  public get $kind(): ExpressionKind.Interpolation { return ExpressionKind.Interpolation; }\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  public get hasBind(): false { return false; }\n  public get hasUnbind(): false { return false; }\n\n  public constructor(\n    public readonly parts: readonly string[],\n    public readonly expressions: readonly IsBindingBehavior[] = emptyArray,\n  ) {\n    this.isMulti = expressions.length > 1;\n    this.firstExpression = expressions[0];\n  }\n\n  public evaluate(f: LF, s: Scope, l: IServiceLocator, c: IConnectable | null): string {\n    if (this.isMulti) {\n      let result = this.parts[0];\n      for (let i = 0; i < this.expressions.length; ++i) {\n        result += String(this.expressions[i].evaluate(f, s, l, c));\n        result += this.parts[i + 1];\n      }\n      return result;\n    } else {\n      return `${this.parts[0]}${this.firstExpression.evaluate(f, s, l, c)}${this.parts[1]}`;\n    }\n  }\n\n  public assign(_f: LF, _s: Scope, _l: IServiceLocator, _obj: unknown): unknown {\n    return void 0;\n  }\n\n  public accept<T>(visitor: IVisitor<T>): T {\n    return visitor.visitInterpolation(this);\n  }\n\n  public toString(): string {\n    return Unparser.unparse(this);\n  }\n}\n\nfunction getFunction(f: LF, obj: object, name: string): ((...args: unknown[]) => unknown) | null {\n  const func = obj == null ? null : (obj as IIndexable)[name];\n  if (typeof func === 'function') {\n    return func as (...args: unknown[]) => unknown;\n  }\n  if (!(f & LF.mustEvaluate) && func == null) {\n    return null;\n  }\n  throw new Error(`Expected '${name}' to be a function`);\n}\n\nfunction $array(result: unknown[], func: (arr: Collection, index: number, item: unknown) => void): void {\n  for (let i = 0, ii = result.length; i < ii; ++i) {\n    func(result, i, result[i]);\n  }\n}\n\nfunction $map(result: Map<unknown, unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n  const arr = Array(result.size);\n  let i = -1;\n  for (const entry of result.entries()) {\n    arr[++i] = entry;\n  }\n  $array(arr, func);\n}\n\nfunction $set(result: Set<unknown>, func: (arr: Collection, index: number, item: unknown) => void): void {\n  const arr = Array(result.size);\n  let i = -1;\n  for (const key of result.keys()) {\n    arr[++i] = key;\n  }\n  $array(arr, func);\n}\n\nfunction $number(result: number, func: (arr: Collection, index: number, item: unknown) => void): void {\n  const arr = Array(result);\n  for (let i = 0; i < result; ++i) {\n    arr[i] = i;\n  }\n  $array(arr, func);\n}\n","\nexport const def = Reflect.defineProperty;\nexport function defineHiddenProp(obj: object, key: PropertyKey, value: unknown): void {\n  def(obj, key, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value\n  });\n}\n\nexport function ensureProto<T extends object, K extends keyof T>(\n  proto: T,\n  key: K,\n  defaultValue: unknown,\n  force: boolean = false\n): void {\n  if (force || !Object.prototype.hasOwnProperty.call(proto, key)) {\n    defineHiddenProp(proto, key, defaultValue);\n  }\n}\n","import type { IIndexable, IServiceLocator } from '@aurelia/kernel';\nimport type { Scope } from './observation/binding-context.js';\nimport type { CollectionLengthObserver, CollectionSizeObserver } from './observation/collection-length-observer.js';\n\nexport interface IBinding {\n  interceptor: this;\n  readonly locator: IServiceLocator;\n  readonly $scope?: Scope;\n  readonly isBound: boolean;\n  $bind(flags: LifecycleFlags, scope: Scope): void;\n  $unbind(flags: LifecycleFlags): void;\n}\n\nexport type InterceptorFunc<TInput = unknown, TOutput = unknown> = (value: TInput) => TOutput;\n\n/*\n* Note: the oneTime binding now has a non-zero value for 2 reasons:\n*  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n*  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n*\n* Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n* This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n*/\nexport enum BindingMode {\n  oneTime  = 0b0001,\n  toView   = 0b0010,\n  fromView = 0b0100,\n  twoWay   = 0b0110,\n  default  = 0b1000\n}\n\nexport const enum LifecycleFlags {\n  none                          = 0b0000_000_00_0,\n  // Bitmask for flags that need to be stored on a binding during $bind for mutation\n  // callbacks outside of $bind\n  persistentBindingFlags        = 0b1111_000_00_1,\n  allowParentScopeTraversal     = 0b0001_000_00_0,\n  observeLeafPropertiesOnly     = 0b0010_000_00_0,\n  targetObserverFlags           = 0b1100_000_00_1,\n  noFlush                       = 0b0100_000_00_0,\n  persistentTargetObserverQueue = 0b1000_000_00_0,\n  bindingStrategy               = 0b0000_000_00_1,\n  isStrictBindingStrategy       = 0b0000_000_00_1,\n  fromBind                      = 0b0000_000_01_0,\n  fromUnbind                    = 0b0000_000_10_0,\n  mustEvaluate                  = 0b0000_001_00_0,\n  isTraversingParentScope       = 0b0000_010_00_0,\n  dispose                       = 0b0000_100_00_0,\n}\n\nexport interface IConnectable {\n  observeProperty(obj: object, key: PropertyKey): void;\n  observeCollection(obj: Collection): void;\n  subscribeTo(subscribable: ISubscribable | ICollectionSubscribable): void;\n}\n\n/** @internal */\nexport const enum SubscriberFlags {\n  None            = 0,\n  Subscriber0     = 0b0001,\n  Subscriber1     = 0b0010,\n  Subscriber2     = 0b0100,\n  SubscribersRest = 0b1000,\n  Any             = 0b1111,\n}\n\nexport enum DelegationStrategy {\n  none      = 0,\n  capturing = 1,\n  bubbling  = 2,\n}\n\nexport interface IBatchable {\n  flushBatch(flags: LifecycleFlags): void;\n}\n\nexport interface ISubscriber<TValue = unknown> {\n  handleChange(newValue: TValue, previousValue: TValue, flags: LifecycleFlags): void;\n}\n\nexport interface ICollectionSubscriber {\n  handleCollectionChange(indexMap: IndexMap, flags: LifecycleFlags): void;\n}\n\nexport interface ISubscribable {\n  subscribe(subscriber: ISubscriber): void;\n  unsubscribe(subscriber: ISubscriber): void;\n}\n\nexport interface ICollectionSubscribable {\n  subscribe(subscriber: ICollectionSubscriber): void;\n  unsubscribe(subscriber: ICollectionSubscriber): void;\n}\n\n/**\n * An interface describing the contract of a subscriber list,\n * with the ability to propagate values to those subscribers\n */\nexport interface ISubscriberRecord<T extends ISubscriber | ICollectionSubscriber> {\n  readonly count: number;\n  add(subscriber: T): boolean;\n  has(subscriber: T): boolean;\n  remove(subscriber: T): boolean;\n  any(): boolean;\n  notify(value: unknown, oldValue: unknown, flags: LifecycleFlags): void;\n  notifyCollection(indexMap: IndexMap, flags: LifecycleFlags): void;\n}\n\n/**\n * An internal interface describing the implementation of a ISubscribable of Aurelia that supports batching\n *\n * This is usually mixed into a class via the import `subscriberCollection` import from Aurelia.\n * The `subscriberCollection` import can be used as either a decorator, or a function call.\n */\nexport interface ISubscriberCollection extends ISubscribable {\n  [key: number]: LifecycleFlags;\n  /**\n   * The backing subscriber record for all subscriber methods of this collection\n   */\n  readonly subs: ISubscriberRecord<ISubscriber>;\n}\n\n/**\n * An internal interface describing the implementation of a ICollectionSubscribable of Aurelia that supports batching\n *\n * This is usually mixed into a class via the import `subscriberCollection` import from Aurelia.\n * The `subscriberCollection` import can be used as either a decorator, or a function call.\n */\nexport interface ICollectionSubscriberCollection extends ICollectionSubscribable {\n  [key: number]: LifecycleFlags;\n  /**\n   * The backing subscriber record for all subscriber methods of this collection\n   */\n  readonly subs: ISubscriberRecord<ICollectionSubscriber>;\n}\n\n/**\n * A collection (array, set or map)\n */\nexport type Collection = unknown[] | Set<unknown> | Map<unknown, unknown>;\n\nexport const enum CollectionKind {\n  indexed = 0b1000,\n  keyed   = 0b0100,\n  array   = 0b1001,\n  map     = 0b0110,\n  set     = 0b0111,\n}\n\nexport type LengthPropertyName<T> =\n  T extends unknown[] ? 'length' :\n    T extends Set<unknown> ? 'size' :\n      T extends Map<unknown, unknown> ? 'size' :\n        never;\n\nexport type CollectionTypeToKind<T> =\n  T extends unknown[] ? CollectionKind.array | CollectionKind.indexed :\n    T extends Set<unknown> ? CollectionKind.set | CollectionKind.keyed :\n      T extends Map<unknown, unknown> ? CollectionKind.map | CollectionKind.keyed :\n        never;\n\nexport type CollectionKindToType<T> =\n  T extends CollectionKind.array ? unknown[] :\n    T extends CollectionKind.indexed ? unknown[] :\n      T extends CollectionKind.map ? Map<unknown, unknown> :\n        T extends CollectionKind.set ? Set<unknown> :\n          T extends CollectionKind.keyed ? Set<unknown> | Map<unknown, unknown> :\n            never;\n\nexport type ObservedCollectionKindToType<T> =\n  T extends CollectionKind.array ? unknown[] :\n    T extends CollectionKind.indexed ? unknown[] :\n      T extends CollectionKind.map ? Map<unknown, unknown> :\n        T extends CollectionKind.set ? Set<unknown> :\n          T extends CollectionKind.keyed ? Map<unknown, unknown> | Set<unknown> :\n            never;\n\nexport const enum AccessorType {\n  None          = 0b0_0000_0000,\n  Observer      = 0b0_0000_0001,\n\n  Node          = 0b0_0000_0010,\n\n  // misc characteristic of accessors/observers when update\n  //\n  // by default, everything is synchronous\n  // except changes that are supposed to cause reflow/heavy computation\n  // an observer can use this flag to signal binding that don't carelessly tell it to update\n  // queue it instead\n  // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n  // todo: https://csstriggers.com/\n  Layout        = 0b0_0000_0100,\n  // by default, everything is an object\n  // eg: a property is accessed on an object\n  // unless explicitly not so\n  Primtive      = 0b0_0000_1000,\n\n  Array         = 0b0_0001_0010,\n  Set           = 0b0_0010_0010,\n  Map           = 0b0_0100_0010,\n}\n\n/**\n * Basic interface to normalize getting/setting a value of any property on any object\n */\nexport interface IAccessor<TValue = unknown> {\n  type: AccessorType;\n  getValue(obj?: object, key?: PropertyKey): TValue;\n  setValue(newValue: TValue, flags: LifecycleFlags, obj?: object, key?: PropertyKey): void;\n}\n\n/**\n * An interface describing a standard contract of an observer in Aurelia binding & observation system\n */\nexport interface IObserver extends IAccessor, ISubscribable {}\n\nexport type AccessorOrObserver = (IAccessor | IObserver) & {\n  doNotCache?: boolean;\n};\n\n/**\n * An array of indices, where the index of an element represents the index to map FROM, and the numeric value of the element itself represents the index to map TO\n *\n * The deletedItems property contains the items (in case of an array) or keys (in case of map or set) that have been deleted.\n */\nexport type IndexMap = number[] & {\n  deletedItems: number[];\n  isIndexMap: true;\n};\n\nexport function copyIndexMap(\n  existing: number[] & { deletedItems?: number[] },\n  deletedItems?: number[],\n): IndexMap {\n  const { length } = existing;\n  const arr = Array(length) as IndexMap;\n  let i = 0;\n  while (i < length) {\n    arr[i] = existing[i];\n    ++i;\n  }\n  if (deletedItems !== void 0) {\n    arr.deletedItems = deletedItems.slice(0);\n  } else if (existing.deletedItems !== void 0) {\n    arr.deletedItems = existing.deletedItems.slice(0);\n  } else {\n    arr.deletedItems = [];\n  }\n  arr.isIndexMap = true;\n  return arr;\n}\n\nexport function createIndexMap(length: number = 0): IndexMap {\n  const arr = Array(length) as IndexMap;\n  let i = 0;\n  while (i < length) {\n    arr[i] = i++;\n  }\n  arr.deletedItems = [];\n  arr.isIndexMap = true;\n  return arr;\n}\n\nexport function cloneIndexMap(indexMap: IndexMap): IndexMap {\n  const clone = indexMap.slice() as IndexMap;\n  clone.deletedItems = indexMap.deletedItems.slice();\n  clone.isIndexMap = true;\n  return clone;\n}\n\nexport function isIndexMap(value: unknown): value is IndexMap {\n  return value instanceof Array && (value as IndexMap).isIndexMap === true;\n}\n\nexport interface IArrayIndexObserver extends IObserver {\n  owner: ICollectionObserver<CollectionKind.array>;\n}\n\n/**\n * Describes a type that specifically tracks changes in a collection (map, set or array)\n */\nexport interface ICollectionChangeTracker<T extends Collection> {\n  collection: T;\n  indexMap: IndexMap;\n}\n\n/**\n * An observer that tracks collection mutations and notifies subscribers (either directly or in batches)\n */\nexport interface ICollectionObserver<T extends CollectionKind> extends\n  ICollectionChangeTracker<CollectionKindToType<T>>,\n  ICollectionSubscribable {\n  type: AccessorType;\n  collection: ObservedCollectionKindToType<T>;\n  getLengthObserver(): T extends CollectionKind.array ? CollectionLengthObserver : CollectionSizeObserver;\n  notify(): void;\n}\nexport type CollectionObserver = ICollectionObserver<CollectionKind>;\n\nexport interface IBindingContext {\n  [key: string]: any;\n}\n\nexport interface IOverrideContext {\n  [key: string]: unknown;\n\n  readonly bindingContext: IBindingContext;\n}\n\nexport type IObservable<T = IIndexable> = T & {\n  $observers?: IIndexable<{}, AccessorOrObserver>;\n};\n","import {\n  SubscriberFlags as SF,\n} from '../observation.js';\nimport { def, defineHiddenProp, ensureProto } from '../utilities-objects.js';\n\nimport type {\n  ICollectionSubscriber,\n  IndexMap,\n  ISubscriber,\n  ISubscriberCollection,\n  ISubscriberRecord,\n  LifecycleFlags as LF,\n} from '../observation.js';\n\nexport type IAnySubscriber = ISubscriber | ICollectionSubscriber;\n\n/* eslint-disable @typescript-eslint/ban-types */\nexport function subscriberCollection(): ClassDecorator;\nexport function subscriberCollection(target: Function): void;\nexport function subscriberCollection(target?: Function): ClassDecorator | void {\n  return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);\n}\n\nfunction subscriberCollectionDeco(target: Function): void { // ClassDecorator expects it to be derived from Function\n  const proto = target.prototype as ISubscriberCollection;\n  // not configurable, as in devtool, the getter could be invoked on the prototype,\n  // and become permanently broken\n  def(proto, 'subs', { get: getSubscriberRecord });\n\n  ensureProto(proto, 'subscribe', addSubscriber);\n  ensureProto(proto, 'unsubscribe', removeSubscriber);\n}\n/* eslint-enable @typescript-eslint/ban-types */\n\nexport class SubscriberRecord<T extends IAnySubscriber> implements ISubscriberRecord<T> {\n  /**\n   * subscriber flags: bits indicating the existence status of the subscribers of this record\n   */\n  private _sf: SF = SF.None;\n  private _s0?: T;\n  private _s1?: T;\n  private _s2?: T;\n  /**\n   * subscriber rest: When there's more than 3 subscribers, use an array to store the subscriber references\n   */\n  private _sr?: T[];\n\n  public count: number = 0;\n\n  public add(subscriber: T): boolean {\n    if (this.has(subscriber)) {\n      return false;\n    }\n    const subscriberFlags = this._sf;\n    if ((subscriberFlags & SF.Subscriber0) === 0) {\n      this._s0 = subscriber;\n      this._sf |= SF.Subscriber0;\n    } else if ((subscriberFlags & SF.Subscriber1) === 0) {\n      this._s1 = subscriber;\n      this._sf |= SF.Subscriber1;\n    } else if ((subscriberFlags & SF.Subscriber2) === 0) {\n      this._s2 = subscriber;\n      this._sf |= SF.Subscriber2;\n    } else if ((subscriberFlags & SF.SubscribersRest) === 0) {\n      this._sr = [subscriber];\n      this._sf |= SF.SubscribersRest;\n    } else {\n      this._sr!.push(subscriber); // Non-null is implied by else branch of (subscriberFlags & SF.SubscribersRest) === 0\n    }\n    ++this.count;\n    return true;\n  }\n\n  public has(subscriber: T): boolean {\n    // Flags here is just a perf tweak\n    // Compared to not using flags, it's a moderate speed-up when this collection does not have the subscriber;\n    // and minor slow-down when it does, and the former is more common than the latter.\n    const subscriberFlags = this._sf;\n    if ((subscriberFlags & SF.Subscriber0) > 0 && this._s0 === subscriber) {\n      return true;\n    }\n    if ((subscriberFlags & SF.Subscriber1) > 0 && this._s1 === subscriber) {\n      return true;\n    }\n    if ((subscriberFlags & SF.Subscriber2) > 0 && this._s2 === subscriber) {\n      return true;\n    }\n    if ((subscriberFlags & SF.SubscribersRest) > 0) {\n      const subscribers = this._sr!; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n      const ii = subscribers.length;\n      let i = 0;\n      for (; i < ii; ++i) {\n        if (subscribers[i] === subscriber) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public any(): boolean {\n    return this._sf !== SF.None;\n  }\n\n  public remove(subscriber: T): boolean {\n    const subscriberFlags = this._sf;\n    if ((subscriberFlags & SF.Subscriber0) > 0 && this._s0 === subscriber) {\n      this._s0 = void 0;\n      this._sf = (this._sf | SF.Subscriber0) ^ SF.Subscriber0;\n      --this.count;\n      return true;\n    } else if ((subscriberFlags & SF.Subscriber1) > 0 && this._s1 === subscriber) {\n      this._s1 = void 0;\n      this._sf = (this._sf | SF.Subscriber1) ^ SF.Subscriber1;\n      --this.count;\n      return true;\n    } else if ((subscriberFlags & SF.Subscriber2) > 0 && this._s2 === subscriber) {\n      this._s2 = void 0;\n      this._sf = (this._sf | SF.Subscriber2) ^ SF.Subscriber2;\n      --this.count;\n      return true;\n    } else if ((subscriberFlags & SF.SubscribersRest) > 0) {\n      const subscribers = this._sr!; // Non-null is implied by (subscriberFlags & SF.SubscribersRest) > 0\n      const ii = subscribers.length;\n      let i = 0;\n      for (; i < ii; ++i) {\n        if (subscribers[i] === subscriber) {\n          subscribers.splice(i, 1);\n          if (ii === 1) {\n            this._sf = (this._sf | SF.SubscribersRest) ^ SF.SubscribersRest;\n          }\n          --this.count;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public notify(val: unknown, oldVal: unknown, flags: LF): void {\n    /**\n     * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n     * callSubscribers invocation, so we're caching them all before invoking any.\n     * Subscribers added during this invocation are not invoked (and they shouldn't be).\n     * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n     * however this is accounted for via $isBound and similar flags on the subscriber objects)\n     */\n    const sub0 = this._s0 as ISubscriber;\n    const sub1 = this._s1 as ISubscriber;\n    const sub2 = this._s2 as ISubscriber;\n    let subs = this._sr as ISubscriber[];\n    if (subs !== void 0) {\n      subs = subs.slice();\n    }\n\n    if (sub0 !== void 0) {\n      sub0.handleChange(val, oldVal, flags);\n    }\n    if (sub1 !== void 0) {\n      sub1.handleChange(val, oldVal, flags);\n    }\n    if (sub2 !== void 0) {\n      sub2.handleChange(val, oldVal, flags);\n    }\n    if (subs !== void 0) {\n      const ii = subs.length;\n      let sub: ISubscriber | undefined;\n      let i = 0;\n      for (; i < ii; ++i) {\n        sub = subs[i];\n        if (sub !== void 0) {\n          sub.handleChange(val, oldVal, flags);\n        }\n      }\n    }\n  }\n\n  public notifyCollection(indexMap: IndexMap, flags: LF): void {\n    const sub0 = this._s0 as ICollectionSubscriber;\n    const sub1 = this._s1 as ICollectionSubscriber;\n    const sub2 = this._s2 as ICollectionSubscriber;\n    let subs = this._sr as ICollectionSubscriber[];\n    if (subs !== void 0) {\n      subs = subs.slice();\n    }\n\n    if (sub0 !== void 0) {\n      sub0.handleCollectionChange(indexMap, flags);\n    }\n    if (sub1 !== void 0) {\n      sub1.handleCollectionChange(indexMap, flags);\n    }\n    if (sub2 !== void 0) {\n      sub2.handleCollectionChange(indexMap, flags);\n    }\n    if (subs !== void 0) {\n      const ii = subs.length;\n      let sub: ICollectionSubscriber | undefined;\n      let i = 0;\n      for (; i < ii; ++i) {\n        sub = subs[i];\n        if (sub !== void 0) {\n          sub.handleCollectionChange(indexMap, flags);\n        }\n      }\n    }\n  }\n}\n\nfunction getSubscriberRecord(this: ISubscriberCollection) {\n  const record = new SubscriberRecord();\n  defineHiddenProp(this, 'subs', record);\n  return record;\n}\n\nfunction addSubscriber(this: ISubscriberCollection, subscriber: IAnySubscriber): boolean {\n  return this.subs.add(subscriber as ISubscriber & ICollectionSubscriber);\n}\n\nfunction removeSubscriber(this: ISubscriberCollection, subscriber: IAnySubscriber): boolean {\n  return this.subs.remove(subscriber as ISubscriber & ICollectionSubscriber);\n}\n","import { def } from '../utilities-objects.js';\n\n/* eslint-disable @typescript-eslint/ban-types */\n/**\n * Add a readonly 'queue' property on the target class to return the default FlushQueue\n * implementation\n */\nexport function withFlushQueue(): ClassDecorator;\nexport function withFlushQueue(target: Function): void;\nexport function withFlushQueue(target?: Function): ClassDecorator | void {\n  return target == null ? queueableDeco : queueableDeco(target);\n}\n\nfunction queueableDeco(target: Function): void {\n  const proto = target.prototype as IWithFlushQueue;\n  def(proto, 'queue', { get: getFlushQueue });\n}\n/* eslint-enable @typescript-eslint/ban-types */\n\nexport interface IFlushable {\n  flush(): void;\n}\n\nexport interface IWithFlushQueue {\n  queue: FlushQueue;\n}\n\nexport class FlushQueue {\n  public static readonly instance: FlushQueue = new FlushQueue();\n\n  private flushing: boolean = false;\n  private readonly items: Set<IFlushable> = new Set();\n\n  public get count(): number {\n    return this.items.size;\n  }\n\n  public add(callable: IFlushable): void {\n    this.items.add(callable);\n    if (this.flushing) {\n      return;\n    }\n    this.flushing = true;\n    const items = this.items;\n    let item: IFlushable;\n    try {\n      for (item of items) {\n        items.delete(item);\n        item.flush();\n      }\n    } finally {\n      this.flushing = false;\n    }\n  }\n\n  public clear(): void {\n    this.items.clear();\n    this.flushing = false;\n  }\n}\n\nfunction getFlushQueue() {\n  return FlushQueue.instance;\n}\n","import { isArrayIndex } from '@aurelia/kernel';\nimport { AccessorType, CollectionKind, LifecycleFlags } from '../observation.js';\nimport { subscriberCollection } from './subscriber-collection.js';\nimport { ensureProto } from '../utilities-objects.js';\nimport { withFlushQueue } from './flush-queue.js';\n\nimport type { Constructable } from '@aurelia/kernel';\nimport type {\n  ICollectionObserver,\n  IndexMap,\n  ISubscriber,\n  ISubscriberCollection,\n  ICollectionSubscriber,\n} from '../observation.js';\nimport type { FlushQueue, IFlushable, IWithFlushQueue } from './flush-queue.js';\n\nexport interface CollectionLengthObserver extends ISubscriberCollection {}\n\nexport class CollectionLengthObserver implements IWithFlushQueue, ICollectionSubscriber, IFlushable {\n\n  public value: number;\n  private oldvalue: number;\n  private f: LifecycleFlags = LifecycleFlags.none;\n\n  public readonly type: AccessorType = AccessorType.Array;\n  public readonly obj: unknown[];\n  // available via withFlushQueue mixin\n  public readonly queue!: FlushQueue;\n\n  public constructor(\n    public readonly owner: ICollectionObserver<CollectionKind.array>,\n  ) {\n    this.value = this.oldvalue = (this.obj = owner.collection).length;\n  }\n\n  public getValue(): number {\n    return this.obj.length;\n  }\n\n  public setValue(newValue: number, flags: LifecycleFlags): void {\n    const currentValue = this.value;\n    // if in the template, length is two-way bound directly\n    // then there's a chance that the new value is invalid\n    // add a guard so that we don't accidentally broadcast invalid values\n    if (newValue !== currentValue && isArrayIndex(newValue)) {\n      if ((flags & LifecycleFlags.noFlush) === 0) {\n        this.obj.length = newValue;\n      }\n      this.value = newValue;\n      this.oldvalue = currentValue;\n      this.f = flags;\n      this.queue.add(this);\n    }\n  }\n\n  public handleCollectionChange(_: IndexMap, flags: LifecycleFlags) {\n    const oldValue = this.value;\n    const value = this.obj.length;\n    if ((this.value = value) !== oldValue) {\n      this.oldvalue = oldValue;\n      this.f = flags;\n      this.queue.add(this);\n    }\n  }\n\n  public flush(): void {\n    oV = this.oldvalue;\n    this.oldvalue = this.value;\n    this.subs.notify(this.value, oV, this.f);\n  }\n}\n\nexport interface CollectionSizeObserver extends ISubscriberCollection {}\n\nexport class CollectionSizeObserver implements ICollectionSubscriber, IFlushable {\n  public value: number;\n  private oldvalue: number;\n  private f: LifecycleFlags = LifecycleFlags.none;\n\n  public readonly type: AccessorType;\n  public readonly obj: Set<unknown> | Map<unknown, unknown>;\n  public readonly queue!: FlushQueue;\n\n  public constructor(\n    public readonly owner: ICollectionObserver<CollectionKind.map | CollectionKind.set>,\n  ) {\n    this.value = this.oldvalue = (this.obj = owner.collection).size;\n    this.type = this.obj instanceof Map ? AccessorType.Map : AccessorType.Set;\n  }\n\n  public getValue(): number {\n    return this.obj.size;\n  }\n\n  public setValue(): void {\n    throw new Error('Map/Set \"size\" is a readonly property');\n  }\n\n  public handleCollectionChange(_: IndexMap, flags: LifecycleFlags): void {\n    const oldValue = this.value;\n    const value = this.obj.size;\n    if ((this.value = value) !== oldValue) {\n      this.oldvalue = oldValue;\n      this.f = flags;\n      this.queue.add(this);\n    }\n  }\n\n  public flush(): void {\n    oV = this.oldvalue;\n    this.oldvalue = this.value;\n    this.subs.notify(this.value, oV, this.f);\n  }\n}\n\ninterface CollectionLengthObserverImpl extends ISubscriberCollection, ICollectionSubscriber {\n  owner: ICollectionObserver<CollectionKind>;\n}\n\nfunction implementLengthObserver(klass: Constructable<ISubscriberCollection>) {\n  const proto = klass.prototype as ISubscriberCollection;\n  ensureProto(proto, 'subscribe', subscribe, true);\n  ensureProto(proto, 'unsubscribe', unsubscribe, true);\n  withFlushQueue(klass);\n  subscriberCollection(klass);\n}\n\nfunction subscribe(this: CollectionLengthObserverImpl, subscriber: ISubscriber): void {\n  if (this.subs.add(subscriber) && this.subs.count === 1) {\n    this.owner.subscribe(this);\n  }\n}\n\nfunction unsubscribe(this: CollectionLengthObserverImpl, subscriber: ISubscriber): void {\n  if (this.subs.remove(subscriber) && this.subs.count === 0) {\n    this.owner.subscribe(this);\n  }\n}\n\nimplementLengthObserver(CollectionLengthObserver);\nimplementLengthObserver(CollectionSizeObserver);\n\n// a reusable variable for `.flush()` methods of observers\n// so that there doesn't need to create an env record for every call\nlet oV: unknown = void 0;\n","import {\n  createIndexMap,\n  LifecycleFlags,\n  AccessorType,\n  ISubscriberCollection,\n  ICollectionSubscriberCollection,\n} from '../observation.js';\nimport {\n  CollectionLengthObserver,\n} from './collection-length-observer.js';\nimport {\n  subscriberCollection,\n} from './subscriber-collection.js';\n\nimport type {\n  CollectionKind,\n  ICollectionObserver,\n  IArrayIndexObserver,\n  IndexMap,\n  ISubscriber,\n} from '../observation.js';\nimport { def, defineHiddenProp } from '../utilities-objects.js';\n\nconst observerLookup = new WeakMap<unknown[], ArrayObserver>();\n\n// https://tc39.github.io/ecma262/#sec-sortcompare\nfunction sortCompare(x: unknown, y: unknown): number {\n  if (x === y) {\n    return 0;\n  }\n  x = x === null ? 'null' : (x as {}).toString();\n  y = y === null ? 'null' : (y as {}).toString();\n  return (x as {}) < (y as {}) ? -1 : 1;\n}\n\nfunction preSortCompare(x: unknown, y: unknown): number {\n  if (x === void 0) {\n    if (y === void 0) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  if (y === void 0) {\n    return -1;\n  }\n  return 0;\n}\n\nfunction insertionSort(arr: unknown[], indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let velement, ielement, vtmp, itmp, order;\n  let i, j;\n  for (i = from + 1; i < to; i++) {\n    velement = arr[i];\n    ielement = indexMap[i];\n    for (j = i - 1; j >= from; j--) {\n      vtmp = arr[j];\n      itmp = indexMap[j];\n      order = compareFn(vtmp, velement);\n      if (order > 0) {\n        arr[j + 1] = vtmp;\n        indexMap[j + 1] = itmp;\n      } else {\n        break;\n      }\n    }\n    arr[j + 1] = velement;\n    indexMap[j + 1] = ielement;\n  }\n}\n\nfunction quickSort(arr: unknown[], indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n  let thirdIndex = 0, i = 0;\n  let v0, v1, v2;\n  let i0, i1, i2;\n  let c01, c02, c12;\n  let vtmp, itmp;\n  let vpivot, ipivot, lowEnd, highStart;\n  let velement, ielement, order, vtopElement;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (to - from <= 10) {\n      insertionSort(arr, indexMap, from, to, compareFn);\n      return;\n    }\n\n    thirdIndex = from + ((to - from) >> 1);\n    v0 = arr[from];                i0 = indexMap[from];\n    v1 = arr[to - 1];              i1 = indexMap[to - 1];\n    v2 = arr[thirdIndex];          i2 = indexMap[thirdIndex];\n    c01 = compareFn(v0, v1);\n    if (c01 > 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v1;                     i0 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    }\n    c02 = compareFn(v0, v2);\n    if (c02 >= 0) {\n      vtmp = v0;                   itmp = i0;\n      v0 = v2;                     i0 = i2;\n      v2 = v1;                     i2 = i1;\n      v1 = vtmp;                   i1 = itmp;\n    } else {\n      c12 = compareFn(v1, v2);\n      if (c12 > 0) {\n        vtmp = v1;                 itmp = i1;\n        v1 = v2;                   i1 = i2;\n        v2 = vtmp;                 i2 = itmp;\n      }\n    }\n    arr[from] = v0;                indexMap[from] = i0;\n    arr[to - 1] = v2;              indexMap[to - 1] = i2;\n    vpivot = v1;                   ipivot = i1;\n    lowEnd = from + 1;\n    highStart = to - 1;\n    arr[thirdIndex] = arr[lowEnd]; indexMap[thirdIndex] = indexMap[lowEnd];\n    arr[lowEnd] = vpivot;          indexMap[lowEnd] = ipivot;\n\n    partition: for (i = lowEnd + 1; i < highStart; i++) {\n      velement = arr[i];           ielement = indexMap[i];\n      order = compareFn(velement, vpivot);\n      if (order < 0) {\n        arr[i] = arr[lowEnd];      indexMap[i] = indexMap[lowEnd];\n        arr[lowEnd] = velement;    indexMap[lowEnd] = ielement;\n        lowEnd++;\n      } else if (order > 0) {\n        do {\n          highStart--;\n          // eslint-disable-next-line eqeqeq\n          if (highStart == i) {\n            break partition;\n          }\n          vtopElement = arr[highStart]; order = compareFn(vtopElement, vpivot);\n        } while (order > 0);\n        arr[i] = arr[highStart];   indexMap[i] = indexMap[highStart];\n        arr[highStart] = velement; indexMap[highStart] = ielement;\n        if (order < 0) {\n          velement = arr[i];       ielement = indexMap[i];\n          arr[i] = arr[lowEnd];    indexMap[i] = indexMap[lowEnd];\n          arr[lowEnd] = velement;  indexMap[lowEnd] = ielement;\n          lowEnd++;\n        }\n      }\n    }\n\n    if (to - highStart < lowEnd - from) {\n      quickSort(arr, indexMap, highStart, to, compareFn);\n      to = lowEnd;\n    } else {\n      quickSort(arr, indexMap, from, lowEnd, compareFn);\n      from = highStart;\n    }\n  }\n}\n\nconst proto = Array.prototype as { [K in keyof any[]]: any[][K] & { observing?: boolean } };\n\nconst $push = proto.push;\nconst $unshift = proto.unshift;\nconst $pop = proto.pop;\nconst $shift = proto.shift;\nconst $splice = proto.splice;\nconst $reverse = proto.reverse;\nconst $sort = proto.sort;\n\nconst native = { push: $push, unshift: $unshift, pop: $pop, shift: $shift, splice: $splice, reverse: $reverse, sort: $sort };\nconst methods: ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'] = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-array.prototype.push\n  push: function (this: unknown[], ...args: unknown[]): ReturnType<typeof Array.prototype.push> {\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      return $push.apply(this, args);\n    }\n    const len = this.length;\n    const argCount = args.length;\n    if (argCount === 0) {\n      return len;\n    }\n    this.length = o.indexMap.length = len + argCount;\n    let i = len;\n    while (i < this.length) {\n      this[i] = args[i - len];\n      o.indexMap[i] = - 2;\n      i++;\n    }\n    o.notify();\n    return this.length;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.unshift\n  unshift: function (this: unknown[], ...args: unknown[]): ReturnType<typeof Array.prototype.unshift>  {\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      return $unshift.apply(this, args);\n    }\n    const argCount = args.length;\n    const inserts = new Array(argCount);\n    let i = 0;\n    while (i < argCount) {\n      inserts[i++] = - 2;\n    }\n    $unshift.apply(o.indexMap, inserts);\n    const len = $unshift.apply(this, args);\n    o.notify();\n    return len;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.pop\n  pop: function (this: unknown[]): ReturnType<typeof Array.prototype.pop> {\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      return $pop.call(this);\n    }\n    const indexMap = o.indexMap;\n    const element = $pop.call(this);\n    // only mark indices as deleted if they actually existed in the original array\n    const index = indexMap.length - 1;\n    if (indexMap[index] > -1) {\n      indexMap.deletedItems.push(indexMap[index]);\n    }\n    $pop.call(indexMap);\n    o.notify();\n    return element;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.shift\n  shift: function (this: unknown[]): ReturnType<typeof Array.prototype.shift> {\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      return $shift.call(this);\n    }\n    const indexMap = o.indexMap;\n    const element = $shift.call(this);\n    // only mark indices as deleted if they actually existed in the original array\n    if (indexMap[0] > -1) {\n      indexMap.deletedItems.push(indexMap[0]);\n    }\n    $shift.call(indexMap);\n    o.notify();\n    return element;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.splice\n  splice: function (this: unknown[], ...args: [number, number, ...unknown[]]): ReturnType<typeof Array.prototype.splice> {\n    const start: number = args[0];\n    const deleteCount: number|undefined = args[1];\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      return $splice.apply(this, args);\n    }\n    const len = this.length;\n    const relativeStart = start | 0;\n    const actualStart = relativeStart < 0 ? Math.max((len + relativeStart), 0) : Math.min(relativeStart, len);\n    const indexMap = o.indexMap;\n    const argCount = args.length;\n    const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;\n    if (actualDeleteCount > 0) {\n      let i = actualStart;\n      const to = i + actualDeleteCount;\n      while (i < to) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(indexMap[i]);\n        }\n        i++;\n      }\n    }\n    if (argCount > 2) {\n      const itemCount = argCount - 2;\n      const inserts = new Array(itemCount);\n      let i = 0;\n      while (i < itemCount) {\n        inserts[i++] = - 2;\n      }\n      $splice.call(indexMap, start, deleteCount, ...inserts);\n    } else {\n      $splice.apply(indexMap, args);\n    }\n    const deleted = $splice.apply(this, args);\n    o.notify();\n    return deleted;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n  reverse: function (this: unknown[]): ReturnType<typeof Array.prototype.reverse> {\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      $reverse.call(this);\n      return this;\n    }\n    const len = this.length;\n    const middle = (len / 2) | 0;\n    let lower = 0;\n    while (lower !== middle) {\n      const upper = len - lower - 1;\n      const lowerValue = this[lower];  const lowerIndex = o.indexMap[lower];\n      const upperValue = this[upper];  const upperIndex = o.indexMap[upper];\n      this[lower] = upperValue;        o.indexMap[lower] = upperIndex;\n      this[upper] = lowerValue;        o.indexMap[upper] = lowerIndex;\n      lower++;\n    }\n    o.notify();\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-array.prototype.sort\n  // https://github.com/v8/v8/blob/master/src/js/array.js\n  sort: function (this: unknown[], compareFn?: (a: unknown, b: unknown) => number): unknown[] {\n    const o = observerLookup.get(this);\n    if (o === void 0) {\n      $sort.call(this, compareFn);\n      return this;\n    }\n    const len = this.length;\n    if (len < 2) {\n      return this;\n    }\n    quickSort(this, o.indexMap, 0, len, preSortCompare);\n    let i = 0;\n    while (i < len) {\n      if (this[i] === void 0) {\n        break;\n      }\n      i++;\n    }\n    if (compareFn === void 0 || typeof compareFn !== 'function'/* spec says throw a TypeError, should we do that too? */) {\n      compareFn = sortCompare;\n    }\n    quickSort(this, o.indexMap, 0, i, compareFn);\n    o.notify();\n    return this;\n  }\n};\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nlet enableArrayObservationCalled = false;\n\nexport function enableArrayObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      defineHiddenProp(proto, method, observe[method]);\n    }\n  }\n}\n\nexport function disableArrayObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      defineHiddenProp(proto, method, native[method]);\n    }\n  }\n}\n\nexport interface ArrayObserver extends ICollectionObserver<CollectionKind.array>, ICollectionSubscriberCollection {}\n\nexport class ArrayObserver {\n  public type: AccessorType = AccessorType.Array;\n\n  private readonly indexObservers: Record<string | number, ArrayIndexObserver | undefined>;\n  private lenObs?: CollectionLengthObserver;\n\n  public constructor(array: unknown[]) {\n\n    if (!enableArrayObservationCalled) {\n      enableArrayObservationCalled = true;\n      enableArrayObservation();\n    }\n\n    this.indexObservers = {};\n\n    this.collection = array;\n    this.indexMap = createIndexMap(array.length);\n    this.lenObs = void 0;\n\n    observerLookup.set(array, this);\n  }\n\n  public notify(): void {\n    const indexMap = this.indexMap;\n    const length = this.collection.length;\n\n    this.indexMap = createIndexMap(length);\n    this.subs.notifyCollection(indexMap, LifecycleFlags.none);\n  }\n\n  public getLengthObserver(): CollectionLengthObserver {\n    return this.lenObs ??= new CollectionLengthObserver(this);\n  }\n\n  public getIndexObserver(index: number): IArrayIndexObserver {\n    // It's unnecessary to destroy/recreate index observer all the time,\n    // so just create once, and add/remove instead\n    return this.indexObservers[index] ??= new ArrayIndexObserver(this, index);\n  }\n}\n\nexport interface ArrayIndexObserver extends IArrayIndexObserver, ISubscriberCollection {}\n\nexport class ArrayIndexObserver implements IArrayIndexObserver {\n\n  public doNotCache: boolean = true;\n  public value: unknown;\n\n  public constructor(\n    public readonly owner: ArrayObserver,\n    public readonly index: number\n  ) {\n    this.value = this.getValue();\n  }\n\n  public getValue(): unknown {\n    return this.owner.collection[this.index];\n  }\n\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    if (newValue === this.getValue()) {\n      return;\n    }\n    const arrayObserver = this.owner;\n    const index = this.index;\n    const indexMap = arrayObserver.indexMap;\n\n    if (indexMap[index] > -1) {\n      indexMap.deletedItems.push(indexMap[index]);\n    }\n    indexMap[index] = -2;\n    // do not need to update current value here\n    // as it will be updated inside handle collection change\n    arrayObserver.collection[index] = newValue;\n    arrayObserver.notify();\n  }\n\n  /**\n   * From interface `ICollectionSubscriber`\n   */\n  public handleCollectionChange(indexMap: IndexMap, flags: LifecycleFlags): void {\n    const index = this.index;\n    const noChange = indexMap[index] === index;\n    if (noChange) {\n      return;\n    }\n    const prevValue = this.value;\n    const currValue = this.value = this.getValue();\n    // hmm\n    if (prevValue !== currValue) {\n      this.subs.notify(currValue, prevValue, flags);\n    }\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this.subs.add(subscriber) && this.subs.count === 1) {\n      this.owner.subscribe(this);\n    }\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    if (this.subs.remove(subscriber) && this.subs.count === 0) {\n      this.owner.unsubscribe(this);\n    }\n  }\n}\n\nsubscriberCollection(ArrayObserver);\nsubscriberCollection(ArrayIndexObserver);\n\nexport function getArrayObserver(array: unknown[]): ArrayObserver {\n  let observer = observerLookup.get(array);\n  if (observer === void 0) {\n    observer = new ArrayObserver(array);\n  }\n  return observer;\n}\n\n/**\n * Applies offsets to the non-negative indices in the IndexMap\n * based on added and deleted items relative to those indices.\n *\n * e.g. turn `[-2, 0, 1]` into `[-2, 1, 2]`, allowing the values at the indices to be\n * used for sorting/reordering items if needed\n */\nexport function applyMutationsToIndices(indexMap: IndexMap): void {\n  let offset = 0;\n  let j = 0;\n  const len = indexMap.length;\n  for (let i = 0; i < len; ++i) {\n    while (indexMap.deletedItems[j] <= i - offset) {\n      ++j;\n      --offset;\n    }\n    if (indexMap[i] === -2) {\n      ++offset;\n    } else {\n      indexMap[i] += offset;\n    }\n  }\n}\n\n/**\n * After `applyMutationsToIndices`, this function can be used to reorder items in a derived\n * array (e.g.  the items in the `views` in the repeater are derived from the `items` property)\n */\nexport function synchronizeIndices<T>(items: T[], indexMap: IndexMap): void {\n  const copy = items.slice();\n\n  const len = indexMap.length;\n  let to = 0;\n  let from = 0;\n  while (to < len) {\n    from = indexMap[to];\n    if (from !== -2) {\n      items[to] = copy[from];\n    }\n    ++to;\n  }\n}\n","import { createIndexMap, AccessorType, LifecycleFlags, ICollectionSubscriberCollection } from '../observation.js';\nimport { CollectionSizeObserver } from './collection-length-observer.js';\nimport { subscriberCollection } from './subscriber-collection.js';\nimport { def } from '../utilities-objects.js';\n\nimport type {\n  ICollectionObserver,\n  CollectionKind,\n} from '../observation.js';\n\nconst observerLookup = new WeakMap<Set<unknown>, SetObserver>();\n\nconst proto = Set.prototype as { [K in keyof Set<any>]: Set<any>[K] & { observing?: boolean } };\n\nconst $add = proto.add;\nconst $clear = proto.clear;\nconst $delete = proto.delete;\n\nconst native = { add: $add, clear: $clear, delete: $delete };\nconst methods: ['add', 'clear', 'delete'] = ['add', 'clear', 'delete'];\n\n// note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, add/delete/clear are easy to reconstruct for the indexMap\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-set.prototype.add\n  add: function (this: Set<unknown>, value: unknown): ReturnType<typeof $add> {\n    const o = observerLookup.get(this);\n    if (o === undefined) {\n      $add.call(this, value);\n      return this;\n    }\n    const oldSize = this.size;\n    $add.call(this, value);\n    const newSize = this.size;\n    if (newSize === oldSize) {\n      return this;\n    }\n    o.indexMap[oldSize] = -2;\n    o.notify();\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-set.prototype.clear\n  clear: function (this: Set<unknown>): ReturnType<typeof $clear>  {\n    const o = observerLookup.get(this);\n    if (o === undefined) {\n      return $clear.call(this);\n    }\n    const size = this.size;\n    if (size > 0) {\n      const indexMap = o.indexMap;\n      let i = 0;\n      // deepscan-disable-next-line\n      for (const _ of this.keys()) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(indexMap[i]);\n        }\n        i++;\n      }\n      $clear.call(this);\n      indexMap.length = 0;\n      o.notify();\n    }\n    return undefined;\n  },\n  // https://tc39.github.io/ecma262/#sec-set.prototype.delete\n  delete: function (this: Set<unknown>, value: unknown): ReturnType<typeof $delete> {\n    const o = observerLookup.get(this);\n    if (o === undefined) {\n      return $delete.call(this, value);\n    }\n    const size = this.size;\n    if (size === 0) {\n      return false;\n    }\n    let i = 0;\n    const indexMap = o.indexMap;\n    for (const entry of this.keys()) {\n      if (entry === value) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(indexMap[i]);\n        }\n        indexMap.splice(i, 1);\n        const deleteResult = $delete.call(this, value);\n        if (deleteResult === true) {\n          o.notify();\n        }\n        return deleteResult;\n      }\n      i++;\n    }\n    return false;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nlet enableSetObservationCalled = false;\n\nexport function enableSetObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nexport function disableSetObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nexport interface SetObserver extends ICollectionObserver<CollectionKind.set>, ICollectionSubscriberCollection {}\n\nexport class SetObserver {\n  public type: AccessorType = AccessorType.Set;\n  private lenObs?: CollectionSizeObserver;\n\n  public constructor(observedSet: Set<unknown>) {\n\n    if (!enableSetObservationCalled) {\n      enableSetObservationCalled = true;\n      enableSetObservation();\n    }\n\n    this.collection = observedSet;\n    this.indexMap = createIndexMap(observedSet.size);\n    this.lenObs = void 0;\n\n    observerLookup.set(observedSet, this);\n  }\n\n  public notify(): void {\n    const indexMap = this.indexMap;\n    const size = this.collection.size;\n\n    this.indexMap = createIndexMap(size);\n    this.subs.notifyCollection(indexMap, LifecycleFlags.none);\n  }\n\n  public getLengthObserver(): CollectionSizeObserver {\n    return this.lenObs ??= new CollectionSizeObserver(this);\n  }\n}\n\nsubscriberCollection(SetObserver);\n\nexport function getSetObserver(observedSet: Set<unknown>): SetObserver {\n  let observer = observerLookup.get(observedSet);\n  if (observer === void 0) {\n    observer = new SetObserver(observedSet);\n  }\n  return observer;\n}\n","import { createIndexMap, AccessorType, LifecycleFlags } from '../observation.js';\nimport { CollectionSizeObserver } from './collection-length-observer.js';\nimport { subscriberCollection } from './subscriber-collection.js';\nimport { def } from '../utilities-objects.js';\n\nimport type {\n  CollectionKind,\n  ICollectionObserver,\n  ICollectionSubscriberCollection,\n} from '../observation.js';\n\nconst observerLookup = new WeakMap<Map<unknown, unknown>, MapObserver>();\n\nconst proto = Map.prototype as { [K in keyof Map<any, any>]: Map<any, any>[K] & { observing?: boolean } };\n\nconst $set = proto.set;\nconst $clear = proto.clear;\nconst $delete = proto.delete;\n\nconst native = { set: $set, clear: $clear, delete: $delete };\nconst methods: ['set', 'clear', 'delete'] = ['set', 'clear', 'delete'];\n\n// note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n// fortunately, map/delete/clear are easy to reconstruct for the indexMap\n\nconst observe = {\n  // https://tc39.github.io/ecma262/#sec-map.prototype.map\n  set: function (this: Map<unknown, unknown>, key: unknown, value: unknown): ReturnType<typeof $set> {\n    const o = observerLookup.get(this);\n    if (o === undefined) {\n      $set.call(this, key, value);\n      return this;\n    }\n    const oldValue = this.get(key);\n    const oldSize = this.size;\n    $set.call(this, key, value);\n    const newSize = this.size;\n    if (newSize === oldSize) {\n      let i = 0;\n      for (const entry of this.entries()) {\n        if (entry[0] === key) {\n          if (entry[1] !== oldValue) {\n            o.indexMap.deletedItems.push(o.indexMap[i]);\n            o.indexMap[i] = -2;\n            o.notify();\n          }\n          return this;\n        }\n        i++;\n      }\n      return this;\n    }\n    o.indexMap[oldSize] = -2;\n    o.notify();\n    return this;\n  },\n  // https://tc39.github.io/ecma262/#sec-map.prototype.clear\n  clear: function (this: Map<unknown, unknown>): ReturnType<typeof $clear>  {\n    const o = observerLookup.get(this);\n    if (o === undefined) {\n      return $clear.call(this);\n    }\n    const size = this.size;\n    if (size > 0) {\n      const indexMap = o.indexMap;\n      let i = 0;\n      // deepscan-disable-next-line\n      for (const _ of this.keys()) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(indexMap[i]);\n        }\n        i++;\n      }\n      $clear.call(this);\n      indexMap.length = 0;\n      o.notify();\n    }\n    return undefined;\n  },\n  // https://tc39.github.io/ecma262/#sec-map.prototype.delete\n  delete: function (this: Map<unknown, unknown>, value: unknown): ReturnType<typeof $delete> {\n    const o = observerLookup.get(this);\n    if (o === undefined) {\n      return $delete.call(this, value);\n    }\n    const size = this.size;\n    if (size === 0) {\n      return false;\n    }\n    let i = 0;\n    const indexMap = o.indexMap;\n    for (const entry of this.keys()) {\n      if (entry === value) {\n        if (indexMap[i] > -1) {\n          indexMap.deletedItems.push(indexMap[i]);\n        }\n        indexMap.splice(i, 1);\n        const deleteResult = $delete.call(this, value);\n        if (deleteResult === true) {\n          o.notify();\n        }\n        return deleteResult;\n      }\n      ++i;\n    }\n    return false;\n  }\n};\n\nconst descriptorProps = {\n  writable: true,\n  enumerable: false,\n  configurable: true\n};\n\nfor (const method of methods) {\n  def(observe[method], 'observing', { value: true, writable: false, configurable: false, enumerable: false });\n}\n\nlet enableMapObservationCalled = false;\n\nexport function enableMapObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing !== true) {\n      def(proto, method, { ...descriptorProps, value: observe[method] });\n    }\n  }\n}\n\nexport function disableMapObservation(): void {\n  for (const method of methods) {\n    if (proto[method].observing === true) {\n      def(proto, method, { ...descriptorProps, value: native[method] });\n    }\n  }\n}\n\nexport interface MapObserver extends ICollectionObserver<CollectionKind.map>, ICollectionSubscriberCollection {}\n\nexport class MapObserver {\n  public type: AccessorType = AccessorType.Map;\n  private lenObs?: CollectionSizeObserver;\n\n  public constructor(map: Map<unknown, unknown>) {\n\n    if (!enableMapObservationCalled) {\n      enableMapObservationCalled = true;\n      enableMapObservation();\n    }\n\n    this.collection = map;\n    this.indexMap = createIndexMap(map.size);\n    this.lenObs = void 0;\n\n    observerLookup.set(map, this);\n  }\n\n  public notify(): void {\n    const indexMap = this.indexMap;\n    const size = this.collection.size;\n\n    this.indexMap = createIndexMap(size);\n    this.subs.notifyCollection(indexMap, LifecycleFlags.none);\n  }\n\n  public getLengthObserver(): CollectionSizeObserver {\n    return this.lenObs ??= new CollectionSizeObserver(this);\n  }\n}\n\nsubscriberCollection(MapObserver);\n\nexport function getMapObserver(map: Map<unknown, unknown>): MapObserver {\n  let observer = observerLookup.get(map);\n  if (observer === void 0) {\n    observer = new MapObserver(map);\n  }\n  return observer;\n}\n","import { def, defineHiddenProp, ensureProto } from '../utilities-objects.js';\nimport { getArrayObserver } from '../observation/array-observer.js';\nimport { getSetObserver } from '../observation/set-observer.js';\nimport { getMapObserver } from '../observation/map-observer.js';\n\nimport type { Class, IServiceLocator } from '@aurelia/kernel';\nimport type {\n  IConnectable,\n  ISubscribable,\n  ISubscriber,\n  IBinding,\n  Collection,\n  CollectionObserver,\n  ICollectionSubscriber,\n  IndexMap,\n  ICollectionSubscribable,\n  LifecycleFlags,\n} from '../observation.js';\nimport type { IObserverLocator } from '../observation/observer-locator.js';\n\n// TODO: add connect-queue (or something similar) back in when everything else is working, to improve startup time\n\nexport interface IPartialConnectableBinding extends IBinding, ISubscriber, ICollectionSubscriber {\n  observerLocator: IObserverLocator;\n}\n\nexport interface IConnectableBinding extends IPartialConnectableBinding, IConnectable {\n  /**\n   * A record storing observers that are currently subscribed to by this binding\n   */\n  obs: BindingObserverRecord;\n}\n\nfunction observeProperty(this: IConnectableBinding, obj: object, key: PropertyKey): void {\n  const observer = this.observerLocator.getObserver(obj, key);\n  /* Note: we need to cast here because we can indeed get an accessor instead of an observer,\n   *  in which case the call to observer.subscribe will throw. It's not very clean and we can solve this in 2 ways:\n   *  1. Fail earlier: only let the locator resolve observers from .getObserver, and throw if no branches are left (e.g. it would otherwise return an accessor)\n   *  2. Fail silently (without throwing): give all accessors a no-op subscribe method\n   *\n   * We'll probably want to implement some global configuration (like a \"strict\" toggle) so users can pick between enforced correctness vs. ease-of-use\n   */\n  this.obs.add(observer);\n}\nfunction getObserverRecord(this: IConnectableBinding): BindingObserverRecord {\n  const record = new BindingObserverRecord(this);\n  defineHiddenProp(this, 'obs', record);\n  return record;\n}\n\nfunction observeCollection(this: IConnectableBinding, collection: Collection): void {\n  let obs: CollectionObserver;\n  if (collection instanceof Array) {\n    obs = getArrayObserver(collection);\n  } else if (collection instanceof Set) {\n    obs = getSetObserver(collection);\n  } else if (collection instanceof Map) {\n    obs = getMapObserver(collection);\n  } else {\n    throw new Error('Unrecognised collection type.');\n  }\n  this.obs.add(obs);\n}\n\nfunction subscribeTo(this: IConnectableBinding, subscribable: ISubscribable | ICollectionSubscribable): void {\n  this.obs.add(subscribable);\n}\n\nfunction noopHandleChange() {\n  throw new Error('method \"handleChange\" not implemented');\n}\n\nfunction noopHandleCollectionChange() {\n  throw new Error('method \"handleCollectionChange\" not implemented');\n}\n\ntype ObservationRecordImplType = {\n  version: number;\n  count: number;\n  binding: IConnectableBinding;\n} & Record<string, unknown>;\n\nexport interface BindingObserverRecord extends ObservationRecordImplType { }\nexport class BindingObserverRecord implements ISubscriber, ICollectionSubscriber {\n  public version: number = 0;\n  public count: number = 0;\n  public slots: number = 0;\n\n  public constructor(\n    public binding: IConnectableBinding\n  ) {\n  }\n\n  public handleChange(value: unknown, oldValue: unknown, flags: LifecycleFlags): unknown {\n    return this.binding.interceptor.handleChange(value, oldValue, flags);\n  }\n\n  public handleCollectionChange(indexMap: IndexMap, flags: LifecycleFlags): void {\n    this.binding.interceptor.handleCollectionChange(indexMap, flags);\n  }\n\n  /**\n   * Add, and subscribe to a given observer\n   */\n  public add(observer: ISubscribable | ICollectionSubscribable): void {\n    // find the observer.\n    const observerSlots = this.slots;\n    let i = observerSlots;\n\n    // find the slot number of the observer\n    while (i-- && this[`_o${i}`] !== observer);\n\n    // if we are not already observing, put the observer in an open slot and subscribe.\n    if (i === -1) {\n      i = 0;\n      // go from the start, find an open slot number\n      while (this[`_o${i}`] !== void 0) {\n        i++;\n      }\n      // store the reference to the observer and subscribe\n      this[`_o${i}`] = observer;\n      observer.subscribe(this);\n      // increment the slot count.\n      if (i === observerSlots) {\n        this.slots = i + 1;\n      }\n      ++this.count;\n    }\n    this[`_v${i}`] = this.version;\n  }\n\n  /**\n   * Unsubscribe the observers that are not up to date with the record version\n   */\n  public clear(all?: boolean): void {\n    const slotCount = this.slots;\n    let slotName: string;\n    let observer: (ISubscribable | ICollectionSubscribable) & { [key: string]: number };\n    let i = 0;\n    if (all === true) {\n      for (; i < slotCount; ++i) {\n        slotName = `_o${i}`;\n        observer = this[slotName] as (ISubscribable | ICollectionSubscribable) & { [key: string]: number };\n        if (observer !== void 0) {\n          this[slotName] = void 0;\n          observer.unsubscribe(this);\n        }\n      }\n      this.count = this.slots = 0;\n    } else {\n      for (; i < slotCount; ++i) {\n        if (this[`_v${i}`] !== this.version) {\n          slotName = `_o${i}`;\n          observer = this[slotName] as (ISubscribable | ICollectionSubscribable) & { [key: string]: number };\n          if (observer !== void 0) {\n            this[slotName] = void 0;\n            observer.unsubscribe(this);\n            this.count--;\n          }\n        }\n      }\n    }\n  }\n}\n\ntype Connectable = IConnectable & Partial<ISubscriber & ICollectionSubscriber>;\ntype DecoratableConnectable<TProto, TClass> = Class<TProto & Connectable, TClass>;\ntype DecoratedConnectable<TProto, TClass> = Class<TProto & Connectable, TClass>;\n\nfunction connectableDecorator<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> {\n  const proto = target.prototype;\n  ensureProto(proto, 'observeProperty', observeProperty, true);\n  ensureProto(proto, 'observeCollection', observeCollection, true);\n  ensureProto(proto, 'subscribeTo', subscribeTo, true);\n  def(proto, 'obs', { get: getObserverRecord });\n  // optionally add these two methods to normalize a connectable impl\n  ensureProto(proto, 'handleChange', noopHandleChange);\n  ensureProto(proto, 'handleCollectionChange', noopHandleCollectionChange);\n\n  return target;\n}\n\nexport function connectable(): typeof connectableDecorator;\nexport function connectable<TProto, TClass>(target: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass>;\nexport function connectable<TProto, TClass>(target?: DecoratableConnectable<TProto, TClass>): DecoratedConnectable<TProto, TClass> | typeof connectableDecorator {\n  return target == null ? connectableDecorator : connectableDecorator(target);\n}\n\nexport type MediatedBinding<K extends string> = {\n  [key in K]: (newValue: unknown, previousValue: unknown, flags: LifecycleFlags) => void;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface BindingMediator<K extends string> extends IConnectableBinding { }\nexport class BindingMediator<K extends string> implements IConnectableBinding {\n  public interceptor = this;\n\n  public constructor(\n    public readonly key: K,\n    public readonly binding: MediatedBinding<K>,\n    public observerLocator: IObserverLocator,\n    public locator: IServiceLocator,\n  ) {\n  }\n\n  public $bind(): void {\n    throw new Error('Method not implemented.');\n  }\n\n  public $unbind(): void {\n    throw new Error('Method not implemented.');\n  }\n\n  public handleChange(newValue: unknown, previousValue: unknown, flags: LifecycleFlags): void {\n    this.binding[this.key](newValue, previousValue, flags);\n  }\n}\n\nconnectableDecorator(BindingMediator);\n","import {\n  DI,\n} from '@aurelia/kernel';\nimport {\n  AccessKeyedExpression,\n  AccessMemberExpression,\n  AccessScopeExpression,\n  AccessThisExpression,\n  ArrayBindingPattern,\n  ArrayLiteralExpression,\n  AssignExpression,\n  BinaryExpression,\n  BindingBehaviorExpression,\n  BindingIdentifier,\n  CallFunctionExpression,\n  CallMemberExpression,\n  CallScopeExpression,\n  ConditionalExpression,\n  CustomExpression,\n  ForOfStatement,\n  Interpolation,\n  ObjectBindingPattern,\n  ObjectLiteralExpression,\n  PrimitiveLiteralExpression,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  UnaryExpression,\n  ValueConverterExpression,\n  AnyBindingExpression,\n  BinaryOperator,\n  BindingIdentifierOrPattern,\n  IsAssign,\n  IsAssignable,\n  IsBinary,\n  IsBindingBehavior,\n  IsConditional,\n  IsExpressionOrStatement,\n  IsLeftHandSide,\n  IsPrimary,\n  IsUnary,\n  IsValueConverter,\n  UnaryOperator,\n  ExpressionKind,\n} from './ast.js';\n\nexport interface IExpressionParser extends ExpressionParser {}\nexport const IExpressionParser = DI.createInterface<IExpressionParser>('IExpressionParser', x => x.singleton(ExpressionParser));\n\nexport class ExpressionParser {\n  private readonly expressionLookup: Record<string, IsBindingBehavior> = Object.create(null);\n  private readonly forOfLookup: Record<string, ForOfStatement> = Object.create(null);\n  private readonly interpolationLookup: Record<string, Interpolation> = Object.create(null);\n\n  public parse(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  public parse(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  public parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  public parse(expression: string, bindingType: BindingType): AnyBindingExpression;\n  public parse(expression: string, bindingType: BindingType): AnyBindingExpression {\n    switch (bindingType) {\n      case BindingType.Interpolation: {\n        let found = this.interpolationLookup[expression];\n        if (found === void 0) {\n          found = this.interpolationLookup[expression] = this.$parse(expression, bindingType);\n        }\n        return found;\n      }\n      case BindingType.ForCommand: {\n        let found = this.forOfLookup[expression];\n        if (found === void 0) {\n          found = this.forOfLookup[expression] = this.$parse(expression, bindingType);\n        }\n        return found;\n      }\n      default: {\n        // Allow empty strings for normal bindings and those that are empty by default (such as a custom attribute without an equals sign)\n        // But don't cache it, because empty strings are always invalid for any other type of binding\n        if (expression.length === 0 && (bindingType & (BindingType.BindCommand | BindingType.OneTimeCommand | BindingType.ToViewCommand))) {\n          return PrimitiveLiteralExpression.$empty;\n        }\n        let found = this.expressionLookup[expression];\n        if (found === void 0) {\n          found = this.expressionLookup[expression] = this.$parse(expression, bindingType);\n        }\n        return found;\n      }\n    }\n  }\n\n  private $parse(expression: string, bindingType: BindingType.ForCommand): ForOfStatement;\n  private $parse(expression: string, bindingType: BindingType.Interpolation): Interpolation;\n  private $parse(expression: string, bindingType: Exclude<BindingType, BindingType.ForCommand | BindingType.Interpolation>): IsBindingBehavior;\n  private $parse(expression: string, bindingType: BindingType): AnyBindingExpression {\n    $state.input = expression;\n    $state.length = expression.length;\n    $state.index = 0;\n    $state.currentChar = expression.charCodeAt(0);\n    return parse($state, Access.Reset, Precedence.Variadic, bindingType === void 0 ? BindingType.BindCommand : bindingType);\n  }\n}\n\nexport const enum Char {\n  Null           = 0x00,\n  Backspace      = 0x08,\n  Tab            = 0x09,\n  LineFeed       = 0x0A,\n  VerticalTab    = 0x0B,\n  FormFeed       = 0x0C,\n  CarriageReturn = 0x0D,\n  Space          = 0x20,\n  Exclamation    = 0x21,\n  DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  Percent        = 0x25,\n  Ampersand      = 0x26,\n  SingleQuote    = 0x27,\n  OpenParen      = 0x28,\n  CloseParen     = 0x29,\n  Asterisk       = 0x2A,\n  Plus           = 0x2B,\n  Comma          = 0x2C,\n  Minus          = 0x2D,\n  Dot            = 0x2E,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Backtick       = 0x60,\n  OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  CloseBracket   = 0x5D,\n  Caret          = 0x5E,\n  Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  Bar            = 0x7C,\n  CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  LessThan       = 0x3C,\n  Equals         = 0x3D,\n  GreaterThan    = 0x3E,\n  Question       = 0x3F,\n\n  Zero   = 0x30,\n  One    = 0x31,\n  Two    = 0x32,\n  Three  = 0x33,\n  Four   = 0x34,\n  Five   = 0x35,\n  Six    = 0x36,\n  Seven  = 0x37,\n  Eight  = 0x38,\n  Nine   = 0x39,\n\n  UpperA = 0x41,\n  UpperB = 0x42,\n  UpperC = 0x43,\n  UpperD = 0x44,\n  UpperE = 0x45,\n  UpperF = 0x46,\n  UpperG = 0x47,\n  UpperH = 0x48,\n  UpperI = 0x49,\n  UpperJ = 0x4A,\n  UpperK = 0x4B,\n  UpperL = 0x4C,\n  UpperM = 0x4D,\n  UpperN = 0x4E,\n  UpperO = 0x4F,\n  UpperP = 0x50,\n  UpperQ = 0x51,\n  UpperR = 0x52,\n  UpperS = 0x53,\n  UpperT = 0x54,\n  UpperU = 0x55,\n  UpperV = 0x56,\n  UpperW = 0x57,\n  UpperX = 0x58,\n  UpperY = 0x59,\n  UpperZ = 0x5A,\n\n  LowerA  = 0x61,\n  LowerB  = 0x62,\n  LowerC  = 0x63,\n  LowerD  = 0x64,\n  LowerE  = 0x65,\n  LowerF  = 0x66,\n  LowerG  = 0x67,\n  LowerH  = 0x68,\n  LowerI  = 0x69,\n  LowerJ  = 0x6A,\n  LowerK  = 0x6B,\n  LowerL  = 0x6C,\n  LowerM  = 0x6D,\n  LowerN  = 0x6E,\n  LowerO  = 0x6F,\n  LowerP  = 0x70,\n  LowerQ  = 0x71,\n  LowerR  = 0x72,\n  LowerS  = 0x73,\n  LowerT  = 0x74,\n  LowerU  = 0x75,\n  LowerV  = 0x76,\n  LowerW  = 0x77,\n  LowerX  = 0x78,\n  LowerY  = 0x79,\n  LowerZ  = 0x7A\n}\n\nfunction unescapeCode(code: number): number {\n  switch (code) {\n    case Char.LowerB: return Char.Backspace;\n    case Char.LowerT: return Char.Tab;\n    case Char.LowerN: return Char.LineFeed;\n    case Char.LowerV: return Char.VerticalTab;\n    case Char.LowerF: return Char.FormFeed;\n    case Char.LowerR: return Char.CarriageReturn;\n    case Char.DoubleQuote: return Char.DoubleQuote;\n    case Char.SingleQuote: return Char.SingleQuote;\n    case Char.Backslash: return Char.Backslash;\n    default: return code;\n  }\n}\n\nexport const enum Access {\n  Reset                   = 0b0000000000000,\n  Ancestor                = 0b0000111111111,\n  This                    = 0b0001000000000,\n  Scope                   = 0b0010000000000,\n  Member                  = 0b0100000000000,\n  Keyed                   = 0b1000000000000\n}\n\nexport const enum Precedence {\n  Variadic                = 0b000111101,\n  Assign                  = 0b000111110,\n  Conditional             = 0b000111111,\n  LogicalOR               = 0b001000000,\n  LogicalAND              = 0b010000000,\n  Equality                = 0b011000000,\n  Relational              = 0b100000000,\n  Additive                = 0b101000000,\n  Multiplicative          = 0b110000000,\n  Binary                  = 0b111000000,\n  LeftHandSide            = 0b111000001,\n  Primary                 = 0b111000010,\n  Unary                   = 0b111000011,\n}\nconst enum Token {\n  EOF                     = 0b110000000000_000_000000,\n  ExpressionTerminal      = 0b100000000000_000_000000,\n  AccessScopeTerminal     = 0b010000000000_000_000000,\n  ClosingToken            = 0b001000000000_000_000000,\n  OpeningToken            = 0b000100000000_000_000000,\n  BinaryOp                = 0b000010000000_000_000000,\n  UnaryOp                 = 0b000001000000_000_000000,\n  LeftHandSide            = 0b000000100000_000_000000,\n  StringOrNumericLiteral  = 0b000000011000_000_000000,\n  NumericLiteral          = 0b000000010000_000_000000,\n  StringLiteral           = 0b000000001000_000_000000,\n  IdentifierName          = 0b000000000110_000_000000,\n  Keyword                 = 0b000000000100_000_000000,\n  Identifier              = 0b000000000010_000_000000,\n  Contextual              = 0b000000000001_000_000000,\n  Precedence              = 0b000000000000_111_000000,\n  Type                    = 0b000000000000_000_111111,\n  FalseKeyword            = 0b000000000100_000_000000,\n  TrueKeyword             = 0b000000000100_000_000001,\n  NullKeyword             = 0b000000000100_000_000010,\n  UndefinedKeyword        = 0b000000000100_000_000011,\n  ThisScope               = 0b000000000110_000_000100,\n  // HostScope               = 0b000000000110_000_000101,\n  ParentScope             = 0b000000000110_000_000110,\n  OpenParen               = 0b010100100000_000_000111,\n  OpenBrace               = 0b000100000000_000_001000,\n  Dot                     = 0b000000100000_000_001001,\n  CloseBrace              = 0b111000000000_000_001010,\n  CloseParen              = 0b111000000000_000_001011,\n  Comma                   = 0b110000000000_000_001100,\n  OpenBracket             = 0b010100100000_000_001101,\n  CloseBracket            = 0b111000000000_000_001110,\n  Colon                   = 0b110000000000_000_001111,\n  Question                = 0b110000000000_000_010000,\n  Ampersand               = 0b110000000000_000_010011,\n  Bar                     = 0b110000000000_000_010100,\n  BarBar                  = 0b110010000000_010_010101,\n  AmpersandAmpersand      = 0b110010000000_011_010110,\n  EqualsEquals            = 0b110010000000_100_010111,\n  ExclamationEquals       = 0b110010000000_100_011000,\n  EqualsEqualsEquals      = 0b110010000000_100_011001,\n  ExclamationEqualsEquals = 0b110010000000_100_011010,\n  LessThan                = 0b110010000000_101_011011,\n  GreaterThan             = 0b110010000000_101_011100,\n  LessThanEquals          = 0b110010000000_101_011101,\n  GreaterThanEquals       = 0b110010000000_101_011110,\n  InKeyword               = 0b110010000100_101_011111,\n  InstanceOfKeyword       = 0b110010000100_101_100000,\n  Plus                    = 0b010011000000_110_100001,\n  Minus                   = 0b010011000000_110_100010,\n  TypeofKeyword           = 0b000001000100_000_100011,\n  VoidKeyword             = 0b000001000100_000_100100,\n  Asterisk                = 0b110010000000_111_100101,\n  Percent                 = 0b110010000000_111_100110,\n  Slash                   = 0b110010000000_111_100111,\n  Equals                  = 0b100000000000_000_101000,\n  Exclamation             = 0b000001000000_000_101001,\n  TemplateTail            = 0b010000100000_000_101010,\n  TemplateContinuation    = 0b010000100000_000_101011,\n  OfKeyword               = 0b100000000101_000_101100\n}\n\nconst $false = PrimitiveLiteralExpression.$false;\nconst $true = PrimitiveLiteralExpression.$true;\nconst $null = PrimitiveLiteralExpression.$null;\nconst $undefined = PrimitiveLiteralExpression.$undefined;\nconst $this = AccessThisExpression.$this;\nconst $parent = AccessThisExpression.$parent;\n\nexport const enum BindingType {\n                None = 0,\n          // if a binding command is taking over the processing of an attribute\n          // then it should add this flag to its binding type\n          // which then tell the binder to proceed the attribute compilation as is,\n          // instead of normal process: transformation -> compilation\n          IgnoreAttr = 0b100000000_0000,\n       Interpolation = 0b010000000_0000,\n          IsRef      = 0b101010000_0000,\n          IsIterator = 0b000100000_0000,\n          IsCustom   = 0b000010000_0000,\n          IsFunction = 0b000001000_0000,\n          IsEvent    = 0b000000100_0000,\n          IsProperty = 0b000000010_0000,\n          IsCommand  = 0b000000001_0000,\n  IsPropertyCommand  = 0b000000011_0000,\n     IsEventCommand  = 0b000000101_0000,\n  DelegationStrategyDelta =      0b0110,\n\n             Command =           0b1111,\n      OneTimeCommand = 0b000000011_0001,\n      ToViewCommand  = 0b000000011_0010,\n     FromViewCommand = 0b000000011_0011,\n       TwoWayCommand = 0b000000011_0100,\n         BindCommand = 0b000000011_0101,\n      TriggerCommand = 0b100000101_0110,\n      CaptureCommand = 0b100000101_0111,\n     DelegateCommand = 0b100000101_1000,\n         CallCommand = 0b000001001_1001,\n      OptionsCommand = 0b000000001_1010,\n          ForCommand = 0b000100001_1011,\n       CustomCommand = 0b000010001_1100\n}\n/* eslint-enable @typescript-eslint/indent */\n\n/** @internal */\nexport class ParserState {\n  public index: number = 0;\n  public startIndex: number = 0;\n  public lastIndex: number = 0;\n  public length: number;\n  public currentToken: Token = Token.EOF;\n  public tokenValue: string | number = '';\n  public currentChar: number;\n  public assignable: boolean = true;\n  public get tokenRaw(): string {\n    return this.input.slice(this.startIndex, this.index);\n  }\n\n  public constructor(\n    public input: string,\n  ) {\n    this.length = input.length;\n    this.currentChar = input.charCodeAt(0);\n  }\n}\n\nconst $state = new ParserState('');\n\n/** @internal */\nexport function parseExpression<TType extends BindingType = BindingType.BindCommand>(input: string, bindingType?: TType):\nTType extends BindingType.Interpolation ? Interpolation :\n  TType extends BindingType.ForCommand ? ForOfStatement :\n    IsBindingBehavior {\n\n  $state.input = input;\n  $state.length = input.length;\n  $state.index = 0;\n  $state.currentChar = input.charCodeAt(0);\n  return parse($state, Access.Reset, Precedence.Variadic, bindingType === void 0 ? BindingType.BindCommand : bindingType);\n}\n\n/** @internal */\n// This is performance-critical code which follows a subset of the well-known ES spec.\n// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the\n// single source of information for being able to figure it out.\n// It generally does not need to change unless the spec changes or spec violations are found, or optimization\n// opportunities are found (which would likely not fix these warnings in any case).\n// It's therefore not considered to have any tangible impact on the maintainability of the code base.\n// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions\n// eslint-disable-next-line max-lines-per-function\nexport function parse<TPrec extends Precedence, TType extends BindingType>(state: ParserState, access: Access, minPrecedence: TPrec, bindingType: TType):\nTPrec extends Precedence.Unary ? IsUnary :\n  TPrec extends Precedence.Binary ? IsBinary :\n    TPrec extends Precedence.LeftHandSide ? IsLeftHandSide :\n      TPrec extends Precedence.Assign ? IsAssign :\n        TPrec extends Precedence.Conditional ? IsConditional :\n          TPrec extends Precedence.Primary ? IsPrimary :\n            TPrec extends Precedence.Multiplicative ? IsBinary :\n              TPrec extends Precedence.Additive ? IsBinary :\n                TPrec extends Precedence.Relational ? IsBinary :\n                  TPrec extends Precedence.Equality ? IsBinary :\n                    TPrec extends Precedence.LogicalAND ? IsBinary :\n                      TPrec extends Precedence.LogicalOR ? IsBinary :\n                        TPrec extends Precedence.Variadic ?\n                          TType extends BindingType.Interpolation ? Interpolation :\n                            TType extends BindingType.ForCommand ? ForOfStatement :\n                              never : never {\n\n  if (bindingType === BindingType.CustomCommand) {\n    return new CustomExpression(state.input) as any;\n  }\n\n  if (state.index === 0) {\n    if (bindingType & BindingType.Interpolation) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return parseInterpolation(state) as any;\n    }\n    nextToken(state);\n    if (state.currentToken & Token.ExpressionTerminal) {\n      throw new Error(`Invalid start of expression: '${state.input}'`);\n    }\n  }\n\n  state.assignable = Precedence.Binary > minPrecedence;\n  let result = void 0 as unknown as IsExpressionOrStatement;\n\n  if (state.currentToken & Token.UnaryOp) {\n    /** parseUnaryExpression\n     * https://tc39.github.io/ecma262/#sec-unary-operators\n     *\n     * UnaryExpression :\n     * 1. LeftHandSideExpression\n     * 2. void UnaryExpression\n     * 3. typeof UnaryExpression\n     * 4. + UnaryExpression\n     * 5. - UnaryExpression\n     * 6. ! UnaryExpression\n     *\n     * IsValidAssignmentTarget\n     * 2,3,4,5,6 = false\n     * 1 = see parseLeftHandSideExpression\n     *\n     * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that\n     */\n    const op = TokenValues[state.currentToken & Token.Type] as UnaryOperator;\n    nextToken(state);\n    result = new UnaryExpression(op, parse(state, access, Precedence.LeftHandSide, bindingType));\n    state.assignable = false;\n  } else {\n    /** parsePrimaryExpression\n     * https://tc39.github.io/ecma262/#sec-primary-expression\n     *\n     * PrimaryExpression :\n     * 1. this\n     * 2. IdentifierName\n     * 3. Literal\n     * 4. ArrayLiteralExpression\n     * 5. ObjectLiteralExpression\n     * 6. TemplateLiteral\n     * 7. ParenthesizedExpression\n     *\n     * Literal :\n     * NullLiteral\n     * BooleanLiteral\n     * NumericLiteral\n     * StringLiteral\n     *\n     * ParenthesizedExpression :\n     * ( AssignmentExpression )\n     *\n     * IsValidAssignmentTarget\n     * 1,3,4,5,6,7 = false\n     * 2 = true\n     */\n    primary: switch (state.currentToken) {\n      case Token.ParentScope: // $parent\n        state.assignable = false;\n        do {\n          nextToken(state);\n          access++; // ancestor\n          if (consumeOpt(state, Token.Dot)) {\n            if ((state.currentToken as Token) === Token.Dot) {\n              throw new Error(`Double dot and spread operators are not supported: '${state.input}'`);\n            } else if ((state.currentToken as Token) === Token.EOF) {\n              throw new Error(`Expected identifier: '${state.input}'`);\n            }\n          } else if (state.currentToken & Token.AccessScopeTerminal) {\n            const ancestor = access & Access.Ancestor;\n            result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);\n            access = Access.This;\n            break primary;\n          } else {\n            throw new Error(`Invalid member expression: '${state.input}'`);\n          }\n        } while (state.currentToken === Token.ParentScope);\n        // falls through\n      case Token.Identifier: // identifier\n        if (bindingType & BindingType.IsIterator) {\n          result = new BindingIdentifier(state.tokenValue as string);\n        } else {\n          result = new AccessScopeExpression(state.tokenValue as string, access & Access.Ancestor);\n          access = Access.Scope;\n        }\n        state.assignable = true;\n        nextToken(state);\n        break;\n      case Token.ThisScope: // $this\n        state.assignable = false;\n        nextToken(state);\n        result = $this;\n        access = Access.This;\n        break;\n      case Token.OpenParen: // parenthesized expression\n        nextToken(state);\n        result = parse(state, Access.Reset, Precedence.Assign, bindingType);\n        consume(state, Token.CloseParen);\n        access = Access.Reset;\n        break;\n      case Token.OpenBracket:\n        result = parseArrayLiteralExpression(state, access, bindingType);\n        access = Access.Reset;\n        break;\n      case Token.OpenBrace:\n        result = parseObjectLiteralExpression(state, bindingType);\n        access = Access.Reset;\n        break;\n      case Token.TemplateTail:\n        result = new TemplateExpression([state.tokenValue as string]);\n        state.assignable = false;\n        nextToken(state);\n        access = Access.Reset;\n        break;\n      case Token.TemplateContinuation:\n        result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, false);\n        access = Access.Reset;\n        break;\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        result = new PrimitiveLiteralExpression(state.tokenValue);\n        state.assignable = false;\n        nextToken(state);\n        access = Access.Reset;\n        break;\n      case Token.NullKeyword:\n      case Token.UndefinedKeyword:\n      case Token.TrueKeyword:\n      case Token.FalseKeyword:\n        result = TokenValues[state.currentToken & Token.Type] as PrimitiveLiteralExpression;\n        state.assignable = false;\n        nextToken(state);\n        access = Access.Reset;\n        break;\n      default:\n        if (state.index >= state.length) {\n          throw new Error(`Unexpected end of expression: '${state.input}'`);\n        } else {\n          throw new Error(`Unconsumed token: '${state.input}'`);\n        }\n    }\n\n    if (bindingType & BindingType.IsIterator) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return parseForOfStatement(state, result as BindingIdentifierOrPattern) as any;\n    }\n    if (Precedence.LeftHandSide < minPrecedence) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return result as any;\n    }\n\n    /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n     * MemberExpression :\n     * 1. PrimaryExpression\n     * 2. MemberExpression [ AssignmentExpression ]\n     * 3. MemberExpression . IdentifierName\n     * 4. MemberExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     * 1,4 = false\n     * 2,3 = true\n     *\n     *\n     * parseCallExpression (Token.OpenParen)\n     * CallExpression :\n     * 1. MemberExpression Arguments\n     * 2. CallExpression Arguments\n     * 3. CallExpression [ AssignmentExpression ]\n     * 4. CallExpression . IdentifierName\n     * 5. CallExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     * 1,2,5 = false\n     * 3,4 = true\n     */\n    let name = state.tokenValue as string;\n    while ((state.currentToken & Token.LeftHandSide) > 0) {\n      const args: IsAssign[] = [];\n      let strings: string[];\n      switch ((state.currentToken as Token)) {\n        case Token.Dot:\n          state.assignable = true;\n          nextToken(state);\n          if ((state.currentToken & Token.IdentifierName) === 0) {\n            throw new Error(`Expected identifier: '${state.input}'`);\n          }\n          name = state.tokenValue as string;\n          nextToken(state);\n          // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags\n          access = ((access & (Access.This | Access.Scope)) << 1) | (access & Access.Member) | ((access & Access.Keyed) >> 1);\n          if ((state.currentToken as Token) === Token.OpenParen) {\n            if (access === Access.Reset) { // if the left hand side is a literal, make sure we parse a CallMemberExpression\n              access = Access.Member;\n            }\n            continue;\n          }\n          if (access & Access.Scope) {\n            result = new AccessScopeExpression(name, (result as AccessScopeExpression | AccessThisExpression).ancestor);\n          } else { // if it's not $Scope, it's $Member\n            result = new AccessMemberExpression(result as IsLeftHandSide, name);\n          }\n          continue;\n        case Token.OpenBracket:\n          state.assignable = true;\n          nextToken(state);\n          access = Access.Keyed;\n          result = new AccessKeyedExpression(result as IsLeftHandSide, parse(state, Access.Reset, Precedence.Assign, bindingType));\n          consume(state, Token.CloseBracket);\n          break;\n        case Token.OpenParen:\n          state.assignable = false;\n          nextToken(state);\n          while ((state.currentToken as Token) !== Token.CloseParen) {\n            args.push(parse(state, Access.Reset, Precedence.Assign, bindingType));\n            if (!consumeOpt(state, Token.Comma)) {\n              break;\n            }\n          }\n          consume(state, Token.CloseParen);\n          if (access & Access.Scope) {\n            result = new CallScopeExpression(name, args, (result as AccessScopeExpression | AccessThisExpression).ancestor);\n          } else if (access & Access.Member) {\n            result = new CallMemberExpression(result as IsLeftHandSide, name, args);\n          } else {\n            result = new CallFunctionExpression(result as IsLeftHandSide, args);\n          }\n          access = 0;\n          break;\n        case Token.TemplateTail:\n          state.assignable = false;\n          strings = [state.tokenValue as string];\n          result = new TaggedTemplateExpression(strings, strings, result as IsLeftHandSide);\n          nextToken(state);\n          break;\n        case Token.TemplateContinuation:\n          result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, true);\n        default:\n      }\n    }\n  }\n\n  if (Precedence.Binary < minPrecedence) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result as any;\n  }\n\n  /** parseBinaryExpression\n   * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n   *\n   * MultiplicativeExpression : (local precedence 6)\n   * UnaryExpression\n   * MultiplicativeExpression * / % UnaryExpression\n   *\n   * AdditiveExpression : (local precedence 5)\n   * MultiplicativeExpression\n   * AdditiveExpression + - MultiplicativeExpression\n   *\n   * RelationalExpression : (local precedence 4)\n   * AdditiveExpression\n   * RelationalExpression < > <= >= instanceof in AdditiveExpression\n   *\n   * EqualityExpression : (local precedence 3)\n   * RelationalExpression\n   * EqualityExpression == != === !== RelationalExpression\n   *\n   * LogicalANDExpression : (local precedence 2)\n   * EqualityExpression\n   * LogicalANDExpression && EqualityExpression\n   *\n   * LogicalORExpression : (local precedence 1)\n   * LogicalANDExpression\n   * LogicalORExpression || LogicalANDExpression\n   */\n  while ((state.currentToken & Token.BinaryOp) > 0) {\n    const opToken = state.currentToken;\n    if ((opToken & Token.Precedence) <= minPrecedence) {\n      break;\n    }\n    nextToken(state);\n    result = new BinaryExpression(TokenValues[opToken & Token.Type] as BinaryOperator, result as IsBinary, parse(state, access, opToken & Token.Precedence, bindingType));\n    state.assignable = false;\n  }\n  if (Precedence.Conditional < minPrecedence) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result as any;\n  }\n\n  /**\n   * parseConditionalExpression\n   * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n   *\n   * ConditionalExpression :\n   * 1. BinaryExpression\n   * 2. BinaryExpression ? AssignmentExpression : AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   * 1,2 = false\n   */\n\n  if (consumeOpt(state, Token.Question)) {\n    const yes = parse(state, access, Precedence.Assign, bindingType);\n    consume(state, Token.Colon);\n    result = new ConditionalExpression(result as IsBinary, yes, parse(state, access, Precedence.Assign, bindingType));\n    state.assignable = false;\n  }\n  if (Precedence.Assign < minPrecedence) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result as any;\n  }\n\n  /** parseAssignmentExpression\n   * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n   *\n   * AssignmentExpression :\n   * 1. ConditionalExpression\n   * 2. LeftHandSideExpression = AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   * 1,2 = false\n   */\n  if (consumeOpt(state, Token.Equals)) {\n    if (!state.assignable) {\n      throw new Error(`Left hand side of expression is not assignable: '${state.input}'`);\n    }\n    result = new AssignExpression(result as IsAssignable, parse(state, access, Precedence.Assign, bindingType));\n  }\n  if (Precedence.Variadic < minPrecedence) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return result as any;\n  }\n\n  /** parseValueConverter\n   */\n  while (consumeOpt(state, Token.Bar)) {\n    if (state.currentToken === Token.EOF) {\n      throw new Error(`Expected identifier to come after ValueConverter operator: '${state.input}'`);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new ValueConverterExpression(result as IsValueConverter, name, args);\n  }\n\n  /** parseBindingBehavior\n   */\n  while (consumeOpt(state, Token.Ampersand)) {\n    if (state.currentToken === Token.EOF) {\n      throw new Error(`Expected identifier to come after BindingBehavior operator: '${state.input}'`);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new BindingBehaviorExpression(result as IsBindingBehavior, name, args);\n  }\n  if (state.currentToken !== Token.EOF) {\n    if (bindingType & BindingType.Interpolation) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return result as any;\n    }\n    if (state.tokenRaw === 'of') {\n      throw new Error(`Unexpected keyword \"of\": '${state.input}'`);\n    }\n    throw new Error(`Unconsumed token: '${state.input}'`);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return result as any;\n}\n\n/**\n * parseArrayLiteralExpression\n * https://tc39.github.io/ecma262/#prod-ArrayLiteralExpression\n *\n * ArrayLiteralExpression :\n * [ Elision(opt) ]\n * [ ElementList ]\n * [ ElementList, Elision(opt) ]\n *\n * ElementList :\n * Elision(opt) AssignmentExpression\n * ElementList, Elision(opt) AssignmentExpression\n *\n * Elision :\n * ,\n * Elision ,\n */\nfunction parseArrayLiteralExpression(state: ParserState, access: Access, bindingType: BindingType): ArrayBindingPattern | ArrayLiteralExpression {\n  nextToken(state);\n  const elements = new Array<IsAssign>();\n  while (state.currentToken !== Token.CloseBracket) {\n    if (consumeOpt(state, Token.Comma)) {\n      elements.push($undefined);\n      if ((state.currentToken as Token) === Token.CloseBracket) {\n        break;\n      }\n    } else {\n      elements.push(parse(state, access, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      if (consumeOpt(state, Token.Comma)) {\n        if ((state.currentToken as Token) === Token.CloseBracket) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  consume(state, Token.CloseBracket);\n  if (bindingType & BindingType.IsIterator) {\n    return new ArrayBindingPattern(elements);\n  } else {\n    state.assignable = false;\n    return new ArrayLiteralExpression(elements);\n  }\n}\n\nfunction parseForOfStatement(state: ParserState, result: BindingIdentifierOrPattern): ForOfStatement {\n  if ((result.$kind & ExpressionKind.IsForDeclaration) === 0) {\n    throw new Error(`Invalid BindingIdentifier at left hand side of \"of\": '${state.input}'`);\n  }\n  if (state.currentToken !== Token.OfKeyword) {\n    throw new Error(`Invalid BindingIdentifier at left hand side of \"of\": '${state.input}'`);\n  }\n  nextToken(state);\n  const declaration = result;\n  const statement = parse(state, Access.Reset, Precedence.Variadic, BindingType.None);\n  return new ForOfStatement(declaration, statement as IsBindingBehavior);\n}\n\n/**\n * parseObjectLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * ObjectLiteralExpression :\n * { }\n * { PropertyDefinitionList }\n *\n * PropertyDefinitionList :\n * PropertyDefinition\n * PropertyDefinitionList, PropertyDefinition\n *\n * PropertyDefinition :\n * IdentifierName\n * PropertyName : AssignmentExpression\n *\n * PropertyName :\n * IdentifierName\n * StringLiteral\n * NumericLiteral\n */\nfunction parseObjectLiteralExpression(state: ParserState, bindingType: BindingType): ObjectBindingPattern | ObjectLiteralExpression {\n  const keys = new Array<string | number>();\n  const values = new Array<IsAssign>();\n  nextToken(state);\n  while (state.currentToken !== Token.CloseBrace) {\n    keys.push(state.tokenValue);\n    // Literal = mandatory colon\n    if (state.currentToken & Token.StringOrNumericLiteral) {\n      nextToken(state);\n      consume(state, Token.Colon);\n      values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n    } else if (state.currentToken & Token.IdentifierName) {\n      // IdentifierName = optional colon\n      const { currentChar, currentToken, index } = state;\n      nextToken(state);\n      if (consumeOpt(state, Token.Colon)) {\n        values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      } else {\n        // Shorthand\n        state.currentChar = currentChar;\n        state.currentToken = currentToken;\n        state.index = index;\n        values.push(parse(state, Access.Reset, Precedence.Primary, bindingType & ~BindingType.IsIterator));\n      }\n    } else {\n      throw new Error(`Invalid or unsupported property definition in object literal: '${state.input}'`);\n    }\n    if ((state.currentToken as Token) !== Token.CloseBrace) {\n      consume(state, Token.Comma);\n    }\n  }\n  consume(state, Token.CloseBrace);\n  if (bindingType & BindingType.IsIterator) {\n    return new ObjectBindingPattern(keys, values);\n  } else {\n    state.assignable = false;\n    return new ObjectLiteralExpression(keys, values);\n  }\n}\n\nfunction parseInterpolation(state: ParserState): Interpolation {\n  const parts = [];\n  const expressions: (IsBindingBehavior | Interpolation)[] = [];\n  const length = state.length;\n  let result = '';\n  while (state.index < length) {\n    switch (state.currentChar) {\n      case Char.Dollar:\n        if (state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n          parts.push(result);\n          result = '';\n\n          state.index += 2;\n          state.currentChar = state.input.charCodeAt(state.index);\n          nextToken(state);\n          const expression = parse(state, Access.Reset, Precedence.Variadic, BindingType.Interpolation);\n          expressions.push(expression);\n          continue;\n        } else {\n          result += '$';\n        }\n        break;\n      case Char.Backslash:\n        result += String.fromCharCode(unescapeCode(nextChar(state)));\n        break;\n      default:\n        result += String.fromCharCode(state.currentChar);\n    }\n    nextChar(state);\n  }\n  if (expressions.length) {\n    parts.push(result);\n    return new Interpolation(parts, expressions as IsBindingBehavior[]);\n  }\n  return null!;\n}\n\n/**\n * parseTemplateLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * TemplateExpression :\n * NoSubstitutionTemplate\n * TemplateHead\n *\n * NoSubstitutionTemplate :\n * ` TemplateCharacters(opt) `\n *\n * TemplateHead :\n * ` TemplateCharacters(opt) ${\n *\n * TemplateSubstitutionTail :\n * TemplateMiddle\n * TemplateTail\n *\n * TemplateMiddle :\n * } TemplateCharacters(opt) ${\n *\n * TemplateTail :\n * } TemplateCharacters(opt) `\n *\n * TemplateCharacters :\n * TemplateCharacter TemplateCharacters(opt)\n *\n * TemplateCharacter :\n * $ [lookahead ≠ {]\n * \\ EscapeSequence\n * SourceCharacter (but not one of ` or \\ or $)\n */\nfunction parseTemplate(state: ParserState, access: Access, bindingType: BindingType, result: IsLeftHandSide, tagged: boolean): TaggedTemplateExpression | TemplateExpression {\n  const cooked = [state.tokenValue as string];\n  // TODO: properly implement raw parts / decide whether we want this\n  consume(state, Token.TemplateContinuation);\n  const expressions = [parse(state, access, Precedence.Assign, bindingType)];\n  while ((state.currentToken = scanTemplateTail(state)) !== Token.TemplateTail) {\n    cooked.push(state.tokenValue as string);\n    consume(state, Token.TemplateContinuation);\n    expressions.push(parse(state, access, Precedence.Assign, bindingType));\n  }\n  cooked.push(state.tokenValue as string);\n  state.assignable = false;\n  if (tagged) {\n    nextToken(state);\n    return new TaggedTemplateExpression(cooked, cooked, result, expressions);\n  } else {\n    nextToken(state);\n    return new TemplateExpression(cooked, expressions);\n  }\n}\n\nfunction nextToken(state: ParserState): void {\n  while (state.index < state.length) {\n    state.startIndex = state.index;\n    if ((state.currentToken = (CharScanners[state.currentChar](state)) as Token) != null) { // a null token means the character must be skipped\n      return;\n    }\n  }\n  state.currentToken = Token.EOF;\n}\n\nfunction nextChar(state: ParserState): number {\n  return state.currentChar = state.input.charCodeAt(++state.index);\n}\n\nfunction scanIdentifier(state: ParserState): Token {\n  // run to the next non-idPart\n  while (IdParts[nextChar(state)]);\n\n  const token: Token|undefined = KeywordLookup[state.tokenValue = state.tokenRaw];\n  return token === undefined ? Token.Identifier : token;\n}\n\nfunction scanNumber(state: ParserState, isFloat: boolean): Token {\n  let char = state.currentChar;\n  if (isFloat === false) {\n    do {\n      char = nextChar(state);\n    } while (char <= Char.Nine && char >= Char.Zero);\n\n    if (char !== Char.Dot) {\n      state.tokenValue = parseInt(state.tokenRaw, 10);\n      return Token.NumericLiteral;\n    }\n    // past this point it's always a float\n    char = nextChar(state);\n    if (state.index >= state.length) {\n      // unless the number ends with a dot - that behaves a little different in native ES expressions\n      // but in our AST that behavior has no effect because numbers are always stored in variables\n      state.tokenValue = parseInt(state.tokenRaw.slice(0, -1), 10);\n      return Token.NumericLiteral;\n    }\n  }\n\n  if (char <= Char.Nine && char >= Char.Zero) {\n    do {\n      char = nextChar(state);\n    } while (char <= Char.Nine && char >= Char.Zero);\n  } else {\n    state.currentChar = state.input.charCodeAt(--state.index);\n  }\n\n  state.tokenValue = parseFloat(state.tokenRaw);\n  return Token.NumericLiteral;\n}\n\nfunction scanString(state: ParserState): Token {\n  const quote = state.currentChar;\n  nextChar(state); // Skip initial quote.\n\n  let unescaped = 0;\n  const buffer = new Array<string>();\n  let marker = state.index;\n\n  while (state.currentChar !== quote) {\n    if (state.currentChar === Char.Backslash) {\n      buffer.push(state.input.slice(marker, state.index));\n      nextChar(state);\n      unescaped = unescapeCode(state.currentChar);\n      nextChar(state);\n      buffer.push(String.fromCharCode(unescaped));\n      marker = state.index;\n    } else if (state.index >= state.length) {\n      throw new Error(`Unterminated quote in string literal: '${state.input}'`);\n    } else {\n      nextChar(state);\n    }\n  }\n\n  const last = state.input.slice(marker, state.index);\n  nextChar(state); // Skip terminating quote.\n\n  // Compute the unescaped string value.\n  buffer.push(last);\n  const unescapedStr = buffer.join('');\n\n  state.tokenValue = unescapedStr;\n  return Token.StringLiteral;\n}\n\nfunction scanTemplate(state: ParserState): Token {\n  let tail = true;\n  let result = '';\n\n  while (nextChar(state) !== Char.Backtick) {\n    if (state.currentChar === Char.Dollar) {\n      if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n        state.index++;\n        tail = false;\n        break;\n      } else {\n        result += '$';\n      }\n    } else if (state.currentChar === Char.Backslash) {\n      result += String.fromCharCode(unescapeCode(nextChar(state)));\n    } else {\n      if (state.index >= state.length) {\n        throw new Error(`Unterminated template string: '${state.input}'`);\n      }\n      result += String.fromCharCode(state.currentChar);\n    }\n  }\n\n  nextChar(state);\n  state.tokenValue = result;\n  if (tail) {\n    return Token.TemplateTail;\n  }\n  return Token.TemplateContinuation;\n}\n\nfunction scanTemplateTail(state: ParserState): Token {\n  if (state.index >= state.length) {\n    throw new Error(`Unterminated template string: '${state.input}'`);\n  }\n  state.index--;\n  return scanTemplate(state);\n}\n\nfunction consumeOpt(state: ParserState, token: Token): boolean {\n  if (state.currentToken === token) {\n    nextToken(state);\n    return true;\n  }\n\n  return false;\n}\n\nfunction consume(state: ParserState, token: Token): void {\n  if (state.currentToken === token) {\n    nextToken(state);\n  } else {\n    throw new Error(`Missing expected token: '${state.input}'`);\n  }\n}\n\n/**\n * Array for mapping tokens to token values. The indices of the values\n * correspond to the token bits 0-38.\n * For this to work properly, the values in the array must be kept in\n * the same order as the token bits.\n * Usage: TokenValues[token & Token.Type]\n */\nconst TokenValues = [\n  $false, $true, $null, $undefined, '$this', null/* '$host' */, '$parent',\n\n  '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\\'', '\"',\n\n  '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n  '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',\n  Token.TemplateTail, Token.TemplateContinuation,\n  'of'\n];\n\nconst KeywordLookup: {\n  [key: string]: Token;\n} = Object.create(null);\nKeywordLookup.true = Token.TrueKeyword;\nKeywordLookup.null = Token.NullKeyword;\nKeywordLookup.false = Token.FalseKeyword;\nKeywordLookup.undefined = Token.UndefinedKeyword;\nKeywordLookup.$this = Token.ThisScope;\nKeywordLookup.$parent = Token.ParentScope;\nKeywordLookup.in = Token.InKeyword;\nKeywordLookup.instanceof = Token.InstanceOfKeyword;\nKeywordLookup.typeof = Token.TypeofKeyword;\nKeywordLookup.void = Token.VoidKeyword;\nKeywordLookup.of = Token.OfKeyword;\n\n/**\n * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n * Single values are denoted by the second value being a 0\n *\n * Copied from output generated with \"node build/generate-unicode.js\"\n *\n * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n */\nconst codes = {\n  /* [$0-9A-Za_a-z] */\n  AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n  IdStart: /* IdentifierStart */[0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n  Digit: /* DecimalNumber */[0x30, 0x3A],\n  Skip: /* Skippable */[0, 0x21, 0x7F, 0xA1]\n};\n\n/**\n * Decompress the ranges into an array of numbers so that the char code\n * can be used as an index to the lookup\n */\nfunction decompress(lookup: (CharScanner | number)[] | null, $set: Set<number> | null, compressed: number[], value: CharScanner | number | boolean): void {\n  const rangeCount = compressed.length;\n  for (let i = 0; i < rangeCount; i += 2) {\n    const start = compressed[i];\n    let end = compressed[i + 1];\n    end = end > 0 ? end : start + 1;\n    if (lookup) {\n      lookup.fill(value as CharScanner | number, start, end);\n    }\n    if ($set) {\n      for (let ch = start; ch < end; ch++) {\n        $set.add(ch);\n      }\n    }\n  }\n}\n\n// CharFuncLookup functions\nfunction returnToken(token: Token): (s: ParserState) => Token {\n  return s => {\n    nextChar(s);\n    return token;\n  };\n}\nconst unexpectedCharacter: CharScanner = s => {\n  throw new Error(`Unexpected character: '${s.input}'`);\n};\nunexpectedCharacter.notMapped = true;\n\n// ASCII IdentifierPart lookup\nconst AsciiIdParts = new Set<number>();\ndecompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n\n// IdentifierPart lookup\nconst IdParts = new Uint8Array(0xFFFF);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ndecompress(IdParts as any, null, codes.IdStart, 1);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ndecompress(IdParts as any, null, codes.Digit, 1);\n\ntype CharScanner = ((p: ParserState) => Token | null) & { notMapped?: boolean };\n\n// Character scanning function lookup\nconst CharScanners = new Array<CharScanner>(0xFFFF);\nCharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n\ndecompress(CharScanners, null, codes.Skip, s => {\n  nextChar(s);\n  return null;\n});\ndecompress(CharScanners, null, codes.IdStart, scanIdentifier);\ndecompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));\n\nCharScanners[Char.DoubleQuote] =\nCharScanners[Char.SingleQuote] = s => {\n  return scanString(s);\n};\nCharScanners[Char.Backtick] = s => {\n  return scanTemplate(s);\n};\n\n// !, !=, !==\nCharScanners[Char.Exclamation] = s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Exclamation;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.ExclamationEquals;\n  }\n  nextChar(s);\n  return Token.ExclamationEqualsEquals;\n};\n\n// =, ==, ===\nCharScanners[Char.Equals] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Equals;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.EqualsEquals;\n  }\n  nextChar(s);\n  return Token.EqualsEqualsEquals;\n};\n\n// &, &&\nCharScanners[Char.Ampersand] = s => {\n  if (nextChar(s) !== Char.Ampersand) {\n    return Token.Ampersand;\n  }\n  nextChar(s);\n  return Token.AmpersandAmpersand;\n};\n\n// |, ||\nCharScanners[Char.Bar] = s => {\n  if (nextChar(s) !== Char.Bar) {\n    return Token.Bar;\n  }\n  nextChar(s);\n  return Token.BarBar;\n};\n\n// .\nCharScanners[Char.Dot] = s => {\n  if (nextChar(s) <= Char.Nine && s.currentChar >= Char.Zero) {\n    return scanNumber(s, true);\n  }\n  return Token.Dot;\n};\n\n// <, <=\nCharScanners[Char.LessThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.LessThan;\n  }\n  nextChar(s);\n  return Token.LessThanEquals;\n};\n\n// >, >=\nCharScanners[Char.GreaterThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.GreaterThan;\n  }\n  nextChar(s);\n  return Token.GreaterThanEquals;\n};\n\nCharScanners[Char.Percent]      = returnToken(Token.Percent);\nCharScanners[Char.OpenParen]    = returnToken(Token.OpenParen);\nCharScanners[Char.CloseParen]   = returnToken(Token.CloseParen);\nCharScanners[Char.Asterisk]     = returnToken(Token.Asterisk);\nCharScanners[Char.Plus]         = returnToken(Token.Plus);\nCharScanners[Char.Comma]        = returnToken(Token.Comma);\nCharScanners[Char.Minus]        = returnToken(Token.Minus);\nCharScanners[Char.Slash]        = returnToken(Token.Slash);\nCharScanners[Char.Colon]        = returnToken(Token.Colon);\nCharScanners[Char.Question]     = returnToken(Token.Question);\nCharScanners[Char.OpenBracket]  = returnToken(Token.OpenBracket);\nCharScanners[Char.CloseBracket] = returnToken(Token.CloseBracket);\nCharScanners[Char.OpenBrace]    = returnToken(Token.OpenBrace);\nCharScanners[Char.CloseBrace]   = returnToken(Token.CloseBrace);\n","import type { IConnectable } from '../observation.js';\n\n/**\n * Current subscription collector\n */\nlet _connectable: IConnectable | null = null;\nconst connectables: IConnectable[] = [];\n// eslint-disable-next-line\nexport let connecting = false;\n\n// todo: layer based collection pause/resume?\nexport function pauseConnecting() {\n  connecting = false;\n}\n\nexport function resumeConnecting() {\n  connecting = true;\n}\n\nexport function currentConnectable(): IConnectable | null {\n  return _connectable;\n}\n\nexport function enterConnectable(connectable: IConnectable): void {\n  if (connectable == null) {\n    throw new Error('Connectable cannot be null/undefined');\n  }\n  if (_connectable == null) {\n    _connectable = connectable;\n    connectables[0] = _connectable;\n    connecting = true;\n    return;\n  }\n  if (_connectable === connectable) {\n    throw new Error(`Trying to enter an active connectable`);\n  }\n  connectables.push(_connectable);\n  _connectable = connectable;\n  connecting = true;\n}\n\nexport function exitConnectable(connectable: IConnectable): void {\n  if (connectable == null) {\n    throw new Error('Connectable cannot be null/undefined');\n  }\n  if (_connectable !== connectable) {\n    throw new Error(`Trying to exit an unactive connectable`);\n  }\n\n  connectables.pop();\n  _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;\n  connecting = _connectable != null;\n}\n\nexport const ConnectableSwitcher = Object.freeze({\n  get current() {\n    return _connectable;\n  },\n  get connecting() {\n    return connecting;\n  },\n  enter: enterConnectable,\n  exit: exitConnectable,\n  pause: pauseConnecting,\n  resume: resumeConnecting,\n});\n","import { IIndexable } from '@aurelia/kernel';\nimport { connecting, currentConnectable } from './connectable-switcher.js';\n\nconst R$get = Reflect.get;\nconst toStringTag = Object.prototype.toString;\nconst proxyMap = new WeakMap<object, object>();\n\nfunction canWrap(obj: unknown): obj is object {\n  switch (toStringTag.call(obj)) {\n    case '[object Object]':\n    case '[object Array]':\n    case '[object Map]':\n    case '[object Set]':\n    // it's unlikely that methods on the following 2 objects need to be observed for changes\n    // so while they are valid/ we don't wrap them either\n    // case '[object Math]':\n    // case '[object Reflect]':\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport const rawKey = '__raw__';\n\nexport function wrap<T extends unknown>(v: T): T {\n  return canWrap(v) ? getProxy(v) : v;\n}\nexport function getProxy<T extends object>(obj: T): T {\n  // deepscan-disable-next-line\n  return proxyMap.get(obj) as T ?? createProxy(obj);\n}\n\nexport function getRaw<T extends object>(obj: T): T {\n  // todo: get in a weakmap if null/undef\n  return (obj as IIndexable)[rawKey] as T ?? obj;\n}\nexport function unwrap<T extends unknown>(v: T): T {\n  return canWrap(v) && (v as IIndexable)[rawKey] as T || v;\n}\n\nfunction doNotCollect(key: PropertyKey): boolean {\n  return key === 'constructor'\n    || key === '__proto__'\n    // probably should revert to v1 naming style for consistency with builtin?\n    // __o__ is shorters & less chance of conflict with other libs as well\n    || key === '$observers'\n    || key === Symbol.toPrimitive\n    || key === Symbol.toStringTag;\n}\n\nfunction createProxy<T extends object>(obj: T): T {\n  const handler: ProxyHandler<object> = obj instanceof Array\n    ? arrayHandler\n    : obj instanceof Map || obj instanceof Set\n      ? collectionHandler\n      : objectHandler;\n\n  const proxiedObj = new Proxy(obj, handler);\n  proxyMap.set(obj, proxiedObj);\n\n  return proxiedObj as T;\n}\n\nconst objectHandler: ProxyHandler<object> = {\n  get(target: IIndexable, key: PropertyKey, receiver: object): unknown {\n    // maybe use symbol?\n    if (key === rawKey) {\n      return target;\n    }\n\n    const connectable = currentConnectable();\n\n    if (!connecting || doNotCollect(key) || connectable == null) {\n      return R$get(target, key, receiver);\n    }\n\n    // todo: static\n    connectable.observeProperty(target, key);\n\n    return wrap(R$get(target, key, receiver));\n  },\n};\n\nconst arrayHandler: ProxyHandler<unknown[]> = {\n  get(target: unknown[], key: PropertyKey, receiver: unknown): unknown {\n    // maybe use symbol?\n    if (key === rawKey) {\n      return target;\n    }\n\n    const connectable = currentConnectable();\n\n    if (!connecting || doNotCollect(key) || connectable == null) {\n      return R$get(target, key, receiver);\n    }\n\n    switch (key) {\n      case 'length':\n        connectable.observeProperty(target, 'length');\n        return target.length;\n      case 'map':\n        return wrappedArrayMap;\n      case 'includes':\n        return wrappedArrayIncludes;\n      case 'indexOf':\n        return wrappedArrayIndexOf;\n      case 'lastIndexOf':\n        return wrappedArrayLastIndexOf;\n      case 'every':\n        return wrappedArrayEvery;\n      case 'filter':\n        return wrappedArrayFilter;\n      case 'find':\n        return wrappedArrayFind;\n      case 'findIndex':\n        return wrappedArrayFindIndex;\n      case 'flat':\n        return wrappedArrayFlat;\n      case 'flatMap':\n        return wrappedArrayFlatMap;\n      case 'join':\n        return wrappedArrayJoin;\n      case 'push':\n        return wrappedArrayPush;\n      case 'pop':\n        return wrappedArrayPop;\n      case 'reduce':\n        return wrappedReduce;\n      case 'reduceRight':\n        return wrappedReduceRight;\n      case 'reverse':\n        return wrappedArrayReverse;\n      case 'shift':\n        return wrappedArrayShift;\n      case 'unshift':\n        return wrappedArrayUnshift;\n      case 'slice':\n        return wrappedArraySlice;\n      case 'splice':\n        return wrappedArraySplice;\n      case 'some':\n        return wrappedArraySome;\n      case 'sort':\n        return wrappedArraySort;\n      case 'keys':\n        return wrappedKeys;\n      case 'values':\n      case Symbol.iterator:\n        return wrappedValues;\n      case 'entries':\n        return wrappedEntries;\n    }\n\n    connectable.observeProperty(target, key);\n\n    return wrap(R$get(target, key, receiver));\n  },\n  // for (let i in array) ...\n  ownKeys(target: unknown[]): (string | symbol)[] {\n    currentConnectable()?.observeProperty(target, 'length');\n    return Reflect.ownKeys(target) as (string | symbol)[];\n  },\n};\n\nfunction wrappedArrayMap(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => unknown, thisArg?: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.map((v, i) =>\n    // do we wrap `thisArg`?\n    unwrap(cb.call(thisArg, wrap(v), i, this))\n  );\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\nfunction wrappedArrayEvery(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => unknown, thisArg?: unknown): boolean {\n  const raw = getRaw(this);\n  const res = raw.every((v, i) => cb.call(thisArg, wrap(v), i, this));\n  currentConnectable()?.observeCollection(raw);\n  return res;\n}\n\nfunction wrappedArrayFilter(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): unknown[] {\n  const raw = getRaw(this);\n  const res = raw.filter((v, i) =>\n    // do we wrap `thisArg`?\n    unwrap(cb.call(thisArg, wrap(v), i, this))\n  );\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\nfunction wrappedArrayIncludes(this: unknown[], v: unknown): boolean {\n  const raw = getRaw(this);\n  const res = raw.includes(unwrap(v));\n  currentConnectable()?.observeCollection(raw);\n  return res;\n}\n\nfunction wrappedArrayIndexOf(this: unknown[], v: unknown): number {\n  const raw = getRaw(this);\n  const res = raw.indexOf(unwrap(v));\n  currentConnectable()?.observeCollection(raw);\n  return res;\n}\nfunction wrappedArrayLastIndexOf(this: unknown[], v: unknown): number {\n  const raw = getRaw(this);\n  const res = raw.lastIndexOf(unwrap(v));\n  currentConnectable()?.observeCollection(raw);\n  return res;\n}\nfunction wrappedArrayFindIndex(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): number {\n  const raw = getRaw(this);\n  const res = raw.findIndex((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));\n  currentConnectable()?.observeCollection(raw);\n  return res;\n}\n\nfunction wrappedArrayFind(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.find((v, i) => cb(wrap(v), i, this), thisArg);\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\nfunction wrappedArrayFlat(this: unknown[]): unknown[] {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return wrap(raw.flat());\n}\nfunction wrappedArrayFlatMap(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => unknown, thisArg?: unknown): unknown[] {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return getProxy(raw.flatMap((v, i) =>\n    wrap(cb.call(thisArg, wrap(v), i, this)))\n  );\n}\nfunction wrappedArrayJoin(this: unknown[], separator?: string): string {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return raw.join(separator);\n}\n\nfunction wrappedArrayPop(this: unknown[]): unknown {\n  return wrap(getRaw(this).pop());\n}\nfunction wrappedArrayPush(this: unknown[], ...args: unknown[]): number {\n  return getRaw(this).push(...args);\n}\nfunction wrappedArrayShift(this: unknown[]): unknown {\n  return wrap(getRaw(this).shift());\n}\nfunction wrappedArrayUnshift(this: unknown[], ...args: unknown[]): unknown {\n  return getRaw(this).unshift(...args);\n}\nfunction wrappedArraySplice(this: unknown[], ...args: [number, number, ...unknown[]]): unknown {\n  return wrap(getRaw(this).splice(...args));\n}\nfunction wrappedArrayReverse(this: unknown[], ...args: unknown[]): unknown[] {\n  const raw = getRaw(this);\n  const res = raw.reverse();\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\nfunction wrappedArraySome(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): boolean {\n  const raw = getRaw(this);\n  const res = raw.some((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));\n  currentConnectable()?.observeCollection(raw);\n  return res;\n}\n\nfunction wrappedArraySort(this: unknown[], cb?: (a: unknown, b: unknown) => number): unknown[] {\n  const raw = getRaw(this);\n  const res = raw.sort(cb);\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\nfunction wrappedArraySlice(this: unknown[], start?: number, end?: number): unknown[] {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return getProxy(raw.slice(start, end));\n}\n\nfunction wrappedReduce(this: unknown[], cb: (curr: unknown, v: unknown, i: number, arr: unknown[]) => unknown, initValue: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.reduce((curr, v, i) => cb(curr, wrap(v), i, this), initValue);\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\nfunction wrappedReduceRight(this: unknown[], cb: (curr: unknown, v: unknown, i: number, arr: unknown[]) => unknown, initValue: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.reduceRight((curr, v, i) => cb(curr, wrap(v), i, this), initValue);\n  currentConnectable()?.observeCollection(raw);\n  return wrap(res);\n}\n\n// the below logic takes inspiration from Vue, Mobx\n// much thanks to them for working out this\nconst collectionHandler: ProxyHandler<$MapOrSet> = {\n  get(target: $MapOrSet, key: PropertyKey, receiver?): unknown {\n    // maybe use symbol?\n    if (key === rawKey) {\n      return target;\n    }\n\n    const connectable = currentConnectable();\n\n    if (!connecting || doNotCollect(key) || connectable == null) {\n      return R$get(target, key, receiver);\n    }\n\n    switch (key) {\n      case 'size':\n        connectable.observeProperty(target, 'size');\n        return target.size;\n      case 'clear':\n        return wrappedClear;\n      case 'delete':\n        return wrappedDelete;\n      case 'forEach':\n        return wrappedForEach;\n      case 'add':\n        if (target instanceof Set) {\n          return wrappedAdd;\n        }\n        break;\n      case 'get':\n        if (target instanceof Map) {\n          return wrappedGet;\n        }\n        break;\n      case 'set':\n        if (target instanceof Map) {\n          return wrappedSet;\n        }\n        break;\n      case 'has':\n        return wrappedHas;\n      case 'keys':\n        return wrappedKeys;\n      case 'values':\n        return wrappedValues;\n      case 'entries':\n        return wrappedEntries;\n      case Symbol.iterator:\n        return target instanceof Map ? wrappedEntries : wrappedValues;\n    }\n\n    return wrap(R$get(target, key, receiver));\n  },\n};\n\ntype $MapOrSet = Map<unknown, unknown> | Set<unknown>;\ntype CollectionMethod = (this: unknown, ...args: unknown[]) => unknown;\n\nfunction wrappedForEach(this: $MapOrSet, cb: CollectionMethod, thisArg?: unknown): void {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return raw.forEach((v: unknown, key: unknown) => {\n    cb.call(/* should wrap or not?? */thisArg, wrap(v), wrap(key), this);\n  });\n}\n\nfunction wrappedHas(this: $MapOrSet, v: unknown): boolean {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return raw.has(unwrap(v));\n}\n\nfunction wrappedGet(this: Map<unknown, unknown>, k: unknown): unknown {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  return wrap(raw.get(unwrap(k)));\n}\nfunction wrappedSet(this: Map<unknown, unknown>, k: unknown, v: unknown): Map<unknown, unknown> {\n  return wrap(getRaw(this).set(unwrap(k), unwrap(v)));\n}\n\nfunction wrappedAdd(this: Set<unknown>, v: unknown): Set<unknown> {\n  return wrap(getRaw(this).add(unwrap(v)));\n}\n\nfunction wrappedClear(this: $MapOrSet): void {\n  return wrap(getRaw(this).clear());\n}\n\nfunction wrappedDelete(this: $MapOrSet, k: unknown): boolean {\n  return wrap(getRaw(this).delete(unwrap(k)));\n}\n\nfunction wrappedKeys(this: $MapOrSet | unknown[]): IterableIterator<unknown> {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  const iterator = raw.keys();\n\n  return {\n    next(): IteratorResult<unknown, unknown> {\n      const next = iterator.next();\n      const value = next.value;\n      const done = next.done;\n\n      return done\n        ? { value: void 0, done }\n        : { value: wrap(value), done };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nfunction wrappedValues(this: $MapOrSet | unknown[]): IterableIterator<unknown> {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  const iterator = raw.values();\n\n  return {\n    next(): IteratorResult<unknown, unknown> {\n      const next = iterator.next();\n      const value = next.value;\n      const done = next.done;\n\n      return done\n        ? { value: void 0, done }\n        : { value: wrap(value), done };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nfunction wrappedEntries(this: $MapOrSet | unknown[]): IterableIterator<unknown> {\n  const raw = getRaw(this);\n  currentConnectable()?.observeCollection(raw);\n  const iterator = raw.entries();\n\n  // return a wrapped iterator which returns observed versions of the\n  // values emitted from the real iterator\n  return {\n    next(): IteratorResult<unknown, unknown> {\n      const next = iterator.next();\n      const value = next.value;\n      const done = next.done;\n\n      return done\n        ? { value: void 0, done }\n        : { value: [wrap(value[0]), wrap(value[1])], done };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nexport const ProxyObservable = Object.freeze({\n  getProxy,\n  getRaw,\n  wrap,\n  unwrap,\n  rawKey,\n});\n","import {\n  LifecycleFlags,\n  AccessorType,\n} from '../observation.js';\nimport { subscriberCollection } from './subscriber-collection.js';\nimport { enterConnectable, exitConnectable } from './connectable-switcher.js';\nimport { connectable } from '../binding/connectable.js';\nimport { wrap, unwrap } from './proxy-observation.js';\nimport { def } from '../utilities-objects.js';\nimport { withFlushQueue } from './flush-queue.js';\n\nimport type {\n  ISubscriber,\n  ICollectionSubscriber,\n  ISubscriberCollection,\n  IConnectable,\n} from '../observation.js';\nimport type { IConnectableBinding } from '../binding/connectable.js';\nimport type { IObserverLocator, ObservableGetter } from './observer-locator.js';\nimport type { FlushQueue, IFlushable, IWithFlushQueue } from './flush-queue.js';\n\nexport interface ComputedObserver extends IConnectableBinding, ISubscriberCollection { }\n\nexport class ComputedObserver implements\n  IConnectableBinding,\n  ISubscriber,\n  ICollectionSubscriber,\n  ISubscriberCollection,\n  IWithFlushQueue,\n  IFlushable {\n  public static create(\n    obj: object,\n    key: PropertyKey,\n    descriptor: PropertyDescriptor,\n    observerLocator: IObserverLocator,\n    useProxy: boolean,\n  ): ComputedObserver {\n    const getter = descriptor.get!;\n    const setter = descriptor.set;\n    const observer = new ComputedObserver(obj, getter, setter, useProxy, observerLocator);\n    const $get = ((/* Computed Observer */) => observer.getValue()) as ObservableGetter;\n    $get.getObserver = () => observer;\n    def(obj, key, {\n      enumerable: descriptor.enumerable,\n      configurable: true,\n      get: $get,\n      set: (/* Computed Observer */v) => {\n        observer.setValue(v, LifecycleFlags.none);\n      },\n    });\n\n    return observer;\n  }\n\n  public interceptor = this;\n\n  public type: AccessorType = AccessorType.Observer;\n  public readonly queue!: FlushQueue;\n\n  public value: unknown = void 0;\n  private oldValue: unknown = void 0;\n\n  // todo: maybe use a counter allow recursive call to a certain level\n  /**\n   * @internal\n   */\n  private running: boolean = false;\n\n  private isDirty: boolean = false;\n\n  public constructor(\n    public readonly obj: object,\n    public readonly get: (watcher: IConnectable) => unknown,\n    public readonly set: undefined | ((v: unknown) => void),\n    public readonly useProxy: boolean,\n    public readonly observerLocator: IObserverLocator,\n  ) {\n  }\n\n  public getValue() {\n    if (this.subs.count === 0) {\n      return this.get.call(this.obj, this);\n    }\n    if (this.isDirty) {\n      this.compute();\n      this.isDirty = false;\n    }\n    return this.value;\n  }\n\n  // deepscan-disable-next-line\n  public setValue(v: unknown, _flags: LifecycleFlags): void {\n    if (typeof this.set === 'function') {\n      if (v !== this.value) {\n        // setting running true as a form of batching\n        this.running = true;\n        this.set.call(this.obj, v);\n        this.running = false;\n\n        this.run();\n      }\n    } else {\n      throw new Error('Property is readonly');\n    }\n  }\n\n  public handleChange(): void {\n    this.isDirty = true;\n    if (this.subs.count > 0) {\n      this.run();\n    }\n  }\n\n  public handleCollectionChange(): void {\n    this.isDirty = true;\n    if (this.subs.count > 0) {\n      this.run();\n    }\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    // in theory, a collection subscriber could be added before a property subscriber\n    // and it should be handled similarly in subscribeToCollection\n    // though not handling for now, and wait until the merge of normal + collection subscription\n    if (this.subs.add(subscriber) && this.subs.count === 1) {\n      this.compute();\n      this.isDirty = false;\n    }\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    if (this.subs.remove(subscriber) && this.subs.count === 0) {\n      this.isDirty = true;\n      this.obs.clear(true);\n    }\n  }\n\n  public flush(): void {\n    oV = this.oldValue;\n    this.oldValue = this.value;\n    this.subs.notify(this.value, oV, LifecycleFlags.none);\n  }\n\n  private run(): void {\n    if (this.running) {\n      return;\n    }\n    const oldValue = this.value;\n    const newValue = this.compute();\n\n    this.isDirty = false;\n\n    if (!Object.is(newValue, oldValue)) {\n      this.oldValue = oldValue;\n      this.queue.add(this);\n    }\n  }\n\n  private compute(): unknown {\n    this.running = true;\n    this.obs.version++;\n    try {\n      enterConnectable(this);\n      return this.value = unwrap(this.get.call(this.useProxy ? wrap(this.obj) : this.obj, this));\n    } finally {\n      this.obs.clear(false);\n      this.running = false;\n      exitConnectable(this);\n    }\n  }\n}\n\nconnectable(ComputedObserver);\nsubscriberCollection(ComputedObserver);\nwithFlushQueue(ComputedObserver);\n\n// a reusable variable for `.flush()` methods of observers\n// so that there doesn't need to create an env record for every call\nlet oV: unknown = void 0;\n","import { DI, IPlatform } from '@aurelia/kernel';\nimport { AccessorType, IObserver, ISubscriberCollection, LifecycleFlags } from '../observation.js';\nimport { subscriberCollection } from './subscriber-collection.js';\n\nimport type { IIndexable, ITask, QueueTaskOptions } from '@aurelia/kernel';\nimport type { IObservable, ISubscriber } from '../observation';\nimport { FlushQueue, IFlushable, IWithFlushQueue, withFlushQueue } from './flush-queue.js';\n\nexport interface IDirtyChecker extends DirtyChecker {}\nexport const IDirtyChecker = DI.createInterface<IDirtyChecker>('IDirtyChecker', x => x.singleton(DirtyChecker));\n\nexport const DirtyCheckSettings = {\n  /**\n   * Default: `6`\n   *\n   * Adjust the global dirty check frequency.\n   * Measures in \"timeouts per check\", such that (given a default of 250 timeouts per second in modern browsers):\n   * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)\n   * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)\n   */\n  timeoutsPerCheck: 25,\n  /**\n   * Default: `false`\n   *\n   * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking\n   * or an adapter, will simply not be observed.\n   */\n  disabled: false,\n  /**\n   * Default: `false`\n   *\n   * Throw an error if a property is being dirty-checked.\n   */\n  throw: false,\n  /**\n   * Resets all dirty checking settings to the framework's defaults.\n   */\n  resetToDefault(): void {\n    this.timeoutsPerCheck = 6;\n    this.disabled = false;\n    this.throw = false;\n  }\n};\n\nconst queueTaskOpts: QueueTaskOptions = {\n  persistent: true,\n};\n\nexport class DirtyChecker implements IWithFlushQueue {\n  /**\n   * @internal\n   */\n  public static inject = [IPlatform];\n  public readonly queue!: FlushQueue;\n  private readonly tracked: DirtyCheckProperty[] = [];\n\n  private task: ITask | null = null;\n  private elapsedFrames: number = 0;\n\n  public constructor(\n    private readonly platform: IPlatform,\n  ) {}\n\n  public createProperty(obj: object, propertyName: string): DirtyCheckProperty {\n    if (DirtyCheckSettings.throw) {\n      throw new Error(`Property '${propertyName}' is being dirty-checked.`);\n    }\n    return new DirtyCheckProperty(this, obj as IIndexable, propertyName);\n  }\n\n  public addProperty(property: DirtyCheckProperty): void {\n    this.tracked.push(property);\n\n    if (this.tracked.length === 1) {\n      this.task = this.platform.taskQueue.queueTask(this.check, queueTaskOpts);\n    }\n  }\n\n  public removeProperty(property: DirtyCheckProperty): void {\n    this.tracked.splice(this.tracked.indexOf(property), 1);\n    if (this.tracked.length === 0) {\n      this.task!.cancel();\n      this.task = null;\n    }\n  }\n\n  private readonly check = () => {\n    if (DirtyCheckSettings.disabled) {\n      return;\n    }\n    if (++this.elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {\n      return;\n    }\n    this.elapsedFrames = 0;\n    const tracked = this.tracked;\n    const len = tracked.length;\n    let current: DirtyCheckProperty;\n    let i = 0;\n    for (; i < len; ++i) {\n      current = tracked[i];\n      if (current.isDirty()) {\n        this.queue.add(current);\n      }\n    }\n  };\n}\n\nwithFlushQueue(DirtyChecker);\n\nexport interface DirtyCheckProperty extends IObserver, ISubscriberCollection { }\n\nexport class DirtyCheckProperty implements DirtyCheckProperty, IFlushable {\n  public oldValue: unknown = void 0;\n  public type: AccessorType = AccessorType.None;\n\n  public constructor(\n    private readonly dirtyChecker: IDirtyChecker,\n    public obj: IObservable & IIndexable,\n    public propertyKey: string,\n  ) {}\n\n  public getValue() {\n    return this.obj[this.propertyKey];\n  }\n\n  public setValue(v: unknown, f: LifecycleFlags) {\n    // todo: this should be allowed, probably\n    // but the construction of dirty checker should throw instead\n    throw new Error(`Trying to set value for property ${this.propertyKey} in dirty checker`);\n  }\n\n  public isDirty(): boolean {\n    return this.oldValue !== this.obj[this.propertyKey];\n  }\n\n  public flush(): void {\n    const oldValue = this.oldValue;\n    const newValue = this.getValue();\n\n    this.oldValue = newValue;\n    this.subs.notify(newValue, oldValue, LifecycleFlags.none);\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this.subs.add(subscriber) && this.subs.count === 1) {\n      this.oldValue = this.obj[this.propertyKey];\n      this.dirtyChecker.addProperty(this);\n    }\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    if (this.subs.remove(subscriber) && this.subs.count === 0) {\n      this.dirtyChecker.removeProperty(this);\n    }\n  }\n}\n\nsubscriberCollection(DirtyCheckProperty);\n","import { Primitive } from '@aurelia/kernel';\nimport { AccessorType } from '../observation.js';\n\nimport type { IAccessor, ISubscribable } from '../observation.js';\n\nexport class PrimitiveObserver implements IAccessor, ISubscribable {\n  public get doNotCache(): true { return true; }\n  public type: AccessorType = AccessorType.None;\n\n  public constructor(\n    public readonly obj: Primitive,\n    public readonly propertyKey: PropertyKey,\n  ) {}\n\n  public getValue(): unknown {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any\n    return (this.obj as any)[this.propertyKey];\n  }\n  public setValue(): void { /* do nothing */ }\n  public subscribe(): void { /* do nothing */ }\n  public unsubscribe(): void { /* do nothing */ }\n}\n","import { AccessorType, LifecycleFlags } from '../observation.js';\nimport type { IAccessor, IObservable } from '../observation.js';\n\nexport class PropertyAccessor implements IAccessor {\n  // the only thing can be guaranteed is it's an object\n  // even if this property accessor is used to access an element\n  public type: AccessorType = AccessorType.None;\n\n  public getValue(obj: object, key: string): unknown {\n    return (obj as IObservable)[key];\n  }\n\n  public setValue(value: unknown, flags: LifecycleFlags, obj: object, key: string): void {\n    (obj as IObservable)[key] = value;\n  }\n}\n","import { AccessorType, LifecycleFlags } from '../observation.js';\nimport { subscriberCollection } from './subscriber-collection.js';\nimport { def } from '../utilities-objects.js';\n\nimport type { IIndexable } from '@aurelia/kernel';\nimport type {\n  IAccessor,\n  InterceptorFunc,\n  ISubscriber,\n  ISubscriberCollection,\n} from '../observation.js';\nimport { FlushQueue, IFlushable, IWithFlushQueue, withFlushQueue } from './flush-queue.js';\n\n// a reusable variable for `.flush()` methods of observers\n// so that there doesn't need to create an env record for every call\nlet oV: unknown = void 0;\n\nexport interface SetterObserver extends IAccessor, ISubscriberCollection {}\n\n/**\n * Observer for the mutation of object property value employing getter-setter strategy.\n * This is used for observing object properties that has no decorator.\n */\nexport class SetterObserver implements IWithFlushQueue, IFlushable {\n  public value: unknown = void 0;\n  public oldValue: unknown = void 0;\n\n  public observing: boolean = false;\n  // todo(bigopon): tweak the flag based on typeof obj (array/set/map/iterator/proxy etc...)\n  public type: AccessorType = AccessorType.Observer;\n  public readonly queue!: FlushQueue;\n\n  private f: LifecycleFlags = LifecycleFlags.none;\n\n  public constructor(\n    public readonly obj: IIndexable,\n    public readonly propertyKey: string,\n  ) {\n  }\n\n  public getValue(): unknown {\n    return this.value;\n  }\n\n  public setValue(newValue: unknown, flags: LifecycleFlags): void {\n    if (this.observing) {\n      const value = this.value;\n      if (Object.is(newValue, value)) {\n        return;\n      }\n      this.value = newValue;\n      this.oldValue = value;\n      this.f = flags;\n      this.queue.add(this);\n    } else {\n      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n      // so calling obj[propertyKey] will actually return this.value.\n      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n      // is unmodified and we need to explicitly set the property value.\n      // This will happen in one-time, to-view and two-way bindings during $bind, meaning that the $bind will not actually update the target value.\n      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether $bind updated the target or not.\n      this.obj[this.propertyKey] = newValue;\n    }\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this.observing === false) {\n      this.start();\n    }\n\n    this.subs.add(subscriber);\n  }\n\n  public flush(): void {\n    oV = this.oldValue;\n    this.oldValue = this.value;\n    this.subs.notify(this.value, oV, this.f);\n  }\n\n  public start(): this {\n    if (this.observing === false) {\n      this.observing = true;\n      this.value = this.obj[this.propertyKey];\n      def(\n        this.obj,\n        this.propertyKey,\n        {\n          enumerable: true,\n          configurable: true,\n          get: (/* Setter Observer */) => this.getValue(),\n          set: (/* Setter Observer */value) => {\n            this.setValue(value, LifecycleFlags.none);\n          },\n        },\n      );\n    }\n    return this;\n  }\n\n  public stop(): this {\n    if (this.observing) {\n      def(this.obj, this.propertyKey, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: this.value,\n      });\n      this.observing = false;\n      // todo(bigopon/fred): add .removeAllSubscribers()\n    }\n    return this;\n  }\n}\n\ntype ChangeHandlerCallback = (this: object, value: unknown, oldValue: unknown, flags: LifecycleFlags) => void;\n\nexport interface SetterNotifier extends IAccessor, ISubscriberCollection {}\n\nexport class SetterNotifier implements IAccessor, IWithFlushQueue, IFlushable {\n  public readonly type: AccessorType = AccessorType.Observer;\n  public readonly queue!: FlushQueue;\n\n  /**\n   * @internal\n   */\n  private v: unknown = void 0;\n  /**\n   * @internal\n   */\n  private oV: unknown = void 0;\n  /**\n   * @internal\n   */\n  private f: LifecycleFlags = LifecycleFlags.none;\n  /**\n   * @internal\n   */\n  private readonly cb?: ChangeHandlerCallback;\n  /**\n   * @internal\n   */\n  private readonly obj: object;\n  /**\n   * @internal\n   */\n  private readonly s: InterceptorFunc | undefined;\n\n  public constructor(\n    obj: object,\n    callbackKey: PropertyKey,\n    set: InterceptorFunc | undefined,\n    initialValue: unknown,\n  ) {\n    this.obj = obj;\n    this.s = set;\n    const callback = (obj as IIndexable)[callbackKey as string];\n    this.cb = typeof callback === 'function' ? callback as ChangeHandlerCallback : void 0;\n    this.v = initialValue;\n  }\n\n  public getValue(): unknown {\n    return this.v;\n  }\n\n  public setValue(value: unknown, flags: LifecycleFlags): void {\n    if (typeof this.s === 'function') {\n      value = this.s(value);\n    }\n    if (!Object.is(value, this.v)) {\n      this.oV = this.v;\n      this.v = value;\n      this.f = flags;\n      this.cb?.call(this.obj, this.v, this.oV, flags);\n      this.queue.add(this);\n    }\n  }\n\n  public flush(): void {\n    oV = this.oV;\n    this.oV = this.v;\n    this.subs.notify(this.v, oV, this.f);\n  }\n}\n\nsubscriberCollection(SetterObserver);\nsubscriberCollection(SetterNotifier);\nwithFlushQueue(SetterObserver);\nwithFlushQueue(SetterNotifier);\n","import { DI, Primitive, isArrayIndex, ILogger } from '@aurelia/kernel';\nimport { getArrayObserver } from './array-observer.js';\nimport { ComputedObserver } from './computed-observer.js';\nimport { IDirtyChecker } from './dirty-checker.js';\nimport { getMapObserver } from './map-observer.js';\nimport { PrimitiveObserver } from './primitive-observer.js';\nimport { PropertyAccessor } from './property-accessor.js';\nimport { getSetObserver } from './set-observer.js';\nimport { SetterObserver } from './setter-observer.js';\nimport { def } from '../utilities-objects.js';\n\nimport type {\n  Collection,\n  IAccessor,\n  ICollectionObserver,\n  IObservable,\n  IObserver,\n  AccessorOrObserver,\n  CollectionKind,\n  CollectionObserver,\n} from '../observation.js';\n\nexport const propertyAccessor = new PropertyAccessor();\n\nexport interface IObjectObservationAdapter {\n  getObserver(object: unknown, propertyName: string, descriptor: PropertyDescriptor, requestor: IObserverLocator): AccessorOrObserver | null;\n}\n\nexport interface IObserverLocator extends ObserverLocator {}\nexport const IObserverLocator = DI.createInterface<IObserverLocator>('IObserverLocator', x => x.singleton(ObserverLocator));\n\nexport interface INodeObserverLocator {\n  handles(obj: unknown, key: PropertyKey, requestor: IObserverLocator): boolean;\n  getObserver(obj: object, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver;\n  getAccessor(obj: object, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver;\n}\nexport const INodeObserverLocator = DI\n  .createInterface<INodeObserverLocator>('INodeObserverLocator', x => x.cachedCallback(handler => {\n    handler.getAll(ILogger).forEach(logger => {\n      logger.error('Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).');\n    });\n    return new DefaultNodeObserverLocator();\n  }));\n\nclass DefaultNodeObserverLocator implements INodeObserverLocator {\n  public handles(): boolean {\n    return false;\n  }\n  public getObserver(): IAccessor | IObserver {\n    return propertyAccessor;\n  }\n  public getAccessor(): IAccessor | IObserver {\n    return propertyAccessor;\n  }\n}\n\nexport type ExtendedPropertyDescriptor = PropertyDescriptor & {\n  get?: ObservableGetter;\n  set?: ObservableSetter;\n};\nexport type ObservableGetter = PropertyDescriptor['get'] & {\n  getObserver?(obj: unknown, requestor: IObserverLocator): IObserver;\n};\nexport type ObservableSetter = PropertyDescriptor['set'] & {\n  getObserver?(obj: unknown, requestor: IObserverLocator): IObserver;\n};\n\nexport class ObserverLocator {\n  protected static readonly inject = [IDirtyChecker, INodeObserverLocator];\n\n  private readonly adapters: IObjectObservationAdapter[] = [];\n\n  public constructor(\n    private readonly dirtyChecker: IDirtyChecker,\n    private readonly nodeObserverLocator: INodeObserverLocator,\n  ) {}\n\n  public addAdapter(adapter: IObjectObservationAdapter): void {\n    this.adapters.push(adapter);\n  }\n\n  public getObserver(obj: object, key: PropertyKey): IObserver {\n    return (obj as IObservable).$observers?.[key as string] as IObserver | undefined\n      ?? this.cache((obj as IObservable), key as string, this.createObserver((obj as IObservable), key as string)) as IObserver;\n  }\n\n  public getAccessor(obj: object, key: string): AccessorOrObserver {\n    const cached = (obj as IObservable).$observers?.[key] as AccessorOrObserver | undefined;\n    if (cached !== void 0) {\n      return cached;\n    }\n    if (this.nodeObserverLocator.handles(obj, key, this)) {\n      return this.nodeObserverLocator.getAccessor(obj, key, this) as AccessorOrObserver;\n    }\n\n    return propertyAccessor;\n  }\n\n  public getArrayObserver(observedArray: unknown[]): ICollectionObserver<CollectionKind.array> {\n    return getArrayObserver(observedArray);\n  }\n\n  public getMapObserver(observedMap: Map<unknown, unknown>): ICollectionObserver<CollectionKind.map>  {\n    return getMapObserver(observedMap);\n  }\n\n  public getSetObserver(observedSet: Set<unknown>): ICollectionObserver<CollectionKind.set>  {\n    return getSetObserver(observedSet);\n  }\n\n  private createObserver(obj: IObservable, key: string): AccessorOrObserver {\n    if (!(obj instanceof Object)) {\n      return new PrimitiveObserver(obj as unknown as Primitive, key);\n    }\n\n    if (this.nodeObserverLocator.handles(obj, key, this)) {\n      return this.nodeObserverLocator.getObserver(obj, key, this) as AccessorOrObserver;\n    }\n\n    switch (key) {\n      case 'length':\n        if (obj instanceof Array) {\n          return getArrayObserver(obj).getLengthObserver();\n        }\n        break;\n      case 'size':\n        if (obj instanceof Map) {\n          return getMapObserver(obj).getLengthObserver();\n        } else if (obj instanceof Set) {\n          return getSetObserver(obj).getLengthObserver();\n        }\n        break;\n      default:\n        if (obj instanceof Array && isArrayIndex(key)) {\n          return getArrayObserver(obj).getIndexObserver(Number(key));\n        }\n        break;\n    }\n\n    let pd = Object.getOwnPropertyDescriptor(obj, key) as ExtendedPropertyDescriptor;\n    // Only instance properties will yield a descriptor here, otherwise walk up the proto chain\n    if (pd === void 0) {\n      let proto = Object.getPrototypeOf(obj) as object | null;\n      while (proto !== null) {\n        pd = Object.getOwnPropertyDescriptor(proto, key) as ExtendedPropertyDescriptor;\n        if (pd === void 0) {\n          proto = Object.getPrototypeOf(proto) as object | null;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // If the descriptor does not have a 'value' prop, it must have a getter and/or setter\n    if (pd !== void 0 && !Object.prototype.hasOwnProperty.call(pd, 'value')) {\n      let obs: AccessorOrObserver | undefined | null = this.getAdapterObserver(obj, key, pd);\n      if (obs == null) {\n        obs = (pd.get?.getObserver ?? pd.set?.getObserver)?.(obj, this) as AccessorOrObserver;\n      }\n\n      return obs == null\n        ? pd.configurable\n          ? ComputedObserver.create(obj, key, pd, this, /* AOT: not true for IE11 */ true)\n          : this.dirtyChecker.createProperty(obj, key)\n        : obs;\n    }\n\n    // Ordinary get/set observation (the common use case)\n    // TODO: think about how to handle a data property that does not sit on the instance (should we do anything different?)\n    return new SetterObserver(obj, key);\n  }\n\n  private getAdapterObserver(obj: IObservable, propertyName: string, pd: PropertyDescriptor): AccessorOrObserver | null {\n    if (this.adapters.length > 0) {\n      for (const adapter of this.adapters) {\n        const observer = adapter.getObserver(obj, propertyName, pd, this);\n        if (observer != null) {\n          return observer;\n        }\n      }\n    }\n    return null;\n  }\n\n  private cache(obj: IObservable, key: string, observer: AccessorOrObserver): AccessorOrObserver {\n    if (observer.doNotCache === true) {\n      return observer;\n    }\n    if (obj.$observers === void 0) {\n      def(obj, '$observers', { value: { [key]: observer } });\n      return observer;\n    }\n    return obj.$observers[key] = observer;\n  }\n}\n\nexport type RepeatableCollection = Collection | null | undefined | number;\n\nexport function getCollectionObserver(collection: RepeatableCollection): CollectionObserver | undefined {\n  let obs: CollectionObserver | undefined;\n  if (collection instanceof Array) {\n    obs = getArrayObserver(collection);\n  } else if (collection instanceof Map) {\n    obs = getMapObserver(collection);\n  } else if (collection instanceof Set) {\n    obs = getSetObserver(collection);\n  }\n  return obs;\n}\n","import { DI } from '@aurelia/kernel';\nimport { connectable } from '../binding/connectable.js';\nimport { enterConnectable, exitConnectable } from './connectable-switcher.js';\nimport { IObserverLocator } from './observer-locator.js';\n\nimport type { ICollectionSubscriber, IConnectable, ISubscriber } from '../observation.js';\nimport type { BindingObserverRecord } from '../binding/connectable.js';\n\nexport interface IObservation extends Observation {}\nexport const IObservation = DI.createInterface<IObservation>('IObservation', x => x.singleton(Observation));\n\nexport class Observation implements IObservation {\n\n  public static get inject() { return [IObserverLocator]; }\n\n  public constructor(\n    public readonly observerLocator: IObserverLocator,\n  ) {}\n\n  /**\n   * Run an effect function an track the dependencies inside it,\n   * to re-run whenever a dependency has changed\n   */\n  public run(fn: EffectFunc): IEffect {\n    const effect = new Effect(this.observerLocator, fn);\n    // todo: batch effect run after it's in\n    effect.run();\n    return effect;\n  }\n}\n\nexport type EffectFunc = (runner: IConnectable) => void;\nexport interface IEffect extends IConnectable {\n  run(): void;\n  stop(): void;\n}\n\ninterface Effect extends IConnectable {}\nclass Effect implements IEffect, ISubscriber, ICollectionSubscriber {\n\n  public readonly interceptor: this = this;\n  public readonly obs!: BindingObserverRecord;\n  // to configure this, potentially a 2nd parameter is needed for run\n  public maxRunCount: number = 10;\n  private queued: boolean = false;\n  private running: boolean = false;\n  private runCount: number = 0;\n  private stopped: boolean = false;\n\n  public constructor(\n    public readonly observerLocator: IObserverLocator,\n    public readonly fn: EffectFunc,\n  ) {\n  }\n\n  public handleChange(): void {\n    this.queued = true;\n    this.run();\n  }\n\n  public handleCollectionChange(): void {\n    this.queued = true;\n    this.run();\n  }\n\n  public run(): void {\n    if (this.stopped) {\n      throw new Error('Effect has already been stopped');\n    }\n    if (this.running) {\n      return;\n    }\n    ++this.runCount;\n    this.running = true;\n    this.queued = false;\n    ++this.obs.version;\n    try {\n      enterConnectable(this);\n      this.fn(this);\n    } finally {\n      this.obs.clear(false);\n      this.running = false;\n      exitConnectable(this);\n    }\n    // when doing this.fn(this), there's a chance that it has recursive effect\n    // continue to run for a certain number before bailing\n    // whenever there's a dependency change while running, this.queued will be true\n    // so we use it as an indicator to continue to run the effect\n    if (this.queued) {\n      if (this.runCount > this.maxRunCount) {\n        this.runCount = 0;\n        throw new Error('Maximum number of recursive effect run reached. Consider handle effect dependencies differently.');\n      }\n      this.run();\n    } else {\n      this.runCount = 0;\n    }\n  }\n\n  public stop(): void {\n    this.stopped = true;\n    this.obs.clear(true);\n  }\n}\n\nconnectable(Effect);\n","import { IObserver, LifecycleFlags } from '../observation.js';\nimport { SetterNotifier } from './setter-observer.js';\nimport { def } from '../utilities-objects.js';\nimport { currentConnectable } from './connectable-switcher.js';\n\nimport type { Constructable, IIndexable } from '@aurelia/kernel';\nimport type { IBindingContext, InterceptorFunc, IObservable } from '../observation.js';\nimport type { ObservableGetter } from './observer-locator.js';\nimport type { SetterObserver } from './setter-observer.js';\n\nexport interface IObservableDefinition {\n  name?: PropertyKey;\n  callback?: PropertyKey;\n  set?: InterceptorFunc;\n}\n\nfunction getObserversLookup(obj: IObservable): IIndexable<{}, SetterObserver | SetterNotifier> {\n  if (obj.$observers === void 0) {\n    def(obj, '$observers', { value: {} });\n    // todo: define in a weakmap\n  }\n  return obj.$observers as IIndexable<{}, SetterObserver | SetterNotifier>;\n}\n\nconst noValue: unknown = {};\n\ntype SetterObserverOwningObject = IIndexable<IBindingContext, IObserver>;\n\n// for\n//    class {\n//      @observable prop\n//    }\nexport function observable(target: Constructable['prototype'], key: PropertyKey, descriptor?: PropertyDescriptor & { initializer?: () => unknown }): void;\n// for\n//    @observable({...})\n//    class {}\n// and\n//    class {\n//      @observable({...}) prop\n//    }\nexport function observable(config: IObservableDefinition): (target: Constructable | Constructable['prototype'], ...args: unknown[]) => void;\n// for\n//    @observable('') class {}\n//    @observable(5) class {}\n//    @observable(Symbol()) class {}\nexport function observable(key: PropertyKey): ClassDecorator;\n// for:\n//    class {\n//      @observable() prop\n//    }\nexport function observable(): PropertyDecorator;\n// impl, wont be seen\nexport function observable(\n  targetOrConfig?: Constructable | Constructable['prototype'] | PropertyKey | IObservableDefinition,\n  key?: PropertyKey,\n  descriptor?: PropertyDescriptor\n): ClassDecorator | PropertyDecorator {\n  // either this check, or arguments.length === 3\n  // or could be both, so can throw against user error for better DX\n  if (key == null) {\n    // for:\n    //    @observable('prop')\n    //    class {}\n    //\n    //    @observable({ name: 'prop', callback: ... })\n    //    class {}\n    //\n    //    class {\n    //      @observable() prop\n    //      @observable({ callback: ... }) prop2\n    //    }\n    return ((t: Constructable, k: PropertyKey, d: PropertyDescriptor) => deco(t, k, d, targetOrConfig)) as ClassDecorator;\n  }\n  // for:\n  //    class {\n  //      @observable prop\n  //    }\n  return deco(targetOrConfig as Constructable['prototype'], key, descriptor) as PropertyDecorator;\n\n  function deco(\n    target: Constructable | Constructable['prototype'],\n    key?: PropertyKey,\n    descriptor?: PropertyDescriptor & { initializer?: CallableFunction },\n    config?: PropertyKey | IObservableDefinition,\n  ): void | PropertyDescriptor {\n    // class decorator?\n    const isClassDecorator = key === void 0;\n    config = typeof config !== 'object'\n      ? { name: config }\n      : (config || {});\n\n    if (isClassDecorator) {\n      key = config.name;\n    }\n\n    if (key == null || key === '') {\n      throw new Error('Invalid usage, cannot determine property name for @observable');\n    }\n\n    // determine callback name based on config or convention.\n    const callback = config.callback || `${String(key)}Changed`;\n    let initialValue = noValue;\n    if (descriptor) {\n      // we're adding a getter and setter which means the property descriptor\n      // cannot have a \"value\" or \"writable\" attribute\n      delete descriptor.value;\n      delete descriptor.writable;\n      initialValue = descriptor.initializer?.();\n      delete descriptor.initializer;\n    } else {\n      descriptor = { configurable: true };\n    }\n\n    // make the accessor enumerable by default, as fields are enumerable\n    if (!('enumerable' in descriptor)) {\n      descriptor.enumerable = true;\n    }\n\n    // todo(bigopon/fred): discuss string api for converter\n    const $set = config.set;\n    descriptor.get = function g(/* @observable */this: SetterObserverOwningObject) {\n      const notifier = getNotifier(this, key!, callback, initialValue, $set);\n      currentConnectable()?.subscribeTo(notifier);\n      return notifier.getValue();\n    };\n    descriptor.set = function s(/* @observable */this: SetterObserverOwningObject, newValue: unknown) {\n      getNotifier(this, key!, callback, initialValue, $set).setValue(newValue, LifecycleFlags.none);\n    };\n    (descriptor.get as ObservableGetter).getObserver = function gO(/* @observable */obj: SetterObserverOwningObject) {\n      return getNotifier(obj, key!, callback, initialValue, $set);\n    };\n\n    if (isClassDecorator) {\n      def((target as Constructable).prototype, key, descriptor);\n    } else {\n      return descriptor;\n    }\n  }\n}\n\nfunction getNotifier(\n  obj: SetterObserverOwningObject,\n  key: PropertyKey,\n  callbackKey: PropertyKey,\n  initialValue: unknown,\n  set: InterceptorFunc | undefined,\n): SetterNotifier {\n  const lookup = getObserversLookup(obj) as unknown as Record<PropertyKey, SetterObserver | SetterNotifier>;\n  let notifier = lookup[key as string] as SetterNotifier;\n  if (notifier == null) {\n    notifier = new SetterNotifier(obj, callbackKey, set, initialValue === noValue ? void 0 : initialValue);\n    lookup[key as string] = notifier;\n  }\n  return notifier;\n}\n\n/*\n          | typescript       | babel\n----------|------------------|-------------------------\nproperty  | config           | config\nw/parens  | target, key      | target, key, descriptor\n----------|------------------|-------------------------\nproperty  | target, key      | target, key, descriptor\nno parens | n/a              | n/a\n----------|------------------|-------------------------\nclass     | config           | config\n          | target           | target\n*/\n"],"names":["Protocol","Metadata","Registration","DI","BindingBehaviorStrategy","firstDefined","mergeArrays","fromAnnotationOrDefinitionOrTypeOrDefault","ExpressionKind","isNumberOrBigInt","isStringOrDate","emptyArray","toStringTag","$set","BindingMode","LifecycleFlags","DelegationStrategy","CollectionKind","AccessorType","isArrayIndex","oV","observerLookup","proto","native","methods","observe","$clear","$delete","descriptorProps","Char","Access","Precedence","BindingType","IPlatform","ILogger"],"mappings":";;;;;;;SAGgB,KAAK,CAAC,GAAG,OAA0B;IACjD,OAAO,UAAU,MAAqB;QACpC,MAAM,GAAG,GAAGA,eAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAClD,MAAM,QAAQ,GAAGC,eAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAC9C,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;YACvBA,eAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;SACvC;aAAM;YACL,QAAQ,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,CAAC;SAC3B;KACF,CAAC;AACJ,CAAC;SAEe,eAAe,CAAC,OAA0B,EAAE,QAA0D,EAAE,GAAW,EAAE,SAAqB;IACxJ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;QAChDC,mBAAY,CAAC,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;KAC7E;AACH;;ACbA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;MAEpB,cAAc;IAGzB,YAAoB,QAA8B,EAAE,KAAe;QACjE,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;YACvB,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;;gBAEpB,IAAI,CAAC,QAAkB,CAAC,GAAG,KAAK,CAAC;aAClC;iBAAM;;gBAEL,KAAK,MAAM,IAAI,IAAI,QAAsB,EAAE;oBACzC,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAY,EAAE;wBACnE,IAAI,CAAC,IAAI,CAAC,GAAI,QAAuB,CAAC,IAAI,CAAC,CAAC;qBAC7C;iBACF;aACF;SACF;KACF;IAsBM,OAAO,MAAM,CAAC,QAA8B,EAAE,KAAe;QAClE,OAAO,IAAI,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;KAC5C;IAEM,OAAO,GAAG,CAAC,KAAY,EAAE,IAAY,EAAE,QAAgB,EAAE,KAAqB;;QACnF,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,YAAY,KAAK,GAAG,CAAC,CAAC;SACvC;QACD,IAAI,eAAe,GAA4B,KAAK,CAAC,eAAe,CAAC;QACrE,IAAI,YAAY,GAAiB,KAAK,CAAC;QAEvC,IAAI,QAAQ,GAAG,CAAC,EAAE;;YAEhB,OAAO,QAAQ,GAAG,CAAC,EAAE;gBACnB,QAAQ,EAAE,CAAC;gBACX,YAAY,GAAG,YAAY,CAAC,WAAW,CAAC;gBACxC,IAAI,CAAA,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,eAAe,KAAI,IAAI,EAAE;oBACzC,OAAO,KAAK,CAAC,CAAC;iBACf;aACF;YAED,eAAe,GAAG,YAAY,CAAC,eAAe,CAAC;;YAE/C,OAAO,IAAI,IAAI,eAAe,GAAG,eAAe,GAAG,eAAe,CAAC,cAAc,CAAC;SACnF;;QAGD,OACE,EAAC,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,UAAU,CAAA;eACtB,eAAe,IAAI,IAAI;eACvB,EAAE,IAAI,IAAI,eAAe,CAAC;eAC1B,EACD,eAAe,CAAC,cAAc;mBAC3B,IAAI,IAAI,eAAe,CAAC,cAAc,CAC1C,EACD;YACA,YAAY,SAAG,YAAa,CAAC,WAAW,mCAAI,IAAI,CAAC;YACjD,eAAe,SAAG,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,eAAe,mCAAI,IAAI,CAAC;SACzD;QAED,IAAI,eAAe,EAAE;YACnB,OAAO,IAAI,IAAI,eAAe,GAAG,eAAe,GAAG,eAAe,CAAC,cAAc,CAAC;SACnF;;;;QAKD,IAAI,KAAK,qCAA2C;YAClD,OAAO,MAAM,CAAC;SACf;QACD,OAAO,KAAK,CAAC,cAAc,IAAI,KAAK,CAAC,eAAe,CAAC;KACtD;CACF;MAEY,KAAK;IAChB,YACS,WAAyB,EACzB,cAA+B,EAC/B,eAAiC,EACxB,UAAmB;QAH5B,gBAAW,GAAX,WAAW,CAAc;QACzB,mBAAc,GAAd,cAAc,CAAiB;QAC/B,oBAAe,GAAf,eAAe,CAAkB;QACxB,eAAU,GAAV,UAAU,CAAS;KAChC;IA+BE,OAAO,MAAM,CAAC,EAAU,EAAE,EAA4B,EAAE,UAAoB;QACjF,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE,EAAqB,EAAE,EAAE,IAAI,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,UAAU,aAAV,UAAU,cAAV,UAAU,GAAI,KAAK,CAAC,CAAC;KAClH;IAEM,OAAO,YAAY,CAAC,EAAoB;QAC7C,IAAI,EAAE,IAAI,IAAI,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,sBAAsB,EAAE,EAAE,CAAC,CAAC;SAC7C;QACD,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE,EAAE,CAAC,cAAc,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;KACtD;IAEM,OAAO,UAAU,CAAC,EAAgB,EAAE,EAAU;QACnD,IAAI,EAAE,IAAI,IAAI,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,kBAAkB,EAAE,EAAE,CAAC,CAAC;SACzC;QACD,OAAO,IAAI,KAAK,CAAC,EAAE,EAAE,EAAqB,EAAE,eAAe,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;KAChF;CACF;MAEY,eAAe;IAK1B,YAAoB,cAA+B;QACjD,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;KACtC;IAEM,OAAO,MAAM,CAAC,EAAU;QAC7B,OAAO,IAAI,eAAe,CAAC,EAAqB,CAAC,CAAC;KACnD;;;MCjKU,SAAS,GAAGC,SAAE,CAAC,eAAe,CAAY,WAAW,EAAE,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,EAAE;MAEnF,QAAQ;IAArB;QACS,YAAO,GAAqC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KA4BxE;IA1BQ,cAAc,CAAC,IAAY,EAAE,KAAsB;QACxD,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,SAAS,KAAK,SAAS,EAAE;YAC3B,OAAO;SACR;QACD,KAAK,MAAM,QAAQ,IAAI,SAAS,CAAC,IAAI,EAAE,EAAE;YACvC,QAAQ,CAAC,YAAY,CAAC,SAAS,EAAE,SAAS,EAAE,KAAM,CAAC,CAAC;SACrD;KACF;IAEM,iBAAiB,CAAC,IAAY,EAAE,QAAqB;QAC1D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC7B,MAAM,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QAChC,IAAI,SAAS,KAAK,SAAS,EAAE;YAC3B,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;SACrC;aAAM;YACL,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;SACzB;KACF;IAEM,oBAAoB,CAAC,IAAY,EAAE,QAAqB;QAC7D,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,SAAS,EAAE;YACb,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;SAC5B;KACF;;;ACAeC;AAAlB,WAAkB,uBAAuB;IACvC,+EAAa,CAAA;IACb,mFAAe,CAAA;AACjB,CAAC,EAHiBA,+BAAuB,KAAvBA,+BAAuB,QAGxC;SAkBe,eAAe,CAAC,SAAoD;IAClF,OAAO,UAAU,MAAM;QACrB,OAAO,eAAe,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;KAClD,CAAC;AACJ,CAAC;MAEY,yBAAyB;IACpC,YACkB,IAA4B,EAC5B,IAAY,EACZ,OAA0B,EAC1B,GAAW,EACX,QAAiC;QAJjC,SAAI,GAAJ,IAAI,CAAwB;QAC5B,SAAI,GAAJ,IAAI,CAAQ;QACZ,YAAO,GAAP,OAAO,CAAmB;QAC1B,QAAG,GAAH,GAAG,CAAQ;QACX,aAAQ,GAAR,QAAQ,CAAyB;KAC/C;IAEG,OAAO,MAAM,CAClB,SAAoD,EACpD,IAA4B;QAG5B,IAAI,IAAY,CAAC;QACjB,IAAI,GAAqC,CAAC;QAC1C,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YACjC,IAAI,GAAG,SAAS,CAAC;YACjB,GAAG,GAAG,EAAE,IAAI,EAAE,CAAC;SAChB;aAAM;YACL,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;YACtB,GAAG,GAAG,SAAS,CAAC;SACjB;QAED,MAAM,uBAAuB,GAAG,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,kBAAkB,CAAC;QAEnF,OAAO,IAAI,yBAAyB,CAClC,IAAI,EACJC,mBAAY,CAAC,eAAe,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,IAAI,CAAC,EAC/DC,kBAAW,CAAC,eAAe,CAAC,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC,EAAE,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,EACtF,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,EAC7BC,gDAAyC,CAAC,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,uBAAuB,2CAA2E,CAC1K,CAAC;KACH;IAEM,QAAQ,CAAC,SAAqB;QACnC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAC9C,QAAQ,QAAQ;YACd;gBACEL,mBAAY,CAAC,SAAS,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;gBACtD,MAAM;YACR;gBACEA,mBAAY,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,sBAAsB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;gBAC5F,MAAM;SACT;QACDA,mBAAY,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACpD,eAAe,CAAC,OAAO,EAAE,eAAe,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;KAC3D;CACF;MAEY,sBAAsB;IAGjC,YACmB,SAAqB,EACrB,IAA4B;QAD5B,cAAS,GAAT,SAAS,CAAY;QACrB,SAAI,GAAJ,IAAI,CAAwB;QAE7C,IAAI,CAAC,IAAI,GAAGC,SAAE,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;KACtC;IAEM,SAAS,CACd,OAA8B,EAC9B,IAA+B;QAE/B,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QACjC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,QAAQ,IAAI,CAAC,MAAM;YACjB,KAAK,CAAC,CAAC;YACP,KAAK,CAAC,CAAC;YACP,KAAK,CAAC;;gBAEJ,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAqC,CAAC;YAC1E,KAAK,CAAC;gBACJ,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,IAAI,CAAqC,CAAC;YAClG,KAAK,CAAC;gBACJ,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,IAAI,CAAqC,CAAC;YAC1H;gBACE,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,SAAS,CAAC,GAAG,CAAC,CAAC,CAAY,CAAC,EAAE,OAAO,EAAE,IAAI,CAAqC,CAAC;SAC1H;KACF;CACF;MAYY,kBAAkB;IAqB7B,YACkB,OAA8B,EAC9B,IAAgC;QADhC,YAAO,GAAP,OAAO,CAAuB;QAC9B,SAAI,GAAJ,IAAI,CAA4B;QAtB3C,gBAAW,GAAS,IAAI,CAAC;QAwB9B,IAAI,WAAqB,CAAC;QAC1B,OAAO,OAAO,CAAC,WAAW,KAAK,IAAI,EAAE;YACnC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;YAClC,OAAO,CAAC,WAAW,GAAG,IAAI,CAAC;YAC3B,OAAO,GAAG,WAAoC,CAAC;SAChD;KACF;IA7BD,IAAW,eAAe;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC;KACrC;IACD,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;KAC7B;IACD,IAAW,MAAM;QACf,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;KAC5B;IACD,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;KAC7B;IACD,IAAW,GAAG;QACZ,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;KACzB;IACD,IAAW,gBAAgB;QACzB,OAAQ,IAAI,CAAC,OAA+E,CAAC,gBAAgB,CAAC;KAC/G;IAcM,YAAY,CAAC,KAAc,EAAE,KAAqB;QACvD,IAAI,CAAC,OAAO,CAAC,YAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KAC1C;IACM,YAAY,CAAC,KAAc,EAAE,KAAqB;QACvD,IAAI,CAAC,OAAO,CAAC,YAAa,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KAC1C;IACM,UAAU,CAAC,IAAY;QAC5B,OAAO,IAAI,CAAC,OAAO,CAAC,UAAW,CAAC,IAAI,CAAC,CAAC;KACvC;IACM,YAAY,CAAC,QAAiB,EAAE,aAAsB,EAAE,KAAqB;QAClF,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;KAC3D;IACM,sBAAsB,CAAC,QAAkB,EAAE,KAAqB;QACrE,IAAI,CAAC,OAAO,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;KACtD;IACM,eAAe,CAAC,GAAW,EAAE,GAAW;QAC7C,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;KACxC;IACM,iBAAiB,CAAC,QAAoB;QAC3C,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;KAC1C;IAEM,KAAK,CAAC,KAAqB,EAAE,KAAY;QAC9C,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KAClC;IACM,OAAO,CAAC,KAAqB;QAClC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;KAC7B;CACF;MAEY,eAAe,GAAwB;IAClD,IAAI,EAAEH,eAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,kBAAkB,CAAC;IAClD,OAAO,CAAC,IAAY;QAClB,OAAO,GAAG,eAAe,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;KAC1C;IACD,MAAM,CAAI,KAAQ;QAChB,OAAO,OAAO,KAAK,KAAK,UAAU,IAAIC,eAAQ,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;KACpF;IACD,MAAM,CAAmD,SAAoD,EAAE,IAAO;QACpH,MAAM,UAAU,GAAG,yBAAyB,CAAC,MAAM,CAAC,SAAS,EAAE,IAA8C,CAAC,CAAC;QAC/GA,eAAQ,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;QACnEA,eAAQ,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAC9DD,eAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,CAAC;QAEvD,OAAO,UAAU,CAAC,IAA8B,CAAC;KAClD;IACD,aAAa,CAA0B,IAAO;QAC5C,MAAM,GAAG,GAAGC,eAAQ,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAiC,CAAC;QACxF,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,gCAAgC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;SAC9D;QAED,OAAO,GAAG,CAAC;KACZ;IACD,QAAQ,CAAmD,IAAmB,EAAE,IAAO,EAAE,KAA0C;QACjIA,eAAQ,CAAC,MAAM,CAACD,eAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;KAChE;IACD,aAAa,CAAmD,IAAmB,EAAE,IAAO;QAC1F,OAAOC,eAAQ,CAAC,MAAM,CAACD,eAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAwC,CAAC;KACvG;;;SC/Ma,cAAc,CAAC,SAAmD;IAChF,OAAO,UAAU,MAAM;QACrB,OAAO,cAAc,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;KACjD,CAAC;AACJ,CAAC;MAEY,wBAAwB;IACnC,YACkB,IAA2B,EAC3B,IAAY,EACZ,OAA0B,EAC1B,GAAW;QAHX,SAAI,GAAJ,IAAI,CAAuB;QAC3B,SAAI,GAAJ,IAAI,CAAQ;QACZ,YAAO,GAAP,OAAO,CAAmB;QAC1B,QAAG,GAAH,GAAG,CAAQ;KACzB;IAEG,OAAO,MAAM,CAClB,SAAmD,EACnD,IAA2B;QAG3B,IAAI,IAAY,CAAC;QACjB,IAAI,GAAoC,CAAC;QACzC,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YACjC,IAAI,GAAG,SAAS,CAAC;YACjB,GAAG,GAAG,EAAE,IAAI,EAAE,CAAC;SAChB;aAAM;YACL,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC;YACtB,GAAG,GAAG,SAAS,CAAC;SACjB;QAED,OAAO,IAAI,wBAAwB,CACjC,IAAI,EACJK,mBAAY,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,IAAI,CAAC,EAC9DC,kBAAW,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC,EAAE,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,EACrF,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,CAC7B,CAAC;KACH;IAEM,QAAQ,CAAC,SAAqB;QACnC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;QACpCJ,mBAAY,CAAC,SAAS,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACtDA,mBAAY,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;QACpD,eAAe,CAAC,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;KAC1D;CACF;MAEY,cAAc,GAAuB;IAChD,IAAI,EAAEF,eAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CAAC;IACjD,OAAO,CAAC,IAAY;QAClB,OAAO,GAAG,cAAc,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC;KACzC;IACD,MAAM,CAAI,KAAQ;QAChB,OAAO,OAAO,KAAK,KAAK,UAAU,IAAIC,eAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;KACnF;IACD,MAAM,CAAkD,SAAmD,EAAE,IAAO;QAClH,MAAM,UAAU,GAAG,wBAAwB,CAAC,MAAM,CAAC,SAAS,EAAE,IAA6C,CAAC,CAAC;QAC7GA,eAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;QAClEA,eAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAC7DD,eAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC;QAEtD,OAAO,UAAU,CAAC,IAA6B,CAAC;KACjD;IACD,aAAa,CAA0B,IAAO;QAC5C,MAAM,GAAG,GAAGC,eAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACvD,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,gCAAgC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;SAC9D;QAED,OAAO,GAAG,CAAC;KACZ;IACD,QAAQ,CAAkD,IAAmB,EAAE,IAAO,EAAE,KAAyC;QAC/HA,eAAQ,CAAC,MAAM,CAACD,eAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;KAChE;IACD,aAAa,CAAkD,IAAmB,EAAE,IAAO;QACzF,OAAOC,eAAQ,CAAC,MAAM,CAACD,eAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;KAChE;;;ACnHH;AAqBkBQ;AAAlB,WAAkB,cAAc;IAC9B,4DAA2C,CAAA;IAC3C,4DAA2C,CAAA;IAC3C,uEAA2C,CAAA;IAC3C,mEAA2C,CAAA;IAC3C,+DAA2C,CAAA;IAC3C,0EAA2C,CAAA;IAC3C,4DAA2C,CAAA;IAC3C,gEAA2C,CAAA;IAC3C,sEAA2C,CAAA;IAC3C,iEAA2C,CAAA;IAC3C,mEAA2C,CAAA;IAC3C,+EAA2C,CAAA;IAC3C,oDAA2C,CAAA;;IAE3C,kEAA2C,CAAA;IAC3C,qEAA2C,CAAA;IAC3C,uEAA2C,CAAA;IAC3C,yEAA2C,CAAA;IAC3C,+EAA2C,CAAA;IAC3C,+DAA2C,CAAA;IAC3C,sDAA2C,CAAA;IAC3C,gEAA2C,CAAA;IAC3C,kEAA2C,CAAA;IAC3C,sEAA2C,CAAA;IAC3C,sEAA2C,CAAA;IAC3C,oEAA2C,CAAA;IAC3C,0EAA2C,CAAA;IAC3C,wDAA2C,CAAA;IAC3C,kEAA2C,CAAA;IAC3C,0DAA2C,CAAA;IAC3C,2EAA2C,CAAA;IAC3C,6EAA2C,CAAA;IAC3C,kEAA2C,CAAA;IAC3C,qFAA2C,CAAA;IAC3C,uFAA2C,CAAA;IAC3C,iFAA2C,CAAA;IAC3C,0EAA2C,CAAA;IAC3C,sEAA2C,CAAA;AAC7C,CAAC,EAvCiBA,sBAAc,KAAdA,sBAAc,QAuC/B;MAmDY,QAAQ;IAArB;QACS,SAAI,GAAW,EAAE,CAAC;KAuP1B;IArPQ,OAAO,OAAO,CAAC,IAA6B;QACjD,MAAM,OAAO,GAAG,IAAI,QAAQ,EAAE,CAAC;QAC/B,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACrB,OAAO,OAAO,CAAC,IAAI,CAAC;KACrB;IAEM,iBAAiB,CAAC,IAA4B;QACnD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;KAC9B;IAEM,gBAAgB,CAAC,IAA2B;QACjD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACtB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,eAAe,CAAC,IAA0B;QAC/C,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE;YACvB,IAAI,CAAC,IAAI,IAAI,OAAO,CAAC;YACrB,OAAO;SACR;QACD,IAAI,CAAC,IAAI,IAAI,SAAS,CAAC;QACvB,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;QAC1B,OAAO,CAAC,EAAE,EAAE;YACV,IAAI,CAAC,IAAI,IAAI,UAAU,CAAC;SACzB;KACF;IAEM,gBAAgB,CAAC,IAA2B;QACjD,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;QACtB,OAAO,CAAC,EAAE,EAAE;YACV,IAAI,CAAC,IAAI,IAAI,UAAU,CAAC;SACzB;QACD,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC;KACxB;IAEM,iBAAiB,CAAC,IAA4B;QACnD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACzD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;aAClB;YACD,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SAC1B;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,kBAAkB,CAAC,IAA6B;QACrD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACrD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;aAClB;YACD,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAC7B,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACxB;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,qBAAqB,CAAC,IAAgC;QAC3D,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,EAAE;YAClC,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACjD,IAAI,CAAC,IAAI,IAAI,IAAI,OAAO,GAAG,CAAC;SAC7B;aAAM;YACL,IAAI,CAAC,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;SAC9B;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,iBAAiB,CAAC,IAA4B;QACnD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,eAAe,CAAC,IAA0B;QAC/C,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QAC7B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,cAAc,CAAC,IAAyB;QAC7C,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;QACtB,OAAO,CAAC,EAAE,EAAE;YACV,IAAI,CAAC,IAAI,IAAI,UAAU,CAAC;SACzB;QACD,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,aAAa,CAAC,IAAwB;QAC3C,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;QACrC,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAClC,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC5B,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SAC5B;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,mBAAmB,CAAC,IAA8B;QACvD,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;QACrC,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAClC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;QACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC5B,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SAC5B;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,UAAU,CAAC,IAAqB;QACrC,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;QAClC,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,YAAW,EAAE,EAAE;YAC7C,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;SAClB;QACD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,WAAW,CAAC,IAAsB;QACvC,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvB,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,aAAY,GAAG,EAAE;YAC/C,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC;SACpC;aAAM;YACL,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC;SAC7B;QACD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACxB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,gBAAgB,CAAC,IAA2B;QACjD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC5B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACtB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACrB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,WAAW,CAAC,IAAsB;QACvC,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACxB,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,mBAAmB,CAAC,IAA8B;QACvD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACrD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;YACjB,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,oBAAoB,CAAC,IAA+B;QACzD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACrD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;YACjB,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,wBAAwB,CAAC,IAAyB;QACvD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACzD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;aAClB;YACD,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SAC1B;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,yBAAyB,CAAC,IAA0B;QACzD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACrD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;aAClB;YACD,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAC7B,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACxB;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEM,sBAAsB,CAAC,IAAuB;QACnD,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC;KACxB;IAEM,gBAAgB,CAAC,IAA2B,IAAU,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC,EAAE;IAE5F,mBAAmB,CAAC,IAAoB;QAC7C,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,IAAI,IAAI,MAAM,CAAC;QACpB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KAC5B;IAEM,kBAAkB,CAAC,IAAmB;QAC3C,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC;QACpC,MAAM,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAClC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;QAClB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC5B,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SAC3B;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;IAEO,SAAS,CAAC,IAAkC;QAClD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;QACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;YACrD,IAAI,CAAC,KAAK,CAAC,EAAE;gBACX,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;aAClB;YACD,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SACtB;QACD,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC;KAClB;CACF;MAIY,gBAAgB;IAC3B,YACkB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;KAC3B;IAEG,QAAQ,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,EAAuB;QAC7E,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;CACF;MAIY,yBAAyB;IAMpC,YACkB,UAA6B,EAC7B,IAAY,EACZ,IAAyB;QAFzB,eAAU,GAAV,UAAU,CAAmB;QAC7B,SAAI,GAAJ,IAAI,CAAQ;QACZ,SAAI,GAAJ,IAAI,CAAqB;QAEzC,IAAI,CAAC,WAAW,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAClD;IAXD,IAAW,KAAK,KAAqC,mCAAsC,EAAE;IAC7F,IAAW,OAAO,KAAW,OAAO,IAAI,CAAC,EAAE;IAC3C,IAAW,SAAS,KAAW,OAAO,IAAI,CAAC,EAAE;IAWtC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KAC7C;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,GAAY;QAC7D,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;KAC7C;IAEM,IAAI,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAsB;QACjD,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE;YAC3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC/B;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,CAA0B,IAAI,CAAC,WAAW,CAAC,CAAC;QAC1E,IAAI,QAAQ,IAAI,IAAI,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,IAAI,sEAAsE,CAAC,CAAC;SAC5H;QACD,IAAI,EAAE,QAAQ,YAAY,sBAAsB,CAAC,EAAE;YACjD,IAAK,CAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,KAAK,CAAC,EAAE;gBAC1D,CAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;gBACvD,QAAQ,CAAC,IAAI,CAAC,IAAqC,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;aACnI;iBAAM;gBACL,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,IAAI,oBAAoB,CAAC,CAAC;aAC1E;SACF;KACF;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAsB;QACnD,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC;QAC7B,MAAM,EAAE,GAAG,CAAwB,CAAC;QACpC,IAAI,EAAE,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC,EAAE;YACtB,IAAI,OAAO,EAAE,CAAC,GAAG,CAAE,CAAC,MAAM,KAAK,UAAU,EAAE;gBACzC,EAAE,CAAC,GAAG,CAAE,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;aAC1B;YACD,EAAE,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC;SAClB;QACD,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;YAC7B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACjC;KACF;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;KAC3C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,wBAAwB;IAMnC,YACkB,UAA4B,EAC5B,IAAY,EACZ,IAAyB;QAFzB,eAAU,GAAV,UAAU,CAAkB;QAC5B,SAAI,GAAJ,IAAI,CAAQ;QACZ,SAAI,GAAJ,IAAI,CAAqB;QAEzC,IAAI,CAAC,YAAY,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAClD;IAXD,IAAW,KAAK,KAAoC,kCAAqC,EAAE;IAE3F,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAW,OAAO,IAAI,CAAC,EAAE;IAUtC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAA6E,IAAI,CAAC,YAAY,CAAC,CAAC;QAChH,IAAI,EAAE,IAAI,IAAI,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,CAAC,IAAI,sEAAsE,CAAC,CAAC;SAC3H;;;;;QAKD,IAAI,CAAC,KAAK,IAAI,KAAK,cAAc,IAAK,CAA6B,CAAC,EAAE;YACpE,MAAM,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;YAC3B,IAAI,OAAO,IAAI,IAAI,EAAE;gBACnB,MAAM,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;oBAChD,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAA2B,CAAC,CAAC;iBACrE;aACF;SACF;QACD,IAAI,QAAQ,IAAI,EAAE,EAAE;YAClB,OAAO,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SACvG;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KAC7C;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,GAAY;QAC7D,MAAM,EAAE,GAAG,CAAC,CAAC,GAAG,CAAoD,IAAI,CAAC,YAAY,CAAC,CAAC;QACvF,IAAI,EAAE,IAAI,IAAI,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,CAAC,IAAI,sEAAsE,CAAC,CAAC;SAC3H;QACD,IAAI,UAAU,IAAI,EAAE,EAAE;YACpB,GAAG,GAAG,EAAE,CAAC,QAAS,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;SAC3E;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;KAC7C;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,CAAsB;QACrD,MAAM,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAA2B,CAAC;QACtE,IAAI,EAAE,CAAC,OAAO,KAAK,KAAK,CAAC,EAAE;YACzB,OAAO;SACR;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;;;YAG1C,QAAQ,CAAC,oBAAoB,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAA2B,CAAC,CAAC;SAC3E;KACF;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;KAC1C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,gBAAgB;IAK3B,YACkB,MAAoB,EACpB,KAAe;QADf,WAAM,GAAN,MAAM,CAAc;QACpB,UAAK,GAAL,KAAK,CAAU;KAC7B;IAPJ,IAAW,KAAK,KAA4B,yBAA6B,EAAE;IAC3E,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;KACrE;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,GAAY;QAC7D,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;KACzC;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KAClC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,qBAAqB;IAKhC,YACkB,SAAmB,EACnB,GAAa,EACb,EAAY;QAFZ,cAAS,GAAT,SAAS,CAAU;QACnB,QAAG,GAAH,GAAG,CAAU;QACb,OAAE,GAAF,EAAE,CAAU;KAC1B;IARJ,IAAW,KAAK,KAAiC,4BAAkC,EAAE;IACrF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAQxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KAC3G;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;KACvC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,oBAAoB;IAO/B,YACkB,WAAmB,CAAC;QAApB,aAAQ,GAAR,QAAQ,CAAY;KAClC;IANJ,IAAW,KAAK,KAAgC,6BAAiC,EAAE;IACnF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAMxC,QAAQ,CAAC,EAAM,EAAE,CAAQ,EAAE,EAAmB,EAAE,EAAuB;;;;;QAI5E,IAAI,EAAE,GAA4B,CAAC,CAAC,eAAe,CAAC;QACpD,IAAI,YAAY,GAAiB,CAAC,CAAC;QACnC,IAAI,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;QACtB,OAAO,CAAC,EAAE,IAAI,EAAE,EAAE;YAChB,YAAY,GAAG,YAAa,CAAC,WAAW,CAAC;YACzC,EAAE,SAAG,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,eAAe,mCAAI,IAAI,CAAC;SAC5C;QACD,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC;KACjD;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;KACtC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;;AAlCsB,0BAAK,GAAyB,IAAI,oBAAoB,CAAC,CAAC,CAAC,CAAC;AAC1D,4BAAO,GAAyB,IAAI,oBAAoB,CAAC,CAAC,CAAC,CAAC;MAoCxE,qBAAqB;IAKhC,YACkB,IAAY,EACZ,WAAmB,CAAC;QADpB,SAAI,GAAJ,IAAI,CAAQ;QACZ,aAAQ,GAAR,QAAQ,CAAY;KAClC;IAPJ,IAAW,KAAK,KAAiC,+BAAkC,EAAE;IACrF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,EAAmB,EAAE,CAAsB;QAC1E,MAAM,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAoB,CAAC;QAClF,IAAI,CAAC,KAAK,IAAI,EAAE;YACd,CAAC,CAAC,eAAe,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;SACnC;QACD,MAAM,cAAc,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAkD,CAAC;QACvF,IAAI,cAAc,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YACnD,MAAM,IAAI,KAAK,CAAC,mEAAmE,CAAC,CAAC;SACtF;QACD,IAAI,CAAC,oCAA+B;YAClC,OAAO,cAAc,CAAC;SACvB;QACD,OAAO,cAAc,IAAI,IAAI,GAAG,EAA8D,GAAG,cAAc,CAAC;KACjH;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,EAAmB,EAAE,GAAY;;QAC9D,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YACzB,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;SACrE;QACD,MAAM,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAgB,CAAC;QAC9E,IAAI,GAAG,YAAY,MAAM,EAAE;YACzB,IAAI,OAAA,GAAG,CAAC,UAAU,0CAAG,IAAI,CAAC,IAAI,OAAM,KAAK,CAAC,EAAE;gBAC1C,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC3C,OAAO,GAAG,CAAC;aACZ;iBAAM;gBACL,OAAO,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;aAC7B;SACF;QACD,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;KACvC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,sBAAsB;IAKjC,YACkB,MAAsB,EACtB,IAAY;QADZ,WAAM,GAAN,MAAM,CAAgB;QACtB,SAAI,GAAJ,IAAI,CAAQ;KAC1B;IAPJ,IAAW,KAAK,KAAkC,+BAAmC,EAAE;IACvF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,0CAAmC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAe,CAAC;QAChH,IAAI,CAAC,oCAA+B;YAClC,IAAI,QAAQ,IAAI,IAAI,EAAE;gBACpB,OAAO,QAAQ,CAAC;aACjB;YACD,IAAI,CAAC,KAAK,IAAI,EAAE;gBACd,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aACxC;YACD,OAAO,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC5B;QACD,IAAI,CAAC,KAAK,IAAI,IAAI,QAAQ,YAAY,MAAM,EAAE;YAC5C,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;SACxC;QACD,OAAO,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;KAC5C;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,GAAY;QAC7D,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAgB,CAAC;QAC/D,IAAI,GAAG,YAAY,MAAM,EAAE;YACzB,IAAI,GAAG,CAAC,UAAU,KAAK,KAAK,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;gBACrE,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aAC5C;iBAAM;gBACL,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC;aACtB;SACF;aAAM;YACL,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC,CAAC;SACnD;QACD,OAAO,GAAG,CAAC;KACZ;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;KACxC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,qBAAqB;IAKhC,YACkB,MAAsB,EACtB,GAAa;QADb,WAAM,GAAN,MAAM,CAAgB;QACtB,QAAG,GAAH,GAAG,CAAU;KAC3B;IAPJ,IAAW,KAAK,KAAiC,8BAAkC,EAAE;IACrF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,0CAAmC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAe,CAAC;QAChH,IAAI,QAAQ,YAAY,MAAM,EAAE;YAC9B,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,0CAAmC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAW,CAAC;YACpG,IAAI,CAAC,KAAK,IAAI,EAAE;gBACd,CAAC,CAAC,eAAe,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;aAClC;YACD,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC;SACtB;QACD,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,GAAY;QAC7D,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAe,CAAC;QACnE,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAW,CAAC;QACvD,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;KAC5B;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;KACvC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,mBAAmB;IAK9B,YACkB,IAAY,EACZ,IAAyB,EACzB,WAAmB,CAAC;QAFpB,SAAI,GAAJ,IAAI,CAAQ;QACZ,SAAI,GAAJ,IAAI,CAAqB;QACzB,aAAQ,GAAR,QAAQ,CAAY;KAClC;IARJ,IAAW,KAAK,KAA+B,4BAAgC,EAAE;IACjF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAQxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACxD,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAE,CAAC;;;;QAIpE,MAAM,IAAI,GAAG,WAAW,CAAC,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QAChD,IAAI,IAAI,EAAE;YACR,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAiB,CAAC,CAAC;SAC/C;QACD,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;KACrC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,oBAAoB;IAK/B,YACkB,MAAsB,EACtB,IAAY,EACZ,IAAyB;QAFzB,WAAM,GAAN,MAAM,CAAgB;QACtB,SAAI,GAAJ,IAAI,CAAQ;QACZ,SAAI,GAAJ,IAAI,CAAqB;KACvC;IARJ,IAAW,KAAK,KAAgC,6BAAiC,EAAE;IACnF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAQxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,0CAAmC,CAAC,GAAG,IAAI,GAAG,CAAC,CAAe,CAAC;QAEhH,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACxD,MAAM,IAAI,GAAG,WAAW,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QACjD,IAAI,IAAI,EAAE;YACR,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAiB,CAAC,CAAC;SAChD;QACD,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;KACtC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,sBAAsB;IAKjC,YACkB,IAAoB,EACpB,IAAyB;QADzB,SAAI,GAAJ,IAAI,CAAgB;QACpB,SAAI,GAAJ,IAAI,CAAqB;KACvC;IAPJ,IAAW,KAAK,KAAkC,+BAAmC,EAAE;IACvF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5C,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;YAC9B,OAAO,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SAC5D;QACD,IAAI,EAAE,CAAC,wBAAmB,KAAK,IAAI,IAAI,IAAI,CAAC,EAAE;YAC5C,OAAO,KAAK,CAAC,CAAC;SACf;QACD,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;KACxC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,gBAAgB;IAK3B,YACkB,SAAyB,EACzB,IAAc,EACd,KAAe;QAFf,cAAS,GAAT,SAAS,CAAgB;QACzB,SAAI,GAAJ,IAAI,CAAU;QACd,UAAK,GAAL,KAAK,CAAU;KAC7B;IARJ,IAAW,KAAK,KAA4B,uBAA6B,EAAE;IAC3E,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAQxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,QAAQ,IAAI,CAAC,SAAS;YACpB,KAAK,IAAI;;gBAEP,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3E,KAAK,IAAI;;gBAEP,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3E,KAAK,IAAI;gBACP,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3E,KAAK,KAAK;gBACR,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC5E,KAAK,IAAI;gBACP,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3E,KAAK,KAAK;gBACR,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC5E,KAAK,YAAY,EAAE;gBACjB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC9C,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE;oBAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,YAAY,KAAK,CAAC;iBACxD;gBACD,OAAO,KAAK,CAAC;aACd;YACD,KAAK,IAAI,EAAE;gBACT,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC9C,IAAI,KAAK,YAAY,MAAM,EAAE;oBAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAW,IAAI,KAAK,CAAC;iBAC1D;gBACD,OAAO,KAAK,CAAC;aACd;;;;;YAKD,KAAK,GAAG,EAAE;gBACR,MAAM,IAAI,GAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBACjD,MAAM,KAAK,GAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;gBAEnD,IAAI,CAAC,CAAC,sCAAiC,CAAC,EAAE;oBACxC,OAAQ,IAAe,GAAI,KAAgB,CAAC;iBAC7C;;gBAGD,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;oBACnB,IAAIC,uBAAgB,CAAC,IAAI,CAAC,IAAIA,uBAAgB,CAAC,KAAK,CAAC,EAAE;wBACrD,OAAO,CAAC,IAAc,IAAI,CAAC,KAAK,KAAe,IAAI,CAAC,CAAC,CAAC;qBACvD;oBACD,IAAIC,qBAAc,CAAC,IAAI,CAAC,IAAIA,qBAAc,CAAC,KAAK,CAAC,EAAE;wBACjD,OAAO,CAAC,IAAc,IAAI,EAAE,KAAK,KAAe,IAAI,EAAE,CAAC,CAAC;qBACzD;iBACF;gBACD,OAAQ,IAAe,GAAI,KAAgB,CAAC;aAC7C;YACD,KAAK,GAAG;gBACN,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAClG,KAAK,GAAG;gBACN,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAClG,KAAK,GAAG;gBACN,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAClG,KAAK,GAAG;gBACN,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAClG,KAAK,GAAG;gBACN,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAClG,KAAK,GAAG;gBACN,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,GAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAClG,KAAK,IAAI;gBACP,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,IAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YACnG,KAAK,IAAI;gBACP,OAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,IAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YACnG;gBACE,MAAM,IAAI,KAAK,CAAC,6BAA6B,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACnE;KACF;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KAClC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,eAAe;IAK1B,YACkB,SAAwB,EACxB,UAA0B;QAD1B,cAAS,GAAT,SAAS,CAAe;QACxB,eAAU,GAAV,UAAU,CAAgB;KACxC;IAPJ,IAAW,KAAK,KAA2B,sBAA4B,EAAE;IACzE,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,QAAQ,IAAI,CAAC,SAAS;YACpB,KAAK,MAAM;gBACT,OAAO,KAAK,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YACnD,KAAK,QAAQ;gBACX,OAAO,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,oCAA+B,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAClF,KAAK,GAAG;gBACN,OAAO,CAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAa,CAAC;YAC5D,KAAK,GAAG;gBACN,OAAO,CAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAC3D,KAAK,GAAG;gBACN,OAAO,CAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAY,CAAC;YAC3D;gBACE,MAAM,IAAI,KAAK,CAAC,4BAA4B,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SAClE;KACF;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;KACjC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MACY,0BAA0B;IAUrC,YACkB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;KAC3B;IANJ,IAAW,KAAK,KAAsC,oCAAuC,EAAE;IAC/F,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAMxC,QAAQ,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,EAAuB;QAC7E,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC;KAC5C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;;AA3BsB,qCAAU,GAA0C,IAAI,0BAA0B,CAAY,KAAK,CAAC,CAAC,CAAC;AACtG,gCAAK,GAAqC,IAAI,0BAA0B,CAAO,IAAI,CAAC,CAAC;AACrF,gCAAK,GAAqC,IAAI,0BAA0B,CAAO,IAAI,CAAC,CAAC;AACrF,iCAAM,GAAsC,IAAI,0BAA0B,CAAQ,KAAK,CAAC,CAAC;AACzF,iCAAM,GAAuC,IAAI,0BAA0B,CAAK,EAAE,CAAC,CAAC;MA0BhG,qBAAqB;IAKhC,YACkB,KAAuC;QAAvC,UAAK,GAAL,KAAK,CAAkC;KACrD;IANJ,IAAW,KAAK,KAAiC,4BAAkC,EAAE;IACrF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAMxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAC1C,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC7C,IAAI,CAAC,IAAI,IAAI,EAAE;gBACb,SAAS;aACV;YACD,MAAM,IAAI,CAAC,CAAC;SACb;QACD,OAAO,MAAM,CAAC;KACf;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa,EAAE,WAAgC;QACnG,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;KACvC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,sBAAsB;IAMjC,YACkB,QAA6B;QAA7B,aAAQ,GAAR,QAAQ,CAAqB;KAC3C;IANJ,IAAW,KAAK,KAAkC,gCAAmC,EAAE;IACvF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAMxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;KACvD;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;KACxC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;;AAvBsB,6BAAM,GAA2B,IAAI,sBAAsB,CAACC,iBAAU,CAAC,CAAC;MA0BpF,uBAAuB;IAMlC,YACkB,IAAkC,EAClC,MAA2B;QAD3B,SAAI,GAAJ,IAAI,CAA8B;QAClC,WAAM,GAAN,MAAM,CAAqB;KACzC;IAPJ,IAAW,KAAK,KAAmC,iCAAoC,EAAE;IACzF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,QAAQ,GAA4B,EAAE,CAAC;QAC7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACzC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC9D;QACD,OAAO,QAAQ,CAAC;KACjB;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;KACzC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;;AA5BsB,8BAAM,GAA4B,IAAI,uBAAuB,CAACA,iBAAU,EAAEA,iBAAU,CAAC,CAAC;MA+BlG,kBAAkB;IAM7B,YACkB,MAAyB,EACzB,cAAmCA,iBAAU;QAD7C,WAAM,GAAN,MAAM,CAAmB;QACzB,gBAAW,GAAX,WAAW,CAAkC;KAC3D;IAPJ,IAAW,KAAK,KAA8B,4BAA+B,EAAE;IAC/E,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAChD,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAC3D,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SAC9B;QACD,OAAO,MAAM,CAAC;KACf;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;KACpC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;;AA7BsB,yBAAM,GAAuB,IAAI,kBAAkB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAgCtE,wBAAwB;IAKnC,YACkB,MAAuD,EACvE,GAAsB,EACN,IAAoB,EACpB,cAAmCA,iBAAU;QAH7C,WAAM,GAAN,MAAM,CAAiD;QAEvD,SAAI,GAAJ,IAAI,CAAgB;QACpB,gBAAW,GAAX,WAAW,CAAkC;QAE7D,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;KAClB;IAXD,IAAW,KAAK,KAAoC,iCAAqC,EAAE;IAC3F,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAWxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAClE,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5C,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAC;SACpF;QACD,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,OAAO,CAAC,CAAC;KACtC;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;KAC1C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,mBAAmB;;IAM9B,YACkB,QAA6B;QAA7B,aAAQ,GAAR,QAAQ,CAAqB;KAC3C;IAPJ,IAAW,KAAK,KAAyC,uCAA0C,EAAE;IACrG,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,EAAuB;;;;;;;;;;;;;QAa7E,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;;QAEjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;KAC/C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,oBAAoB;;IAM/B,YACkB,IAAkC,EAClC,MAA2B;QAD3B,SAAI,GAAJ,IAAI,CAA8B;QAClC,WAAM,GAAN,MAAM,CAAqB;KACzC;IARJ,IAAW,KAAK,KAA0C,wCAA2C,EAAE;IACvG,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAQxC,QAAQ,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,EAAuB;;;;;QAK7E,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;;QAEjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC;KAChD;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;MAEY,iBAAiB;IAK5B,YACkB,IAAY;QAAZ,SAAI,GAAJ,IAAI,CAAQ;KAC1B;IANJ,IAAW,KAAK,KAAuC,qCAAwC,EAAE;IACjG,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAMxC,QAAQ,CAAC,EAAM,EAAE,EAAS,EAAE,EAA0B,EAAE,EAAuB;QACpF,OAAO,IAAI,CAAC,IAAI,CAAC;KAClB;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;KAC7C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;AAED,MAAMC,aAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAEpC,CAAC;AAEF;AACA;MACa,cAAc;IAKzB,YACkB,WAAuC,EACvC,QAA2B;QAD3B,gBAAW,GAAX,WAAW,CAA4B;QACvC,aAAQ,GAAR,QAAQ,CAAmB;KACzC;IAPJ,IAAW,KAAK,KAAoC,iCAAqC,EAAE;IAC3F,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAOxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KAC3C;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,KAAK,CAAC,EAAM,EAAE,MAA8C;QACjE,QAAQA,aAAW,CAAC,IAAI,CAAC,MAAM,CAAC;YAC9B,KAAK,gBAAgB,EAAE,OAAQ,MAAoB,CAAC,MAAM,CAAC;YAC3D,KAAK,cAAc,EAAE,OAAQ,MAAgC,CAAC,IAAI,CAAC;YACnE,KAAK,cAAc,EAAE,OAAQ,MAAuB,CAAC,IAAI,CAAC;YAC1D,KAAK,iBAAiB,EAAE,OAAO,MAAgB,CAAC;YAChD,KAAK,eAAe,EAAE,OAAO,CAAC,CAAC;YAC/B,KAAK,oBAAoB,EAAE,OAAO,CAAC,CAAC;YACpC,SAAS,MAAM,IAAI,KAAK,CAAC,gBAAgBA,aAAW,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACtE;KACF;;IAGM,OAAO,CAAC,CAAK,EAAE,MAA8C,EAAE,IAA6D;QACjI,QAAQA,aAAW,CAAC,IAAI,CAAC,MAAM,CAAC;YAC9B,KAAK,gBAAgB,EAAE,OAAO,MAAM,CAAC,MAAmB,EAAE,IAAI,CAAC,CAAC;YAChE,KAAK,cAAc,EAAE,OAAO,IAAI,CAAC,MAA+B,EAAE,IAAI,CAAC,CAAC;YACxE,KAAK,cAAc,EAAE,OAAOC,MAAI,CAAC,MAAsB,EAAE,IAAI,CAAC,CAAC;YAC/D,KAAK,iBAAiB,EAAE,OAAO,OAAO,CAAC,MAAgB,EAAE,IAAI,CAAC,CAAC;YAC/D,KAAK,eAAe,EAAE,OAAO;YAC7B,KAAK,oBAAoB,EAAE,OAAO;YAClC,SAAS,MAAM,IAAI,KAAK,CAAC,uBAAuBD,aAAW,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SAC7E;KACF;IAEM,IAAI,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAsB;QACjD,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;YACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC7B;KACF;IAEM,MAAM,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAsB;QACnD,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE;YAC3B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC/B;KACF;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;KAC1C;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;AAED;;;;;MAKa,aAAa;IAOxB,YACkB,KAAwB,EACxB,cAA4CD,iBAAU;QADtD,UAAK,GAAL,KAAK,CAAmB;QACxB,gBAAW,GAAX,WAAW,CAA2C;QAEtE,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,eAAe,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;KACvC;IAZD,IAAW,KAAK,KAAmC,8BAAoC,EAAE;IAGzF,IAAW,OAAO,KAAY,OAAO,KAAK,CAAC,EAAE;IAC7C,IAAW,SAAS,KAAY,OAAO,KAAK,CAAC,EAAE;IAUxC,QAAQ,CAAC,CAAK,EAAE,CAAQ,EAAE,CAAkB,EAAE,CAAsB;QACzE,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;gBAChD,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAC3D,MAAM,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;aAC7B;YACD,OAAO,MAAM,CAAC;SACf;aAAM;YACL,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;SACvF;KACF;IAEM,MAAM,CAAC,EAAM,EAAE,EAAS,EAAE,EAAmB,EAAE,IAAa;QACjE,OAAO,KAAK,CAAC,CAAC;KACf;IAEM,MAAM,CAAI,OAAoB;QACnC,OAAO,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;KACzC;IAEM,QAAQ;QACb,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAC/B;CACF;AAED,SAAS,WAAW,CAAC,CAAK,EAAE,GAAW,EAAE,IAAY;IACnD,MAAM,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAI,GAAkB,CAAC,IAAI,CAAC,CAAC;IAC5D,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;QAC9B,OAAO,IAAuC,CAAC;KAChD;IACD,IAAI,EAAE,CAAC,wBAAmB,IAAI,IAAI,IAAI,IAAI,EAAE;QAC1C,OAAO,IAAI,CAAC;KACb;IACD,MAAM,IAAI,KAAK,CAAC,aAAa,IAAI,oBAAoB,CAAC,CAAC;AACzD,CAAC;AAED,SAAS,MAAM,CAAC,MAAiB,EAAE,IAA6D;IAC9F,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;QAC/C,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;KAC5B;AACH,CAAC;AAED,SAAS,IAAI,CAAC,MAA6B,EAAE,IAA6D;IACxG,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC/B,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACX,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;QACpC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC;KAClB;IACD,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACpB,CAAC;AAED,SAASE,MAAI,CAAC,MAAoB,EAAE,IAA6D;IAC/F,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC/B,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IACX,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,EAAE;QAC/B,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC;KAChB;IACD,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACpB,CAAC;AAED,SAAS,OAAO,CAAC,MAAc,EAAE,IAA6D;IAC5F,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;IAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE;QAC/B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;KACZ;IACD,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACpB;;ACn5CO,MAAM,GAAG,GAAG,OAAO,CAAC,cAAc,CAAC;SAC1B,gBAAgB,CAAC,GAAW,EAAE,GAAgB,EAAE,KAAc;IAC5E,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE;QACZ,UAAU,EAAE,KAAK;QACjB,YAAY,EAAE,IAAI;QAClB,QAAQ,EAAE,IAAI;QACd,KAAK;KACN,CAAC,CAAC;AACL,CAAC;SAEe,WAAW,CACzB,KAAQ,EACR,GAAM,EACN,YAAqB,EACrB,QAAiB,KAAK;IAEtB,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE;QAC9D,gBAAgB,CAAC,KAAK,EAAE,GAAG,EAAE,YAAY,CAAC,CAAC;KAC5C;AACH;;ACLA;;;;;;;;AAQYC;AAAZ,WAAY,WAAW;IACrB,mDAAiB,CAAA;IACjB,iDAAiB,CAAA;IACjB,qDAAiB,CAAA;IACjB,iDAAiB,CAAA;IACjB,mDAAiB,CAAA;AACnB,CAAC,EANWA,mBAAW,KAAXA,mBAAW,QAMtB;AAEiBC;AAAlB,WAAkB,cAAc;IAC9B,mDAA+C,CAAA;;;IAG/C,yFAA+C,CAAA;IAC/C,8FAA+C,CAAA;IAC/C,+FAA+C,CAAA;IAC/C,mFAA+C,CAAA;IAC/C,2DAA+C,CAAA;IAC/C,uGAA+C,CAAA;IAC/C,yEAA+C,CAAA;IAC/C,yFAA+C,CAAA;IAC/C,2DAA+C,CAAA;IAC/C,+DAA+C,CAAA;IAC/C,mEAA+C,CAAA;IAC/C,0FAA+C,CAAA;IAC/C,0DAA+C,CAAA;AACjD,CAAC,EAjBiBA,sBAAc,KAAdA,sBAAc,QAiB/B;AAQD;AACA,IAAkB,eAOjB;AAPD,WAAkB,eAAe;IAC/B,qDAAmB,CAAA;IACnB,mEAAwB,CAAA;IACxB,mEAAwB,CAAA;IACxB,mEAAwB,CAAA;IACxB,2EAAwB,CAAA;IACxB,oDAAwB,CAAA;AAC1B,CAAC,EAPiB,eAAe,KAAf,eAAe,QAOhC;AAEWC;AAAZ,WAAY,kBAAkB;IAC5B,2DAAa,CAAA;IACb,qEAAa,CAAA;IACb,mEAAa,CAAA;AACf,CAAC,EAJWA,0BAAkB,KAAlBA,0BAAkB,QAI7B;AAuEiBC;AAAlB,WAAkB,cAAc;IAC9B,yDAAgB,CAAA;IAChB,qDAAgB,CAAA;IAChB,qDAAgB,CAAA;IAChB,iDAAgB,CAAA;IAChB,iDAAgB,CAAA;AAClB,CAAC,EANiBA,sBAAc,KAAdA,sBAAc,QAM/B;AA8BiBC;AAAlB,WAAkB,YAAY;IAC5B,+CAA6B,CAAA;IAC7B,uDAA6B,CAAA;IAE7B,+CAA6B,CAAA;;;;;;;;;IAU7B,mDAA6B,CAAA;;;;IAI7B,uDAA6B,CAAA;IAE7B,kDAA6B,CAAA;IAC7B,8CAA6B,CAAA;IAC7B,8CAA6B,CAAA;AAC/B,CAAC,EAvBiBA,oBAAY,KAAZA,oBAAY,QAuB7B;SA8Be,YAAY,CAC1B,QAAgD,EAChD,YAAuB;IAEvB,MAAM,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;IAC5B,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAa,CAAC;IACtC,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,CAAC,GAAG,MAAM,EAAE;QACjB,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACrB,EAAE,CAAC,CAAC;KACL;IACD,IAAI,YAAY,KAAK,KAAK,CAAC,EAAE;QAC3B,GAAG,CAAC,YAAY,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KAC1C;SAAM,IAAI,QAAQ,CAAC,YAAY,KAAK,KAAK,CAAC,EAAE;QAC3C,GAAG,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KACnD;SAAM;QACL,GAAG,CAAC,YAAY,GAAG,EAAE,CAAC;KACvB;IACD,GAAG,CAAC,UAAU,GAAG,IAAI,CAAC;IACtB,OAAO,GAAG,CAAC;AACb,CAAC;SAEe,cAAc,CAAC,SAAiB,CAAC;IAC/C,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAa,CAAC;IACtC,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,CAAC,GAAG,MAAM,EAAE;QACjB,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC;KACd;IACD,GAAG,CAAC,YAAY,GAAG,EAAE,CAAC;IACtB,GAAG,CAAC,UAAU,GAAG,IAAI,CAAC;IACtB,OAAO,GAAG,CAAC;AACb,CAAC;SAEe,aAAa,CAAC,QAAkB;IAC9C,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAc,CAAC;IAC3C,KAAK,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;IACnD,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;IACxB,OAAO,KAAK,CAAC;AACf,CAAC;SAEe,UAAU,CAAC,KAAc;IACvC,OAAO,KAAK,YAAY,KAAK,IAAK,KAAkB,CAAC,UAAU,KAAK,IAAI,CAAC;AAC3E;;SC7PgB,oBAAoB,CAAC,MAAiB;IACpD,OAAO,MAAM,IAAI,IAAI,GAAG,wBAAwB,GAAG,wBAAwB,CAAC,MAAM,CAAC,CAAC;AACtF,CAAC;AAED,SAAS,wBAAwB,CAAC,MAAgB;IAChD,MAAM,KAAK,GAAG,MAAM,CAAC,SAAkC,CAAC;;;IAGxD,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,mBAAmB,EAAE,CAAC,CAAC;IAEjD,WAAW,CAAC,KAAK,EAAE,WAAW,EAAE,aAAa,CAAC,CAAC;IAC/C,WAAW,CAAC,KAAK,EAAE,aAAa,EAAE,gBAAgB,CAAC,CAAC;AACtD,CAAC;AACD;MAEa,gBAAgB;IAA7B;;;;QAIU,QAAG,gBAAe;QASnB,UAAK,GAAW,CAAC,CAAC;KAgK1B;IA9JQ,GAAG,CAAC,UAAa;QACtB,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YACxB,OAAO,KAAK,CAAC;SACd;QACD,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC;QACjC,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;YAC5C,IAAI,CAAC,GAAG,GAAG,UAAU,CAAC;YACtB,IAAI,CAAC,GAAG,wBAAmB;SAC5B;aAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;YACnD,IAAI,CAAC,GAAG,GAAG,UAAU,CAAC;YACtB,IAAI,CAAC,GAAG,wBAAmB;SAC5B;aAAM,IAAI,CAAC,eAAe,4BAAuB,CAAC,EAAE;YACnD,IAAI,CAAC,GAAG,GAAG,UAAU,CAAC;YACtB,IAAI,CAAC,GAAG,wBAAmB;SAC5B;aAAM,IAAI,CAAC,eAAe,gCAA2B,CAAC,EAAE;YACvD,IAAI,CAAC,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC;YACxB,IAAI,CAAC,GAAG,4BAAuB;SAChC;aAAM;YACL,IAAI,CAAC,GAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAC5B;QACD,EAAE,IAAI,CAAC,KAAK,CAAC;QACb,OAAO,IAAI,CAAC;KACb;IAEM,GAAG,CAAC,UAAa;;;;QAItB,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC;QACjC,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YACrE,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YACrE,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YACrE,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;YAC9C,MAAM,WAAW,GAAG,IAAI,CAAC,GAAI,CAAC;YAC9B,MAAM,EAAE,GAAG,WAAW,CAAC,MAAM,CAAC;YAC9B,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAClB,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBACjC,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;KACd;IAEM,GAAG;QACR,OAAO,IAAI,CAAC,GAAG,kBAAa;KAC7B;IAEM,MAAM,CAAC,UAAa;QACzB,MAAM,eAAe,GAAG,IAAI,CAAC,GAAG,CAAC;QACjC,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YACrE,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC;YAClB,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,8CAAoC;YACxD,EAAE,IAAI,CAAC,KAAK,CAAC;YACb,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YAC5E,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC;YAClB,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,8CAAoC;YACxD,EAAE,IAAI,CAAC,KAAK,CAAC;YACb,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,CAAC,eAAe,0BAAqB,CAAC,IAAI,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YAC5E,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC;YAClB,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,8CAAoC;YACxD,EAAE,IAAI,CAAC,KAAK,CAAC;YACb,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,CAAC,eAAe,8BAAyB,CAAC,EAAE;YACrD,MAAM,WAAW,GAAG,IAAI,CAAC,GAAI,CAAC;YAC9B,MAAM,EAAE,GAAG,WAAW,CAAC,MAAM,CAAC;YAC9B,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAClB,IAAI,WAAW,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;oBACjC,WAAW,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;oBACzB,IAAI,EAAE,KAAK,CAAC,EAAE;wBACZ,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,sDAA4C;qBACjE;oBACD,EAAE,IAAI,CAAC,KAAK,CAAC;oBACb,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;KACd;IAEM,MAAM,CAAC,GAAY,EAAE,MAAe,EAAE,KAAS;;;;;;;;QAQpD,MAAM,IAAI,GAAG,IAAI,CAAC,GAAkB,CAAC;QACrC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAkB,CAAC;QACrC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAkB,CAAC;QACrC,IAAI,IAAI,GAAG,IAAI,CAAC,GAAoB,CAAC;QACrC,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;SACrB;QAED,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;SACvC;QACD,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;SACvC;QACD,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;SACvC;QACD,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YACvB,IAAI,GAA4B,CAAC;YACjC,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAClB,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACd,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;oBAClB,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;iBACtC;aACF;SACF;KACF;IAEM,gBAAgB,CAAC,QAAkB,EAAE,KAAS;QACnD,MAAM,IAAI,GAAG,IAAI,CAAC,GAA4B,CAAC;QAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,GAA4B,CAAC;QAC/C,MAAM,IAAI,GAAG,IAAI,CAAC,GAA4B,CAAC;QAC/C,IAAI,IAAI,GAAG,IAAI,CAAC,GAA8B,CAAC;QAC/C,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;SACrB;QAED,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC9C;QACD,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC9C;QACD,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC9C;QACD,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;YACnB,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YACvB,IAAI,GAAsC,CAAC;YAC3C,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE;gBAClB,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACd,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE;oBAClB,GAAG,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;iBAC7C;aACF;SACF;KACF;CACF;AAED,SAAS,mBAAmB;IAC1B,MAAM,MAAM,GAAG,IAAI,gBAAgB,EAAE,CAAC;IACtC,gBAAgB,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACvC,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,aAAa,CAA8B,UAA0B;IAC5E,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAiD,CAAC,CAAC;AAC1E,CAAC;AAED,SAAS,gBAAgB,CAA8B,UAA0B;IAC/E,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAiD,CAAC,CAAC;AAC7E;;SCpNgB,cAAc,CAAC,MAAiB;IAC9C,OAAO,MAAM,IAAI,IAAI,GAAG,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;AAChE,CAAC;AAED,SAAS,aAAa,CAAC,MAAgB;IACrC,MAAM,KAAK,GAAG,MAAM,CAAC,SAA4B,CAAC;IAClD,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE,GAAG,EAAE,aAAa,EAAE,CAAC,CAAC;AAC9C,CAAC;MAWY,UAAU;IAAvB;QAGU,aAAQ,GAAY,KAAK,CAAC;QACjB,UAAK,GAAoB,IAAI,GAAG,EAAE,CAAC;KA4BrD;IA1BC,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;KACxB;IAEM,GAAG,CAAC,QAAoB;QAC7B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACzB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,OAAO;SACR;QACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,IAAI,IAAgB,CAAC;QACrB,IAAI;YACF,KAAK,IAAI,IAAI,KAAK,EAAE;gBAClB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACnB,IAAI,CAAC,KAAK,EAAE,CAAC;aACd;SACF;gBAAS;YACR,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;SACvB;KACF;IAEM,KAAK;QACV,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;KACvB;;AA9BsB,mBAAQ,GAAe,IAAI,UAAU,EAAE,CAAC;AAiCjE,SAAS,aAAa;IACpB,OAAO,UAAU,CAAC,QAAQ,CAAC;AAC7B;;MC7Ca,wBAAwB;IAWnC,YACkB,KAAgD;QAAhD,UAAK,GAAL,KAAK,CAA2C;QAR1D,MAAC,gBAAuC;QAEhC,SAAI,kBAAoC;QAQtD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,UAAU,EAAE,MAAM,CAAC;KACnE;IAEM,QAAQ;QACb,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;KACxB;IAEM,QAAQ,CAAC,QAAgB,EAAE,KAAqB;QACrD,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC;;;;QAIhC,IAAI,QAAQ,KAAK,YAAY,IAAIC,mBAAY,CAAC,QAAQ,CAAC,EAAE;YACvD,IAAI,CAAC,KAAK,0BAA+B,CAAC,EAAE;gBAC1C,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,QAAQ,CAAC;aAC5B;YACD,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;YACtB,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC;YAC7B,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,sBAAsB,CAAC,CAAW,EAAE,KAAqB;QAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,MAAM,QAAQ,EAAE;YACrC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,KAAK;QACVC,IAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAEA,IAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;KAC1C;CACF;MAIY,sBAAsB;IASjC,YACkB,KAAmE;QAAnE,UAAK,GAAL,KAAK,CAA8D;QAP7E,MAAC,gBAAuC;QAS9C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC;QAChE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,YAAY,GAAG,+BAAuC;KAC3E;IAEM,QAAQ;QACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;KACtB;IAEM,QAAQ;QACb,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;KAC1D;IAEM,sBAAsB,CAAC,CAAW,EAAE,KAAqB;QAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;QAC5B,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,MAAM,QAAQ,EAAE;YACrC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,KAAK;QACVA,IAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAEA,IAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;KAC1C;CACF;AAMD,SAAS,uBAAuB,CAAC,KAA2C;IAC1E,MAAM,KAAK,GAAG,KAAK,CAAC,SAAkC,CAAC;IACvD,WAAW,CAAC,KAAK,EAAE,WAAW,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;IACjD,WAAW,CAAC,KAAK,EAAE,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;IACrD,cAAc,CAAC,KAAK,CAAC,CAAC;IACtB,oBAAoB,CAAC,KAAK,CAAC,CAAC;AAC9B,CAAC;AAED,SAAS,SAAS,CAAqC,UAAuB;IAC5E,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QACtD,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;KAC5B;AACH,CAAC;AAED,SAAS,WAAW,CAAqC,UAAuB;IAC9E,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QACzD,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;KAC5B;AACH,CAAC;AAED,uBAAuB,CAAC,wBAAwB,CAAC,CAAC;AAClD,uBAAuB,CAAC,sBAAsB,CAAC,CAAC;AAEhD;AACA;AACA,IAAIA,IAAE,GAAY,KAAK,CAAC;;ACzHxB,MAAMC,gBAAc,GAAG,IAAI,OAAO,EAA4B,CAAC;AAE/D;AACA,SAAS,WAAW,CAAC,CAAU,EAAE,CAAU;IACzC,IAAI,CAAC,KAAK,CAAC,EAAE;QACX,OAAO,CAAC,CAAC;KACV;IACD,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAI,CAAQ,CAAC,QAAQ,EAAE,CAAC;IAC/C,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAI,CAAQ,CAAC,QAAQ,EAAE,CAAC;IAC/C,OAAQ,CAAQ,GAAI,CAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AACxC,CAAC;AAED,SAAS,cAAc,CAAC,CAAU,EAAE,CAAU;IAC5C,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAChB,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,OAAO,CAAC,CAAC;SACV;aAAM;YACL,OAAO,CAAC,CAAC;SACV;KACF;IACD,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;QAChB,OAAO,CAAC,CAAC,CAAC;KACX;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AAED,SAAS,aAAa,CAAC,GAAc,EAAE,QAAkB,EAAE,IAAY,EAAE,EAAU,EAAE,SAA6C;IAChI,IAAI,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC;IAC1C,IAAI,CAAC,EAAE,CAAC,CAAC;IACT,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;QAC9B,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;QAClB,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACvB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;YAC9B,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YACd,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACnB,KAAK,GAAG,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YAClC,IAAI,KAAK,GAAG,CAAC,EAAE;gBACb,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;gBAClB,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;aACxB;iBAAM;gBACL,MAAM;aACP;SACF;QACD,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;QACtB,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC;KAC5B;AACH,CAAC;AAED,SAAS,SAAS,CAAC,GAAc,EAAE,QAAkB,EAAE,IAAY,EAAE,EAAU,EAAE,SAA6C;IAC5H,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;IAC1B,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;IACf,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;IACf,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAClB,IAAI,IAAI,EAAE,IAAI,CAAC;IACf,IAAI,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,CAAC;IACtC,IAAI,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,CAAC;;IAG3C,OAAO,IAAI,EAAE;QACX,IAAI,EAAE,GAAG,IAAI,IAAI,EAAE,EAAE;YACnB,aAAa,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,SAAS,CAAC,CAAC;YAClD,OAAO;SACR;QAED,UAAU,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC;QACvC,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;QAAgB,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;QACnD,EAAE,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QAAc,EAAE,GAAG,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QACrD,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC;QAAU,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;QACzD,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QACxB,IAAI,GAAG,GAAG,CAAC,EAAE;YACX,IAAI,GAAG,EAAE,CAAC;YAAmB,IAAI,GAAG,EAAE,CAAC;YACvC,EAAE,GAAG,EAAE,CAAC;YAAqB,EAAE,GAAG,EAAE,CAAC;YACrC,EAAE,GAAG,IAAI,CAAC;YAAmB,EAAE,GAAG,IAAI,CAAC;SACxC;QACD,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;QACxB,IAAI,GAAG,IAAI,CAAC,EAAE;YACZ,IAAI,GAAG,EAAE,CAAC;YAAmB,IAAI,GAAG,EAAE,CAAC;YACvC,EAAE,GAAG,EAAE,CAAC;YAAqB,EAAE,GAAG,EAAE,CAAC;YACrC,EAAE,GAAG,EAAE,CAAC;YAAqB,EAAE,GAAG,EAAE,CAAC;YACrC,EAAE,GAAG,IAAI,CAAC;YAAmB,EAAE,GAAG,IAAI,CAAC;SACxC;aAAM;YACL,GAAG,GAAG,SAAS,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;YACxB,IAAI,GAAG,GAAG,CAAC,EAAE;gBACX,IAAI,GAAG,EAAE,CAAC;gBAAiB,IAAI,GAAG,EAAE,CAAC;gBACrC,EAAE,GAAG,EAAE,CAAC;gBAAmB,EAAE,GAAG,EAAE,CAAC;gBACnC,EAAE,GAAG,IAAI,CAAC;gBAAiB,EAAE,GAAG,IAAI,CAAC;aACtC;SACF;QACD,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;QAAgB,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;QACnD,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;QAAc,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;QACrD,MAAM,GAAG,EAAE,CAAC;QAAmB,MAAM,GAAG,EAAE,CAAC;QAC3C,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC;QAClB,SAAS,GAAG,EAAE,GAAG,CAAC,CAAC;QACnB,GAAG,CAAC,UAAU,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;QAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;QACvE,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;QAAU,QAAQ,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;QAEzD,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;YAClD,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAAW,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACpD,KAAK,GAAG,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;YACpC,IAAI,KAAK,GAAG,CAAC,EAAE;gBACb,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;gBAAM,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAC1D,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;gBAAI,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;gBACvD,MAAM,EAAE,CAAC;aACV;iBAAM,IAAI,KAAK,GAAG,CAAC,EAAE;gBACpB,GAAG;oBACD,SAAS,EAAE,CAAC;;oBAEZ,IAAI,SAAS,IAAI,CAAC,EAAE;wBAClB,MAAM,SAAS,CAAC;qBACjB;oBACD,WAAW,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;oBAAC,KAAK,GAAG,SAAS,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;iBACtE,QAAQ,KAAK,GAAG,CAAC,EAAE;gBACpB,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC;gBAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;gBAC7D,GAAG,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;gBAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC;gBAC1D,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;oBAAO,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;oBAChD,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;oBAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;oBACxD,GAAG,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;oBAAE,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;oBACrD,MAAM,EAAE,CAAC;iBACV;aACF;SACF;QAED,IAAI,EAAE,GAAG,SAAS,GAAG,MAAM,GAAG,IAAI,EAAE;YAClC,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,EAAE,EAAE,SAAS,CAAC,CAAC;YACnD,EAAE,GAAG,MAAM,CAAC;SACb;aAAM;YACL,SAAS,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;YAClD,IAAI,GAAG,SAAS,CAAC;SAClB;KACF;AACH,CAAC;AAED,MAAMC,OAAK,GAAG,KAAK,CAAC,SAAuE,CAAC;AAE5F,MAAM,KAAK,GAAGA,OAAK,CAAC,IAAI,CAAC;AACzB,MAAM,QAAQ,GAAGA,OAAK,CAAC,OAAO,CAAC;AAC/B,MAAM,IAAI,GAAGA,OAAK,CAAC,GAAG,CAAC;AACvB,MAAM,MAAM,GAAGA,OAAK,CAAC,KAAK,CAAC;AAC3B,MAAM,OAAO,GAAGA,OAAK,CAAC,MAAM,CAAC;AAC7B,MAAM,QAAQ,GAAGA,OAAK,CAAC,OAAO,CAAC;AAC/B,MAAM,KAAK,GAAGA,OAAK,CAAC,IAAI,CAAC;AAEzB,MAAMC,QAAM,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;AAC7H,MAAMC,SAAO,GAAqE,CAAC,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;AAEnJ,MAAMC,SAAO,GAAG;;IAEd,IAAI,EAAE,UAA2B,GAAG,IAAe;QACjD,MAAM,CAAC,GAAGJ,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SAChC;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7B,IAAI,QAAQ,KAAK,CAAC,EAAE;YAClB,OAAO,GAAG,CAAC;SACZ;QACD,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,CAAC;QACjD,IAAI,CAAC,GAAG,GAAG,CAAC;QACZ,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE;YACtB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;YACxB,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAE,CAAC,CAAC;YACpB,CAAC,EAAE,CAAC;SACL;QACD,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,IAAI,CAAC,MAAM,CAAC;KACpB;;IAED,OAAO,EAAE,UAA2B,GAAG,IAAe;QACpD,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACnC;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7B,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC;QACpC,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,QAAQ,EAAE;YACnB,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAE,CAAC,CAAC;SACpB;QACD,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACpC,MAAM,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACvC,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,GAAG,CAAC;KACZ;;IAED,GAAG,EAAE;QACH,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACxB;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;QAEhC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;QAClC,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;YACxB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;SAC7C;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpB,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,OAAO,CAAC;KAChB;;IAED,KAAK,EAAE;QACL,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC1B;QACD,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;QAElC,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;YACpB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;SACzC;QACD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACtB,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,OAAO,CAAC;KAChB;;IAED,MAAM,EAAE,UAA2B,GAAG,IAAoC;QACxE,MAAM,KAAK,GAAW,IAAI,CAAC,CAAC,CAAC,CAAC;QAC9B,MAAM,WAAW,GAAqB,IAAI,CAAC,CAAC,CAAC,CAAC;QAC9C,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SAClC;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,aAAa,GAAG,KAAK,GAAG,CAAC,CAAC;QAChC,MAAM,WAAW,GAAG,aAAa,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,aAAa,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;QAC1G,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7B,MAAM,iBAAiB,GAAG,QAAQ,KAAK,CAAC,GAAG,CAAC,GAAG,QAAQ,KAAK,CAAC,GAAG,GAAG,GAAG,WAAW,GAAG,WAAW,CAAC;QAChG,IAAI,iBAAiB,GAAG,CAAC,EAAE;YACzB,IAAI,CAAC,GAAG,WAAW,CAAC;YACpB,MAAM,EAAE,GAAG,CAAC,GAAG,iBAAiB,CAAC;YACjC,OAAO,CAAC,GAAG,EAAE,EAAE;gBACb,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzC;gBACD,CAAC,EAAE,CAAC;aACL;SACF;QACD,IAAI,QAAQ,GAAG,CAAC,EAAE;YAChB,MAAM,SAAS,GAAG,QAAQ,GAAG,CAAC,CAAC;YAC/B,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,SAAS,CAAC,CAAC;YACrC,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,SAAS,EAAE;gBACpB,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAE,CAAC,CAAC;aACpB;YACD,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC,CAAC;SACxD;aAAM;YACL,OAAO,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SAC/B;QACD,MAAM,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC1C,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,OAAO,CAAC;KAChB;;IAED,OAAO,EAAE;QACP,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACpB,OAAO,IAAI,CAAC;SACb;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,MAAM,MAAM,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,OAAO,KAAK,KAAK,MAAM,EAAE;YACvB,MAAM,KAAK,GAAG,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC;YAC9B,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;YAAE,MAAM,UAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACtE,MAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;YAAE,MAAM,UAAU,GAAG,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACtE,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YAAQ,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YAChE,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YAAQ,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;YAChE,KAAK,EAAE,CAAC;SACT;QACD,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,IAAI,CAAC;KACb;;;IAGD,IAAI,EAAE,UAA2B,SAA8C;QAC7E,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YAChB,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YAC5B,OAAO,IAAI,CAAC;SACb;QACD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,IAAI,GAAG,GAAG,CAAC,EAAE;YACX,OAAO,IAAI,CAAC;SACb;QACD,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,GAAG,EAAE,cAAc,CAAC,CAAC;QACpD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,OAAO,CAAC,GAAG,GAAG,EAAE;YACd,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,EAAE;gBACtB,MAAM;aACP;YACD,CAAC,EAAE,CAAC;SACL;QACD,IAAI,SAAS,KAAK,KAAK,CAAC,IAAI,OAAO,SAAS,KAAK,UAAU,4DAA2D;YACpH,SAAS,GAAG,WAAW,CAAC;SACzB;QACD,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,EAAE,SAAS,CAAC,CAAC;QAC7C,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,IAAI,CAAC;KACb;CACF,CAAC;AAEF,KAAK,MAAM,MAAM,IAAIG,SAAO,EAAE;IAC5B,GAAG,CAACC,SAAO,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;CAC7G;AAED,IAAI,4BAA4B,GAAG,KAAK,CAAC;SAEzB,sBAAsB;IACpC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;QAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;YACpC,gBAAgB,CAACA,OAAK,EAAE,MAAM,EAAEG,SAAO,CAAC,MAAM,CAAC,CAAC,CAAC;SAClD;KACF;AACH,CAAC;SAEe,uBAAuB;IACrC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;QAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;YACpC,gBAAgB,CAACA,OAAK,EAAE,MAAM,EAAEC,QAAM,CAAC,MAAM,CAAC,CAAC,CAAC;SACjD;KACF;AACH,CAAC;MAIY,aAAa;IAMxB,YAAmB,KAAgB;QAL5B,SAAI,kBAAoC;QAO7C,IAAI,CAAC,4BAA4B,EAAE;YACjC,4BAA4B,GAAG,IAAI,CAAC;YACpC,sBAAsB,EAAE,CAAC;SAC1B;QAED,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QAEzB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAC7C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;QAErBF,gBAAc,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;KACjC;IAEM,MAAM;QACX,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC;QAEtC,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;QACvC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,eAAsB,CAAC;KAC3D;IAEM,iBAAiB;;QACtB,aAAO,IAAI,CAAC,MAAM,oCAAX,IAAI,CAAC,MAAM,GAAK,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAC;KAC3D;IAEM,gBAAgB,CAAC,KAAa;;;;;QAGnC,mBAAO,IAAI,CAAC,cAAc,EAAC,KAAK,wCAAL,KAAK,IAAM,IAAI,kBAAkB,CAAC,IAAI,EAAE,KAAK,CAAC,EAAC;KAC3E;CACF;MAIY,kBAAkB;IAK7B,YACkB,KAAoB,EACpB,KAAa;QADb,UAAK,GAAL,KAAK,CAAe;QACpB,UAAK,GAAL,KAAK,CAAQ;QALxB,eAAU,GAAY,IAAI,CAAC;QAOhC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;KAC9B;IAEM,QAAQ;QACb,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC1C;IAEM,QAAQ,CAAC,QAAiB,EAAE,KAAqB;QACtD,IAAI,QAAQ,KAAK,IAAI,CAAC,QAAQ,EAAE,EAAE;YAChC,OAAO;SACR;QACD,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC;QACjC,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,MAAM,QAAQ,GAAG,aAAa,CAAC,QAAQ,CAAC;QAExC,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;YACxB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;SAC7C;QACD,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;;;QAGrB,aAAa,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;QAC3C,aAAa,CAAC,MAAM,EAAE,CAAC;KACxB;;;;IAKM,sBAAsB,CAAC,QAAkB,EAAE,KAAqB;QACrE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACzB,MAAM,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC;QAC3C,IAAI,QAAQ,EAAE;YACZ,OAAO;SACR;QACD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;QAC7B,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;;QAE/C,IAAI,SAAS,KAAK,SAAS,EAAE;YAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;SAC/C;KACF;IAEM,SAAS,CAAC,UAAuB;QACtC,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACtD,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAC5B;KACF;IAEM,WAAW,CAAC,UAAuB;QACxC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACzD,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SAC9B;KACF;CACF;AAED,oBAAoB,CAAC,aAAa,CAAC,CAAC;AACpC,oBAAoB,CAAC,kBAAkB,CAAC,CAAC;SAEzB,gBAAgB,CAAC,KAAgB;IAC/C,IAAI,QAAQ,GAAGA,gBAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IACzC,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvB,QAAQ,GAAG,IAAI,aAAa,CAAC,KAAK,CAAC,CAAC;KACrC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;;;;;;SAOgB,uBAAuB,CAAC,QAAkB;IACxD,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;IAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;QAC5B,OAAO,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,MAAM,EAAE;YAC7C,EAAE,CAAC,CAAC;YACJ,EAAE,MAAM,CAAC;SACV;QACD,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;YACtB,EAAE,MAAM,CAAC;SACV;aAAM;YACL,QAAQ,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC;SACvB;KACF;AACH,CAAC;AAED;;;;SAIgB,kBAAkB,CAAI,KAAU,EAAE,QAAkB;IAClE,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;IAE3B,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC;IAC5B,IAAI,EAAE,GAAG,CAAC,CAAC;IACX,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,OAAO,EAAE,GAAG,GAAG,EAAE;QACf,IAAI,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;QACpB,IAAI,IAAI,KAAK,CAAC,CAAC,EAAE;YACf,KAAK,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;SACxB;QACD,EAAE,EAAE,CAAC;KACN;AACH;;ACvfA,MAAMA,gBAAc,GAAG,IAAI,OAAO,EAA6B,CAAC;AAEhE,MAAMC,OAAK,GAAG,GAAG,CAAC,SAA6E,CAAC;AAEhG,MAAM,IAAI,GAAGA,OAAK,CAAC,GAAG,CAAC;AACvB,MAAMI,QAAM,GAAGJ,OAAK,CAAC,KAAK,CAAC;AAC3B,MAAMK,SAAO,GAAGL,OAAK,CAAC,MAAM,CAAC;AAE7B,MAAMC,QAAM,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAEG,QAAM,EAAE,MAAM,EAAEC,SAAO,EAAE,CAAC;AAC7D,MAAMH,SAAO,GAA+B,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;AAEvE;AACA;AAEA,MAAMC,SAAO,GAAG;;IAEd,GAAG,EAAE,UAA8B,KAAc;QAC/C,MAAM,CAAC,GAAGJ,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YACvB,OAAO,IAAI,CAAC;SACb;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACvB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,OAAO,KAAK,OAAO,EAAE;YACvB,OAAO,IAAI,CAAC;SACb;QACD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;QACzB,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,IAAI,CAAC;KACb;;IAED,KAAK,EAAE;QACL,MAAM,CAAC,GAAGA,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAOK,QAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC1B;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;YAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;;YAEV,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;gBAC3B,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzC;gBACD,CAAC,EAAE,CAAC;aACL;YACDA,QAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClB,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;YACpB,CAAC,CAAC,MAAM,EAAE,CAAC;SACZ;QACD,OAAO,SAAS,CAAC;KAClB;;IAED,MAAM,EAAE,UAA8B,KAAc;QAClD,MAAM,CAAC,GAAGL,gBAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAOM,SAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SAClC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,KAAK,CAAC,EAAE;YACd,OAAO,KAAK,CAAC;SACd;QACD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;YAC/B,IAAI,KAAK,KAAK,KAAK,EAAE;gBACnB,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzC;gBACD,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACtB,MAAM,YAAY,GAAGA,SAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC/C,IAAI,YAAY,KAAK,IAAI,EAAE;oBACzB,CAAC,CAAC,MAAM,EAAE,CAAC;iBACZ;gBACD,OAAO,YAAY,CAAC;aACrB;YACD,CAAC,EAAE,CAAC;SACL;QACD,OAAO,KAAK,CAAC;KACd;CACF,CAAC;AAEF,MAAMC,iBAAe,GAAG;IACtB,QAAQ,EAAE,IAAI;IACd,UAAU,EAAE,KAAK;IACjB,YAAY,EAAE,IAAI;CACnB,CAAC;AAEF,KAAK,MAAM,MAAM,IAAIJ,SAAO,EAAE;IAC5B,GAAG,CAACC,SAAO,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;CAC7G;AAED,IAAI,0BAA0B,GAAG,KAAK,CAAC;SAEvB,oBAAoB;IAClC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;QAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;YACpC,GAAG,CAACA,OAAK,EAAE,MAAM,EAAE,EAAE,GAAGM,iBAAe,EAAE,KAAK,EAAEH,SAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACpE;KACF;AACH,CAAC;SAEe,qBAAqB;IACnC,KAAK,MAAM,MAAM,IAAID,SAAO,EAAE;QAC5B,IAAIF,OAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;YACpC,GAAG,CAACA,OAAK,EAAE,MAAM,EAAE,EAAE,GAAGM,iBAAe,EAAE,KAAK,EAAEL,QAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACnE;KACF;AACH,CAAC;MAIY,WAAW;IAItB,YAAmB,WAAyB;QAHrC,SAAI,gBAAkC;QAK3C,IAAI,CAAC,0BAA0B,EAAE;YAC/B,0BAA0B,GAAG,IAAI,CAAC;YAClC,oBAAoB,EAAE,CAAC;SACxB;QAED,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC;QAC9B,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACjD,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;QAErBF,gBAAc,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;KACvC;IAEM,MAAM;QACX,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QAElC,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,eAAsB,CAAC;KAC3D;IAEM,iBAAiB;;QACtB,aAAO,IAAI,CAAC,MAAM,oCAAX,IAAI,CAAC,MAAM,GAAK,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAC;KACzD;CACF;AAED,oBAAoB,CAAC,WAAW,CAAC,CAAC;SAElB,cAAc,CAAC,WAAyB;IACtD,IAAI,QAAQ,GAAGA,gBAAc,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAC/C,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvB,QAAQ,GAAG,IAAI,WAAW,CAAC,WAAW,CAAC,CAAC;KACzC;IACD,OAAO,QAAQ,CAAC;AAClB;;ACzJA,MAAM,cAAc,GAAG,IAAI,OAAO,EAAsC,CAAC;AAEzE,MAAM,KAAK,GAAG,GAAG,CAAC,SAAuF,CAAC;AAE1G,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC;AACvB,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC;AAC3B,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC;AAE7B,MAAM,MAAM,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC;AAC7D,MAAM,OAAO,GAA+B,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;AAEvE;AACA;AAEA,MAAM,OAAO,GAAG;;IAEd,GAAG,EAAE,UAAuC,GAAY,EAAE,KAAc;QACtE,MAAM,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAC5B,OAAO,IAAI,CAAC;SACb;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAC5B,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,IAAI,OAAO,KAAK,OAAO,EAAE;YACvB,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;gBAClC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;oBACpB,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;wBACzB,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC5C,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;wBACnB,CAAC,CAAC,MAAM,EAAE,CAAC;qBACZ;oBACD,OAAO,IAAI,CAAC;iBACb;gBACD,CAAC,EAAE,CAAC;aACL;YACD,OAAO,IAAI,CAAC;SACb;QACD,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;QACzB,CAAC,CAAC,MAAM,EAAE,CAAC;QACX,OAAO,IAAI,CAAC;KACb;;IAED,KAAK,EAAE;QACL,MAAM,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC1B;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;YAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;;YAEV,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;gBAC3B,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzC;gBACD,CAAC,EAAE,CAAC;aACL;YACD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClB,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;YACpB,CAAC,CAAC,MAAM,EAAE,CAAC;SACZ;QACD,OAAO,SAAS,CAAC;KAClB;;IAED,MAAM,EAAE,UAAuC,KAAc;QAC3D,MAAM,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,KAAK,SAAS,EAAE;YACnB,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SAClC;QACD,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAI,IAAI,KAAK,CAAC,EAAE;YACd,OAAO,KAAK,CAAC;SACd;QACD,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC;QAC5B,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,EAAE;YAC/B,IAAI,KAAK,KAAK,KAAK,EAAE;gBACnB,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oBACpB,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzC;gBACD,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACtB,MAAM,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;gBAC/C,IAAI,YAAY,KAAK,IAAI,EAAE;oBACzB,CAAC,CAAC,MAAM,EAAE,CAAC;iBACZ;gBACD,OAAO,YAAY,CAAC;aACrB;YACD,EAAE,CAAC,CAAC;SACL;QACD,OAAO,KAAK,CAAC;KACd;CACF,CAAC;AAEF,MAAM,eAAe,GAAG;IACtB,QAAQ,EAAE,IAAI;IACd,UAAU,EAAE,KAAK;IACjB,YAAY,EAAE,IAAI;CACnB,CAAC;AAEF,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;IAC5B,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;CAC7G;AAED,IAAI,0BAA0B,GAAG,KAAK,CAAC;SAEvB,oBAAoB;IAClC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC5B,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;YACpC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,GAAG,eAAe,EAAE,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACpE;KACF;AACH,CAAC;SAEe,qBAAqB;IACnC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC5B,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,SAAS,KAAK,IAAI,EAAE;YACpC,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,GAAG,eAAe,EAAE,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACnE;KACF;AACH,CAAC;MAIY,WAAW;IAItB,YAAmB,GAA0B;QAHtC,SAAI,gBAAkC;QAK3C,IAAI,CAAC,0BAA0B,EAAE;YAC/B,0BAA0B,GAAG,IAAI,CAAC;YAClC,oBAAoB,EAAE,CAAC;SACxB;QAED,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;QACtB,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACzC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;QAErB,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;KAC/B;IAEM,MAAM;QACX,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QAElC,IAAI,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,eAAsB,CAAC;KAC3D;IAEM,iBAAiB;;QACtB,aAAO,IAAI,CAAC,MAAM,oCAAX,IAAI,CAAC,MAAM,GAAK,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAC;KACzD;CACF;AAED,oBAAoB,CAAC,WAAW,CAAC,CAAC;SAElB,cAAc,CAAC,GAA0B;IACvD,IAAI,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvB,QAAQ,GAAG,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC;KACjC;IACD,OAAO,QAAQ,CAAC;AAClB;;ACjJA,SAAS,eAAe,CAA4B,GAAW,EAAE,GAAgB;IAC/E,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;;;;;;;;IAQ5D,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AACzB,CAAC;AACD,SAAS,iBAAiB;IACxB,MAAM,MAAM,GAAG,IAAI,qBAAqB,CAAC,IAAI,CAAC,CAAC;IAC/C,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;IACtC,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,iBAAiB,CAA4B,UAAsB;IAC1E,IAAI,GAAuB,CAAC;IAC5B,IAAI,UAAU,YAAY,KAAK,EAAE;QAC/B,GAAG,GAAG,gBAAgB,CAAC,UAAU,CAAC,CAAC;KACpC;SAAM,IAAI,UAAU,YAAY,GAAG,EAAE;QACpC,GAAG,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC;KAClC;SAAM,IAAI,UAAU,YAAY,GAAG,EAAE;QACpC,GAAG,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC;KAClC;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;KAClD;IACD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACpB,CAAC;AAED,SAAS,WAAW,CAA4B,YAAqD;IACnG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAC7B,CAAC;AAED,SAAS,gBAAgB;IACvB,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;AAC3D,CAAC;AAED,SAAS,0BAA0B;IACjC,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;AACrE,CAAC;MASY,qBAAqB;IAKhC,YACS,OAA4B;QAA5B,YAAO,GAAP,OAAO,CAAqB;QAL9B,YAAO,GAAW,CAAC,CAAC;QACpB,UAAK,GAAW,CAAC,CAAC;QAClB,UAAK,GAAW,CAAC,CAAC;KAKxB;IAEM,YAAY,CAAC,KAAc,EAAE,QAAiB,EAAE,KAAqB;QAC1E,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;KACtE;IAEM,sBAAsB,CAAC,QAAkB,EAAE,KAAqB;QACrE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,sBAAsB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;KAClE;;;;IAKM,GAAG,CAAC,QAAiD;;QAE1D,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC;QACjC,IAAI,CAAC,GAAG,aAAa,CAAC;;QAGtB,OAAO,CAAC,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,QAAQ;YAAC,CAAC;;QAG3C,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACZ,CAAC,GAAG,CAAC,CAAC;;YAEN,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE;gBAChC,CAAC,EAAE,CAAC;aACL;;YAED,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC;YAC1B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;;YAEzB,IAAI,CAAC,KAAK,aAAa,EAAE;gBACvB,IAAI,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;aACpB;YACD,EAAE,IAAI,CAAC,KAAK,CAAC;SACd;QACD,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;KAC/B;;;;IAKM,KAAK,CAAC,GAAa;QACxB,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC;QAC7B,IAAI,QAAgB,CAAC;QACrB,IAAI,QAA+E,CAAC;QACpF,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,IAAI,GAAG,KAAK,IAAI,EAAE;YAChB,OAAO,CAAC,GAAG,SAAS,EAAE,EAAE,CAAC,EAAE;gBACzB,QAAQ,GAAG,KAAK,CAAC,EAAE,CAAC;gBACpB,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAA0E,CAAC;gBACnG,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;oBACvB,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,CAAC;oBACxB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;iBAC5B;aACF;YACD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;SAC7B;aAAM;YACL,OAAO,CAAC,GAAG,SAAS,EAAE,EAAE,CAAC,EAAE;gBACzB,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,IAAI,CAAC,OAAO,EAAE;oBACnC,QAAQ,GAAG,KAAK,CAAC,EAAE,CAAC;oBACpB,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAA0E,CAAC;oBACnG,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;wBACvB,IAAI,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,CAAC;wBACxB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;wBAC3B,IAAI,CAAC,KAAK,EAAE,CAAC;qBACd;iBACF;aACF;SACF;KACF;CACF;AAMD,SAAS,oBAAoB,CAAiB,MAA8C;IAC1F,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;IAC/B,WAAW,CAAC,KAAK,EAAE,iBAAiB,EAAE,eAAe,EAAE,IAAI,CAAC,CAAC;IAC7D,WAAW,CAAC,KAAK,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,IAAI,CAAC,CAAC;IACjE,WAAW,CAAC,KAAK,EAAE,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;IACrD,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,GAAG,EAAE,iBAAiB,EAAE,CAAC,CAAC;;IAE9C,WAAW,CAAC,KAAK,EAAE,cAAc,EAAE,gBAAgB,CAAC,CAAC;IACrD,WAAW,CAAC,KAAK,EAAE,wBAAwB,EAAE,0BAA0B,CAAC,CAAC;IAEzE,OAAO,MAAM,CAAC;AAChB,CAAC;SAIe,WAAW,CAAiB,MAA+C;IACzF,OAAO,MAAM,IAAI,IAAI,GAAG,oBAAoB,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;AAC9E,CAAC;MAQY,eAAe;IAG1B,YACkB,GAAM,EACN,OAA2B,EACpC,eAAiC,EACjC,OAAwB;QAHf,QAAG,GAAH,GAAG,CAAG;QACN,YAAO,GAAP,OAAO,CAAoB;QACpC,oBAAe,GAAf,eAAe,CAAkB;QACjC,YAAO,GAAP,OAAO,CAAiB;QAN1B,gBAAW,GAAG,IAAI,CAAC;KAQzB;IAEM,KAAK;QACV,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC5C;IAEM,OAAO;QACZ,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC5C;IAEM,YAAY,CAAC,QAAiB,EAAE,aAAsB,EAAE,KAAqB;QAClF,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;KACxD;CACF;AAED,oBAAoB,CAAC,eAAe,CAAC;;MC5KxB,iBAAiB,GAAGlB,SAAE,CAAC,eAAe,CAAoB,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,gBAAgB,CAAC,EAAE;MAEnH,gBAAgB;IAA7B;QACmB,qBAAgB,GAAsC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC1E,gBAAW,GAAmC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAClE,wBAAmB,GAAkC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;KA+C3F;IAzCQ,KAAK,CAAC,UAAkB,EAAE,WAAwB;QACvD,QAAQ,WAAW;YACjB,+BAAgC;gBAC9B,IAAI,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;gBACjD,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;oBACpB,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;iBACrF;gBACD,OAAO,KAAK,CAAC;aACd;YACD,2BAA6B;gBAC3B,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;gBACzC,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;oBACpB,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;iBAC7E;gBACD,OAAO,KAAK,CAAC;aACd;YACD,SAAS;;;gBAGP,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,KAAK,WAAW,IAAI,wEAAiF,CAAC,EAAE;oBACjI,OAAO,0BAA0B,CAAC,MAAM,CAAC;iBAC1C;gBACD,IAAI,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBAC9C,IAAI,KAAK,KAAK,KAAK,CAAC,EAAE;oBACpB,KAAK,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;iBAClF;gBACD,OAAO,KAAK,CAAC;aACd;SACF;KACF;IAKO,MAAM,CAAC,UAAkB,EAAE,WAAwB;QACzD,MAAM,CAAC,KAAK,GAAG,UAAU,CAAC;QAC1B,MAAM,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;QAClC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;QACjB,MAAM,CAAC,WAAW,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAC9C,OAAO,KAAK,CAAC,MAAM,oCAAqC,WAAW,KAAK,KAAK,CAAC,0BAA6B,WAAW,CAAC,CAAC;KACzH;CACF;AAEiB0B;AAAlB,WAAkB,IAAI;IACpB,+BAAqB,CAAA;IACrB,yCAAqB,CAAA;IACrB,6BAAqB,CAAA;IACrB,wCAAqB,CAAA;IACrB,8CAAqB,CAAA;IACrB,wCAAqB,CAAA;IACrB,oDAAqB,CAAA;IACrB,kCAAqB,CAAA;IACrB,8CAAqB,CAAA;IACrB,8CAAqB,CAAA;IACrB,oCAAqB,CAAA;IACrB,sCAAqB,CAAA;IACrB,0CAAqB,CAAA;IACrB,8CAAqB,CAAA;IACrB,0CAAqB,CAAA;IACrB,4CAAqB,CAAA;IACrB,wCAAqB,CAAA;IACrB,gCAAqB,CAAA;IACrB,kCAAqB,CAAA;IACrB,kCAAqB,CAAA;IACrB,8BAAqB,CAAA;IACrB,kCAAqB,CAAA;IACrB,0CAAqB,CAAA;IACrB,wCAAqB,CAAA;IACrB,8CAAqB,CAAA;IACrB,0CAAqB,CAAA;IACrB,gDAAqB,CAAA;IACrB,kCAAqB,CAAA;IACrB,4CAAqB,CAAA;IACrB,2CAAqB,CAAA;IACrB,+BAAqB,CAAA;IACrB,6CAAqB,CAAA;IACrB,kCAAqB,CAAA;IACrB,wCAAqB,CAAA;IACrB,oCAAqB,CAAA;IACrB,8CAAqB,CAAA;IACrB,wCAAqB,CAAA;IAErB,gCAAa,CAAA;IACb,8BAAa,CAAA;IACb,8BAAa,CAAA;IACb,kCAAa,CAAA;IACb,gCAAa,CAAA;IACb,gCAAa,CAAA;IACb,8BAAa,CAAA;IACb,kCAAa,CAAA;IACb,kCAAa,CAAA;IACb,gCAAa,CAAA;IAEb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IACb,oCAAa,CAAA;IAEb,oCAAc,CAAA;IACd,oCAAc,CAAA;IACd,oCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;IACd,qCAAc,CAAA;AAChB,CAAC,EAvGiBA,YAAI,KAAJA,YAAI,QAuGrB;AAED,SAAS,YAAY,CAAC,IAAY;IAChC,QAAQ,IAAI;QACV,sBAAkB,yBAAsB;QACxC,uBAAkB,mBAAgB;QAClC,uBAAkB,yBAAqB;QACvC,uBAAkB,4BAAwB;QAC1C,uBAAkB,yBAAqB;QACvC,uBAAkB,+BAA2B;QAC7C,2BAAuB,4BAAwB;QAC/C,2BAAuB,4BAAwB;QAC/C,yBAAqB,0BAAsB;QAC3C,SAAS,OAAO,IAAI,CAAC;KACtB;AACH,CAAC;AAEiBC;AAAlB,WAAkB,MAAM;IACtB,qCAAyC,CAAA;IACzC,6CAAyC,CAAA;IACzC,qCAAyC,CAAA;IACzC,wCAAyC,CAAA;IACzC,0CAAyC,CAAA;IACzC,wCAAyC,CAAA;AAC3C,CAAC,EAPiBA,cAAM,KAANA,cAAM,QAOvB;AAEiBC;AAAlB,WAAkB,UAAU;IAC1B,oDAAqC,CAAA;IACrC,gDAAqC,CAAA;IACrC,0DAAqC,CAAA;IACrC,sDAAqC,CAAA;IACrC,yDAAqC,CAAA;IACrC,qDAAqC,CAAA;IACrC,yDAAqC,CAAA;IACrC,qDAAqC,CAAA;IACrC,iEAAqC,CAAA;IACrC,iDAAqC,CAAA;IACrC,6DAAqC,CAAA;IACrC,mDAAqC,CAAA;IACrC,+CAAqC,CAAA;AACvC,CAAC,EAdiBA,kBAAU,KAAVA,kBAAU,QAc3B;AACD,IAAW,KA6DV;AA7DD,WAAW,KAAK;IACd,qCAAmD,CAAA;IACnD,mEAAmD,CAAA;IACnD,oEAAmD,CAAA;IACnD,sDAAmD,CAAA;IACnD,sDAAmD,CAAA;IACnD,6CAAmD,CAAA;IACnD,2CAAmD,CAAA;IACnD,qDAAmD,CAAA;IACnD,yEAAmD,CAAA;IACnD,wDAAmD,CAAA;IACnD,sDAAmD,CAAA;IACnD,wDAAmD,CAAA;IACnD,0CAAmD,CAAA;IACnD,gDAAmD,CAAA;IACnD,+CAAmD,CAAA;IACnD,+CAAmD,CAAA;IACnD,kCAAmD,CAAA;IACnD,oDAAmD,CAAA;IACnD,kDAAmD,CAAA;IACnD,kDAAmD,CAAA;IACnD,4DAAmD,CAAA;IACnD,8CAAmD,CAAA;;IAEnD,kDAAmD,CAAA;IACnD,gDAAmD,CAAA;IACnD,gDAAmD,CAAA;IACnD,mCAAmD,CAAA;IACnD,mDAAmD,CAAA;IACnD,mDAAmD,CAAA;IACnD,yCAAmD,CAAA;IACnD,oDAAmD,CAAA;IACnD,uDAAmD,CAAA;IACnD,yCAAmD,CAAA;IACnD,+CAAmD,CAAA;IACnD,iDAAmD,CAAA;IACnD,qCAAmD,CAAA;IACnD,2CAAmD,CAAA;IACnD,mEAAmD,CAAA;IACnD,uDAAmD,CAAA;IACnD,iEAAmD,CAAA;IACnD,mEAAmD,CAAA;IACnD,6EAAmD,CAAA;IACnD,+CAAmD,CAAA;IACnD,qDAAmD,CAAA;IACnD,2DAAmD,CAAA;IACnD,iEAAmD,CAAA;IACnD,iDAAmD,CAAA;IACnD,iEAAmD,CAAA;IACnD,sCAAmD,CAAA;IACnD,wCAAmD,CAAA;IACnD,uDAAmD,CAAA;IACnD,mDAAmD,CAAA;IACnD,+CAAmD,CAAA;IACnD,6CAAmD,CAAA;IACnD,yCAAmD,CAAA;IACnD,2CAAmD,CAAA;IACnD,mDAAmD,CAAA;IACnD,sDAAmD,CAAA;IACnD,sEAAmD,CAAA;IACnD,iDAAmD,CAAA;AACrD,CAAC,EA7DU,KAAK,KAAL,KAAK,QA6Df;AAED,MAAM,MAAM,GAAG,0BAA0B,CAAC,MAAM,CAAC;AACjD,MAAM,KAAK,GAAG,0BAA0B,CAAC,KAAK,CAAC;AAC/C,MAAM,KAAK,GAAG,0BAA0B,CAAC,KAAK,CAAC;AAC/C,MAAM,UAAU,GAAG,0BAA0B,CAAC,UAAU,CAAC;AACzD,MAAM,KAAK,GAAG,oBAAoB,CAAC,KAAK,CAAC;AACzC,MAAM,OAAO,GAAG,oBAAoB,CAAC,OAAO,CAAC;AAE3BC;AAAlB,WAAkB,WAAW;IACb,6CAAQ,CAAA;;;;;IAKd,4DAA6B,CAAA;IAChC,kEAAgC,CAAA;IAC7B,kDAA6B,CAAA;IAC7B,2DAA6B,CAAA;IAC7B,uDAA6B,CAAA;IAC7B,2DAA6B,CAAA;IAC7B,oDAA6B,CAAA;IAC7B,0DAA6B,CAAA;IAC7B,wDAA6B,CAAA;IACrC,wEAAqC,CAAA;IAClC,kEAAkC,CAAA;IACrC,mFAAqC,CAAA;IAE1B,oDAA0B,CAAA;IACjC,kEAAiC,CAAA;IACjC,gEAAiC,CAAA;IAClC,oEAAkC,CAAA;IAChC,gEAAgC,CAAA;IAC9B,4DAA8B,CAAA;IACjC,oEAAiC,CAAA;IACjC,oEAAiC,CAAA;IAClC,sEAAkC,CAAA;IAC9B,6DAA8B,CAAA;IACjC,kEAAiC,CAAA;IAC7B,2DAA6B,CAAA;IAChC,iEAAgC,CAAA;AACvC,CAAC,EAhCiBA,mBAAW,KAAXA,mBAAW,QAgC5B;AACD;AAEA;MACa,WAAW;IAatB,YACS,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;QAbf,UAAK,GAAW,CAAC,CAAC;QAClB,eAAU,GAAW,CAAC,CAAC;QACvB,cAAS,GAAW,CAAC,CAAC;QAEtB,iBAAY,qBAAoB;QAChC,eAAU,GAAoB,EAAE,CAAC;QAEjC,eAAU,GAAY,IAAI,CAAC;QAQhC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC3B,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;KACxC;IATD,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;KACtD;CAQF;AAED,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC,CAAC;AAEnC;SACgB,eAAe,CAAsD,KAAa,EAAE,WAAmB;IAKrH,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;IAC7B,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;IACjB,MAAM,CAAC,WAAW,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IACzC,OAAO,KAAK,CAAC,MAAM,oCAAqC,WAAW,KAAK,KAAK,CAAC,0BAA6B,WAAW,CAAC,CAAC;AAC1H,CAAC;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;SACgB,KAAK,CAAsD,KAAkB,EAAE,MAAc,EAAE,aAAoB,EAAE,WAAkB;IAkBrJ,IAAI,WAAW,8BAAgC;QAC7C,OAAO,IAAI,gBAAgB,CAAC,KAAK,CAAC,KAAK,CAAQ,CAAC;KACjD;IAED,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE;QACrB,IAAI,WAAW,6BAA8B;;YAE3C,OAAO,kBAAkB,CAAC,KAAK,CAAQ,CAAC;SACzC;QACD,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,IAAI,KAAK,CAAC,YAAY,qCAA6B;YACjD,MAAM,IAAI,KAAK,CAAC,iCAAiC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SAClE;KACF;IAED,KAAK,CAAC,UAAU,GAAG,mBAAoB,aAAa,CAAC;IACrD,IAAI,MAAM,GAAG,KAAK,CAAuC,CAAC;IAE1D,IAAI,KAAK,CAAC,YAAY,wBAAkB;;;;;;;;;;;;;;;;;;QAkBtC,MAAM,EAAE,GAAG,WAAW,CAAC,KAAK,CAAC,YAAY,iBAA+B,CAAC;QACzE,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,MAAM,GAAG,IAAI,eAAe,CAAC,EAAE,EAAE,KAAK,CAAC,KAAK,EAAE,MAAM,0BAA2B,WAAW,CAAC,CAAC,CAAC;QAC7F,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;KAC1B;SAAM;;;;;;;;;;;;;;;;;;;;;;;;;;QA0BL,OAAO,EAAE,QAAQ,KAAK,CAAC,YAAY;YACjC;gBACE,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;gBACzB,GAAG;oBACD,SAAS,CAAC,KAAK,CAAC,CAAC;oBACjB,MAAM,EAAE,CAAC;oBACT,IAAI,UAAU,CAAC,KAAK,kBAAY,EAAE;wBAChC,IAAK,KAAK,CAAC,YAAsB,sBAAgB;4BAC/C,MAAM,IAAI,KAAK,CAAC,uDAAuD,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;yBACxF;6BAAM,IAAK,KAAK,CAAC,YAAsB,wBAAgB;4BACtD,MAAM,IAAI,KAAK,CAAC,yBAAyB,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;yBAC1D;qBACF;yBAAM,IAAI,KAAK,CAAC,YAAY,qCAA8B;wBACzD,MAAM,QAAQ,GAAG,MAAM,sBAAmB;wBAC1C,MAAM,GAAG,QAAQ,KAAK,CAAC,GAAG,KAAK,GAAG,QAAQ,KAAK,CAAC,GAAG,OAAO,GAAG,IAAI,oBAAoB,CAAC,QAAQ,CAAC,CAAC;wBAChG,MAAM,kBAAe;wBACrB,MAAM,OAAO,CAAC;qBACf;yBAAM;wBACL,MAAM,IAAI,KAAK,CAAC,+BAA+B,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;qBAChE;iBACF,QAAQ,KAAK,CAAC,YAAY,6BAAwB;;YAErD;gBACE,IAAI,WAAW,yBAA2B;oBACxC,MAAM,GAAG,IAAI,iBAAiB,CAAC,KAAK,CAAC,UAAoB,CAAC,CAAC;iBAC5D;qBAAM;oBACL,MAAM,GAAG,IAAI,qBAAqB,CAAC,KAAK,CAAC,UAAoB,EAAE,MAAM,sBAAmB,CAAC;oBACzF,MAAM,oBAAgB;iBACvB;gBACD,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;gBACxB,SAAS,CAAC,KAAK,CAAC,CAAC;gBACjB,MAAM;YACR;gBACE,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;gBACzB,SAAS,CAAC,KAAK,CAAC,CAAC;gBACjB,MAAM,GAAG,KAAK,CAAC;gBACf,MAAM,kBAAe;gBACrB,MAAM;YACR;gBACE,SAAS,CAAC,KAAK,CAAC,CAAC;gBACjB,MAAM,GAAG,KAAK,CAAC,KAAK,kCAAmC,WAAW,CAAC,CAAC;gBACpE,OAAO,CAAC,KAAK,2BAAmB,CAAC;gBACjC,MAAM,iBAAgB;gBACtB,MAAM;YACR;gBACE,MAAM,GAAG,2BAA2B,CAAC,KAAK,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;gBACjE,MAAM,iBAAgB;gBACtB,MAAM;YACR;gBACE,MAAM,GAAG,4BAA4B,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;gBAC1D,MAAM,iBAAgB;gBACtB,MAAM;YACR;gBACE,MAAM,GAAG,IAAI,kBAAkB,CAAC,CAAC,KAAK,CAAC,UAAoB,CAAC,CAAC,CAAC;gBAC9D,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;gBACzB,SAAS,CAAC,KAAK,CAAC,CAAC;gBACjB,MAAM,iBAAgB;gBACtB,MAAM;YACR;gBACE,MAAM,GAAG,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE,MAAwB,EAAE,KAAK,CAAC,CAAC;gBACpF,MAAM,iBAAgB;gBACtB,MAAM;YACR,8BAAyB;YACzB;gBACE,MAAM,GAAG,IAAI,0BAA0B,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;gBAC1D,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;gBACzB,SAAS,CAAC,KAAK,CAAC,CAAC;gBACjB,MAAM,iBAAgB;gBACtB,MAAM;YACR,4BAAuB;YACvB,iCAA4B;YAC5B,4BAAuB;YACvB;gBACE,MAAM,GAAG,WAAW,CAAC,KAAK,CAAC,YAAY,iBAA4C,CAAC;gBACpF,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;gBACzB,SAAS,CAAC,KAAK,CAAC,CAAC;gBACjB,MAAM,iBAAgB;gBACtB,MAAM;YACR;gBACE,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE;oBAC/B,MAAM,IAAI,KAAK,CAAC,kCAAkC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;iBACnE;qBAAM;oBACL,MAAM,IAAI,KAAK,CAAC,sBAAsB,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;iBACvD;SACJ;QAED,IAAI,WAAW,yBAA2B;;YAExC,OAAO,mBAAmB,CAAC,KAAK,EAAE,MAAoC,CAAQ,CAAC;SAChF;QACD,IAAI,yBAA0B,aAAa,EAAE;;YAE3C,OAAO,MAAa,CAAC;SACtB;;;;;;;;;;;;;;;;;;;;;;;;;QA0BD,IAAI,IAAI,GAAG,KAAK,CAAC,UAAoB,CAAC;QACtC,OAAO,CAAC,KAAK,CAAC,YAAY,+BAAyB,CAAC,EAAE;YACpD,MAAM,IAAI,GAAe,EAAE,CAAC;YAC5B,IAAI,OAAiB,CAAC;YACtB,QAAS,KAAK,CAAC,YAAsB;gBACnC;oBACE,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;oBACxB,SAAS,CAAC,KAAK,CAAC,CAAC;oBACjB,IAAI,CAAC,KAAK,CAAC,YAAY,kCAA6B,CAAC,EAAE;wBACrD,MAAM,IAAI,KAAK,CAAC,yBAAyB,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;qBAC1D;oBACD,IAAI,GAAG,KAAK,CAAC,UAAoB,CAAC;oBAClC,SAAS,CAAC,KAAK,CAAC,CAAC;;oBAEjB,MAAM,GAAG,CAAC,CAAC,MAAM,IAAI,kCAA2B,KAAK,CAAC,KAAK,MAAM,qBAAiB,IAAI,CAAC,MAAM,wBAAoB,CAAC,CAAC,CAAC;oBACpH,IAAK,KAAK,CAAC,YAAsB,6BAAsB;wBACrD,IAAI,MAAM,oBAAmB;4BAC3B,MAAM,qBAAiB;yBACxB;wBACD,SAAS;qBACV;oBACD,IAAI,MAAM,qBAAiB;wBACzB,MAAM,GAAG,IAAI,qBAAqB,CAAC,IAAI,EAAG,MAAuD,CAAC,QAAQ,CAAC,CAAC;qBAC7G;yBAAM;wBACL,MAAM,GAAG,IAAI,sBAAsB,CAAC,MAAwB,EAAE,IAAI,CAAC,CAAC;qBACrE;oBACD,SAAS;gBACX;oBACE,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;oBACxB,SAAS,CAAC,KAAK,CAAC,CAAC;oBACjB,MAAM,oBAAgB;oBACtB,MAAM,GAAG,IAAI,qBAAqB,CAAC,MAAwB,EAAE,KAAK,CAAC,KAAK,kCAAmC,WAAW,CAAC,CAAC,CAAC;oBACzH,OAAO,CAAC,KAAK,6BAAqB,CAAC;oBACnC,MAAM;gBACR;oBACE,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;oBACzB,SAAS,CAAC,KAAK,CAAC,CAAC;oBACjB,OAAQ,KAAK,CAAC,YAAsB,+BAAuB;wBACzD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,kCAAmC,WAAW,CAAC,CAAC,CAAC;wBACtE,IAAI,CAAC,UAAU,CAAC,KAAK,sBAAc,EAAE;4BACnC,MAAM;yBACP;qBACF;oBACD,OAAO,CAAC,KAAK,2BAAmB,CAAC;oBACjC,IAAI,MAAM,qBAAiB;wBACzB,MAAM,GAAG,IAAI,mBAAmB,CAAC,IAAI,EAAE,IAAI,EAAG,MAAuD,CAAC,QAAQ,CAAC,CAAC;qBACjH;yBAAM,IAAI,MAAM,sBAAkB;wBACjC,MAAM,GAAG,IAAI,oBAAoB,CAAC,MAAwB,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;qBACzE;yBAAM;wBACL,MAAM,GAAG,IAAI,sBAAsB,CAAC,MAAwB,EAAE,IAAI,CAAC,CAAC;qBACrE;oBACD,MAAM,GAAG,CAAC,CAAC;oBACX,MAAM;gBACR;oBACE,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;oBACzB,OAAO,GAAG,CAAC,KAAK,CAAC,UAAoB,CAAC,CAAC;oBACvC,MAAM,GAAG,IAAI,wBAAwB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAwB,CAAC,CAAC;oBAClF,SAAS,CAAC,KAAK,CAAC,CAAC;oBACjB,MAAM;gBACR;oBACE,MAAM,GAAG,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,WAAW,EAAE,MAAwB,EAAE,IAAI,CAAC,CAAC;aAEtF;SACF;KACF;IAED,IAAI,mBAAoB,aAAa,EAAE;;QAErC,OAAO,MAAa,CAAC;KACtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA6BD,OAAO,CAAC,KAAK,CAAC,YAAY,2BAAqB,CAAC,EAAE;QAChD,MAAM,OAAO,GAAG,KAAK,CAAC,YAAY,CAAC;QACnC,IAAI,CAAC,OAAO,4BAAwB,aAAa,EAAE;YACjD,MAAM;SACP;QACD,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,MAAM,GAAG,IAAI,gBAAgB,CAAC,WAAW,CAAC,OAAO,iBAAgC,EAAE,MAAkB,EAAE,KAAK,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,yBAAqB,WAAW,CAAC,CAAC,CAAC;QACtK,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;KAC1B;IACD,IAAI,uBAAyB,aAAa,EAAE;;QAE1C,OAAO,MAAa,CAAC;KACtB;;;;;;;;;;;;IAcD,IAAI,UAAU,CAAC,KAAK,yBAAiB,EAAE;QACrC,MAAM,GAAG,GAAG,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC;QACjE,OAAO,CAAC,KAAK,sBAAc,CAAC;QAC5B,MAAM,GAAG,IAAI,qBAAqB,CAAC,MAAkB,EAAE,GAAG,EAAE,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC,CAAC;QAClH,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;KAC1B;IACD,IAAI,kBAAoB,aAAa,EAAE;;QAErC,OAAO,MAAa,CAAC;KACtB;;;;;;;;;;;;IAaD,IAAI,UAAU,CAAC,KAAK,uBAAe,EAAE;QACnC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,oDAAoD,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SACrF;QACD,MAAM,GAAG,IAAI,gBAAgB,CAAC,MAAsB,EAAE,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC,CAAC;KAC7G;IACD,IAAI,oBAAsB,aAAa,EAAE;;QAEvC,OAAO,MAAa,CAAC;KACtB;;;IAID,OAAO,UAAU,CAAC,KAAK,oBAAY,EAAE;QACnC,IAAI,KAAK,CAAC,YAAY,wBAAgB;YACpC,MAAM,IAAI,KAAK,CAAC,+DAA+D,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SAChG;QACD,MAAM,IAAI,GAAG,KAAK,CAAC,UAAoB,CAAC;QACxC,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,MAAM,IAAI,GAAG,IAAI,KAAK,EAAY,CAAC;QACnC,OAAO,UAAU,CAAC,KAAK,sBAAc,EAAE;YACrC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC,CAAC;SACjE;QACD,MAAM,GAAG,IAAI,wBAAwB,CAAC,MAA0B,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;KAC/E;;;IAID,OAAO,UAAU,CAAC,KAAK,0BAAkB,EAAE;QACzC,IAAI,KAAK,CAAC,YAAY,wBAAgB;YACpC,MAAM,IAAI,KAAK,CAAC,gEAAgE,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SACjG;QACD,MAAM,IAAI,GAAG,KAAK,CAAC,UAAoB,CAAC;QACxC,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,MAAM,IAAI,GAAG,IAAI,KAAK,EAAY,CAAC;QACnC,OAAO,UAAU,CAAC,KAAK,sBAAc,EAAE;YACrC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC,CAAC;SACjE;QACD,MAAM,GAAG,IAAI,yBAAyB,CAAC,MAA2B,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;KACjF;IACD,IAAI,KAAK,CAAC,YAAY,wBAAgB;QACpC,IAAI,WAAW,6BAA8B;;YAE3C,OAAO,MAAa,CAAC;SACtB;QACD,IAAI,KAAK,CAAC,QAAQ,KAAK,IAAI,EAAE;YAC3B,MAAM,IAAI,KAAK,CAAC,6BAA6B,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SAC9D;QACD,MAAM,IAAI,KAAK,CAAC,sBAAsB,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;KACvD;;IAED,OAAO,MAAa,CAAC;AACvB,CAAC;AAED;;;;;;;;;;;;;;;;;AAiBA,SAAS,2BAA2B,CAAC,KAAkB,EAAE,MAAc,EAAE,WAAwB;IAC/F,SAAS,CAAC,KAAK,CAAC,CAAC;IACjB,MAAM,QAAQ,GAAG,IAAI,KAAK,EAAY,CAAC;IACvC,OAAO,KAAK,CAAC,YAAY,iCAAyB;QAChD,IAAI,UAAU,CAAC,KAAK,sBAAc,EAAE;YAClC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC1B,IAAK,KAAK,CAAC,YAAsB,iCAAyB;gBACxD,MAAM;aACP;SACF;aAAM;YACL,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,GAAG,sBAAwB,CAAC,CAAC;YAC9F,IAAI,UAAU,CAAC,KAAK,sBAAc,EAAE;gBAClC,IAAK,KAAK,CAAC,YAAsB,iCAAyB;oBACxD,MAAM;iBACP;aACF;iBAAM;gBACL,MAAM;aACP;SACF;KACF;IACD,OAAO,CAAC,KAAK,6BAAqB,CAAC;IACnC,IAAI,WAAW,yBAA2B;QACxC,OAAO,IAAI,mBAAmB,CAAC,QAAQ,CAAC,CAAC;KAC1C;SAAM;QACL,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;QACzB,OAAO,IAAI,sBAAsB,CAAC,QAAQ,CAAC,CAAC;KAC7C;AACH,CAAC;AAED,SAAS,mBAAmB,CAAC,KAAkB,EAAE,MAAkC;IACjF,IAAI,CAAC,MAAM,CAAC,KAAK,qCAAwC,CAAC,EAAE;QAC1D,MAAM,IAAI,KAAK,CAAC,yDAAyD,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;KAC1F;IACD,IAAI,KAAK,CAAC,YAAY,8BAAsB;QAC1C,MAAM,IAAI,KAAK,CAAC,yDAAyD,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;KAC1F;IACD,SAAS,CAAC,KAAK,CAAC,CAAC;IACjB,MAAM,WAAW,GAAG,MAAM,CAAC;IAC3B,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,iDAAsD,CAAC;IACpF,OAAO,IAAI,cAAc,CAAC,WAAW,EAAE,SAA8B,CAAC,CAAC;AACzE,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;AAqBA,SAAS,4BAA4B,CAAC,KAAkB,EAAE,WAAwB;IAChF,MAAM,IAAI,GAAG,IAAI,KAAK,EAAmB,CAAC;IAC1C,MAAM,MAAM,GAAG,IAAI,KAAK,EAAY,CAAC;IACrC,SAAS,CAAC,KAAK,CAAC,CAAC;IACjB,OAAO,KAAK,CAAC,YAAY,+BAAuB;QAC9C,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;;QAE5B,IAAI,KAAK,CAAC,YAAY,uCAAiC;YACrD,SAAS,CAAC,KAAK,CAAC,CAAC;YACjB,OAAO,CAAC,KAAK,sBAAc,CAAC;YAC5B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,kCAAmC,WAAW,GAAG,sBAAwB,CAAC,CAAC;SACnG;aAAM,IAAI,KAAK,CAAC,YAAY,8BAAyB;;YAEpD,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC;YACnD,SAAS,CAAC,KAAK,CAAC,CAAC;YACjB,IAAI,UAAU,CAAC,KAAK,sBAAc,EAAE;gBAClC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,kCAAmC,WAAW,GAAG,sBAAwB,CAAC,CAAC;aACnG;iBAAM;;gBAEL,KAAK,CAAC,WAAW,GAAG,WAAW,CAAC;gBAChC,KAAK,CAAC,YAAY,GAAG,YAAY,CAAC;gBAClC,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC;gBACpB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,oCAAoC,WAAW,GAAG,sBAAwB,CAAC,CAAC;aACpG;SACF;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,kEAAkE,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SACnG;QACD,IAAK,KAAK,CAAC,YAAsB,+BAAuB;YACtD,OAAO,CAAC,KAAK,sBAAc,CAAC;SAC7B;KACF;IACD,OAAO,CAAC,KAAK,2BAAmB,CAAC;IACjC,IAAI,WAAW,yBAA2B;QACxC,OAAO,IAAI,oBAAoB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KAC/C;SAAM;QACL,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;QACzB,OAAO,IAAI,uBAAuB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KAClD;AACH,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAkB;IAC5C,MAAM,KAAK,GAAG,EAAE,CAAC;IACjB,MAAM,WAAW,GAA0C,EAAE,CAAC;IAC9D,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;IAC5B,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,OAAO,KAAK,CAAC,KAAK,GAAG,MAAM,EAAE;QAC3B,QAAQ,KAAK,CAAC,WAAW;YACvB;gBACE,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,0BAAqB;oBAC9D,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACnB,MAAM,GAAG,EAAE,CAAC;oBAEZ,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;oBACjB,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;oBACxD,SAAS,CAAC,KAAK,CAAC,CAAC;oBACjB,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,6DAA+D,CAAC;oBAC9F,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;oBAC7B,SAAS;iBACV;qBAAM;oBACL,MAAM,IAAI,GAAG,CAAC;iBACf;gBACD,MAAM;YACR;gBACE,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC7D,MAAM;YACR;gBACE,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;SACpD;QACD,QAAQ,CAAC,KAAK,CAAC,CAAC;KACjB;IACD,IAAI,WAAW,CAAC,MAAM,EAAE;QACtB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACnB,OAAO,IAAI,aAAa,CAAC,KAAK,EAAE,WAAkC,CAAC,CAAC;KACrE;IACD,OAAO,IAAK,CAAC;AACf,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,SAAS,aAAa,CAAC,KAAkB,EAAE,MAAc,EAAE,WAAwB,EAAE,MAAsB,EAAE,MAAe;IAC1H,MAAM,MAAM,GAAG,CAAC,KAAK,CAAC,UAAoB,CAAC,CAAC;;IAE5C,OAAO,CAAC,KAAK,oCAA6B,CAAC;IAC3C,MAAM,WAAW,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC,CAAC;IAC3E,OAAO,CAAC,KAAK,CAAC,YAAY,GAAG,gBAAgB,CAAC,KAAK,CAAC,iCAA0B;QAC5E,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,UAAoB,CAAC,CAAC;QACxC,OAAO,CAAC,KAAK,oCAA6B,CAAC;QAC3C,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,mBAAqB,WAAW,CAAC,CAAC,CAAC;KACxE;IACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,UAAoB,CAAC,CAAC;IACxC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;IACzB,IAAI,MAAM,EAAE;QACV,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,OAAO,IAAI,wBAAwB,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC;KAC1E;SAAM;QACL,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,OAAO,IAAI,kBAAkB,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;KACpD;AACH,CAAC;AAED,SAAS,SAAS,CAAC,KAAkB;IACnC,OAAO,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,MAAM,EAAE;QACjC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC;QAC/B,IAAI,CAAC,KAAK,CAAC,YAAY,IAAI,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,CAAU,KAAK,IAAI,EAAE;YACpF,OAAO;SACR;KACF;IACD,KAAK,CAAC,YAAY,qBAAa;AACjC,CAAC;AAED,SAAS,QAAQ,CAAC,KAAkB;IAClC,OAAO,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;AACnE,CAAC;AAED,SAAS,cAAc,CAAC,KAAkB;;IAExC,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAAC,CAAC;IAEjC,MAAM,KAAK,GAAoB,aAAa,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;IAChF,OAAO,KAAK,KAAK,SAAS,2BAAsB,KAAK,CAAC;AACxD,CAAC;AAED,SAAS,UAAU,CAAC,KAAkB,EAAE,OAAgB;IACtD,IAAI,IAAI,GAAG,KAAK,CAAC,WAAW,CAAC;IAC7B,IAAI,OAAO,KAAK,KAAK,EAAE;QACrB,GAAG;YACD,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;SACxB,QAAQ,IAAI,qBAAiB,IAAI,mBAAe;QAEjD,IAAI,IAAI,mBAAe;YACrB,KAAK,CAAC,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAChD,iCAA4B;SAC7B;;QAED,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QACvB,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE;;;YAG/B,KAAK,CAAC,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAC7D,iCAA4B;SAC7B;KACF;IAED,IAAI,IAAI,qBAAiB,IAAI,mBAAe;QAC1C,GAAG;YACD,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;SACxB,QAAQ,IAAI,qBAAiB,IAAI,mBAAe;KAClD;SAAM;QACL,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;KAC3D;IAED,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IAC9C,iCAA4B;AAC9B,CAAC;AAED,SAAS,UAAU,CAAC,KAAkB;IACpC,MAAM,KAAK,GAAG,KAAK,CAAC,WAAW,CAAC;IAChC,QAAQ,CAAC,KAAK,CAAC,CAAC;IAEhB,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,MAAM,MAAM,GAAG,IAAI,KAAK,EAAU,CAAC;IACnC,IAAI,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC;IAEzB,OAAO,KAAK,CAAC,WAAW,KAAK,KAAK,EAAE;QAClC,IAAI,KAAK,CAAC,WAAW,yBAAqB;YACxC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YACpD,QAAQ,CAAC,KAAK,CAAC,CAAC;YAChB,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC5C,QAAQ,CAAC,KAAK,CAAC,CAAC;YAChB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;YAC5C,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC;SACtB;aAAM,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE;YACtC,MAAM,IAAI,KAAK,CAAC,0CAA0C,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;SAC3E;aAAM;YACL,QAAQ,CAAC,KAAK,CAAC,CAAC;SACjB;KACF;IAED,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;IACpD,QAAQ,CAAC,KAAK,CAAC,CAAC;;IAGhB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClB,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAErC,KAAK,CAAC,UAAU,GAAG,YAAY,CAAC;IAChC,gCAA2B;AAC7B,CAAC;AAED,SAAS,YAAY,CAAC,KAAkB;IACtC,IAAI,IAAI,GAAG,IAAI,CAAC;IAChB,IAAI,MAAM,GAAG,EAAE,CAAC;IAEhB,OAAO,QAAQ,CAAC,KAAK,CAAC,wBAAoB;QACxC,IAAI,KAAK,CAAC,WAAW,sBAAkB;YACrC,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,0BAAqB;gBAClG,KAAK,CAAC,KAAK,EAAE,CAAC;gBACd,IAAI,GAAG,KAAK,CAAC;gBACb,MAAM;aACP;iBAAM;gBACL,MAAM,IAAI,GAAG,CAAC;aACf;SACF;aAAM,IAAI,KAAK,CAAC,WAAW,yBAAqB;YAC/C,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;SAC9D;aAAM;YACL,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE;gBAC/B,MAAM,IAAI,KAAK,CAAC,kCAAkC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;aACnE;YACD,MAAM,IAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;SAClD;KACF;IAED,QAAQ,CAAC,KAAK,CAAC,CAAC;IAChB,KAAK,CAAC,UAAU,GAAG,MAAM,CAAC;IAC1B,IAAI,IAAI,EAAE;QACR,iCAA0B;KAC3B;IACD,yCAAkC;AACpC,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAkB;IAC1C,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,EAAE;QAC/B,MAAM,IAAI,KAAK,CAAC,kCAAkC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;KACnE;IACD,KAAK,CAAC,KAAK,EAAE,CAAC;IACd,OAAO,YAAY,CAAC,KAAK,CAAC,CAAC;AAC7B,CAAC;AAED,SAAS,UAAU,CAAC,KAAkB,EAAE,KAAY;IAClD,IAAI,KAAK,CAAC,YAAY,KAAK,KAAK,EAAE;QAChC,SAAS,CAAC,KAAK,CAAC,CAAC;QACjB,OAAO,IAAI,CAAC;KACb;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED,SAAS,OAAO,CAAC,KAAkB,EAAE,KAAY;IAC/C,IAAI,KAAK,CAAC,YAAY,KAAK,KAAK,EAAE;QAChC,SAAS,CAAC,KAAK,CAAC,CAAC;KAClB;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,4BAA4B,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;KAC7D;AACH,CAAC;AAED;;;;;;;AAOA,MAAM,WAAW,GAAG;IAClB,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,OAAO,EAAE,IAAI,gBAAe,SAAS;IAEvE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG;IAE3D,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG;IACxD,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,GAAG,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;;IAEnF,IAAI;CACL,CAAC;AAEF,MAAM,aAAa,GAEf,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACxB,aAAa,CAAC,IAAI,0BAAqB;AACvC,aAAa,CAAC,IAAI,0BAAqB;AACvC,aAAa,CAAC,KAAK,2BAAsB;AACzC,aAAa,CAAC,SAAS,+BAA0B;AACjD,aAAa,CAAC,KAAK,wBAAmB;AACtC,aAAa,CAAC,OAAO,0BAAqB;AAC1C,aAAa,CAAC,EAAE,2BAAmB;AACnC,aAAa,CAAC,UAAU,mCAA2B;AACnD,aAAa,CAAC,MAAM,6BAAuB;AAC3C,aAAa,CAAC,IAAI,2BAAqB;AACvC,aAAa,CAAC,EAAE,2BAAmB;AAEnC;;;;;;;;AAQA,MAAM,KAAK,GAAG;;IAEZ,WAAW,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;IACnE,OAAO,wBAAuB,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC;IACze,KAAK,sBAAqB,CAAC,IAAI,EAAE,IAAI,CAAC;IACtC,IAAI,kBAAiB,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;CAC3C,CAAC;AAEF;;;;AAIA,SAAS,UAAU,CAAC,MAAuC,EAAE,IAAwB,EAAE,UAAoB,EAAE,KAAqC;IAChJ,MAAM,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC;IACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,IAAI,CAAC,EAAE;QACtC,MAAM,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,GAAG,GAAG,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5B,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,KAAK,GAAG,CAAC,CAAC;QAChC,IAAI,MAAM,EAAE;YACV,MAAM,CAAC,IAAI,CAAC,KAA6B,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;SACxD;QACD,IAAI,IAAI,EAAE;YACR,KAAK,IAAI,EAAE,GAAG,KAAK,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE;gBACnC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;aACd;SACF;KACF;AACH,CAAC;AAED;AACA,SAAS,WAAW,CAAC,KAAY;IAC/B,OAAO,CAAC;QACN,QAAQ,CAAC,CAAC,CAAC,CAAC;QACZ,OAAO,KAAK,CAAC;KACd,CAAC;AACJ,CAAC;AACD,MAAM,mBAAmB,GAAgB,CAAC;IACxC,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC;AACxD,CAAC,CAAC;AACF,mBAAmB,CAAC,SAAS,GAAG,IAAI,CAAC;AAErC;AACA,MAAM,YAAY,GAAG,IAAI,GAAG,EAAU,CAAC;AACvC,UAAU,CAAC,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;AAExD;AACA,MAAM,OAAO,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC;AACvC;AACA,UAAU,CAAC,OAAc,EAAE,IAAI,EAAE,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;AACnD;AACA,UAAU,CAAC,OAAc,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AAIjD;AACA,MAAM,YAAY,GAAG,IAAI,KAAK,CAAc,MAAM,CAAC,CAAC;AACpD,YAAY,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAElD,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC;IAC1C,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,OAAO,IAAI,CAAC;AACd,CAAC,CAAC,CAAC;AACH,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;AAC9D,UAAU,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC,IAAI,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AAEvE,YAAY,sBAAkB;IAC9B,YAAY,sBAAkB,GAAG,CAAC;QAChC,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC;KACtB,CAAC;AACF,YAAY,mBAAe,GAAG,CAAC;IAC7B,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC;AAEF;AACA,YAAY,sBAAkB,GAAG,CAAC;IAChC,IAAI,QAAQ,CAAC,CAAC,CAAC,sBAAkB;QAC/B,+BAAyB;KAC1B;IACD,IAAI,QAAQ,CAAC,CAAC,CAAC,sBAAkB;QAC/B,uCAA+B;KAChC;IACD,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,6CAAqC;AACvC,CAAC,CAAC;AAEF;AACA,YAAY,iBAAa,GAAI,CAAC;IAC5B,IAAI,QAAQ,CAAC,CAAC,CAAC,sBAAkB;QAC/B,4BAAoB;KACrB;IACD,IAAI,QAAQ,CAAC,CAAC,CAAC,sBAAkB;QAC/B,kCAA0B;KAC3B;IACD,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,wCAAgC;AAClC,CAAC,CAAC;AAEF;AACA,YAAY,oBAAgB,GAAG,CAAC;IAC9B,IAAI,QAAQ,CAAC,CAAC,CAAC,yBAAqB;QAClC,+BAAuB;KACxB;IACD,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,wCAAgC;AAClC,CAAC,CAAC;AAEF;AACA,YAAY,eAAU,GAAG,CAAC;IACxB,IAAI,QAAQ,CAAC,CAAC,CAAC,oBAAe;QAC5B,yBAAiB;KAClB;IACD,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,4BAAoB;AACtB,CAAC,CAAC;AAEF;AACA,YAAY,cAAU,GAAG,CAAC;IACxB,IAAI,QAAQ,CAAC,CAAC,CAAC,qBAAiB,CAAC,CAAC,WAAW,mBAAe;QAC1D,OAAO,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;KAC5B;IACD,uBAAiB;AACnB,CAAC,CAAC;AAEF;AACA,YAAY,mBAAe,GAAI,CAAC;IAC9B,IAAI,QAAQ,CAAC,CAAC,CAAC,sBAAkB;QAC/B,8BAAsB;KACvB;IACD,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,oCAA4B;AAC9B,CAAC,CAAC;AAEF;AACA,YAAY,sBAAkB,GAAI,CAAC;IACjC,IAAI,QAAQ,CAAC,CAAC,CAAC,sBAAkB;QAC/B,iCAAyB;KAC1B;IACD,QAAQ,CAAC,CAAC,CAAC,CAAC;IACZ,uCAA+B;AACjC,CAAC,CAAC;AAEF,YAAY,kBAAc,GAAQ,WAAW,uBAAe,CAAC;AAC7D,YAAY,oBAAgB,GAAM,WAAW,wBAAiB,CAAC;AAC/D,YAAY,qBAAiB,GAAK,WAAW,0BAAkB,CAAC;AAChE,YAAY,mBAAe,GAAO,WAAW,wBAAgB,CAAC;AAC9D,YAAY,eAAW,GAAW,WAAW,mBAAY,CAAC;AAC1D,YAAY,gBAAY,GAAU,WAAW,qBAAa,CAAC;AAC3D,YAAY,gBAAY,GAAU,WAAW,oBAAa,CAAC;AAC3D,YAAY,gBAAY,GAAU,WAAW,qBAAa,CAAC;AAC3D,YAAY,gBAAY,GAAU,WAAW,qBAAa,CAAC;AAC3D,YAAY,mBAAe,GAAO,WAAW,wBAAgB,CAAC;AAC9D,YAAY,sBAAkB,GAAI,WAAW,0BAAmB,CAAC;AACjE,YAAY,uBAAmB,GAAG,WAAW,4BAAoB,CAAC;AAClE,YAAY,qBAAgB,GAAM,WAAW,wBAAiB,CAAC;AAC/D,YAAY,sBAAiB,GAAK,WAAW,0BAAkB;;ACl0C/D;;;AAGA,IAAI,YAAY,GAAwB,IAAI,CAAC;AAC7C,MAAM,YAAY,GAAmB,EAAE,CAAC;AACxC;AACO,IAAI,UAAU,GAAG,KAAK,CAAC;AAE9B;SACgB,eAAe;IAC7B,UAAU,GAAG,KAAK,CAAC;AACrB,CAAC;SAEe,gBAAgB;IAC9B,UAAU,GAAG,IAAI,CAAC;AACpB,CAAC;SAEe,kBAAkB;IAChC,OAAO,YAAY,CAAC;AACtB,CAAC;SAEe,gBAAgB,CAAC,WAAyB;IACxD,IAAI,WAAW,IAAI,IAAI,EAAE;QACvB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KACzD;IACD,IAAI,YAAY,IAAI,IAAI,EAAE;QACxB,YAAY,GAAG,WAAW,CAAC;QAC3B,YAAY,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC;QAC/B,UAAU,GAAG,IAAI,CAAC;QAClB,OAAO;KACR;IACD,IAAI,YAAY,KAAK,WAAW,EAAE;QAChC,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;KAC1D;IACD,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAChC,YAAY,GAAG,WAAW,CAAC;IAC3B,UAAU,GAAG,IAAI,CAAC;AACpB,CAAC;SAEe,eAAe,CAAC,WAAyB;IACvD,IAAI,WAAW,IAAI,IAAI,EAAE;QACvB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KACzD;IACD,IAAI,YAAY,KAAK,WAAW,EAAE;QAChC,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;KAC3D;IAED,YAAY,CAAC,GAAG,EAAE,CAAC;IACnB,YAAY,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;IACtF,UAAU,GAAG,YAAY,IAAI,IAAI,CAAC;AACpC,CAAC;MAEY,mBAAmB,GAAG,MAAM,CAAC,MAAM,CAAC;IAC/C,IAAI,OAAO;QACT,OAAO,YAAY,CAAC;KACrB;IACD,IAAI,UAAU;QACZ,OAAO,UAAU,CAAC;KACnB;IACD,KAAK,EAAE,gBAAgB;IACvB,IAAI,EAAE,eAAe;IACrB,KAAK,EAAE,eAAe;IACtB,MAAM,EAAE,gBAAgB;CACzB;;AC9DD,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC;AAC1B,MAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;AAC9C,MAAM,QAAQ,GAAG,IAAI,OAAO,EAAkB,CAAC;AAE/C,SAAS,OAAO,CAAC,GAAY;IAC3B,QAAQ,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC;QAC3B,KAAK,iBAAiB,CAAC;QACvB,KAAK,gBAAgB,CAAC;QACtB,KAAK,cAAc,CAAC;QACpB,KAAK,cAAc;;;;;YAKjB,OAAO,IAAI,CAAC;QACd;YACE,OAAO,KAAK,CAAC;KAChB;AACH,CAAC;AAEM,MAAM,MAAM,GAAG,SAAS,CAAC;SAEhB,IAAI,CAAoB,CAAI;IAC1C,OAAO,OAAO,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AACtC,CAAC;SACe,QAAQ,CAAmB,GAAM;;;IAE/C,aAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAM,mCAAI,WAAW,CAAC,GAAG,CAAC,CAAC;AACpD,CAAC;SAEe,MAAM,CAAmB,GAAM;;;IAE7C,aAAQ,GAAkB,CAAC,MAAM,CAAM,mCAAI,GAAG,CAAC;AACjD,CAAC;SACe,MAAM,CAAoB,CAAI;IAC5C,OAAO,OAAO,CAAC,CAAC,CAAC,IAAK,CAAgB,CAAC,MAAM,CAAM,IAAI,CAAC,CAAC;AAC3D,CAAC;AAED,SAAS,YAAY,CAAC,GAAgB;IACpC,OAAO,GAAG,KAAK,aAAa;WACvB,GAAG,KAAK,WAAW;;;WAGnB,GAAG,KAAK,YAAY;WACpB,GAAG,KAAK,MAAM,CAAC,WAAW;WAC1B,GAAG,KAAK,MAAM,CAAC,WAAW,CAAC;AAClC,CAAC;AAED,SAAS,WAAW,CAAmB,GAAM;IAC3C,MAAM,OAAO,GAAyB,GAAG,YAAY,KAAK;UACtD,YAAY;UACZ,GAAG,YAAY,GAAG,IAAI,GAAG,YAAY,GAAG;cACtC,iBAAiB;cACjB,aAAa,CAAC;IAEpB,MAAM,UAAU,GAAG,IAAI,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;IAC3C,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;IAE9B,OAAO,UAAe,CAAC;AACzB,CAAC;AAED,MAAM,aAAa,GAAyB;IAC1C,GAAG,CAAC,MAAkB,EAAE,GAAgB,EAAE,QAAgB;;QAExD,IAAI,GAAG,KAAK,MAAM,EAAE;YAClB,OAAO,MAAM,CAAC;SACf;QAED,MAAM,WAAW,GAAG,kBAAkB,EAAE,CAAC;QAEzC,IAAI,CAAC,UAAU,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,WAAW,IAAI,IAAI,EAAE;YAC3D,OAAO,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;SACrC;;QAGD,WAAW,CAAC,eAAe,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAEzC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC;KAC3C;CACF,CAAC;AAEF,MAAM,YAAY,GAA4B;IAC5C,GAAG,CAAC,MAAiB,EAAE,GAAgB,EAAE,QAAiB;;QAExD,IAAI,GAAG,KAAK,MAAM,EAAE;YAClB,OAAO,MAAM,CAAC;SACf;QAED,MAAM,WAAW,GAAG,kBAAkB,EAAE,CAAC;QAEzC,IAAI,CAAC,UAAU,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,WAAW,IAAI,IAAI,EAAE;YAC3D,OAAO,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;SACrC;QAED,QAAQ,GAAG;YACT,KAAK,QAAQ;gBACX,WAAW,CAAC,eAAe,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBAC9C,OAAO,MAAM,CAAC,MAAM,CAAC;YACvB,KAAK,KAAK;gBACR,OAAO,eAAe,CAAC;YACzB,KAAK,UAAU;gBACb,OAAO,oBAAoB,CAAC;YAC9B,KAAK,SAAS;gBACZ,OAAO,mBAAmB,CAAC;YAC7B,KAAK,aAAa;gBAChB,OAAO,uBAAuB,CAAC;YACjC,KAAK,OAAO;gBACV,OAAO,iBAAiB,CAAC;YAC3B,KAAK,QAAQ;gBACX,OAAO,kBAAkB,CAAC;YAC5B,KAAK,MAAM;gBACT,OAAO,gBAAgB,CAAC;YAC1B,KAAK,WAAW;gBACd,OAAO,qBAAqB,CAAC;YAC/B,KAAK,MAAM;gBACT,OAAO,gBAAgB,CAAC;YAC1B,KAAK,SAAS;gBACZ,OAAO,mBAAmB,CAAC;YAC7B,KAAK,MAAM;gBACT,OAAO,gBAAgB,CAAC;YAC1B,KAAK,MAAM;gBACT,OAAO,gBAAgB,CAAC;YAC1B,KAAK,KAAK;gBACR,OAAO,eAAe,CAAC;YACzB,KAAK,QAAQ;gBACX,OAAO,aAAa,CAAC;YACvB,KAAK,aAAa;gBAChB,OAAO,kBAAkB,CAAC;YAC5B,KAAK,SAAS;gBACZ,OAAO,mBAAmB,CAAC;YAC7B,KAAK,OAAO;gBACV,OAAO,iBAAiB,CAAC;YAC3B,KAAK,SAAS;gBACZ,OAAO,mBAAmB,CAAC;YAC7B,KAAK,OAAO;gBACV,OAAO,iBAAiB,CAAC;YAC3B,KAAK,QAAQ;gBACX,OAAO,kBAAkB,CAAC;YAC5B,KAAK,MAAM;gBACT,OAAO,gBAAgB,CAAC;YAC1B,KAAK,MAAM;gBACT,OAAO,gBAAgB,CAAC;YAC1B,KAAK,MAAM;gBACT,OAAO,WAAW,CAAC;YACrB,KAAK,QAAQ,CAAC;YACd,KAAK,MAAM,CAAC,QAAQ;gBAClB,OAAO,aAAa,CAAC;YACvB,KAAK,SAAS;gBACZ,OAAO,cAAc,CAAC;SACzB;QAED,WAAW,CAAC,eAAe,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAEzC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC;KAC3C;;IAED,OAAO,CAAC,MAAiB;;QACvB,MAAA,kBAAkB,EAAE,0CAAE,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE;QACxD,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAwB,CAAC;KACvD;CACF,CAAC;AAEF,SAAS,eAAe,CAAkB,EAAsD,EAAE,OAAiB;;IACjH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;;IAEvB,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAC3C,CAAC;IACF,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED,SAAS,iBAAiB,CAAkB,EAAsD,EAAE,OAAiB;;IACnH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IACpE,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,kBAAkB,CAAkB,EAAsD,EAAE,OAAiB;;IACpH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;;IAE1B,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAC3C,CAAC;IACF,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED,SAAS,oBAAoB,CAAkB,CAAU;;IACvD,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACpC,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,mBAAmB,CAAkB,CAAU;;IACtD,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACnC,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC;AACb,CAAC;AACD,SAAS,uBAAuB,CAAkB,CAAU;;IAC1D,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC;AACb,CAAC;AACD,SAAS,qBAAqB,CAAkB,EAAsD,EAAE,OAAiB;;IACvH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAChF,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,gBAAgB,CAAkB,EAAsD,EAAE,OAAiB;;IAClH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;IAC9D,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED,SAAS,gBAAgB;;IACvB,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;AAC1B,CAAC;AACD,SAAS,mBAAmB,CAAkB,EAAsD,EAAE,OAAiB;;IACrH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,KAC/B,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAC1C,CAAC;AACJ,CAAC;AACD,SAAS,gBAAgB,CAAkB,SAAkB;;IAC3D,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAC7B,CAAC;AAED,SAAS,eAAe;IACtB,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;AAClC,CAAC;AACD,SAAS,gBAAgB,CAAkB,GAAG,IAAe;IAC3D,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;AACpC,CAAC;AACD,SAAS,iBAAiB;IACxB,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;AACpC,CAAC;AACD,SAAS,mBAAmB,CAAkB,GAAG,IAAe;IAC9D,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,CAAC;AACvC,CAAC;AACD,SAAS,kBAAkB,CAAkB,GAAG,IAAoC;IAClF,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AAC5C,CAAC;AACD,SAAS,mBAAmB,CAAkB,GAAG,IAAe;;IAC9D,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;IAC1B,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED,SAAS,gBAAgB,CAAkB,EAAsD,EAAE,OAAiB;;IAClH,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC3E,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,gBAAgB,CAAkB,EAAuC;;IAChF,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED,SAAS,iBAAiB,CAAkB,KAAc,EAAE,GAAY;;IACtE,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;AACzC,CAAC;AAED,SAAS,aAAa,CAAkB,EAAqE,EAAE,SAAkB;;IAC/H,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,CAAC;IAC9E,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED,SAAS,kBAAkB,CAAkB,EAAqE,EAAE,SAAkB;;IACpI,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAM,GAAG,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS,CAAC,CAAC;IACnF,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AACnB,CAAC;AAED;AACA;AACA,MAAM,iBAAiB,GAA4B;IACjD,GAAG,CAAC,MAAiB,EAAE,GAAgB,EAAE,QAAS;;QAEhD,IAAI,GAAG,KAAK,MAAM,EAAE;YAClB,OAAO,MAAM,CAAC;SACf;QAED,MAAM,WAAW,GAAG,kBAAkB,EAAE,CAAC;QAEzC,IAAI,CAAC,UAAU,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,WAAW,IAAI,IAAI,EAAE;YAC3D,OAAO,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;SACrC;QAED,QAAQ,GAAG;YACT,KAAK,MAAM;gBACT,WAAW,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBAC5C,OAAO,MAAM,CAAC,IAAI,CAAC;YACrB,KAAK,OAAO;gBACV,OAAO,YAAY,CAAC;YACtB,KAAK,QAAQ;gBACX,OAAO,aAAa,CAAC;YACvB,KAAK,SAAS;gBACZ,OAAO,cAAc,CAAC;YACxB,KAAK,KAAK;gBACR,IAAI,MAAM,YAAY,GAAG,EAAE;oBACzB,OAAO,UAAU,CAAC;iBACnB;gBACD,MAAM;YACR,KAAK,KAAK;gBACR,IAAI,MAAM,YAAY,GAAG,EAAE;oBACzB,OAAO,UAAU,CAAC;iBACnB;gBACD,MAAM;YACR,KAAK,KAAK;gBACR,IAAI,MAAM,YAAY,GAAG,EAAE;oBACzB,OAAO,UAAU,CAAC;iBACnB;gBACD,MAAM;YACR,KAAK,KAAK;gBACR,OAAO,UAAU,CAAC;YACpB,KAAK,MAAM;gBACT,OAAO,WAAW,CAAC;YACrB,KAAK,QAAQ;gBACX,OAAO,aAAa,CAAC;YACvB,KAAK,SAAS;gBACZ,OAAO,cAAc,CAAC;YACxB,KAAK,MAAM,CAAC,QAAQ;gBAClB,OAAO,MAAM,YAAY,GAAG,GAAG,cAAc,GAAG,aAAa,CAAC;SACjE;QAED,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC,CAAC;KAC3C;CACF,CAAC;AAKF,SAAS,cAAc,CAAkB,EAAoB,EAAE,OAAiB;;IAC9E,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC,OAAO,CAAC,CAAC,CAAU,EAAE,GAAY;QAC1C,EAAE,CAAC,IAAI,4BAA2B,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;KACtE,CAAC,CAAC;AACL,CAAC;AAED,SAAS,UAAU,CAAkB,CAAU;;IAC7C,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5B,CAAC;AAED,SAAS,UAAU,CAA8B,CAAU;;IACzD,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC;AACD,SAAS,UAAU,CAA8B,CAAU,EAAE,CAAU;IACrE,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD,CAAC;AAED,SAAS,UAAU,CAAqB,CAAU;IAChD,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC;AAED,SAAS,YAAY;IACnB,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;AACpC,CAAC;AAED,SAAS,aAAa,CAAkB,CAAU;IAChD,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC;AAED,SAAS,WAAW;;IAClB,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,MAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;IAE5B,OAAO;QACL,IAAI;YACF,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YAEvB,OAAO,IAAI;kBACP,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE;kBACvB,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC;SAClC;QACD,CAAC,MAAM,CAAC,QAAQ,CAAC;YACf,OAAO,IAAI,CAAC;SACb;KACF,CAAC;AACJ,CAAC;AAED,SAAS,aAAa;;IACpB,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,MAAM,QAAQ,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC;IAE9B,OAAO;QACL,IAAI;YACF,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YAEvB,OAAO,IAAI;kBACP,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE;kBACvB,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC;SAClC;QACD,CAAC,MAAM,CAAC,QAAQ,CAAC;YACf,OAAO,IAAI,CAAC;SACb;KACF,CAAC;AACJ,CAAC;AAED,SAAS,cAAc;;IACrB,MAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IACzB,MAAA,kBAAkB,EAAE,0CAAE,iBAAiB,CAAC,GAAG,EAAE;IAC7C,MAAM,QAAQ,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;;;IAI/B,OAAO;QACL,IAAI;YACF,MAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YAEvB,OAAO,IAAI;kBACP,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,EAAE;kBACvB,EAAE,KAAK,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC;SACvD;QACD,CAAC,MAAM,CAAC,QAAQ,CAAC;YACf,OAAO,IAAI,CAAC;SACb;KACF,CAAC;AACJ,CAAC;MAEY,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC;IAC3C,QAAQ;IACR,MAAM;IACN,IAAI;IACJ,MAAM;IACN,MAAM;CACP;;MCzbY,gBAAgB;IA+C3B,YACkB,GAAW,EACX,GAAuC,EACvC,GAAuC,EACvC,QAAiB,EACjB,eAAiC;QAJjC,QAAG,GAAH,GAAG,CAAQ;QACX,QAAG,GAAH,GAAG,CAAoC;QACvC,QAAG,GAAH,GAAG,CAAoC;QACvC,aAAQ,GAAR,QAAQ,CAAS;QACjB,oBAAe,GAAf,eAAe,CAAkB;QArB5C,gBAAW,GAAG,IAAI,CAAC;QAEnB,SAAI,oBAAuC;QAG3C,UAAK,GAAY,KAAK,CAAC,CAAC;QACvB,aAAQ,GAAY,KAAK,CAAC,CAAC;;;;;QAM3B,YAAO,GAAY,KAAK,CAAC;QAEzB,YAAO,GAAY,KAAK,CAAC;KAShC;IA/CM,OAAO,MAAM,CAClB,GAAW,EACX,GAAgB,EAChB,UAA8B,EAC9B,eAAiC,EACjC,QAAiB;QAEjB,MAAM,MAAM,GAAG,UAAU,CAAC,GAAI,CAAC;QAC/B,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;QAC9B,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,CAAC,CAAC;QACtF,MAAM,IAAI,IAAI,8BAA6B,QAAQ,CAAC,QAAQ,EAAE,CAAqB,CAAC;QACpF,IAAI,CAAC,WAAW,GAAG,MAAM,QAAQ,CAAC;QAClC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE;YACZ,UAAU,EAAE,UAAU,CAAC,UAAU;YACjC,YAAY,EAAE,IAAI;YAClB,GAAG,EAAE,IAAI;YACT,GAAG,EAAE,yBAAwB,CAAC;gBAC5B,QAAQ,CAAC,QAAQ,CAAC,CAAC,eAAsB,CAAC;aAC3C;SACF,CAAC,CAAC;QAEH,OAAO,QAAQ,CAAC;KACjB;IA2BM,QAAQ;QACb,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACzB,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;SACtC;QACD,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;SACtB;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;;IAGM,QAAQ,CAAC,CAAU,EAAE,MAAsB;QAChD,IAAI,OAAO,IAAI,CAAC,GAAG,KAAK,UAAU,EAAE;YAClC,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;;gBAEpB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;gBACpB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC3B,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;gBAErB,IAAI,CAAC,GAAG,EAAE,CAAC;aACZ;SACF;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;SACzC;KACF;IAEM,YAAY;QACjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,EAAE;YACvB,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;KACF;IAEM,sBAAsB;QAC3B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,EAAE;YACvB,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;KACF;IAEM,SAAS,CAAC,UAAuB;;;;QAItC,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACtD,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;SACtB;KACF;IAEM,WAAW,CAAC,UAAuB;QACxC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACzD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,KAAK;QACVZ,IAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAEA,IAAE,eAAsB,CAAC;KACvD;IAEO,GAAG;QACT,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAO;SACR;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC5B,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAEhC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QAErB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;YAClC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEO,OAAO;QACb,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;QACnB,IAAI;YACF,gBAAgB,CAAC,IAAI,CAAC,CAAC;YACvB,OAAO,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;SAC5F;gBAAS;YACR,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACtB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YACrB,eAAe,CAAC,IAAI,CAAC,CAAC;SACvB;KACF;CACF;AAED,WAAW,CAAC,gBAAgB,CAAC,CAAC;AAC9B,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;AACvC,cAAc,CAAC,gBAAgB,CAAC,CAAC;AAEjC;AACA;AACA,IAAIA,IAAE,GAAY,KAAK,CAAC;;MCzKX,aAAa,GAAGjB,SAAE,CAAC,eAAe,CAAgB,eAAe,EAAE,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE;MAEnG,kBAAkB,GAAG;;;;;;;;;IAShC,gBAAgB,EAAE,EAAE;;;;;;;IAOpB,QAAQ,EAAE,KAAK;;;;;;IAMf,KAAK,EAAE,KAAK;;;;IAIZ,cAAc;QACZ,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAC1B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACpB;EACD;AAEF,MAAM,aAAa,GAAqB;IACtC,UAAU,EAAE,IAAI;CACjB,CAAC;MAEW,YAAY;IAWvB,YACmB,QAAmB;QAAnB,aAAQ,GAAR,QAAQ,CAAW;QANrB,YAAO,GAAyB,EAAE,CAAC;QAE5C,SAAI,GAAiB,IAAI,CAAC;QAC1B,kBAAa,GAAW,CAAC,CAAC;QA6BjB,UAAK,GAAG;YACvB,IAAI,kBAAkB,CAAC,QAAQ,EAAE;gBAC/B,OAAO;aACR;YACD,IAAI,EAAE,IAAI,CAAC,aAAa,GAAG,kBAAkB,CAAC,gBAAgB,EAAE;gBAC9D,OAAO;aACR;YACD,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;YACvB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;YAC3B,IAAI,OAA2B,CAAC;YAChC,IAAI,CAAC,GAAG,CAAC,CAAC;YACV,OAAO,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;gBACnB,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,OAAO,CAAC,OAAO,EAAE,EAAE;oBACrB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;iBACzB;aACF;SACF,CAAC;KA3CE;IAEG,cAAc,CAAC,GAAW,EAAE,YAAoB;QACrD,IAAI,kBAAkB,CAAC,KAAK,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,aAAa,YAAY,2BAA2B,CAAC,CAAC;SACvE;QACD,OAAO,IAAI,kBAAkB,CAAC,IAAI,EAAE,GAAiB,EAAE,YAAY,CAAC,CAAC;KACtE;IAEM,WAAW,CAAC,QAA4B;QAC7C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE5B,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;SAC1E;KACF;IAEM,cAAc,CAAC,QAA4B;QAChD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;QACvD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,IAAI,CAAC,IAAK,CAAC,MAAM,EAAE,CAAC;YACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SAClB;KACF;;AAnCD;;;AAGc,mBAAM,GAAG,CAAC8B,gBAAS,CAAC,CAAC;AAuDrC,cAAc,CAAC,YAAY,CAAC,CAAC;MAIhB,kBAAkB;IAI7B,YACmB,YAA2B,EACrC,GAA6B,EAC7B,WAAmB;QAFT,iBAAY,GAAZ,YAAY,CAAe;QACrC,QAAG,GAAH,GAAG,CAA0B;QAC7B,gBAAW,GAAX,WAAW,CAAQ;QANrB,aAAQ,GAAY,KAAK,CAAC,CAAC;QAC3B,SAAI,gBAAmC;KAM1C;IAEG,QAAQ;QACb,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;KACnC;IAEM,QAAQ,CAAC,CAAU,EAAE,CAAiB;;;QAG3C,MAAM,IAAI,KAAK,CAAC,oCAAoC,IAAI,CAAC,WAAW,mBAAmB,CAAC,CAAC;KAC1F;IAEM,OAAO;QACZ,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;KACrD;IAEM,KAAK;QACV,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAEjC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,eAAsB,CAAC;KAC3D;IAEM,SAAS,CAAC,UAAuB;QACtC,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACtD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC3C,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;SACrC;KACF;IAEM,WAAW,CAAC,UAAuB;QACxC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;YACzD,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;SACxC;KACF;CACF;AAED,oBAAoB,CAAC,kBAAkB,CAAC;;MCxJ3B,iBAAiB;IAI5B,YACkB,GAAc,EACd,WAAwB;QADxB,QAAG,GAAH,GAAG,CAAW;QACd,gBAAW,GAAX,WAAW,CAAa;QAJnC,SAAI,gBAAmC;KAK1C;IANJ,IAAW,UAAU,KAAW,OAAO,IAAI,CAAC,EAAE;IAQvC,QAAQ;;QAEb,OAAQ,IAAI,CAAC,GAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;KAC5C;IACM,QAAQ,MAA6B;IACrC,SAAS,MAA6B;IACtC,WAAW,MAA6B;;;MCjBpC,gBAAgB;IAA7B;;;QAGS,SAAI,gBAAmC;KAS/C;IAPQ,QAAQ,CAAC,GAAW,EAAE,GAAW;QACtC,OAAQ,GAAmB,CAAC,GAAG,CAAC,CAAC;KAClC;IAEM,QAAQ,CAAC,KAAc,EAAE,KAAqB,EAAE,GAAW,EAAE,GAAW;QAC5E,GAAmB,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;KACnC;;;ACDH;AACA;AACA,IAAI,EAAE,GAAY,KAAK,CAAC,CAAC;AAIzB;;;;MAIa,cAAc;IAWzB,YACkB,GAAe,EACf,WAAmB;QADnB,QAAG,GAAH,GAAG,CAAY;QACf,gBAAW,GAAX,WAAW,CAAQ;QAZ9B,UAAK,GAAY,KAAK,CAAC,CAAC;QACxB,aAAQ,GAAY,KAAK,CAAC,CAAC;QAE3B,cAAS,GAAY,KAAK,CAAC;;QAE3B,SAAI,oBAAuC;QAG1C,MAAC,gBAAuC;KAM/C;IAEM,QAAQ;QACb,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;IAEM,QAAQ,CAAC,QAAiB,EAAE,KAAqB;QACtD,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YACzB,IAAI,MAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;gBAC9B,OAAO;aACR;YACD,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;YACtB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YACtB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;YACf,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtB;aAAM;;;;;;;YAOL,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC;SACvC;KACF;IAEM,SAAS,CAAC,UAAuB;QACtC,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE;YAC5B,IAAI,CAAC,KAAK,EAAE,CAAC;SACd;QAED,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;KAC3B;IAEM,KAAK;QACV,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;KAC1C;IAEM,KAAK;QACV,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE;YAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACxC,GAAG,CACD,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,WAAW,EAChB;gBACE,UAAU,EAAE,IAAI;gBAChB,YAAY,EAAE,IAAI;gBAClB,GAAG,EAAE,4BAA2B,IAAI,CAAC,QAAQ,EAAE;gBAC/C,GAAG,EAAE,uBAAsB,KAAK;oBAC9B,IAAI,CAAC,QAAQ,CAAC,KAAK,eAAsB,CAAC;iBAC3C;aACF,CACF,CAAC;SACH;QACD,OAAO,IAAI,CAAC;KACb;IAEM,IAAI;QACT,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,WAAW,EAAE;gBAC9B,UAAU,EAAE,IAAI;gBAChB,YAAY,EAAE,IAAI;gBAClB,QAAQ,EAAE,IAAI;gBACd,KAAK,EAAE,IAAI,CAAC,KAAK;aAClB,CAAC,CAAC;YACH,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;;SAExB;QACD,OAAO,IAAI,CAAC;KACb;CACF;MAMY,cAAc;IA6BzB,YACE,GAAW,EACX,WAAwB,EACxB,GAAgC,EAChC,YAAqB;QAhCP,SAAI,oBAAuC;;;;QAMnD,MAAC,GAAY,KAAK,CAAC,CAAC;;;;QAIpB,OAAE,GAAY,KAAK,CAAC,CAAC;;;;QAIrB,MAAC,gBAAuC;QAoB9C,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC;QACb,MAAM,QAAQ,GAAI,GAAkB,CAAC,WAAqB,CAAC,CAAC;QAC5D,IAAI,CAAC,EAAE,GAAG,OAAO,QAAQ,KAAK,UAAU,GAAG,QAAiC,GAAG,KAAK,CAAC,CAAC;QACtF,IAAI,CAAC,CAAC,GAAG,YAAY,CAAC;KACvB;IAEM,QAAQ;QACb,OAAO,IAAI,CAAC,CAAC,CAAC;KACf;IAEM,QAAQ,CAAC,KAAc,EAAE,KAAqB;;QACnD,IAAI,OAAO,IAAI,CAAC,CAAC,KAAK,UAAU,EAAE;YAChC,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;SACvB;QACD,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE;YAC7B,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;YACjB,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;YACf,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC;YACf,MAAA,IAAI,CAAC,EAAE,0CAAE,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE;YAChD,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACtB;KACF;IAEM,KAAK;QACV,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC;QACb,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;QACjB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;KACtC;CACF;AAED,oBAAoB,CAAC,cAAc,CAAC,CAAC;AACrC,oBAAoB,CAAC,cAAc,CAAC,CAAC;AACrC,cAAc,CAAC,cAAc,CAAC,CAAC;AAC/B,cAAc,CAAC,cAAc,CAAC;;ACrKvB,MAAM,gBAAgB,GAAG,IAAI,gBAAgB,EAAE,CAAC;MAO1C,gBAAgB,GAAG9B,SAAE,CAAC,eAAe,CAAmB,kBAAkB,EAAE,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,eAAe,CAAC,EAAE;MAO/G,oBAAoB,GAAGA,SAAE;KACnC,eAAe,CAAuB,sBAAsB,EAAE,CAAC,IAAI,CAAC,CAAC,cAAc,CAAC,OAAO;IAC1F,OAAO,CAAC,MAAM,CAAC+B,cAAO,CAAC,CAAC,OAAO,CAAC,MAAM;QACpC,MAAM,CAAC,KAAK,CAAC,qGAAqG,CAAC,CAAC;KACrH,CAAC,CAAC;IACH,OAAO,IAAI,0BAA0B,EAAE,CAAC;AAC1C,CAAC,CAAC,EAAE;AAEN,MAAM,0BAA0B;IACvB,OAAO;QACZ,OAAO,KAAK,CAAC;KACd;IACM,WAAW;QAChB,OAAO,gBAAgB,CAAC;KACzB;IACM,WAAW;QAChB,OAAO,gBAAgB,CAAC;KACzB;CACF;MAaY,eAAe;IAK1B,YACmB,YAA2B,EAC3B,mBAAyC;QADzC,iBAAY,GAAZ,YAAY,CAAe;QAC3B,wBAAmB,GAAnB,mBAAmB,CAAsB;QAJ3C,aAAQ,GAAgC,EAAE,CAAC;KAKxD;IAEG,UAAU,CAAC,OAAkC;QAClD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;KAC7B;IAEM,WAAW,CAAC,GAAW,EAAE,GAAgB;;QAC9C,aAAO,MAAC,GAAmB,CAAC,UAAU,0CAAG,GAAa,CAA0B,mCAC3E,IAAI,CAAC,KAAK,CAAE,GAAmB,EAAE,GAAa,EAAE,IAAI,CAAC,cAAc,CAAE,GAAmB,EAAE,GAAa,CAAC,CAAc,CAAC;KAC7H;IAEM,WAAW,CAAC,GAAW,EAAE,GAAW;;QACzC,MAAM,MAAM,GAAG,MAAC,GAAmB,CAAC,UAAU,0CAAG,GAAG,CAAmC,CAAC;QACxF,IAAI,MAAM,KAAK,KAAK,CAAC,EAAE;YACrB,OAAO,MAAM,CAAC;SACf;QACD,IAAI,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE;YACpD,OAAO,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAuB,CAAC;SACnF;QAED,OAAO,gBAAgB,CAAC;KACzB;IAEM,gBAAgB,CAAC,aAAwB;QAC9C,OAAO,gBAAgB,CAAC,aAAa,CAAC,CAAC;KACxC;IAEM,cAAc,CAAC,WAAkC;QACtD,OAAO,cAAc,CAAC,WAAW,CAAC,CAAC;KACpC;IAEM,cAAc,CAAC,WAAyB;QAC7C,OAAO,cAAc,CAAC,WAAW,CAAC,CAAC;KACpC;IAEO,cAAc,CAAC,GAAgB,EAAE,GAAW;;QAClD,IAAI,EAAE,GAAG,YAAY,MAAM,CAAC,EAAE;YAC5B,OAAO,IAAI,iBAAiB,CAAC,GAA2B,EAAE,GAAG,CAAC,CAAC;SAChE;QAED,IAAI,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE;YACpD,OAAO,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAuB,CAAC;SACnF;QAED,QAAQ,GAAG;YACT,KAAK,QAAQ;gBACX,IAAI,GAAG,YAAY,KAAK,EAAE;oBACxB,OAAO,gBAAgB,CAAC,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;iBAClD;gBACD,MAAM;YACR,KAAK,MAAM;gBACT,IAAI,GAAG,YAAY,GAAG,EAAE;oBACtB,OAAO,cAAc,CAAC,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;iBAChD;qBAAM,IAAI,GAAG,YAAY,GAAG,EAAE;oBAC7B,OAAO,cAAc,CAAC,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;iBAChD;gBACD,MAAM;YACR;gBACE,IAAI,GAAG,YAAY,KAAK,IAAIf,mBAAY,CAAC,GAAG,CAAC,EAAE;oBAC7C,OAAO,gBAAgB,CAAC,GAAG,CAAC,CAAC,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;iBAC5D;gBACD,MAAM;SACT;QAED,IAAI,EAAE,GAAG,MAAM,CAAC,wBAAwB,CAAC,GAAG,EAAE,GAAG,CAA+B,CAAC;;QAEjF,IAAI,EAAE,KAAK,KAAK,CAAC,EAAE;YACjB,IAAI,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,GAAG,CAAkB,CAAC;YACxD,OAAO,KAAK,KAAK,IAAI,EAAE;gBACrB,EAAE,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,GAAG,CAA+B,CAAC;gBAC/E,IAAI,EAAE,KAAK,KAAK,CAAC,EAAE;oBACjB,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAkB,CAAC;iBACvD;qBAAM;oBACL,MAAM;iBACP;aACF;SACF;;QAGD,IAAI,EAAE,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE;YACvE,IAAI,GAAG,GAA0C,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;YACvF,IAAI,GAAG,IAAI,IAAI,EAAE;gBACf,GAAG,GAAG,mBAAC,EAAE,CAAC,GAAG,0CAAE,WAAW,yCAAI,EAAE,CAAC,GAAG,0CAAE,WAAW,CAAC,0CAAG,GAAG,EAAE,IAAI,CAAuB,CAAC;aACvF;YAED,OAAO,GAAG,IAAI,IAAI;kBACd,EAAE,CAAC,YAAY;sBACb,gBAAgB,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,+BAA+B,IAAI,CAAC;sBAC9E,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,GAAG,EAAE,GAAG,CAAC;kBAC5C,GAAG,CAAC;SACT;;;QAID,OAAO,IAAI,cAAc,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;KACrC;IAEO,kBAAkB,CAAC,GAAgB,EAAE,YAAoB,EAAE,EAAsB;QACvF,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YAC5B,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACnC,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,GAAG,EAAE,YAAY,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;gBAClE,IAAI,QAAQ,IAAI,IAAI,EAAE;oBACpB,OAAO,QAAQ,CAAC;iBACjB;aACF;SACF;QACD,OAAO,IAAI,CAAC;KACb;IAEO,KAAK,CAAC,GAAgB,EAAE,GAAW,EAAE,QAA4B;QACvE,IAAI,QAAQ,CAAC,UAAU,KAAK,IAAI,EAAE;YAChC,OAAO,QAAQ,CAAC;SACjB;QACD,IAAI,GAAG,CAAC,UAAU,KAAK,KAAK,CAAC,EAAE;YAC7B,GAAG,CAAC,GAAG,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,GAAG,GAAG,QAAQ,EAAE,EAAE,CAAC,CAAC;YACvD,OAAO,QAAQ,CAAC;SACjB;QACD,OAAO,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;KACvC;;AA7HyB,sBAAM,GAAG,CAAC,aAAa,EAAE,oBAAoB,CAAC,CAAC;SAkI3D,qBAAqB,CAAC,UAAgC;IACpE,IAAI,GAAmC,CAAC;IACxC,IAAI,UAAU,YAAY,KAAK,EAAE;QAC/B,GAAG,GAAG,gBAAgB,CAAC,UAAU,CAAC,CAAC;KACpC;SAAM,IAAI,UAAU,YAAY,GAAG,EAAE;QACpC,GAAG,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC;KAClC;SAAM,IAAI,UAAU,YAAY,GAAG,EAAE;QACpC,GAAG,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC;KAClC;IACD,OAAO,GAAG,CAAC;AACb;;MCvMa,YAAY,GAAGhB,SAAE,CAAC,eAAe,CAAe,cAAc,EAAE,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE;MAE/F,WAAW;IAItB,YACkB,eAAiC;QAAjC,oBAAe,GAAf,eAAe,CAAkB;KAC/C;IAJG,WAAW,MAAM,KAAK,OAAO,CAAC,gBAAgB,CAAC,CAAC,EAAE;;;;;IAUlD,GAAG,CAAC,EAAc;QACvB,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC;;QAEpD,MAAM,CAAC,GAAG,EAAE,CAAC;QACb,OAAO,MAAM,CAAC;KACf;CACF;AASD,MAAM,MAAM;IAWV,YACkB,eAAiC,EACjC,EAAc;QADd,oBAAe,GAAf,eAAe,CAAkB;QACjC,OAAE,GAAF,EAAE,CAAY;QAXhB,gBAAW,GAAS,IAAI,CAAC;;QAGlC,gBAAW,GAAW,EAAE,CAAC;QACxB,WAAM,GAAY,KAAK,CAAC;QACxB,YAAO,GAAY,KAAK,CAAC;QACzB,aAAQ,GAAW,CAAC,CAAC;QACrB,YAAO,GAAY,KAAK,CAAC;KAMhC;IAEM,YAAY;QACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,GAAG,EAAE,CAAC;KACZ;IAEM,sBAAsB;QAC3B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,GAAG,EAAE,CAAC;KACZ;IAEM,GAAG;QACR,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;SACpD;QACD,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAO;SACR;QACD,EAAE,IAAI,CAAC,QAAQ,CAAC;QAChB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC;QACnB,IAAI;YACF,gBAAgB,CAAC,IAAI,CAAC,CAAC;YACvB,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;SACf;gBAAS;YACR,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACtB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;YACrB,eAAe,CAAC,IAAI,CAAC,CAAC;SACvB;;;;;QAKD,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IAAI,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE;gBACpC,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;gBAClB,MAAM,IAAI,KAAK,CAAC,kGAAkG,CAAC,CAAC;aACrH;YACD,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;aAAM;YACL,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;SACnB;KACF;IAEM,IAAI;QACT,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACtB;CACF;AAED,WAAW,CAAC,MAAM,CAAC;;ACzFnB,SAAS,kBAAkB,CAAC,GAAgB;IAC1C,IAAI,GAAG,CAAC,UAAU,KAAK,KAAK,CAAC,EAAE;QAC7B,GAAG,CAAC,GAAG,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC;;KAEvC;IACD,OAAO,GAAG,CAAC,UAA6D,CAAC;AAC3E,CAAC;AAED,MAAM,OAAO,GAAY,EAAE,CAAC;AA2B5B;SACgB,UAAU,CACxB,cAAiG,EACjG,GAAiB,EACjB,UAA+B;;;IAI/B,IAAI,GAAG,IAAI,IAAI,EAAE;;;;;;;;;;;;QAYf,QAAQ,CAAC,CAAgB,EAAE,CAAc,EAAE,CAAqB,KAAK,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,cAAc,CAAC,EAAoB;KACvH;;;;;IAKD,OAAO,IAAI,CAAC,cAA4C,EAAE,GAAG,EAAE,UAAU,CAAsB,CAAC;IAEhG,SAAS,IAAI,CACX,MAAkD,EAClD,GAAiB,EACjB,UAAoE,EACpE,MAA4C;;;QAG5C,MAAM,gBAAgB,GAAG,GAAG,KAAK,KAAK,CAAC,CAAC;QACxC,MAAM,GAAG,OAAO,MAAM,KAAK,QAAQ;cAC/B,EAAE,IAAI,EAAE,MAAM,EAAE;eACf,MAAM,IAAI,EAAE,CAAC,CAAC;QAEnB,IAAI,gBAAgB,EAAE;YACpB,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;SACnB;QAED,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,EAAE,EAAE;YAC7B,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;SAClF;;QAGD,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;QAC5D,IAAI,YAAY,GAAG,OAAO,CAAC;QAC3B,IAAI,UAAU,EAAE;;;YAGd,OAAO,UAAU,CAAC,KAAK,CAAC;YACxB,OAAO,UAAU,CAAC,QAAQ,CAAC;YAC3B,YAAY,SAAG,UAAU,CAAC,WAAW,+CAAtB,UAAU,CAAgB,CAAC;YAC1C,OAAO,UAAU,CAAC,WAAW,CAAC;SAC/B;aAAM;YACL,UAAU,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;SACrC;;QAGD,IAAI,EAAE,YAAY,IAAI,UAAU,CAAC,EAAE;YACjC,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC;SAC9B;;QAGD,MAAM,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC;QACxB,UAAU,CAAC,GAAG,GAAG,SAAS,CAAC;;YACzB,MAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,EAAE,GAAI,EAAE,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;YACvE,MAAA,kBAAkB,EAAE,0CAAE,WAAW,CAAC,QAAQ,EAAE;YAC5C,OAAO,QAAQ,CAAC,QAAQ,EAAE,CAAC;SAC5B,CAAC;QACF,UAAU,CAAC,GAAG,GAAG,SAAS,CAAC,CAAoD,QAAiB;YAC9F,WAAW,CAAC,IAAI,EAAE,GAAI,EAAE,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,QAAQ,eAAsB,CAAC;SAC/F,CAAC;QACD,UAAU,CAAC,GAAwB,CAAC,WAAW,GAAG,SAAS,EAAE,mBAAkB,GAA+B;YAC7G,OAAO,WAAW,CAAC,GAAG,EAAE,GAAI,EAAE,QAAQ,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;SAC7D,CAAC;QAEF,IAAI,gBAAgB,EAAE;YACpB,GAAG,CAAE,MAAwB,CAAC,SAAS,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC;SAC3D;aAAM;YACL,OAAO,UAAU,CAAC;SACnB;KACF;AACH,CAAC;AAED,SAAS,WAAW,CAClB,GAA+B,EAC/B,GAAgB,EAChB,WAAwB,EACxB,YAAqB,EACrB,GAAgC;IAEhC,MAAM,MAAM,GAAG,kBAAkB,CAAC,GAAG,CAAoE,CAAC;IAC1G,IAAI,QAAQ,GAAG,MAAM,CAAC,GAAa,CAAmB,CAAC;IACvD,IAAI,QAAQ,IAAI,IAAI,EAAE;QACpB,QAAQ,GAAG,IAAI,cAAc,CAAC,GAAG,EAAE,WAAW,EAAE,GAAG,EAAE,YAAY,KAAK,OAAO,GAAG,KAAK,CAAC,GAAG,YAAY,CAAC,CAAC;QACvG,MAAM,CAAC,GAAa,CAAC,GAAG,QAAQ,CAAC;KAClC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}