{"version":3,"file":"index.esm.js","sources":["../../src/rule-interfaces.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/rules.ts","../../src/rule-provider.ts","../../src/ast-serialization.ts","../../src/serialization.ts","../../src/validator.ts","../../src/configuration.ts"],"sourcesContent":["import { Class, DI } from '@aurelia/kernel';\nimport { IsBindingBehavior, IExpressionParser } from '@aurelia/runtime';\nimport { Deserializer } from './ast-serialization.js';\nimport { IValidationRules } from './rule-provider.js';\nimport { IValidationMessageProvider } from './rules.js';\n\nexport type IValidateable<T = any> = (Class<T> | object) & { [key in PropertyKey]: any };\nexport type ValidationRuleExecutionPredicate<TObject extends IValidateable = IValidateable> = (object?: TObject) => boolean;\n\nexport interface IValidationRule<TValue = any, TObject extends IValidateable = IValidateable> {\n  tag?: string;\n  messageKey: string;\n  canExecute(object?: IValidateable): boolean;\n\n  /**\n   * Core rule execution.\n   *\n   * @param {TValue} value - value to validate\n   * @param {TObject} [object] - target object\n   * @returns {(boolean | Promise<boolean>)} - `true | Promise<true>` if the validation is successful, else `false | Promise<false>`.\n   */\n  execute(value: TValue, object?: TObject): boolean | Promise<boolean>;\n  accept(visitor: IValidationVisitor): any;\n}\n\nexport interface IRequiredRule extends IValidationRule { }\nexport interface IRegexRule extends IValidationRule<string> {\n  readonly pattern: RegExp;\n}\nexport interface ILengthRule extends IValidationRule<string> {\n  readonly length: number;\n  readonly isMax: boolean;\n}\nexport interface ISizeRule extends IValidationRule<unknown[]> {\n  readonly count: number;\n  readonly isMax: boolean;\n}\nexport interface IRangeRule extends IValidationRule<number> {\n  readonly min: number;\n  readonly max: number;\n  readonly isInclusive: boolean;\n}\nexport interface IEqualsRule extends IValidationRule {\n  readonly expectedValue: unknown;\n}\n\nexport type ValidationDisplayNameAccessor = () => string;\n/**\n * Describes a property to be validated.\n */\nexport interface IRuleProperty {\n  /**\n   * parsed property expression.\n   */\n  expression?: IsBindingBehavior;\n  /**\n   * name of the property; absent for a object validation.\n   */\n  name: string | number | undefined;\n  /**\n   * display name of the property to be used in validation error messages.\n   */\n  displayName: string | ValidationDisplayNameAccessor | undefined;\n  accept(visitor: IValidationVisitor): any;\n}\n\n/**\n * Describes a collection of rules, defined on a property.\n */\nexport interface IPropertyRule {\n  property: IRuleProperty;\n  $rules: IValidationRule[][];\n  accept(visitor: IValidationVisitor): any;\n}\n\nexport interface IValidationVisitor {\n  visitRequiredRule(rule: IRequiredRule): string;\n  visitRegexRule(rule: IRegexRule): string;\n  visitLengthRule(rule: ILengthRule): string;\n  visitSizeRule(rule: ISizeRule): string;\n  visitRangeRule(rule: IRangeRule): string;\n  visitEqualsRule(rule: IEqualsRule): string;\n  visitRuleProperty(property: IRuleProperty): string;\n  visitPropertyRule(propertyRule: IPropertyRule): string;\n}\n\nexport const IValidationExpressionHydrator = DI.createInterface<IValidationExpressionHydrator>('IValidationExpressionHydrator');\nexport interface IValidationExpressionHydrator {\n  readonly astDeserializer: Deserializer;\n  readonly parser: IExpressionParser;\n  readonly messageProvider: IValidationMessageProvider;\n  hydrate(raw: any, validationRules: IValidationRules): any;\n  hydrateRuleset(ruleset: any, validationRules: IValidationRules): IPropertyRule[];\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Constructable, Protocol, Metadata, Class, DI, toArray } from '@aurelia/kernel';\nimport { Interpolation, PrimitiveLiteralExpression } from '@aurelia/runtime';\nimport {\n  IValidateable,\n  IValidationRule,\n  IRequiredRule,\n  IRegexRule,\n  ILengthRule,\n  ISizeRule,\n  IRangeRule,\n  IEqualsRule,\n  IValidationVisitor,\n  ValidationDisplayNameAccessor,\n} from './rule-interfaces.js';\n\n/**\n * Retrieves validation messages and property display names.\n */\nexport interface IValidationMessageProvider {\n  /**\n   * Gets the parsed message for the `rule`.\n   */\n  getMessage(rule: IValidationRule): Interpolation | PrimitiveLiteralExpression;\n  /**\n   * Gets the parsed message for the `rule`.\n   */\n  setMessage(rule: IValidationRule, message: string): Interpolation | PrimitiveLiteralExpression;\n  /**\n   * Core message parsing function.\n   */\n  parseMessage(message: string): Interpolation | PrimitiveLiteralExpression;\n  /**\n   * Formulates a property display name using the property name and the configured displayName (if provided).\n   */\n  getDisplayName(propertyName: string | number | undefined, displayName?: string | null | ValidationDisplayNameAccessor): string | undefined;\n}\n\nexport const IValidationMessageProvider = DI.createInterface<IValidationMessageProvider>('IValidationMessageProvider');\n\nexport interface ValidationRuleAlias {\n  name: string;\n  defaultMessage?: string;\n}\nexport interface ValidationRuleDefinition {\n  aliases: ValidationRuleAlias[];\n}\nexport type RuleType<TRule extends IValidationRule> = Class<TRule, { $TYPE: string }>;\nexport const ValidationRuleAliasMessage = Object.freeze({\n  aliasKey: Protocol.annotation.keyFor('validation-rule-alias-message'),\n  define<TRule extends IValidationRule>(target: RuleType<TRule>, definition: ValidationRuleDefinition): RuleType<TRule> {\n    ValidationRuleAliasMessage.setDefaultMessage(target, definition);\n    return target;\n  },\n  setDefaultMessage<TRule extends IValidationRule>(rule: Constructable<TRule>, { aliases }: ValidationRuleDefinition, append: boolean = true) {\n    // conditionally merge\n    const defaultMessages = append ? Metadata.getOwn(this.aliasKey, rule.prototype) as ValidationRuleAlias[] : void 0;\n    if (defaultMessages !== void 0) {\n      // TODO: have polyfill for `Object.fromEntries` as IE does not yet support it\n      const allMessages: Record<string, string> = {\n        ...Object.fromEntries(defaultMessages.map(({ name, defaultMessage }) => [name, defaultMessage])) as Record<string, string>,\n        ...Object.fromEntries(aliases.map(({ name, defaultMessage }) => [name, defaultMessage])) as Record<string, string>,\n      };\n      aliases = toArray(Object.entries(allMessages)).map(([name, defaultMessage]) => ({ name, defaultMessage }));\n    }\n    Metadata.define(ValidationRuleAliasMessage.aliasKey, aliases, rule instanceof Function ? rule.prototype : rule);\n  },\n  getDefaultMessages<TRule extends IValidationRule>(rule: Constructable<TRule> | TRule): ValidationRuleAlias[] {\n    return Metadata.get(this.aliasKey, rule instanceof Function ? rule.prototype : rule);\n  }\n});\n\nexport function validationRule(definition: ValidationRuleDefinition) {\n  return function <TRule extends IValidationRule>(target: RuleType<TRule>) {\n    return ValidationRuleAliasMessage.define(target, definition);\n  };\n}\n\n/**\n * Abstract validation rule.\n */\n@validationRule({ aliases: [{ name: (void 0)!, defaultMessage: `\\${$displayName} is invalid.` }] })\nexport class BaseValidationRule<TValue = any, TObject extends IValidateable = IValidateable> implements IValidationRule<TValue, TObject> {\n  public static readonly $TYPE: string = '';\n  public tag?: string = (void 0)!;\n  public constructor(\n    public messageKey: string = (void 0)!,\n  ) { }\n  public canExecute(_object?: IValidateable): boolean { return true; }\n  public execute(_value: TValue, _object?: TObject): boolean | Promise<boolean> {\n    throw new Error('No base implementation of execute. Did you forget to implement the execute method?'); // TODO: reporter\n  }\n  public accept(_visitor: IValidationVisitor): any {\n    throw new Error('No base implementation of accept. Did you forget to implement the accept method?'); // TODO: reporter\n  }\n}\n\n/**\n * Passes the validation if the value is not `null`, and not `undefined`.\n * In case of string, it must not be empty.\n *\n * @see PropertyRule#required\n */\n@validationRule({ aliases: [{ name: 'required', defaultMessage: `\\${$displayName} is required.` }] })\nexport class RequiredRule extends BaseValidationRule implements IRequiredRule {\n  public static readonly $TYPE: string = 'RequiredRule';\n  public constructor() { super('required'); }\n  public execute(value: unknown): boolean | Promise<boolean> {\n    return value !== null\n      && value !== void 0\n      && !(typeof value === 'string' && !/\\S/.test(value));\n  }\n  public accept(visitor: IValidationVisitor) {\n    return visitor.visitRequiredRule(this);\n  }\n}\n\n/**\n * Passes the validation if the non-`null`, non-`undefined`, and non-empty string value matches the given pattern described by a regular expression.\n * There are 2 aliases: 'matches' (any random regex), and 'email' (with email regex).\n *\n * @see PropertyRule#matches\n * @see PropertyRule#email\n */\n@validationRule({\n  aliases: [\n    { name: 'matches', defaultMessage: `\\${$displayName} is not correctly formatted.` },\n    { name: 'email', defaultMessage: `\\${$displayName} is not a valid email.` },\n  ]\n})\nexport class RegexRule extends BaseValidationRule<string> implements IRegexRule {\n  public static readonly $TYPE: string = 'RegexRule';\n  public constructor(public readonly pattern: RegExp, messageKey: string = 'matches') {\n    super(messageKey);\n  }\n  public execute(value: string): boolean | Promise<boolean> {\n    return value === null\n      || value === undefined\n      || value.length === 0\n      || this.pattern.test(value);\n  }\n  public accept(visitor: IValidationVisitor) {\n    return visitor.visitRegexRule(this);\n  }\n}\n\n/**\n * Passes the validation if the non-`null`, non-`undefined`, and non-empty string value matches the given length constraint.\n * There are 2 aliases: 'minLength', and 'maxLength'.\n *\n * @see PropertyRule#minLength\n * @see PropertyRule#maxLength\n */\n@validationRule({\n  aliases: [\n    { name: 'minLength', defaultMessage: `\\${$displayName} must be at least \\${$rule.length} character\\${$rule.length === 1 ? '' : 's'}.` },\n    { name: 'maxLength', defaultMessage: `\\${$displayName} cannot be longer than \\${$rule.length} character\\${$rule.length === 1 ? '' : 's'}.` },\n  ]\n})\nexport class LengthRule extends BaseValidationRule<string> implements ILengthRule {\n  public static readonly $TYPE: string = 'LengthRule';\n  public constructor(public readonly length: number, public readonly isMax: boolean) {\n    super(isMax ? 'maxLength' : 'minLength');\n  }\n  public execute(value: string): boolean | Promise<boolean> {\n    return value === null\n      || value === undefined\n      || value.length === 0\n      || (this.isMax ? value.length <= this.length : value.length >= this.length);\n  }\n  public accept(visitor: IValidationVisitor) {\n    return visitor.visitLengthRule(this);\n  }\n}\n\n/**\n * Passes the validation if the non-`null`, and non-`undefined` array value matches the given count constraint.\n * There are 2 aliases: 'minItems', and 'maxItems'.\n *\n * @see PropertyRule#minItems\n * @see PropertyRule#maxItems\n */\n@validationRule({\n  aliases: [\n    { name: 'minItems', defaultMessage: `\\${$displayName} must contain at least \\${$rule.count} item\\${$rule.count === 1 ? '' : 's'}.` },\n    { name: 'maxItems', defaultMessage: `\\${$displayName} cannot contain more than \\${$rule.count} item\\${$rule.count === 1 ? '' : 's'}.` },\n  ]\n})\nexport class SizeRule extends BaseValidationRule<unknown[]> implements ISizeRule {\n  public static readonly $TYPE: string = 'SizeRule';\n  public constructor(public readonly count: number, public readonly isMax: boolean) {\n    super(isMax ? 'maxItems' : 'minItems');\n  }\n  public execute(value: unknown[]): boolean | Promise<boolean> {\n    return value === null\n      || value === undefined\n      || (this.isMax ? value.length <= this.count : value.length >= this.count);\n  }\n  public accept(visitor: IValidationVisitor) {\n    return visitor.visitSizeRule(this);\n  }\n}\n\ntype Range = {\n  min?: number;\n  max?: number;\n};\n\n/**\n * Passes the validation if the non-`null`, and non-`undefined` numeric value matches the given interval constraint.\n * There are 2 aliases: 'min' (`[min,]`), 'max' (`[, max]`), range (`[min, max]`), and 'between' (`(min, max)`).\n *\n * @see PropertyRule#min\n * @see PropertyRule#max\n * @see PropertyRule#range\n * @see PropertyRule#between\n */\n@validationRule({\n  aliases: [\n    { name: 'min', defaultMessage: `\\${$displayName} must be at least \\${$rule.min}.` },\n    { name: 'max', defaultMessage: `\\${$displayName} must be at most \\${$rule.max}.` },\n    { name: 'range', defaultMessage: `\\${$displayName} must be between or equal to \\${$rule.min} and \\${$rule.max}.` },\n    { name: 'between', defaultMessage: `\\${$displayName} must be between but not equal to \\${$rule.min} and \\${$rule.max}.` },\n  ]\n})\nexport class RangeRule extends BaseValidationRule<number> implements IRangeRule {\n  public static readonly $TYPE: string = 'RangeRule';\n  public readonly min: number = Number.NEGATIVE_INFINITY;\n  public readonly max: number = Number.POSITIVE_INFINITY;\n  public constructor(public readonly isInclusive: boolean, { min, max }: Range) {\n    super(\n      min !== void 0 && max !== void 0\n        ? (isInclusive ? 'range' : 'between')\n        : (min !== void 0 ? 'min' : 'max')\n    );\n    this.min = min ?? this.min;\n    this.max = max ?? this.max;\n  }\n  public execute(value: number, _object?: IValidateable): boolean | Promise<boolean> {\n    return value === null\n      || value === undefined\n      || (this.isInclusive\n        ? value >= this.min && value <= this.max\n        : value > this.min && value < this.max\n      );\n  }\n  public accept(visitor: IValidationVisitor) {\n    return visitor.visitRangeRule(this);\n  }\n}\n\n/**\n * Passes the validation if the the non-`null`, non-`undefined`, non-empty value matches given expected value.\n *\n * @see PropertyRule#equals\n */\n@validationRule({\n  aliases: [\n    { name: 'equals', defaultMessage: `\\${$displayName} must be \\${$rule.expectedValue}.` },\n  ]\n})\nexport class EqualsRule extends BaseValidationRule implements IEqualsRule {\n  public static readonly $TYPE: string = 'EqualsRule';\n  public constructor(public readonly expectedValue: unknown) { super('equals'); }\n  public execute(value: unknown): boolean | Promise<boolean> {\n    return value === null\n      || value === undefined\n      || value as any === ''\n      || value === this.expectedValue;\n  }\n  public accept(visitor: IValidationVisitor) {\n    return visitor.visitEqualsRule(this);\n  }\n}\n","import { Class, DI, Protocol, Metadata, ILogger, IServiceLocator } from '@aurelia/kernel';\nimport {\n  BindingType,\n  IExpressionParser,\n  Interpolation,\n  IsBindingBehavior,\n  LifecycleFlags,\n  PrimitiveLiteralExpression,\n  AccessScopeExpression,\n  Scope,\n  ExpressionKind,\n} from '@aurelia/runtime';\nimport {\n  ValidationRuleAlias,\n  RequiredRule,\n  RegexRule,\n  LengthRule,\n  SizeRule,\n  RangeRule,\n  EqualsRule,\n  IValidationMessageProvider,\n  ValidationRuleAliasMessage,\n  BaseValidationRule,\n} from './rules.js';\nimport {\n  IValidateable,\n  ValidationRuleExecutionPredicate,\n  IValidationVisitor,\n  ValidationDisplayNameAccessor,\n  IRuleProperty,\n  IPropertyRule,\n  IValidationExpressionHydrator,\n  IValidationRule,\n} from './rule-interfaces.js';\n\n/**\n * Contract to register the custom messages for rules, during plugin registration.\n */\nexport interface ICustomMessage<TRule extends IValidationRule = IValidationRule> {\n  rule: Class<TRule>;\n  aliases: ValidationRuleAlias[];\n}\n\n/* @internal */\nexport const ICustomMessages = DI.createInterface<ICustomMessage[]>('ICustomMessages');\n\nexport class RuleProperty implements IRuleProperty {\n  public static $TYPE: string = 'RuleProperty';\n  public constructor(\n    public expression?: IsBindingBehavior,\n    public name: string | number | undefined = void 0,\n    public displayName: string | ValidationDisplayNameAccessor | undefined = void 0,\n  ) { }\n  public accept(visitor: IValidationVisitor): string {\n    return visitor.visitRuleProperty(this);\n  }\n}\nexport type RuleCondition<TObject extends IValidateable = IValidateable, TValue = any> = (value: TValue, object?: TObject) => boolean | Promise<boolean>;\n\nexport const validationRulesRegistrar = Object.freeze({\n  name: 'validation-rules',\n  defaultRuleSetName: '__default',\n  set(target: IValidateable, rules: IPropertyRule[], tag?: string): void {\n    const key = `${validationRulesRegistrar.name}:${tag ?? validationRulesRegistrar.defaultRuleSetName}`;\n    Metadata.define(Protocol.annotation.keyFor(key), rules, target);\n    const keys = Metadata.getOwn(Protocol.annotation.name, target) as string[];\n    if (keys === void 0) {\n      Metadata.define(Protocol.annotation.name, [key], target);\n    } else {\n      keys.push(key);\n    }\n  },\n  get(target: IValidateable, tag?: string): PropertyRule[] {\n    const key = Protocol.annotation.keyFor(validationRulesRegistrar.name, tag ?? validationRulesRegistrar.defaultRuleSetName);\n    return Metadata.get(key, target) ?? Metadata.getOwn(key, target.constructor);\n  },\n  unset(target: IValidateable, tag?: string): void {\n    const keys = Metadata.getOwn(Protocol.annotation.name, target) as string[];\n    for (const key of keys.slice(0)) {\n      if (key.startsWith(validationRulesRegistrar.name) && (tag === void 0 || key.endsWith(tag))) {\n        Metadata.delete(Protocol.annotation.keyFor(key), target);\n        const index = keys.indexOf(key);\n        if (index > -1) {\n          keys.splice(index, 1);\n        }\n      }\n    }\n  },\n  isValidationRulesSet(target: IValidateable) {\n    const keys = Metadata.getOwn(Protocol.annotation.name, target) as string[];\n    return keys !== void 0 && keys.some((key) => key.startsWith(validationRulesRegistrar.name));\n  }\n});\n\nclass ValidationMessageEvaluationContext {\n  public constructor(\n    private readonly messageProvider: IValidationMessageProvider,\n    public readonly $displayName: string | undefined,\n    public readonly $propertyName: string | number | undefined,\n    public readonly $value: unknown,\n    public readonly $rule: IValidationRule,\n    public readonly $object?: IValidateable,\n  ) { }\n  public $getDisplayName(propertyName: string | number | undefined, displayName?: string | null | ValidationDisplayNameAccessor) {\n    return this.messageProvider.getDisplayName(propertyName, displayName);\n  }\n}\nexport class PropertyRule<TObject extends IValidateable = IValidateable, TValue = unknown> implements IPropertyRule {\n  public static readonly $TYPE: string = 'PropertyRule';\n  private latestRule?: IValidationRule;\n\n  public constructor(\n    private readonly locator: IServiceLocator,\n    public readonly validationRules: IValidationRules,\n    public readonly messageProvider: IValidationMessageProvider,\n    public property: RuleProperty,\n    public $rules: IValidationRule[][] = [[]],\n  ) { }\n  public accept(visitor: IValidationVisitor): string {\n    return visitor.visitPropertyRule(this);\n  }\n\n  /** @internal */\n  public addRule(rule: IValidationRule) {\n    const rules: IValidationRule[] = this.getLeafRules();\n    rules.push(this.latestRule = rule);\n    return this;\n  }\n\n  private getLeafRules(): IValidationRule[] {\n    const depth = this.$rules.length - 1;\n    return this.$rules[depth];\n  }\n\n  public async validate(\n    object?: IValidateable,\n    tag?: string,\n    flags?: LifecycleFlags,\n    scope?: Scope\n  ): Promise<ValidationResult[]> {\n    if (flags === void 0) {\n      flags = LifecycleFlags.none;\n    }\n    if (scope === void 0) {\n      scope = Scope.create({ [rootObjectSymbol]: object });\n    }\n    const expression = this.property.expression;\n    let value: unknown;\n    if (expression === void 0) {\n      value = object;\n    } else {\n      value = expression.evaluate(flags, scope, null, this.locator, null); // TODO: get proper hostScope?\n    }\n\n    let isValid = true;\n    const validateRuleset = async (rules: IValidationRule[]) => {\n      const validateRule = async (rule: IValidationRule) => {\n        let isValidOrPromise = rule.execute(value, object);\n        if (isValidOrPromise instanceof Promise) {\n          isValidOrPromise = await isValidOrPromise;\n        }\n        isValid = isValid && isValidOrPromise;\n        const { displayName, name } = this.property;\n        let message: string | undefined;\n        if (!isValidOrPromise) {\n          const messageEvaluationScope = Scope.create(\n            new ValidationMessageEvaluationContext(\n              this.messageProvider,\n              this.messageProvider.getDisplayName(name, displayName),\n              name,\n              value,\n              rule,\n              object,\n            ));\n          message = this.messageProvider.getMessage(rule).evaluate(flags!, messageEvaluationScope, null, null!, null) as string;\n        }\n        return new ValidationResult(isValidOrPromise, message, name, object, rule, this);\n      };\n\n      const promises: Promise<ValidationResult>[] = [];\n      for (const rule of rules) {\n        if (rule.canExecute(object) && (tag === void 0 || rule.tag === tag)) {\n          promises.push(validateRule(rule));\n        }\n      }\n      return Promise.all(promises);\n    };\n    const accumulateResult = async (results: ValidationResult[], rules: IValidationRule[]) => {\n      const result = await validateRuleset(rules);\n      results.push(...result);\n      return results;\n    };\n    return this.$rules.reduce(\n      async (acc, ruleset) => acc.then(async (accValidateResult) => isValid ? accumulateResult(accValidateResult, ruleset) : Promise.resolve(accValidateResult)),\n      Promise.resolve([] as ValidationResult[])\n    );\n  }\n\n  // #region customization API\n  /**\n   * Validate subsequent rules after previously declared rules have been validated successfully.\n   * Use to postpone validation of costly rules until less expensive rules pass validation.\n   */\n  public then() {\n    this.$rules.push([]);\n    return this;\n  }\n\n  /**\n   * Specifies the key to use when looking up the rule's validation message.\n   * Note that custom keys needs to be registered during plugin registration.\n   */\n  public withMessageKey(key: string) {\n    this.assertLatestRule(this.latestRule);\n    this.latestRule.messageKey = key;\n    return this;\n  }\n\n  /**\n   * Specifies rule's validation message; this overrides the rules default validation message.\n   */\n  public withMessage(message: string) {\n    const rule = this.latestRule;\n    this.assertLatestRule(rule);\n    this.messageProvider.setMessage(rule, message);\n    return this;\n  }\n\n  /**\n   * Specifies a condition that must be met before attempting to validate the rule.\n   *\n   * @param {ValidationRuleExecutionPredicate<TObject>} condition - A function that accepts the object as a parameter and returns true or false whether the rule should be evaluated.\n   */\n  public when(this: PropertyRule<TObject>, condition: ValidationRuleExecutionPredicate<TObject>) {\n    this.assertLatestRule(this.latestRule);\n    this.latestRule.canExecute = condition;\n    return this;\n  }\n\n  /**\n   * Tags the rule instance.\n   * The tag can later be used to perform selective validation.\n   */\n  public tag(tag: string) {\n    this.assertLatestRule(this.latestRule);\n    this.latestRule.tag = tag;\n    return this;\n  }\n\n  private assertLatestRule(latestRule: IValidationRule | undefined): asserts latestRule is IValidationRule {\n    if (latestRule === void 0) {\n      throw new Error('No rule has been added'); // TODO: use reporter\n    }\n  }\n  // #endregion\n\n  // #region rule helper API\n  /**\n   * Sets the display name of the ensured property.\n   */\n  public displayName(name: string | ValidationDisplayNameAccessor) {\n    this.property.displayName = name;\n    return this;\n  }\n\n  /**\n   * Applies an ad-hoc rule function to the ensured property or object.\n   *\n   * @param {RuleCondition} condition - The function to validate the rule. Will be called with two arguments, the property value and the object.\n   */\n  public satisfies(condition: RuleCondition) {\n    const rule = new (class extends BaseValidationRule { public execute: RuleCondition = condition; })();\n    return this.addRule(rule);\n  }\n\n  /**\n   * Applies a custom rule instance.\n   *\n   * @param {TRule} validationRule - rule instance.\n   */\n  public satisfiesRule<TRule extends IValidationRule>(validationRule: TRule) {\n    return this.addRule(validationRule);\n  }\n\n  /**\n   * Applies an instance of `RequiredRule`.\n   */\n  public required() {\n    return this.addRule(new RequiredRule());\n  }\n\n  /**\n   * Applies an instance of `RegexRule`.\n   */\n  public matches(this: PropertyRule<TObject, string>, regex: RegExp) {\n    return this.addRule(new RegexRule(regex));\n  }\n\n  /**\n   * Applies an instance of `RegexRule` with email pattern.\n   */\n  public email(this: PropertyRule<TObject, string>) {\n    // eslint-disable-next-line no-useless-escape\n    const emailPattern = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n    return this.addRule(new RegexRule(emailPattern, 'email'));\n  }\n\n  /**\n   * Applies an instance of `LengthRule` with min `length` constraint.\n   * Applicable for string value.\n   */\n  public minLength(this: PropertyRule<TObject, string>, length: number) {\n    return this.addRule(new LengthRule(length, false));\n  }\n\n  /**\n   * Applies an instance of `LengthRule` with max `length` constraint.\n   * Applicable for string value.\n   */\n  public maxLength(this: PropertyRule<TObject, string>, length: number) {\n    return this.addRule(new LengthRule(length, true));\n  }\n\n  /**\n   * Applies an instance of `SizeRule` with min `count` constraint.\n   * Applicable for array value.\n   */\n  public minItems(this: PropertyRule<TObject, unknown[]>, count: number) {\n    return this.addRule(new SizeRule(count, false));\n  }\n\n  /**\n   * Applies an instance of `SizeRule` with max `count` constraint.\n   * Applicable for array value.\n   */\n  public maxItems(this: PropertyRule<TObject, unknown[]>, count: number) {\n    return this.addRule(new SizeRule(count, true));\n  }\n\n  /**\n   * Applies an instance of `RangeRule` with [`constraint`,] interval.\n   * Applicable for number value.\n   */\n  public min(this: PropertyRule<TObject, number>, constraint: number) {\n    return this.addRule(new RangeRule(true, { min: constraint }));\n  }\n\n  /**\n   * Applies an instance of `RangeRule` with [,`constraint`] interval.\n   * Applicable for number value.\n   */\n  public max(this: PropertyRule<TObject, number>, constraint: number) {\n    return this.addRule(new RangeRule(true, { max: constraint }));\n  }\n\n  /**\n   * Applies an instance of `RangeRule` with [`min`,`max`] interval.\n   * Applicable for number value.\n   */\n  public range(this: PropertyRule<TObject, number>, min: number, max: number) {\n    return this.addRule(new RangeRule(true, { min, max }));\n  }\n\n  /**\n   * Applies an instance of `RangeRule` with (`min`,`max`) interval.\n   * Applicable for number value.\n   */\n  public between(this: PropertyRule<TObject, number>, min: number, max: number) {\n    return this.addRule(new RangeRule(false, { min, max }));\n  }\n\n  /**\n   * Applies an instance of `EqualsRule` with the `expectedValue`.\n   */\n  public equals(expectedValue: unknown) {\n    return this.addRule(new EqualsRule(expectedValue));\n  }\n  // #endregion\n\n  // #region ValidationRules proxy\n  /**\n   * Targets a object property for validation\n   *\n   * @param {(keyof TObject | string | PropertyAccessor<TObject, TValue>)} property - can be string or a property accessor function.\n   */\n  public ensure<TProp extends keyof TObject>(property: TProp): PropertyRule<TObject, TObject[TProp]>;\n  public ensure<TValue>(property: PropertyAccessor<TObject, TValue>): PropertyRule<TObject, TValue>;\n  public ensure(property: string): PropertyRule;\n  public ensure<TValue>(property: string | PropertyAccessor<TObject, TValue>) {\n    this.latestRule = void 0;\n    return this.validationRules.ensure<TValue>(property);\n  }\n\n  /**\n   * Targets an object with validation rules.\n   */\n  public ensureObject() {\n    this.latestRule = void 0;\n    return this.validationRules.ensureObject();\n  }\n\n  /**\n   * Rules that have been defined using the fluent API.\n   */\n  public get rules() {\n    return this.validationRules.rules;\n  }\n\n  /**\n   * Applies the rules to a class or object, making them discoverable by the StandardValidator.\n   *\n   * @param {IValidateable} target - A class or object.\n   * @param {string} [tag] - Tag to use to mark the ruleset for the `target`\n   */\n  public on<TAnotherObject extends IValidateable = IValidateable>(target: Class<TAnotherObject> | TAnotherObject, tag?: string): IValidationRules<TAnotherObject>;\n  public on(target: IValidateable, tag?: string) {\n    return this.validationRules.on(target, tag);\n  }\n  // #endregion\n}\n\nexport class ModelBasedRule {\n  public constructor(\n    public ruleset: any,\n    public tag: string = validationRulesRegistrar.defaultRuleSetName\n  ) { }\n}\n\nexport interface IValidationRules<TObject extends IValidateable = IValidateable> {\n  rules: PropertyRule[];\n  /**\n   * Targets a object property for validation\n   *\n   * @param {(keyof TObject | string | PropertyAccessor<TObject, TValue>)} property - can be string or a property accessor function.\n   */\n  ensure<TProp extends keyof TObject>(property: TProp): PropertyRule<TObject, TObject[TProp]>;\n  ensure<TValue>(property: string | PropertyAccessor<TObject, TValue>): PropertyRule<TObject, TValue>;\n\n  /**\n   * Targets an object with validation rules.\n   */\n  ensureObject(): PropertyRule;\n\n  /**\n   * Applies the rules to a class or object, making them discoverable by the StandardValidator.\n   *\n   * @param {IValidateable} target - A class or object.\n   * @param {string} [tag] - Tag to use to mark the ruleset for the `target`\n   */\n  on<TAnotherObject extends IValidateable = IValidateable>(target: Class<TAnotherObject> | TAnotherObject, tag?: string): IValidationRules<TAnotherObject>;\n\n  /**\n   * Removes the rules from a class or object.\n   *\n   * @param {IValidateable} [target] - When omitted, it removes rules for all the objects, for which rules are registered via this instance of IValidationRules\n   * @param {string} [tag] - Use this tag to remove a specific ruleset. If omitted all rulesets of the object are removed.\n   */\n  off<TAnotherObject extends IValidateable = IValidateable>(target?: Class<TAnotherObject> | TAnotherObject, tag?: string): void;\n  applyModelBasedRules(target: IValidateable, rules: ModelBasedRule[]): void;\n}\nexport const IValidationRules = DI.createInterface<IValidationRules>('IValidationRules');\n\nexport class ValidationRules<TObject extends IValidateable = IValidateable> implements IValidationRules<TObject> {\n  public rules: PropertyRule[] = [];\n  private readonly targets: Set<IValidateable> = new Set<IValidateable>();\n\n  public constructor(\n    @IServiceLocator private readonly locator: IServiceLocator,\n    @IExpressionParser private readonly parser: IExpressionParser,\n    @IValidationMessageProvider private readonly messageProvider: IValidationMessageProvider,\n    @IValidationExpressionHydrator private readonly deserializer: IValidationExpressionHydrator,\n  ) { }\n\n  public ensure<TValue>(property: keyof TObject | string | PropertyAccessor): PropertyRule {\n    const [name, expression] = parsePropertyName(property as any, this.parser);\n    // eslint-disable-next-line eqeqeq\n    let rule = this.rules.find((r) => r.property.name == name);\n    if (rule === void 0) {\n      rule = new PropertyRule(this.locator, this, this.messageProvider, new RuleProperty(expression, name));\n      this.rules.push(rule);\n    }\n    return rule;\n  }\n\n  public ensureObject(): PropertyRule {\n    const rule = new PropertyRule(this.locator, this, this.messageProvider, new RuleProperty());\n    this.rules.push(rule);\n    return rule;\n  }\n\n  public on(target: IValidateable, tag?: string) {\n    const rules = validationRulesRegistrar.get(target, tag);\n    if (Object.is(rules, this.rules)) {\n      return this;\n    }\n    this.rules = rules ?? [];\n    validationRulesRegistrar.set(target, this.rules, tag);\n    this.targets.add(target);\n    return this;\n  }\n\n  public off(target?: IValidateable, tag?: string): void {\n    const $targets = target !== void 0 ? [target] : Array.from(this.targets);\n    for (const $target of $targets) {\n      validationRulesRegistrar.unset($target, tag);\n      if (!validationRulesRegistrar.isValidationRulesSet($target)) {\n        this.targets.delete($target);\n      }\n    }\n  }\n\n  public applyModelBasedRules(target: IValidateable, rules: ModelBasedRule[]): void {\n    const tags: Set<string> = new Set<string>();\n    for (const rule of rules) {\n      const tag = rule.tag;\n      if (tags.has(tag)) {\n        console.warn(`A ruleset for tag ${tag} is already defined which will be overwritten`); // TODO: use reporter/logger\n      }\n      const ruleset = this.deserializer.hydrateRuleset(rule.ruleset, this);\n      validationRulesRegistrar.set(target, ruleset, tag);\n      tags.add(tag);\n    }\n  }\n}\n\n// eslint-disable-next-line no-useless-escape\nconst classicAccessorPattern = /^function\\s*\\([$_\\w\\d]+\\)\\s*\\{(?:\\s*[\"']{1}use strict[\"']{1};)?(?:[$_\\s\\w\\d\\/\\*.['\"\\]+;]+)?\\s*return\\s+[$_\\w\\d]+((\\.[$_\\w\\d]+|\\[['\"$_\\w\\d]+\\])+)\\s*;?\\s*\\}$/;\nconst arrowAccessorPattern = /^\\(?[$_\\w\\d]+\\)?\\s*=>\\s*[$_\\w\\d]+((\\.[$_\\w\\d]+|\\[['\"$_\\w\\d]+\\])+)$/;\nexport const rootObjectSymbol = '$root';\nexport type PropertyAccessor<TObject extends IValidateable = IValidateable, TValue = unknown> = (object: TObject) => TValue;\nexport function parsePropertyName(property: string | PropertyAccessor, parser: IExpressionParser): [string, IsBindingBehavior] {\n\n  switch (typeof property) {\n    case 'string':\n      break;\n    case 'function': {\n      const fn = property.toString();\n      const match = arrowAccessorPattern.exec(fn) ?? classicAccessorPattern.exec(fn);\n      if (match === null) {\n        throw new Error(`Unable to parse accessor function:\\n${fn}`); // TODO: use reporter\n      }\n      property = match[1].substring(1);\n      break;\n    }\n    default:\n      throw new Error(`Unable to parse accessor function:\\n${property}`); // TODO: use reporter\n  }\n\n  return [property, parser.parse(`${rootObjectSymbol}.${property}`, BindingType.BindCommand)];\n}\n\n/**\n * The result of validating an individual validation rule.\n */\nexport class ValidationResult<TRule extends IValidationRule = IValidationRule> {\n  private static nextId: number = 0;\n\n  /**\n   * A number that uniquely identifies the result instance.\n   */\n  public id: number;\n  /**\n   * @param {boolean} valid - `true` is the validation was successful, else `false`.\n   * @param {(string | undefined)} message - Evaluated validation message, if the result is not valid, else `undefined`.\n   * @param {(string | number | undefined)} propertyName - Associated property name.\n   * @param {(IValidateable | undefined)} object - Associated target object.\n   * @param {(TRule | undefined)} rule - Associated instance of rule.\n   * @param {(PropertyRule | undefined)} propertyRule - Associated parent property rule.\n   * @param {boolean} [isManual=false] - `true` if the validation result is added manually.\n   */\n  public constructor(\n    public valid: boolean,\n    public message: string | undefined,\n    public propertyName: string | number | undefined,\n    public object: IValidateable | undefined,\n    public rule: TRule | undefined,\n    public propertyRule: PropertyRule | undefined,\n    public isManual: boolean = false\n  ) {\n    this.id = ValidationResult.nextId++;\n  }\n\n  public toString() {\n    return this.valid ? 'Valid.' : this.message;\n  }\n}\n\nconst contextualProperties: Readonly<Set<string>> = new Set([\n  'displayName',\n  'propertyName',\n  'value',\n  'object',\n  'config',\n  'getDisplayName'\n]);\n\nexport class ValidationMessageProvider implements IValidationMessageProvider {\n\n  private readonly logger: ILogger;\n  protected registeredMessages: WeakMap<IValidationRule, Interpolation | PrimitiveLiteralExpression> = new WeakMap<IValidationRule, Interpolation | PrimitiveLiteralExpression>();\n\n  public constructor(\n    @IExpressionParser public parser: IExpressionParser,\n    @ILogger logger: ILogger,\n    @ICustomMessages customMessages: ICustomMessage[],\n  ) {\n    this.logger = logger.scopeTo(ValidationMessageProvider.name);\n    for (const { rule, aliases } of customMessages) {\n      ValidationRuleAliasMessage.setDefaultMessage(rule, { aliases });\n    }\n  }\n\n  public getMessage(rule: IValidationRule): Interpolation | PrimitiveLiteralExpression {\n    const parsedMessage = this.registeredMessages.get(rule);\n    if (parsedMessage !== void 0) { return parsedMessage; }\n\n    const validationMessages = ValidationRuleAliasMessage.getDefaultMessages(rule);\n    const messageKey = rule.messageKey;\n    let message: string | undefined;\n    const messageCount = validationMessages.length;\n    if (messageCount === 1 && messageKey === void 0) {\n      message = validationMessages[0].defaultMessage;\n    } else {\n      message = validationMessages.find(m => m.name === messageKey)?.defaultMessage;\n    }\n    if (!message) {\n      message = ValidationRuleAliasMessage.getDefaultMessages(BaseValidationRule)[0].defaultMessage!;\n    }\n    return this.setMessage(rule, message);\n  }\n\n  public setMessage(rule: IValidationRule, message: string): Interpolation | PrimitiveLiteralExpression {\n    const parsedMessage = this.parseMessage(message);\n    this.registeredMessages.set(rule, parsedMessage);\n    return parsedMessage;\n  }\n\n  public parseMessage(message: string): Interpolation | PrimitiveLiteralExpression {\n    const parsed = this.parser.parse(message, BindingType.Interpolation);\n    if (parsed?.$kind === ExpressionKind.Interpolation) {\n      for (const expr of parsed.expressions) {\n        const name = (expr as AccessScopeExpression).name;\n        if (contextualProperties.has(name)) {\n          this.logger.warn(`Did you mean to use \"$${name}\" instead of \"${name}\" in this validation message template: \"${message}\"?`);\n        }\n        if (expr.$kind === ExpressionKind.AccessThis || (expr as AccessScopeExpression).ancestor > 0) {\n          throw new Error('$parent is not permitted in validation message expressions.'); // TODO: use reporter\n        }\n      }\n      return parsed;\n    }\n    return new PrimitiveLiteralExpression(message);\n  }\n\n  public getDisplayName(propertyName: string | number | undefined, displayName?: string | null | ValidationDisplayNameAccessor): string | undefined {\n    if (displayName !== null && displayName !== undefined) {\n      return (displayName instanceof Function) ? displayName() : displayName;\n    }\n\n    if (propertyName === void 0) { return; }\n    // split on upper-case letters.\n    const words = propertyName.toString().split(/(?=[A-Z])/).join(' ');\n    // capitalize first letter.\n    return words.charAt(0).toUpperCase() + words.slice(1);\n  }\n}\n","import { IExpressionHydrator } from '@aurelia/runtime';\nimport * as AST from '@aurelia/runtime';\n\nenum ASTExpressionTypes {\n  BindingBehaviorExpression = 'BindingBehaviorExpression',\n  ValueConverterExpression = 'ValueConverterExpression',\n  AssignExpression = 'AssignExpression',\n  ConditionalExpression = 'ConditionalExpression',\n  AccessThisExpression = 'AccessThisExpression',\n  AccessScopeExpression = 'AccessScopeExpression',\n  AccessMemberExpression = 'AccessMemberExpression',\n  AccessKeyedExpression = 'AccessKeyedExpression',\n  CallScopeExpression = 'CallScopeExpression',\n  CallMemberExpression = 'CallMemberExpression',\n  CallFunctionExpression = 'CallFunctionExpression',\n  BinaryExpression = 'BinaryExpression',\n  UnaryExpression = 'UnaryExpression',\n  PrimitiveLiteralExpression = 'PrimitiveLiteralExpression',\n  ArrayLiteralExpression = 'ArrayLiteralExpression',\n  ObjectLiteralExpression = 'ObjectLiteralExpression',\n  TemplateExpression = 'TemplateExpression',\n  TaggedTemplateExpression = 'TaggedTemplateExpression',\n  ArrayBindingPattern = 'ArrayBindingPattern',\n  ObjectBindingPattern = 'ObjectBindingPattern',\n  BindingIdentifier = 'BindingIdentifier',\n  ForOfStatement = 'ForOfStatement',\n  Interpolation = 'Interpolation'\n}\n\nexport class Deserializer implements IExpressionHydrator {\n  public static deserialize(serializedExpr: string): AST.IsExpressionOrStatement {\n    const deserializer = new Deserializer();\n    const raw = JSON.parse(serializedExpr);\n    return deserializer.hydrate(raw);\n  }\n  public hydrate(raw: any): any {\n    switch (raw.$TYPE) {\n      case ASTExpressionTypes.AccessMemberExpression: {\n        const expr: Pick<AST.AccessMemberExpression, 'object' | 'name'> = raw;\n        return new AST.AccessMemberExpression(this.hydrate(expr.object), expr.name);\n      }\n      case ASTExpressionTypes.AccessKeyedExpression: {\n        const expr: Pick<AST.AccessKeyedExpression, 'object' | 'key'> = raw;\n        return new AST.AccessKeyedExpression(this.hydrate(expr.object), this.hydrate(expr.key));\n      }\n      case ASTExpressionTypes.AccessThisExpression: {\n        const expr: Pick<AST.AccessThisExpression, 'ancestor'> = raw;\n        return new AST.AccessThisExpression(expr.ancestor);\n      }\n      case ASTExpressionTypes.AccessScopeExpression: {\n        const expr: Pick<AST.AccessScopeExpression, 'name' | 'ancestor'> = raw;\n        return new AST.AccessScopeExpression(expr.name, expr.ancestor);\n      }\n      case ASTExpressionTypes.ArrayLiteralExpression: {\n        const expr: Pick<AST.ArrayLiteralExpression, 'elements'> = raw;\n        return new AST.ArrayLiteralExpression(this.hydrate(expr.elements));\n      }\n      case ASTExpressionTypes.ObjectLiteralExpression: {\n        const expr: Pick<AST.ObjectLiteralExpression, 'keys' | 'values'> = raw;\n        return new AST.ObjectLiteralExpression(this.hydrate(expr.keys), this.hydrate(expr.values));\n      }\n      case ASTExpressionTypes.PrimitiveLiteralExpression: {\n        const expr: Pick<AST.PrimitiveLiteralExpression, 'value'> = raw;\n        return new AST.PrimitiveLiteralExpression(this.hydrate(expr.value));\n      }\n      case ASTExpressionTypes.CallFunctionExpression: {\n        const expr: Pick<AST.CallFunctionExpression, 'func' | 'args'> = raw;\n        return new AST.CallFunctionExpression(this.hydrate(expr.func), this.hydrate(expr.args));\n      }\n      case ASTExpressionTypes.CallMemberExpression: {\n        const expr: Pick<AST.CallMemberExpression, 'object' | 'name' | 'args'> = raw;\n        return new AST.CallMemberExpression(this.hydrate(expr.object), expr.name, this.hydrate(expr.args));\n      }\n      case ASTExpressionTypes.CallScopeExpression: {\n        const expr: Pick<AST.CallScopeExpression, 'name' | 'args' | 'ancestor'> = raw;\n        return new AST.CallScopeExpression(expr.name, this.hydrate(expr.args), expr.ancestor);\n      }\n      case ASTExpressionTypes.TemplateExpression: {\n        const expr: Pick<AST.TemplateExpression, 'cooked' | 'expressions'> = raw;\n        return new AST.TemplateExpression(this.hydrate(expr.cooked), this.hydrate(expr.expressions));\n      }\n      case ASTExpressionTypes.TaggedTemplateExpression: {\n        const expr: Pick<AST.TaggedTemplateExpression, 'cooked' | 'func' | 'expressions'> & {\n          raw: any;\n        } = raw;\n        return new AST.TaggedTemplateExpression(this.hydrate(expr.cooked), this.hydrate(expr.raw), this.hydrate(expr.func), this.hydrate(expr.expressions));\n      }\n      case ASTExpressionTypes.UnaryExpression: {\n        const expr: Pick<AST.UnaryExpression, 'operation' | 'expression'> = raw;\n        return new AST.UnaryExpression(expr.operation, this.hydrate(expr.expression));\n      }\n      case ASTExpressionTypes.BinaryExpression: {\n        const expr: Pick<AST.BinaryExpression, 'operation' | 'left' | 'right'> = raw;\n        return new AST.BinaryExpression(expr.operation, this.hydrate(expr.left), this.hydrate(expr.right));\n      }\n      case ASTExpressionTypes.ConditionalExpression: {\n        const expr: Pick<AST.ConditionalExpression, 'condition' | 'yes' | 'no'> = raw;\n        return new AST.ConditionalExpression(this.hydrate(expr.condition), this.hydrate(expr.yes), this.hydrate(expr.no));\n      }\n      case ASTExpressionTypes.AssignExpression: {\n        const expr: Pick<AST.AssignExpression, 'target' | 'value'> = raw;\n        return new AST.AssignExpression(this.hydrate(expr.target), this.hydrate(expr.value));\n      }\n      case ASTExpressionTypes.ValueConverterExpression: {\n        const expr: Pick<AST.ValueConverterExpression, 'expression' | 'name' | 'args'> = raw;\n        return new AST.ValueConverterExpression(this.hydrate(expr.expression), expr.name, this.hydrate(expr.args));\n      }\n      case ASTExpressionTypes.BindingBehaviorExpression: {\n        const expr: Pick<AST.BindingBehaviorExpression, 'expression' | 'name' | 'args'> = raw;\n        return new AST.BindingBehaviorExpression(this.hydrate(expr.expression), expr.name, this.hydrate(expr.args));\n      }\n      case ASTExpressionTypes.ArrayBindingPattern: {\n        const expr: Pick<AST.ArrayBindingPattern, 'elements'> = raw;\n        return new AST.ArrayBindingPattern(this.hydrate(expr.elements));\n      }\n      case ASTExpressionTypes.ObjectBindingPattern: {\n        const expr: Pick<AST.ObjectBindingPattern, 'keys' | 'values'> = raw;\n        return new AST.ObjectBindingPattern(this.hydrate(expr.keys), this.hydrate(expr.values));\n      }\n      case ASTExpressionTypes.BindingIdentifier: {\n        const expr: Pick<AST.BindingIdentifier, 'name'> = raw;\n        return new AST.BindingIdentifier(expr.name);\n      }\n      case ASTExpressionTypes.ForOfStatement: {\n        const expr: Pick<AST.ForOfStatement, 'declaration' | 'iterable'> = raw;\n        return new AST.ForOfStatement(this.hydrate(expr.declaration), this.hydrate(expr.iterable));\n      }\n      case ASTExpressionTypes.Interpolation: {\n        const expr: {\n          cooked: any;\n          expressions: any;\n        } = raw;\n        return new AST.Interpolation(this.hydrate(expr.cooked), this.hydrate(expr.expressions));\n      }\n      default:\n        if (Array.isArray(raw)) {\n          if (typeof raw[0] === 'object') {\n            return this.deserializeExpressions(raw);\n          } else {\n            return raw.map(deserializePrimitive);\n          }\n        } else if (typeof raw !== 'object') {\n          return deserializePrimitive(raw);\n        }\n        throw new Error(`unable to deserialize the expression: ${raw}`); // TODO use reporter/logger\n    }\n  }\n  private deserializeExpressions(exprs: unknown[]) {\n    const expressions: AST.IsExpressionOrStatement[] = [];\n    for (const expr of exprs) {\n      expressions.push(this.hydrate(expr));\n    }\n    return expressions;\n  }\n}\nexport class Serializer implements AST.IVisitor<string> {\n  public static serialize(expr: AST.IsExpressionOrStatement): string {\n    const visitor = new Serializer();\n    if (expr == null || typeof expr.accept !== 'function') {\n      return `${expr}`;\n    }\n    return expr.accept(visitor);\n  }\n  public visitAccessMember(expr: AST.AccessMemberExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.AccessMemberExpression}\",\"name\":\"${expr.name}\",\"object\":${expr.object.accept(this)}}`;\n  }\n  public visitAccessKeyed(expr: AST.AccessKeyedExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.AccessKeyedExpression}\",\"object\":${expr.object.accept(this)},\"key\":${expr.key.accept(this)}}`;\n  }\n  public visitAccessThis(expr: AST.AccessThisExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.AccessThisExpression}\",\"ancestor\":${expr.ancestor}}`;\n  }\n  public visitAccessScope(expr: AST.AccessScopeExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.AccessScopeExpression}\",\"name\":\"${expr.name}\",\"ancestor\":${expr.ancestor}}`;\n  }\n  public visitArrayLiteral(expr: AST.ArrayLiteralExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ArrayLiteralExpression}\",\"elements\":${this.serializeExpressions(expr.elements)}}`;\n  }\n  public visitObjectLiteral(expr: AST.ObjectLiteralExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ObjectLiteralExpression}\",\"keys\":${serializePrimitives(expr.keys)},\"values\":${this.serializeExpressions(expr.values)}}`;\n  }\n  public visitPrimitiveLiteral(expr: AST.PrimitiveLiteralExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.PrimitiveLiteralExpression}\",\"value\":${serializePrimitive(expr.value)}}`;\n  }\n  public visitCallFunction(expr: AST.CallFunctionExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.CallFunctionExpression}\",\"func\":${expr.func.accept(this)},\"args\":${this.serializeExpressions(expr.args)}}`;\n  }\n  public visitCallMember(expr: AST.CallMemberExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.CallMemberExpression}\",\"name\":\"${expr.name}\",\"object\":${expr.object.accept(this)},\"args\":${this.serializeExpressions(expr.args)}}`;\n  }\n  public visitCallScope(expr: AST.CallScopeExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.CallScopeExpression}\",\"name\":\"${expr.name}\",\"ancestor\":${expr.ancestor},\"args\":${this.serializeExpressions(expr.args)}}`;\n  }\n  public visitTemplate(expr: AST.TemplateExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.TemplateExpression}\",\"cooked\":${serializePrimitives(expr.cooked)},\"expressions\":${this.serializeExpressions(expr.expressions)}}`;\n  }\n  public visitTaggedTemplate(expr: AST.TaggedTemplateExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.TaggedTemplateExpression}\",\"cooked\":${serializePrimitives(expr.cooked)},\"raw\":${serializePrimitives(expr.cooked.raw as readonly unknown[])},\"func\":${expr.func.accept(this)},\"expressions\":${this.serializeExpressions(expr.expressions)}}`;\n  }\n  public visitUnary(expr: AST.UnaryExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.UnaryExpression}\",\"operation\":\"${expr.operation}\",\"expression\":${expr.expression.accept(this)}}`;\n  }\n  public visitBinary(expr: AST.BinaryExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.BinaryExpression}\",\"operation\":\"${expr.operation}\",\"left\":${expr.left.accept(this)},\"right\":${expr.right.accept(this)}}`;\n  }\n  public visitConditional(expr: AST.ConditionalExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ConditionalExpression}\",\"condition\":${expr.condition.accept(this)},\"yes\":${expr.yes.accept(this)},\"no\":${expr.no.accept(this)}}`;\n  }\n  public visitAssign(expr: AST.AssignExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.AssignExpression}\",\"target\":${expr.target.accept(this)},\"value\":${expr.value.accept(this)}}`;\n  }\n  public visitValueConverter(expr: AST.ValueConverterExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ValueConverterExpression}\",\"name\":\"${expr.name}\",\"expression\":${expr.expression.accept(this)},\"args\":${this.serializeExpressions(expr.args)}}`;\n  }\n  public visitBindingBehavior(expr: AST.BindingBehaviorExpression): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.BindingBehaviorExpression}\",\"name\":\"${expr.name}\",\"expression\":${expr.expression.accept(this)},\"args\":${this.serializeExpressions(expr.args)}}`;\n  }\n  public visitArrayBindingPattern(expr: AST.ArrayBindingPattern): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ArrayBindingPattern}\",\"elements\":${this.serializeExpressions(expr.elements)}}`;\n  }\n  public visitObjectBindingPattern(expr: AST.ObjectBindingPattern): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ObjectBindingPattern}\",\"keys\":${serializePrimitives(expr.keys)},\"values\":${this.serializeExpressions(expr.values)}}`;\n  }\n  public visitBindingIdentifier(expr: AST.BindingIdentifier): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.BindingIdentifier}\",\"name\":\"${expr.name}\"}`;\n  }\n  public visitHtmlLiteral(_expr: AST.HtmlLiteralExpression): string { throw new Error('visitHtmlLiteral'); }\n  public visitForOfStatement(expr: AST.ForOfStatement): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.ForOfStatement}\",\"declaration\":${expr.declaration.accept(this)},\"iterable\":${expr.iterable.accept(this)}}`;\n  }\n  public visitInterpolation(expr: AST.Interpolation): string {\n    return `{\"$TYPE\":\"${ASTExpressionTypes.Interpolation}\",\"cooked\":${serializePrimitives(expr.parts)},\"expressions\":${this.serializeExpressions(expr.expressions)}}`;\n  }\n  private serializeExpressions(args: readonly AST.IsExpressionOrStatement[]): string {\n    let text = '[';\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      if (i !== 0) {\n        text += ',';\n      }\n      text += args[i].accept(this);\n    }\n    text += ']';\n    return text;\n  }\n}\n\nexport function serializePrimitives(values: readonly unknown[]): string {\n  let text = '[';\n  for (let i = 0, ii = values.length; i < ii; ++i) {\n    if (i !== 0) {\n      text += ',';\n    }\n    text += serializePrimitive(values[i]);\n  }\n  text += ']';\n  return text;\n}\n\nexport function serializePrimitive(value: unknown): string {\n  if (typeof value === 'string') {\n    return `\"\\\\\"${escapeString(value)}\\\\\"\"`;\n  } else if (value == null) {\n    return `\"${value}\"`;\n  } else {\n    return `${value}`;\n  }\n}\n\nfunction escapeString(str: string): string {\n  let ret = '';\n  for (let i = 0, ii = str.length; i < ii; ++i) {\n    ret += escape(str.charAt(i));\n  }\n  return ret;\n}\n\nfunction escape(ch: string): string {\n  switch (ch) {\n    case '\\b': return '\\\\b';\n    case '\\t': return '\\\\t';\n    case '\\n': return '\\\\n';\n    case '\\v': return '\\\\v';\n    case '\\f': return '\\\\f';\n    case '\\r': return '\\\\r';\n    case '\"': return '\\\\\"';\n    // case '\\'': return '\\\\\\''; /* when used in serialization context, escaping `'` (single quote) is not needed as the string is wrapped in a par of `\"` (double quote) */\n    case '\\\\': return '\\\\\\\\';\n    default: return ch;\n  }\n}\n\nexport function deserializePrimitive(value: unknown): any {\n  if (typeof value === 'string') {\n    if (value === 'null') { return null; }\n    if (value === 'undefined') { return undefined; }\n    return value.substring(1, value.length - 1);\n  } else {\n    return value;\n  }\n}\n","import { IContainer, IServiceLocator } from '@aurelia/kernel';\nimport { IExpressionParser, BindingType, LifecycleFlags, Scope } from '@aurelia/runtime';\nimport { Deserializer, serializePrimitive, Serializer } from './ast-serialization.js';\nimport {\n  IPropertyRule,\n  IRuleProperty,\n  IValidationExpressionHydrator,\n  IValidationRule,\n  IValidationVisitor,\n  IValidateable,\n  IRequiredRule,\n  IRegexRule,\n} from './rule-interfaces.js';\nimport { IValidationRules, parsePropertyName, PropertyRule, RuleProperty } from './rule-provider.js';\nimport {\n  EqualsRule,\n  IValidationMessageProvider,\n  LengthRule,\n  RangeRule,\n  RegexRule,\n  RequiredRule,\n  SizeRule,\n} from './rules.js';\n\nexport type Visitable<T extends IValidationRule> = (PropertyRule | RuleProperty | T) & { accept(visitor: ValidationSerializer): string };\n\nexport class ValidationSerializer implements IValidationVisitor {\n  public static serialize<T extends IValidationRule>(object: Visitable<T>): string {\n    if (object == null || typeof object.accept !== 'function') {\n      return `${object}`;\n    }\n    const visitor = new ValidationSerializer();\n    return object.accept(visitor);\n  }\n  public visitRequiredRule(rule: RequiredRule): string {\n    return `{\"$TYPE\":\"${RequiredRule.$TYPE}\",\"messageKey\":\"${rule.messageKey}\",\"tag\":${serializePrimitive(rule.tag)}}`;\n  }\n  public visitRegexRule(rule: RegexRule): string {\n    const pattern = rule.pattern;\n    return `{\"$TYPE\":\"${RegexRule.$TYPE}\",\"messageKey\":\"${rule.messageKey}\",\"tag\":${serializePrimitive(rule.tag)},\"pattern\":{\"source\":${serializePrimitive(pattern.source)},\"flags\":\"${pattern.flags}\"}}`;\n  }\n  public visitLengthRule(rule: LengthRule): string {\n    return `{\"$TYPE\":\"${LengthRule.$TYPE}\",\"messageKey\":\"${rule.messageKey}\",\"tag\":${serializePrimitive(rule.tag)},\"length\":${serializePrimitive(rule.length)},\"isMax\":${serializePrimitive(rule.isMax)}}`;\n  }\n  public visitSizeRule(rule: SizeRule): string {\n    return `{\"$TYPE\":\"${SizeRule.$TYPE}\",\"messageKey\":\"${rule.messageKey}\",\"tag\":${serializePrimitive(rule.tag)},\"count\":${serializePrimitive(rule.count)},\"isMax\":${serializePrimitive(rule.isMax)}}`;\n  }\n  public visitRangeRule(rule: RangeRule): string {\n    return `{\"$TYPE\":\"${RangeRule.$TYPE}\",\"messageKey\":\"${rule.messageKey}\",\"tag\":${serializePrimitive(rule.tag)},\"isInclusive\":${rule.isInclusive},\"min\":${this.serializeNumber(rule.min)},\"max\":${this.serializeNumber(rule.max)}}`;\n  }\n  public visitEqualsRule(rule: EqualsRule): string {\n    const expectedValue: any = rule.expectedValue;\n    let serializedExpectedValue: string;\n    if (typeof expectedValue !== 'object' || expectedValue === null) {\n      serializedExpectedValue = serializePrimitive(expectedValue);\n    } else {\n      serializedExpectedValue = JSON.stringify(expectedValue);\n    }\n    return `{\"$TYPE\":\"${EqualsRule.$TYPE}\",\"messageKey\":\"${rule.messageKey}\",\"tag\":${serializePrimitive(rule.tag)},\"expectedValue\":${serializedExpectedValue}}`;\n  }\n  public visitRuleProperty(property: RuleProperty): string {\n    const displayName = property.displayName;\n    if (displayName !== void 0 && typeof displayName !== 'string') {\n      throw new Error('Serializing a non-string displayName for rule property is not supported.'); // TODO: use reporter/logger\n    }\n    const expression = property.expression;\n    return `{\"$TYPE\":\"${RuleProperty.$TYPE}\",\"name\":${serializePrimitive(property.name)},\"expression\":${expression ? Serializer.serialize(expression) : null},\"displayName\":${serializePrimitive(displayName)}}`;\n  }\n  public visitPropertyRule(propertyRule: PropertyRule): string {\n    return `{\"$TYPE\":\"${PropertyRule.$TYPE}\",\"property\":${propertyRule.property.accept(this)},\"$rules\":${this.serializeRules(propertyRule.$rules)}}`;\n  }\n  private serializeNumber(num: number): string {\n    return num === Number.POSITIVE_INFINITY || num === Number.NEGATIVE_INFINITY ? null! : num.toString();\n  }\n  private serializeRules(ruleset: IValidationRule[][]) {\n    return `[${ruleset.map((rules) => `[${rules.map((rule) => rule.accept(this)).join(',')}]`).join(',')}]`;\n  }\n}\n\nexport class ValidationDeserializer implements IValidationExpressionHydrator {\n  private static container: IContainer;\n  public static register(container: IContainer) {\n    this.container = container;\n  }\n  public static deserialize(json: string, validationRules: IValidationRules): IValidationRule | IRuleProperty | IPropertyRule {\n    const messageProvider = this.container.get(IValidationMessageProvider);\n    const parser = this.container.get(IExpressionParser);\n    const deserializer = new ValidationDeserializer(this.container, messageProvider, parser);\n    const raw = JSON.parse(json);\n    return deserializer.hydrate(raw, validationRules);\n  }\n  public readonly astDeserializer: Deserializer = new Deserializer();\n  public constructor(\n    @IServiceLocator private readonly locator: IServiceLocator,\n    @IValidationMessageProvider public readonly messageProvider: IValidationMessageProvider,\n    @IExpressionParser public readonly parser: IExpressionParser\n  ) { }\n\n  public hydrate(raw: any, validationRules: IValidationRules): any {\n    switch (raw.$TYPE) {\n      case RequiredRule.$TYPE: {\n        const $raw: Pick<RequiredRule, 'messageKey' | 'tag'> = raw;\n        const rule = new RequiredRule();\n        rule.messageKey = $raw.messageKey;\n        rule.tag = this.astDeserializer.hydrate($raw.tag);\n        return rule;\n      }\n      case RegexRule.$TYPE: {\n        const $raw: Pick<RegexRule, 'pattern' | 'messageKey' | 'tag'> = raw;\n        const pattern = $raw.pattern;\n        const astDeserializer = this.astDeserializer;\n        const rule = new RegexRule(new RegExp(astDeserializer.hydrate(pattern.source), pattern.flags), $raw.messageKey);\n        rule.tag = astDeserializer.hydrate($raw.tag);\n        return rule;\n      }\n      case LengthRule.$TYPE: {\n        const $raw: Pick<LengthRule, 'length' | 'isMax' | 'messageKey' | 'tag'> = raw;\n        const rule = new LengthRule($raw.length, $raw.isMax);\n        rule.messageKey = $raw.messageKey;\n        rule.tag = this.astDeserializer.hydrate($raw.tag);\n        return rule;\n      }\n      case SizeRule.$TYPE: {\n        const $raw: Pick<SizeRule, 'count' | 'isMax' | 'messageKey' | 'tag'> = raw;\n        const rule = new SizeRule($raw.count, $raw.isMax);\n        rule.messageKey = $raw.messageKey;\n        rule.tag = this.astDeserializer.hydrate($raw.tag);\n        return rule;\n      }\n      case RangeRule.$TYPE: {\n        const $raw: Pick<RangeRule, 'isInclusive' | 'max' | 'min' | 'messageKey' | 'tag'> = raw;\n        const rule = new RangeRule($raw.isInclusive, { min: $raw.min ?? Number.NEGATIVE_INFINITY, max: $raw.max ?? Number.POSITIVE_INFINITY });\n        rule.messageKey = $raw.messageKey;\n        rule.tag = this.astDeserializer.hydrate($raw.tag);\n        return rule;\n      }\n      case EqualsRule.$TYPE: {\n        const $raw: Pick<EqualsRule, 'expectedValue' | 'messageKey' | 'tag'> = raw;\n        const astDeserializer = this.astDeserializer;\n        const rule = new EqualsRule(typeof $raw.expectedValue !== 'object' ? astDeserializer.hydrate($raw.expectedValue) : $raw.expectedValue);\n        rule.messageKey = $raw.messageKey;\n        rule.tag = astDeserializer.hydrate($raw.tag);\n        return rule;\n      }\n      case RuleProperty.$TYPE: {\n        const $raw: Pick<RuleProperty, 'expression' | 'name' | 'displayName'> = raw;\n        const astDeserializer = this.astDeserializer;\n        let name: any = $raw.name;\n        name = name === 'undefined' ? void 0 : astDeserializer.hydrate(name);\n\n        let expression: any = $raw.expression;\n        if (expression !== null && expression !== void 0) {\n          expression = astDeserializer.hydrate(expression);\n        } else if (name !== void 0) {\n          ([, expression] = parsePropertyName(name, this.parser));\n        } else {\n          expression = void 0;\n        }\n\n        let displayName = $raw.displayName;\n        displayName = displayName === 'undefined' ? void 0 : astDeserializer.hydrate(displayName);\n        return new RuleProperty(expression, name, displayName);\n      }\n      case PropertyRule.$TYPE: {\n        const $raw: Pick<PropertyRule, 'property' | '$rules'> = raw;\n        return new PropertyRule(\n          this.locator,\n          validationRules,\n          this.messageProvider,\n          this.hydrate($raw.property, validationRules),\n          $raw.$rules.map((rules) => rules.map((rule) => this.hydrate(rule, validationRules)))\n        );\n      }\n    }\n  }\n\n  public hydrateRuleset(ruleset: any[], validationRules: IValidationRules): PropertyRule[] {\n    if (!Array.isArray(ruleset)) {\n      throw new Error(\"The ruleset has to be an array of serialized property rule objects\"); // TODO: use reporter\n    }\n    return ruleset.map(($rule) => this.hydrate($rule, validationRules) as PropertyRule);\n  }\n}\n\ninterface ModelPropertyRule<TRuleConfig extends { tag?: string; messageKey?: string } = any> {\n  displayName?: string;\n  rules: Record<string, TRuleConfig>[];\n}\n\nexport class ModelValidationExpressionHydrator implements IValidationExpressionHydrator {\n  public readonly astDeserializer: Deserializer = new Deserializer();\n  public constructor(\n    @IServiceLocator private readonly locator: IServiceLocator,\n    @IValidationMessageProvider public readonly messageProvider: IValidationMessageProvider,\n    @IExpressionParser public readonly parser: IExpressionParser\n  ) { }\n\n  public hydrate(_raw: any, _validationRules: IValidationRules) {\n    throw new Error('Method not implemented.');\n  }\n\n  public hydrateRuleset(ruleset: Record<string, any>, validationRules: IValidationRules): any[] {\n    const accRules: IPropertyRule[] = [];\n    // depth first traversal\n    const iterate = (entries: [string, any][], propertyPath: string[] = []) => {\n      for (const [key, value] of entries) {\n        if (this.isModelPropertyRule(value)) {\n          const rules: IValidationRule[][] = value.rules.map((rule) => Object.entries(rule).map(([ruleName, ruleConfig]) => this.hydrateRule(ruleName, ruleConfig)));\n          const propertyPrefix = propertyPath.join('.');\n          const property = this.hydrateRuleProperty({ name: propertyPrefix !== '' ? `${propertyPrefix}.${key}` : key, displayName: value.displayName });\n          accRules.push(new PropertyRule(this.locator, validationRules, this.messageProvider, property, rules));\n        } else {\n          iterate(Object.entries(value), [...propertyPath, key]);\n        }\n      }\n    };\n    iterate(Object.entries(ruleset));\n    return accRules;\n  }\n\n  protected hydrateRule(ruleName: string, ruleConfig: any): IValidationRule {\n    switch (ruleName) {\n      case 'required':\n        return this.hydrateRequiredRule(ruleConfig);\n      case 'regex':\n        return this.hydrateRegexRule(ruleConfig);\n      case 'maxLength':\n        return this.hydrateLengthRule({ ...ruleConfig, isMax: true });\n      case 'minLength':\n        return this.hydrateLengthRule({ ...ruleConfig, isMax: false });\n      case 'maxItems':\n        return this.hydrateSizeRule({ ...ruleConfig, isMax: true });\n      case 'minItems':\n        return this.hydrateSizeRule({ ...ruleConfig, isMax: false });\n      case 'range':\n        return this.hydrateRangeRule({ ...ruleConfig, isInclusive: true });\n      case 'between':\n        return this.hydrateRangeRule({ ...ruleConfig, isInclusive: false });\n      case 'equals':\n        return this.hydrateEqualsRule(ruleConfig);\n      default:\n        throw new Error(`Unsupported rule ${ruleName}`);\n    }\n  }\n\n  protected setCommonRuleProperties(raw: Pick<IValidationRule, 'messageKey' | 'tag'> & { when?: string | ((object?: IValidateable) => boolean) }, rule: RequiredRule) {\n    const messageKey = raw.messageKey;\n    if (messageKey !== void 0 && messageKey !== null) {\n      rule.messageKey = messageKey;\n    }\n    rule.tag = raw.tag;\n    const when = raw.when;\n    if (when) {\n      if (typeof when === 'string') {\n        const parsed = this.parser.parse(when, BindingType.None);\n        rule.canExecute = (object: IValidateable) => {\n          const flags = LifecycleFlags.none; // TODO? need to get the flags propagated here?\n          return parsed.evaluate(flags, Scope.create({ $object: object }), null, this.locator, null) as boolean; // TODO get hostScope?\n        };\n      } else if (typeof when === 'function') {\n        rule.canExecute = when;\n      }\n    }\n  }\n\n  private isModelPropertyRule(value: any): value is ModelPropertyRule {\n    return typeof value === 'object' && 'rules' in value;\n  }\n\n  private hydrateRequiredRule(raw: Pick<IRequiredRule, 'messageKey' | 'tag'>) {\n    const rule = new RequiredRule();\n    this.setCommonRuleProperties(raw, rule);\n    return rule;\n  }\n\n  private hydrateRegexRule(raw: Pick<IRegexRule, 'pattern' | 'messageKey' | 'tag'>) {\n    const pattern = raw.pattern;\n    const rule = new RegexRule(new RegExp(pattern.source, pattern.flags), raw.messageKey);\n    rule.tag = raw.tag;\n    return rule;\n  }\n\n  private hydrateLengthRule(raw: Pick<LengthRule, 'length' | 'isMax' | 'messageKey' | 'tag'>) {\n    const rule = new LengthRule(raw.length, raw.isMax);\n    this.setCommonRuleProperties(raw, rule);\n    return rule;\n  }\n\n  private hydrateSizeRule(raw: Pick<SizeRule, 'count' | 'isMax' | 'messageKey' | 'tag'>) {\n    const rule = new SizeRule(raw.count, raw.isMax);\n    this.setCommonRuleProperties(raw, rule);\n    return rule;\n  }\n\n  private hydrateRangeRule(raw: Pick<RangeRule, 'isInclusive' | 'max' | 'min' | 'messageKey' | 'tag'>) {\n    const rule = new RangeRule(raw.isInclusive, { min: raw.min, max: raw.max });\n    this.setCommonRuleProperties(raw, rule);\n    return rule;\n  }\n\n  private hydrateEqualsRule(raw: Pick<EqualsRule, 'expectedValue' | 'messageKey' | 'tag'>) {\n    const rule = new EqualsRule(raw.expectedValue);\n    this.setCommonRuleProperties(raw, rule);\n    return rule;\n  }\n\n  private hydrateRuleProperty(raw: Pick<RuleProperty, 'expression' | 'name' | 'displayName'>) {\n    const rawName = raw.name;\n    if (!rawName || typeof rawName !== 'string') {\n      throw new Error('The property name needs to be a non-empty string'); // TODO: use reporter\n    }\n    const [name, expression] = parsePropertyName(rawName, this.parser);\n    return new RuleProperty(expression, name, raw.displayName);\n  }\n}\n","import { DI } from '@aurelia/kernel';\nimport { LifecycleFlags, Scope } from '@aurelia/runtime';\nimport { ValidationResult, validationRulesRegistrar, PropertyRule, rootObjectSymbol } from './rule-provider.js';\nimport { IValidateable } from './rule-interfaces.js';\n\n/**\n * IInstruction for the validation controller's validate method.\n */\nexport class ValidateInstruction<TObject extends IValidateable = IValidateable> {\n  /**\n   * @param {TObject} [object=(void 0)!] - The object to validate.\n   * @param {(keyof TObject | string)} [propertyName=(void 0)!] - The property name to validate.\n   * @param {PropertyRule[]} [rules=(void 0)!] - The rules to validate.\n   * @param {string} [objectTag=(void 0)!] - The tag indicating the ruleset defined for the object.\n   * @param {string} [propertyTag=(void 0)!] - The tag indicating the ruleset for the property.\n   * @param {LifecycleFlags} [flags=LifecycleFlags.none] - Use this to enable lifecycle flag sensitive expression evaluation.\n   */\n  public constructor(\n    public object: TObject = (void 0)!,\n    public propertyName: keyof TObject | string = (void 0)!,\n    public rules: PropertyRule[] = (void 0)!,\n    public objectTag: string = (void 0)!,\n    public propertyTag: string = (void 0)!,\n    public flags: LifecycleFlags = LifecycleFlags.none,\n  ) { }\n}\n\nexport const IValidator = DI.createInterface<IValidator>('IValidator');\n\n/**\n * The core validator contract.\n */\nexport interface IValidator {\n  /**\n   * Core validate function that works with a validate instruction.\n   *\n   * @param {ValidateInstruction<T>} instruction - The instruction on how to perform the validation.\n   * - case `{object}` - the default ruleset defined on the instance or the class are used.\n   * - case `{object, propertyName}` - only the rules defined for the particular property are validated.\n   * - case `{object, rules}`  or `{object, propertyName, rules}` - only the specified rules are used for validation.\n   * - case `{object, objectTag}` - only the tagged ruleset are used for validation.\n   * - case `{object, objectTag, propertyName}` - only the rules for the property in the tagged ruleset are used for validation.\n   * - case `{object, objectTag, propertyName, propertyTag}` - only the tagged rules for the property in the tagged ruleset for the object are validated\n   */\n  validate<TObject extends IValidateable = IValidateable>(instruction: ValidateInstruction<TObject>): Promise<ValidationResult[]>;\n}\n\n/**\n * Standard implementation of `IValidator`.\n */\nexport class StandardValidator implements IValidator {\n  public async validate<TObject extends IValidateable = IValidateable>(instruction: ValidateInstruction<TObject>): Promise<ValidationResult[]> {\n    const object = instruction.object;\n    const propertyName = instruction.propertyName;\n    const propertyTag = instruction.propertyTag;\n    const flags = instruction.flags;\n\n    const rules = instruction.rules ?? validationRulesRegistrar.get(object, instruction.objectTag) ?? [];\n    const scope = Scope.create({ [rootObjectSymbol]: object });\n\n    if (propertyName !== void 0) {\n      return (await rules.find((r) => r.property.name === propertyName)?.validate(object, propertyTag, flags, scope)) ?? [];\n    }\n\n    return (await Promise.all(rules.map(async (rule) => rule.validate(object, propertyTag, flags, scope)))).flat();\n  }\n}\n","import { IContainer, noop, Registration } from '@aurelia/kernel';\nimport { IValidationExpressionHydrator } from './rule-interfaces.js';\nimport { ICustomMessages, IValidationRules, ValidationMessageProvider, ValidationRules } from './rule-provider.js';\nimport { IValidationMessageProvider } from './rules.js';\nimport { ModelValidationExpressionHydrator, ValidationDeserializer } from './serialization.js';\nimport { ValidationCustomizationOptions } from './validation-customization-options.js';\nimport { IValidator, StandardValidator } from './validator.js';\n\nexport type ValidationConfigurationProvider = (options: ValidationCustomizationOptions) => void;\n\nexport function getDefaultValidationConfiguration(): ValidationCustomizationOptions {\n  return {\n    ValidatorType: StandardValidator,\n    MessageProviderType: ValidationMessageProvider,\n    CustomMessages: [],\n    HydratorType: ModelValidationExpressionHydrator,\n  };\n}\n\nfunction createConfiguration(optionsProvider: ValidationConfigurationProvider) {\n  return {\n    optionsProvider,\n    register(container: IContainer) {\n      const options: ValidationCustomizationOptions = getDefaultValidationConfiguration();\n\n      optionsProvider(options);\n\n      container.register(\n        Registration.instance(ICustomMessages, options.CustomMessages),\n        Registration.singleton(IValidator, options.ValidatorType),\n        Registration.singleton(IValidationMessageProvider, options.MessageProviderType),\n        Registration.singleton(IValidationExpressionHydrator, options.HydratorType),\n        Registration.transient(IValidationRules, ValidationRules),\n        ValidationDeserializer\n      );\n      return container;\n    },\n    customize(cb?: ValidationConfigurationProvider) {\n      return createConfiguration(cb ?? optionsProvider);\n    },\n  };\n}\n\nexport const ValidationConfiguration = createConfiguration(noop);\n"],"names":[],"mappings":"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"}