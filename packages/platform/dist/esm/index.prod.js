const e=new Map;function t(e){return function(){throw new Error(`The PLATFORM did not receive a valid reference to the global function '${e}'.`)}}class s{constructor(e,s={}){var i,n,a,h,o,c,l,d,u,p,m,v,g;this.macroTaskRequested=!1,this.macroTaskHandle=-1,this.globalThis=e,this.decodeURI="decodeURI"in s?s.decodeURI:e.decodeURI,this.decodeURIComponent="decodeURIComponent"in s?s.decodeURIComponent:e.decodeURIComponent,this.encodeURI="encodeURI"in s?s.encodeURI:e.encodeURI,this.encodeURIComponent="encodeURIComponent"in s?s.encodeURIComponent:e.encodeURIComponent,this.Date="Date"in s?s.Date:e.Date,this.Reflect="Reflect"in s?s.Reflect:e.Reflect,this.clearInterval="clearInterval"in s?s.clearInterval:null!==(n=null===(i=e.clearInterval)||void 0===i?void 0:i.bind(e))&&void 0!==n?n:t("clearInterval"),this.clearTimeout="clearTimeout"in s?s.clearTimeout:null!==(h=null===(a=e.clearTimeout)||void 0===a?void 0:a.bind(e))&&void 0!==h?h:t("clearTimeout"),this.queueMicrotask="queueMicrotask"in s?s.queueMicrotask:null!==(c=null===(o=e.queueMicrotask)||void 0===o?void 0:o.bind(e))&&void 0!==c?c:t("queueMicrotask"),this.setInterval="setInterval"in s?s.setInterval:null!==(d=null===(l=e.setInterval)||void 0===l?void 0:l.bind(e))&&void 0!==d?d:t("setInterval"),this.setTimeout="setTimeout"in s?s.setTimeout:null!==(p=null===(u=e.setTimeout)||void 0===u?void 0:u.bind(e))&&void 0!==p?p:t("setTimeout"),this.console="console"in s?s.console:e.console,this.performanceNow="performanceNow"in s?s.performanceNow:null!==(g=null===(v=null===(m=e.performance)||void 0===m?void 0:m.now)||void 0===v?void 0:v.bind(e.performance))&&void 0!==g?g:t("performance.now"),this.flushMacroTask=this.flushMacroTask.bind(this),this.taskQueue=new r(this,this.requestMacroTask.bind(this),this.cancelMacroTask.bind(this))}static getOrCreate(t,i={}){let r=e.get(t);return void 0===r&&e.set(t,r=new s(t,i)),r}static set(t,s){e.set(t,s)}requestMacroTask(){this.macroTaskRequested=!0,-1===this.macroTaskHandle&&(this.macroTaskHandle=this.setTimeout(this.flushMacroTask,0))}cancelMacroTask(){this.macroTaskRequested=!1,this.macroTaskHandle>-1&&(this.clearTimeout(this.macroTaskHandle),this.macroTaskHandle=-1)}flushMacroTask(){this.macroTaskHandle=-1,!0===this.macroTaskRequested&&(this.macroTaskRequested=!1,this.taskQueue.flush())}}function i(e){return e.persistent}class r{constructor(e,t,s){this.platform=e,this.$request=t,this.$cancel=s,this.processing=[],this.suspenderTask=void 0,this.pendingAsyncCount=0,this.pending=[],this.delayed=[],this.flushRequested=!1,this.yieldPromise=void 0,this.taskPool=[],this.taskPoolSize=0,this.lastRequest=0,this.lastFlush=0,this.requestFlush=()=>{this.tracer.enabled&&this.tracer.enter(this,"requestFlush"),this.flushRequested||(this.flushRequested=!0,this.lastRequest=this.platform.performanceNow(),this.$request()),this.tracer.enabled&&this.tracer.leave(this,"requestFlush")},this.tracer=new l(e.console)}get isEmpty(){return 0===this.pendingAsyncCount&&0===this.processing.length&&0===this.pending.length&&0===this.delayed.length}get hasNoMoreFiniteWork(){return 0===this.pendingAsyncCount&&this.processing.every(i)&&this.pending.every(i)&&this.delayed.every(i)}flush(e=this.platform.performanceNow()){if(this.tracer.enabled&&this.tracer.enter(this,"flush"),this.flushRequested=!1,this.lastFlush=e,void 0===this.suspenderTask){if(this.pending.length>0&&(this.processing.push(...this.pending),this.pending.length=0),this.delayed.length>0){let t=-1;for(;++t<this.delayed.length&&this.delayed[t].queueTime<=e;);this.processing.push(...this.delayed.splice(0,t))}let t;for(;this.processing.length>0;)if((t=this.processing.shift()).run(),1===t.status){if(!0===t.suspend)return this.suspenderTask=t,this.requestFlush(),void(this.tracer.enabled&&this.tracer.leave(this,"flush early async"));++this.pendingAsyncCount}if(this.pending.length>0&&(this.processing.push(...this.pending),this.pending.length=0),this.delayed.length>0){let t=-1;for(;++t<this.delayed.length&&this.delayed[t].queueTime<=e;);this.processing.push(...this.delayed.splice(0,t))}if((this.processing.length>0||this.delayed.length>0||this.pendingAsyncCount>0)&&this.requestFlush(),void 0!==this.yieldPromise&&this.hasNoMoreFiniteWork){const e=this.yieldPromise;this.yieldPromise=void 0,e.resolve()}}else this.requestFlush();this.tracer.enabled&&this.tracer.leave(this,"flush full")}cancel(){this.tracer.enabled&&this.tracer.enter(this,"cancel"),this.flushRequested&&(this.$cancel(),this.flushRequested=!1),this.tracer.enabled&&this.tracer.leave(this,"cancel")}async yield(){this.tracer.enabled&&this.tracer.enter(this,"yield"),this.isEmpty?this.tracer.enabled&&this.tracer.leave(this,"yield empty"):(void 0===this.yieldPromise&&(this.tracer.enabled&&this.tracer.trace(this,"yield - creating promise"),this.yieldPromise=v()),await this.yieldPromise,this.tracer.enabled&&this.tracer.leave(this,"yield task"))}queueTask(e,t){this.tracer.enabled&&this.tracer.enter(this,"queueTask");const{delay:s,preempt:i,persistent:r,reusable:n,suspend:a}={...d,...t};if(i){if(s>0)throw new Error("Invalid arguments: preempt cannot be combined with a greater-than-zero delay");if(r)throw new Error("Invalid arguments: preempt cannot be combined with persistent")}0===this.processing.length&&this.requestFlush();const h=this.platform.performanceNow();let o;if(n){const t=this.taskPool,l=this.taskPoolSize-1;l>=0?(o=t[l],t[l]=void 0,this.taskPoolSize=l,o.reuse(h,s,i,r,a,e)):o=new c(this.tracer,this,h,h+s,i,r,a,n,e)}else o=new c(this.tracer,this,h,h+s,i,r,a,n,e);return i?this.processing[this.processing.length]=o:0===s?this.pending[this.pending.length]=o:this.delayed[this.delayed.length]=o,this.tracer.enabled&&this.tracer.leave(this,"queueTask"),o}remove(e){this.tracer.enabled&&this.tracer.enter(this,"remove");let t=this.processing.indexOf(e);if(t>-1)return this.processing.splice(t,1),void(this.tracer.enabled&&this.tracer.leave(this,"remove processing"));if(t=this.pending.indexOf(e),t>-1)return this.pending.splice(t,1),void(this.tracer.enabled&&this.tracer.leave(this,"remove pending"));if(t=this.delayed.indexOf(e),t>-1)return this.delayed.splice(t,1),void(this.tracer.enabled&&this.tracer.leave(this,"remove delayed"));throw this.tracer.enabled&&this.tracer.leave(this,"remove error"),new Error(`Task #${e.id} could not be found`)}returnToPool(e){this.tracer.enabled&&this.tracer.trace(this,"returnToPool"),this.taskPool[this.taskPoolSize++]=e}resetPersistentTask(e){this.tracer.enabled&&this.tracer.enter(this,"resetPersistentTask"),e.reset(this.platform.performanceNow()),e.createdTime===e.queueTime?this.pending[this.pending.length]=e:this.delayed[this.delayed.length]=e,this.tracer.enabled&&this.tracer.leave(this,"resetPersistentTask")}completeAsyncTask(e){var t;if(this.tracer.enabled&&this.tracer.enter(this,"completeAsyncTask"),!0===e.suspend){if(this.suspenderTask!==e)throw this.tracer.enabled&&this.tracer.leave(this,"completeAsyncTask error"),new Error(`Async task completion mismatch: suspenderTask=${null===(t=this.suspenderTask)||void 0===t?void 0:t.id}, task=${e.id}`);this.suspenderTask=void 0}else--this.pendingAsyncCount;if(void 0!==this.yieldPromise&&this.hasNoMoreFiniteWork){const e=this.yieldPromise;this.yieldPromise=void 0,e.resolve()}this.isEmpty&&this.cancel(),this.tracer.enabled&&this.tracer.leave(this,"completeAsyncTask")}}class n extends Error{constructor(e){super("Task was canceled."),this.task=e}}let a=0;var h,o;!function(e){e[e.pending=0]="pending",e[e.running=1]="running",e[e.completed=2]="completed",e[e.canceled=3]="canceled"}(h||(h={}));class c{constructor(e,t,s,i,r,n,h,o,c){this.tracer=e,this.taskQueue=t,this.createdTime=s,this.queueTime=i,this.preempt=r,this.persistent=n,this.suspend=h,this.reusable=o,this.callback=c,this.id=++a,this.resolve=void 0,this.reject=void 0,this._result=void 0,this._status=0}get result(){const e=this._result;if(void 0===e)switch(this._status){case 0:{const e=this._result=v();return this.resolve=e.resolve,this.reject=e.reject,e}case 1:throw new Error("Trying to await task from within task will cause a deadlock.");case 2:return this._result=Promise.resolve();case 3:return this._result=Promise.reject(new n(this))}return e}get status(){return this._status}run(e=this.taskQueue.platform.performanceNow()){if(this.tracer.enabled&&this.tracer.enter(this,"run"),0!==this._status)throw this.tracer.enabled&&this.tracer.leave(this,"run error"),new Error(`Cannot run task in ${this._status} state`);const{persistent:t,reusable:s,taskQueue:i,callback:r,resolve:n,reject:a,createdTime:h}=this;this._status=1;try{const o=r(e-h);o instanceof Promise?o.then((e=>{this.persistent?i.resetPersistentTask(this):(this._status=t?3:2,this.dispose()),i.completeAsyncTask(this),this.tracer.enabled&&this.tracer.leave(this,"run async then"),void 0!==n&&n(e),!this.persistent&&s&&i.returnToPool(this)})).catch((e=>{if(this.persistent||this.dispose(),i.completeAsyncTask(this),this.tracer.enabled&&this.tracer.leave(this,"run async catch"),void 0===a)throw e;a(e)})):(this.persistent?i.resetPersistentTask(this):(this._status=t?3:2,this.dispose()),this.tracer.enabled&&this.tracer.leave(this,"run sync success"),void 0!==n&&n(o),!this.persistent&&s&&i.returnToPool(this))}catch(e){if(this.persistent||this.dispose(),this.tracer.enabled&&this.tracer.leave(this,"run sync error"),void 0===a)throw e;a(e)}}cancel(){if(this.tracer.enabled&&this.tracer.enter(this,"cancel"),0===this._status){const e=this.taskQueue,t=this.reusable,s=this.reject;return e.remove(this),e.isEmpty&&e.cancel(),this._status=3,this.dispose(),t&&e.returnToPool(this),void 0!==s&&s(new n(this)),this.tracer.enabled&&this.tracer.leave(this,"cancel true =pending"),!0}return 1===this._status&&this.persistent?(this.persistent=!1,this.tracer.enabled&&this.tracer.leave(this,"cancel true =running+persistent"),!0):(this.tracer.enabled&&this.tracer.leave(this,"cancel false"),!1)}reset(e){this.tracer.enabled&&this.tracer.enter(this,"reset");const t=this.queueTime-this.createdTime;this.createdTime=e,this.queueTime=e+t,this._status=0,this.resolve=void 0,this.reject=void 0,this._result=void 0,this.tracer.enabled&&this.tracer.leave(this,"reset")}reuse(e,t,s,i,r,n){this.tracer.enabled&&this.tracer.enter(this,"reuse"),this.createdTime=e,this.queueTime=e+t,this.preempt=s,this.persistent=i,this.suspend=r,this.callback=n,this._status=0,this.tracer.enabled&&this.tracer.leave(this,"reuse")}dispose(){this.tracer.enabled&&this.tracer.trace(this,"dispose"),this.callback=void 0,this.resolve=void 0,this.reject=void 0,this._result=void 0}}class l{constructor(e){this.console=e,this.enabled=!1,this.depth=0}enter(e,t){this.log(`${"  ".repeat(this.depth++)}> `,e,t)}leave(e,t){this.log(`${"  ".repeat(--this.depth)}< `,e,t)}trace(e,t){this.log(`${"  ".repeat(this.depth)}- `,e,t)}log(e,t,s){if(t instanceof r){this.console.log(`${e}[Q.${s}] ${`processing=${t.processing.length} pending=${t.pending.length} delayed=${t.delayed.length} flushReq=${t.flushRequested} susTask=${!!t.suspenderTask}`}`)}else{const i=t.id,r=Math.round(10*t.createdTime)/10,n=Math.round(10*t.queueTime)/10,a=t.preempt,h=t.reusable,o=t.persistent,c=t.suspend,l=function(e){switch(e){case 0:return"pending";case 1:return"running";case 3:return"canceled";case 2:return"completed"}}(t._status);this.console.log(`${e}[T.${s}] ${`id=${i} created=${r} queue=${n} preempt=${a} persistent=${o} reusable=${h} status=${l} suspend=${c}`}`)}}}!function(e){e[e.render=0]="render",e[e.macroTask=1]="macroTask",e[e.postRender=2]="postRender"}(o||(o={}));const d={delay:0,preempt:!1,persistent:!1,reusable:!0,suspend:!1};let u,p;function m(e,t){u=e,p=t}function v(){const e=new Promise(m);return e.resolve=u,e.reject=p,e}export{s as Platform,c as Task,n as TaskAbortError,r as TaskQueue,o as TaskQueuePriority,h as TaskStatus};
