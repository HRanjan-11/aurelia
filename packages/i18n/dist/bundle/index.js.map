{"version":3,"file":"index.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/utils.ts","../../src/df/date-format-binding-behavior.ts","../../src/i18n-configuration-options.ts","../../src/i18next-wrapper.ts","../../src/i18n.ts","../../src/df/date-format-value-converter.ts","../../src/nf/number-format-binding-behavior.ts","../../src/nf/number-format-value-converter.ts","../../src/rt/relative-time-binding-behavior.ts","../../src/rt/relative-time-value-converter.ts","../../src/t/translation-binding-behavior.ts","../../src/t/translation-binding.ts","../../src/t/translation-parameters-renderer.ts","../../src/t/translation-renderer.ts","../../src/t/translation-value-converter.ts","../../src/configuration.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { BindingBehaviorExpression, IBinding, IsValueConverter, ValueConverterExpression } from '@aurelia/runtime';\nimport { Writable } from '@aurelia/kernel';\n\nexport const enum Signals {\n  I18N_EA_CHANNEL = 'i18n:locale:changed',\n  I18N_SIGNAL = 'aurelia-translation-signal',\n  RT_SIGNAL = 'aurelia-relativetime-signal'\n}\n\nexport const enum ValueConverters {\n  translationValueConverterName = 't',\n  dateFormatValueConverterName = 'df',\n  numberFormatValueConverterName = 'nf',\n  relativeTimeValueConverterName = 'rt'\n}\n\nexport type BindingWithBehavior = IBinding & {\n  sourceExpression: BindingBehaviorExpression;\n};\n\nexport function createIntlFormatValueConverterExpression(name: string, binding: BindingWithBehavior) {\n\n  const expression = binding.sourceExpression.expression;\n\n  if (!(expression instanceof ValueConverterExpression)) {\n    const vcExpression = new ValueConverterExpression(expression as IsValueConverter, name, binding.sourceExpression.args);\n    (binding.sourceExpression as Writable<BindingBehaviorExpression>).expression = vcExpression;\n  }\n}\n","import { bindingBehavior, LifecycleFlags } from '@aurelia/runtime';\nimport { BindingWithBehavior, createIntlFormatValueConverterExpression, ValueConverters } from '../utils.js';\n\nimport type { Scope } from '@aurelia/runtime';\n\n@bindingBehavior(ValueConverters.dateFormatValueConverterName)\nexport class DateFormatBindingBehavior {\n\n  public bind(flags: LifecycleFlags, _scope: Scope, _hostScope: Scope | null, binding: BindingWithBehavior) {\n    createIntlFormatValueConverterExpression(ValueConverters.dateFormatValueConverterName, binding);\n  }\n}\n","import { Class, DI } from '@aurelia/kernel';\nimport { InitOptions, Module, ThirdPartyModule } from 'i18next';\n\nexport type I18nModule = Module | ThirdPartyModule;\n\nexport const I18nInitOptions = DI.createInterface<I18nInitOptions>('I18nInitOptions');\nexport interface I18nInitOptions extends InitOptions {\n  /**\n   * Collection of i18next plugins to use.\n   */\n  plugins?: (I18nModule | Class<I18nModule>)[];\n  skipTranslationOnMissingKey?: boolean;\n\n  /**\n   * Leeway for computing the time difference for relative time formatting.\n   * If abs(t1 - now) < 1 time_unit, where t1 is the date being formatted, and time_unit is a unit of time such as minute, hour etc.,\n   * then the relative time formatting may sometime produce unexpected results, such as 'in 60 seconds' instead of 'in 1 minute'.\n   * A non-zero rtEpsilon ensures nicer results instead. Default is 0.01. A smaller value for epsilon ensures stricter comparison.\n   */\n  rtEpsilon?: number;\n}\n\nexport interface I18nConfigurationOptions {\n  initOptions?: I18nInitOptions;\n  translationAttributeAliases?: string[];\n}\n","import { DI } from '@aurelia/kernel';\nimport i18next from 'i18next';\n\nexport const I18nWrapper = DI.createInterface<I18nextWrapper>('I18nextWrapper');\n\n/**\n * A wrapper class over i18next to facilitate the easy testing and DI.\n */\nexport class I18nextWrapper {\n  public i18next: i18next.i18n = i18next;\n}\n","import { DI, IEventAggregator } from '@aurelia/kernel';\nimport { ISignaler } from '@aurelia/runtime';\nimport i18nextCore from 'i18next';\nimport { I18nInitOptions } from './i18n-configuration-options.js';\nimport { I18nextWrapper, I18nWrapper } from './i18next-wrapper.js';\nimport { Signals } from './utils.js';\n\nconst enum TimeSpan {\n  Second = 1000,\n  Minute = Second * 60,\n  Hour = Minute * 60,\n  Day = Hour * 24,\n  Week = Day * 7,\n  Month = Day * 30,\n  Year = Day * 365\n}\n\nexport class I18nKeyEvaluationResult {\n  public key: string;\n  public value: string = (void 0)!;\n  public attributes: string[];\n\n  public constructor(keyExpr: string) {\n    const re = /\\[([a-z\\-, ]*)\\]/ig;\n    this.attributes = [];\n\n    // check if a attribute was specified in the key\n    const matches = re.exec(keyExpr);\n    if (matches) {\n      keyExpr = keyExpr.replace(matches[0], '');\n      this.attributes = matches[1].split(',');\n    }\n    this.key = keyExpr;\n  }\n}\n\nexport interface I18N {\n  i18next: i18nextCore.i18n;\n  readonly initPromise: Promise<void>;\n  /**\n   * Evaluates the `keyExpr` to translated values.\n   * For a single key, `I18nService#tr` method can also be easily used.\n   *\n   * @example\n   *  evaluate('key1;[attr]key2;[attr1,attr2]key3', [options]) => [\n   *    {key: 'key1', attributes:[], value: 'translated_value_of_key1'}\n   *    {key: 'key2', attributes:['attr'], value: 'translated_value_of_key2'}\n   *    {key: 'key3', attributes:['attr1', 'attr2'], value: 'translated_value_of_key3'}\n   *  ]\n   */\n  evaluate(keyExpr: string, options?: i18nextCore.TOptions): I18nKeyEvaluationResult[];\n  tr(key: string | string[], options?: i18nextCore.TOptions): string;\n  getLocale(): string;\n  setLocale(newLocale: string): Promise<void>;\n  /**\n   * Returns `Intl.NumberFormat` instance with given `[options]`, and `[locales]` which can be used to format a number.\n   * If the `locales` is skipped, then the `Intl.NumberFormat` instance is created using the currently active locale.\n   */\n  createNumberFormat(options?: Intl.NumberFormatOptions, locales?: string | string[]): Intl.NumberFormat;\n  /**\n   * Formats the given `input` number according to the given `[options]`, and `[locales]`.\n   * If the `locales` is skipped, then the number is formatted using the currently active locale.\n   *\n   * @returns Formatted number.\n   */\n  nf(input: number, options?: Intl.NumberFormatOptions, locales?: string | string[]): string;\n  /**\n   * Unformats a given numeric string to a number.\n   */\n  uf(numberLike: string, locale?: string): number;\n  /**\n   * Returns `Intl.DateTimeFormat` instance with given `[options]`, and `[locales]` which can be used to format a date.\n   * If the `locales` is skipped, then the `Intl.DateTimeFormat` instance is created using the currently active locale.\n   */\n  createDateTimeFormat(options?: Intl.DateTimeFormatOptions, locales?: string | string[]): Intl.DateTimeFormat;\n  /**\n   * Formats the given `input` date according to the given `[options]` and `[locales]`.\n   * If the `locales` is skipped, then the date is formatted using the currently active locale.\n   *\n   * @returns Formatted date.\n   */\n  df(input: number | Date, options?: Intl.DateTimeFormatOptions, locales?: string | string[]): string;\n  /**\n   * Returns `Intl.RelativeTimeFormat` instance with given `[options]`, and `[locales]` which can be used to format a value with associated time unit.\n   * If the `locales` is skipped, then the `Intl.RelativeTimeFormat` instance is created using the currently active locale.\n   */\n  createRelativeTimeFormat(options?: Intl.RelativeTimeFormatOptions, locales?: string | string[]): Intl.RelativeTimeFormat;\n  /**\n   * Returns a relative time format of the given `input` date as per the given `[options]`, and `[locales]`.\n   * If the `locales` is skipped, then the currently active locale is used for formatting.\n   */\n  rt(input: Date, options?: Intl.RelativeTimeFormatOptions, locales?: string | string[]): string;\n  /**\n   * Queue a subscriber to be invoked for when the locale of a I18N service changes\n   */\n  subscribeLocaleChange(subscriber: ILocalChangeSubscriber): void;\n}\nexport const I18N = DI.createInterface<I18N>('I18N');\n\nexport interface ILocalChangeSubscriber {\n  handleLocaleChange(locales: { oldLocale: string; newLocale: string }): void;\n}\n/**\n * Translation service class.\n */\nexport class I18nService implements I18N {\n\n  public i18next: i18nextCore.i18n;\n  /**\n   * This is used for i18next initialization and awaited for before the bind phase.\n   * If need be (usually there is none), this can be awaited for explicitly in client code.\n   */\n  public readonly initPromise: Promise<void>;\n  private options!: I18nInitOptions;\n  private readonly localeSubscribers: Set<ILocalChangeSubscriber> = new Set();\n\n  public constructor(\n    @I18nWrapper i18nextWrapper: I18nextWrapper,\n    @I18nInitOptions options: I18nInitOptions,\n    @IEventAggregator private readonly ea: IEventAggregator,\n    @ISignaler private readonly signaler: ISignaler,\n  ) {\n    this.i18next = i18nextWrapper.i18next;\n    this.initPromise = this.initializeI18next(options);\n  }\n\n  public evaluate(keyExpr: string, options?: i18nextCore.TOptions): I18nKeyEvaluationResult[] {\n    const parts = keyExpr.split(';');\n    const results: I18nKeyEvaluationResult[] = [];\n    for (const part of parts) {\n      const result = new I18nKeyEvaluationResult(part);\n      const key = result.key;\n      const translation = this.tr(key, options);\n      if (this.options.skipTranslationOnMissingKey && translation === key) {\n        // TODO change this once the logging infra is there.\n        console.warn(`Couldn't find translation for key: ${key}`);\n      } else {\n        result.value = translation;\n        results.push(result);\n      }\n    }\n    return results;\n  }\n\n  public tr(key: string | string[], options?: i18nextCore.TOptions): string {\n    return this.i18next.t(key, options);\n  }\n\n  public getLocale(): string {\n    return this.i18next.language;\n  }\n  public async setLocale(newLocale: string): Promise<void> {\n    const oldLocale = this.getLocale();\n    const locales = { oldLocale, newLocale };\n    await this.i18next.changeLanguage(newLocale);\n    this.ea.publish(Signals.I18N_EA_CHANNEL, locales);\n    this.localeSubscribers.forEach(sub => sub.handleLocaleChange(locales));\n    this.signaler.dispatchSignal(Signals.I18N_SIGNAL);\n  }\n\n  public createNumberFormat(options?: Intl.NumberFormatOptions, locales?: string | string[]): Intl.NumberFormat {\n    return Intl.NumberFormat(locales || this.getLocale(), options);\n  }\n\n  public nf(input: number, options?: Intl.NumberFormatOptions, locales?: string | string[]): string {\n    return this.createNumberFormat(options, locales).format(input);\n  }\n\n  public createDateTimeFormat(options?: Intl.DateTimeFormatOptions, locales?: string | string[]): Intl.DateTimeFormat {\n    return Intl.DateTimeFormat(locales || this.getLocale(), options);\n  }\n\n  public df(input: number | Date, options?: Intl.DateTimeFormatOptions, locales?: string | string[]): string {\n    return this.createDateTimeFormat(options, locales).format(input);\n  }\n\n  public uf(numberLike: string, locale?: string): number {\n    // Unfortunately the Intl specs does not specify a way to get the thousand and decimal separators for a given locale.\n    // Only straightforward way would be to include the CLDR data and query for the separators, which certainly is a overkill.\n    const comparer = this.nf(10000 / 3, undefined, locale);\n\n    let thousandSeparator = comparer[1];\n    const decimalSeparator = comparer[5];\n\n    if (thousandSeparator === '.') {\n      thousandSeparator = '\\\\.';\n    }\n\n    // remove all thousand separators\n    const result = numberLike.replace(new RegExp(thousandSeparator, 'g'), '')\n      // remove non-numeric signs except -> , .\n      .replace(/[^\\d.,-]/g, '')\n      // replace original decimalSeparator with english one\n      .replace(decimalSeparator, '.');\n\n    // return real number\n    return Number(result);\n  }\n\n  public createRelativeTimeFormat(options?: Intl.RelativeTimeFormatOptions, locales?: string | string[]): Intl.RelativeTimeFormat {\n    return new Intl.RelativeTimeFormat(locales || this.getLocale(), options);\n  }\n\n  public rt(input: Date, options?: Intl.RelativeTimeFormatOptions, locales?: string | string[]): string {\n    let difference = input.getTime() - this.now();\n    const epsilon = this.options.rtEpsilon! * (difference > 0 ? 1 : 0);\n\n    const formatter = this.createRelativeTimeFormat(options, locales);\n\n    let value: number = difference / TimeSpan.Year;\n    if (Math.abs(value + epsilon) >= 1) {\n      return formatter.format(Math.round(value), 'year');\n    }\n\n    value = difference / TimeSpan.Month;\n    if (Math.abs(value + epsilon) >= 1) {\n      return formatter.format(Math.round(value), 'month');\n    }\n\n    value = difference / TimeSpan.Week;\n    if (Math.abs(value + epsilon) >= 1) {\n      return formatter.format(Math.round(value), 'week');\n    }\n\n    value = difference / TimeSpan.Day;\n    if (Math.abs(value + epsilon) >= 1) {\n      return formatter.format(Math.round(value), 'day');\n    }\n\n    value = difference / TimeSpan.Hour;\n    if (Math.abs(value + epsilon) >= 1) {\n      return formatter.format(Math.round(value), 'hour');\n    }\n\n    value = difference / TimeSpan.Minute;\n    if (Math.abs(value + epsilon) >= 1) {\n      return formatter.format(Math.round(value), 'minute');\n    }\n\n    difference = Math.abs(difference) < TimeSpan.Second ? TimeSpan.Second : difference;\n    value = difference / TimeSpan.Second;\n    return formatter.format(Math.round(value), 'second');\n  }\n\n  public subscribeLocaleChange(subscriber: ILocalChangeSubscriber): void {\n    this.localeSubscribers.add(subscriber);\n  }\n\n  private now() {\n    return new Date().getTime();\n  }\n\n  private async initializeI18next(options: I18nInitOptions) {\n    const defaultOptions: I18nInitOptions = {\n      lng: 'en',\n      fallbackLng: ['en'],\n      debug: false,\n      plugins: [],\n      rtEpsilon: 0.01,\n      skipTranslationOnMissingKey: false,\n    };\n    this.options = { ...defaultOptions, ...options };\n    for (const plugin of this.options.plugins!) {\n      this.i18next.use(plugin);\n    }\n    await this.i18next.init(this.options);\n  }\n}\n","import { valueConverter } from '@aurelia/runtime';\nimport { I18N } from '../i18n.js';\nimport { Signals, ValueConverters } from '../utils.js';\n\n@valueConverter(ValueConverters.dateFormatValueConverterName)\nexport class DateFormatValueConverter {\n  public readonly signals: string[] = [Signals.I18N_SIGNAL];\n\n  public constructor(\n    @I18N private readonly i18n: I18N,\n  ) {}\n\n  public toView(value: string | number | Date, options?: Intl.DateTimeFormatOptions, locale?: string) {\n\n    if ((!value && value !== 0) || (typeof value === 'string' && value.trim() === '')) {\n      return value;\n    }\n\n    // convert '0' to 01/01/1970 or ISO string to Date and return the original value if invalid date is constructed\n    if (typeof value === 'string') {\n      const numValue = Number(value);\n      const tempDate = new Date(Number.isInteger(numValue) ? numValue : value);\n      if (isNaN(tempDate.getTime())) {\n        return value;\n      }\n      value = tempDate;\n    }\n\n    return this.i18n.df(value, options, locale);\n  }\n}\n","import { bindingBehavior, LifecycleFlags } from '@aurelia/runtime';\nimport { BindingWithBehavior, createIntlFormatValueConverterExpression, ValueConverters } from '../utils.js';\n\nimport type { Scope } from '@aurelia/runtime';\n\n@bindingBehavior(ValueConverters.numberFormatValueConverterName)\nexport class NumberFormatBindingBehavior {\n\n  public bind(flags: LifecycleFlags, _scope: Scope, _hostScope: Scope | null, binding: BindingWithBehavior) {\n    createIntlFormatValueConverterExpression(ValueConverters.numberFormatValueConverterName, binding);\n  }\n}\n","import { valueConverter } from '@aurelia/runtime';\nimport { I18N } from '../i18n.js';\nimport { Signals, ValueConverters } from '../utils.js';\n\n@valueConverter(ValueConverters.numberFormatValueConverterName)\nexport class NumberFormatValueConverter {\n  public readonly signals: string[] = [Signals.I18N_SIGNAL];\n\n  public constructor(\n    @I18N private readonly i18n: I18N,\n  ) {}\n\n  public toView(value: unknown, options?: Intl.NumberFormatOptions, locale?: string) {\n    if (typeof value !== 'number') {\n      return value;\n    }\n\n    return this.i18n.nf(value, options, locale);\n  }\n}\n","import { bindingBehavior, LifecycleFlags } from '@aurelia/runtime';\nimport { BindingWithBehavior, createIntlFormatValueConverterExpression, ValueConverters } from '../utils.js';\n\nimport type { Scope } from '@aurelia/runtime';\n\n@bindingBehavior(ValueConverters.relativeTimeValueConverterName)\nexport class RelativeTimeBindingBehavior {\n\n  public bind(flags: LifecycleFlags, _scope: Scope, _hostScope: Scope | null, binding: BindingWithBehavior) {\n    createIntlFormatValueConverterExpression(ValueConverters.relativeTimeValueConverterName, binding);\n  }\n}\n","import { valueConverter } from '@aurelia/runtime';\nimport { I18N } from '../i18n.js';\nimport { Signals, ValueConverters } from '../utils.js';\n\n@valueConverter(ValueConverters.relativeTimeValueConverterName)\nexport class RelativeTimeValueConverter {\n  public readonly signals: string[] = [Signals.I18N_SIGNAL, Signals.RT_SIGNAL];\n\n  public constructor(\n    @I18N private readonly i18n: I18N,\n  ) {}\n\n  public toView(value: unknown, options?: Intl.RelativeTimeFormatOptions, locale?: string) {\n\n    if (!(value instanceof Date)) {\n      return value;\n    }\n\n    return this.i18n.rt(value, options, locale);\n  }\n}\n","import { bindingBehavior, IsValueConverter, LifecycleFlags, ValueConverterExpression, BindingBehaviorExpression } from '@aurelia/runtime-html';\nimport { BindingWithBehavior, ValueConverters } from '../utils.js';\nimport { Writable } from '@aurelia/kernel';\n\nimport type { Scope } from '@aurelia/runtime';\n\n@bindingBehavior(ValueConverters.translationValueConverterName)\nexport class TranslationBindingBehavior {\n\n  public bind(flags: LifecycleFlags, _scope: Scope, _hostScope: Scope | null, binding: BindingWithBehavior) {\n    const expression = binding.sourceExpression.expression;\n\n    if (!(expression instanceof ValueConverterExpression)) {\n      const vcExpression = new ValueConverterExpression(expression as IsValueConverter, ValueConverters.translationValueConverterName, binding.sourceExpression.args);\n      (binding.sourceExpression as Writable<BindingBehaviorExpression>).expression = vcExpression;\n    }\n  }\n}\n","import { toArray } from '@aurelia/kernel';\nimport {\n  BindingType,\n  connectable,\n  CustomElement,\n  CustomExpression,\n  Interpolation,\n  LifecycleFlags,\n  IPlatform,\n} from '@aurelia/runtime-html';\nimport i18next from 'i18next';\nimport { I18N } from '../i18n.js';\n\nimport type { ITask, QueueTaskOptions, IContainer, IServiceLocator } from '@aurelia/kernel';\nimport {\n  Scope,\n  IsBindingBehavior,\n  IsExpression,\n  IConnectableBinding,\n  IExpressionParser,\n  IObserverLocator,\n  IPartialConnectableBinding,\n  IAccessor,\n  AccessorType,\n} from '@aurelia/runtime';\nimport type { CallBindingInstruction, IHydratableController, INode } from '@aurelia/runtime-html';\n\ninterface TranslationBindingCreationContext {\n  parser: IExpressionParser;\n  observerLocator: IObserverLocator;\n  context: IContainer;\n  controller: IHydratableController;\n  target: HTMLElement;\n  instruction: CallBindingInstruction;\n  platform: IPlatform;\n  isParameterContext?: boolean;\n}\nconst contentAttributes = ['textContent', 'innerHTML', 'prepend', 'append'] as const;\ntype ContentAttribute = typeof contentAttributes[number];\ninterface ContentValue {\n  textContent?: string;\n  innerHTML?: string;\n  prepend?: string;\n  append?: string;\n}\n\nconst attributeAliases = new Map([['text', 'textContent'], ['html', 'innerHTML']]);\n\nexport interface TranslationBinding extends IConnectableBinding { }\n\nconst forOpts = { optional: true } as const;\nconst taskQueueOpts: QueueTaskOptions = {\n  reusable: false,\n  preempt: true,\n};\n\n@connectable()\nexport class TranslationBinding implements IPartialConnectableBinding {\n  public interceptor: this = this;\n  public isBound: boolean = false;\n  public expr!: IsExpression;\n  private readonly i18n: I18N;\n  private readonly contentAttributes: readonly string[] = contentAttributes;\n  private keyExpression: string | undefined | null;\n  private scope!: Scope;\n  private hostScope: Scope | null = null;\n  private task: ITask | null = null;\n  private isInterpolation!: boolean;\n  private readonly targetAccessors: Set<IAccessor>;\n\n  public target: HTMLElement;\n  private readonly platform: IPlatform;\n  private parameter: ParameterBinding | null = null;\n\n  public constructor(\n    target: INode,\n    public observerLocator: IObserverLocator,\n    public locator: IServiceLocator,\n    platform: IPlatform,\n  ) {\n    this.target = target as HTMLElement;\n    this.i18n = this.locator.get(I18N);\n    this.platform = platform;\n    this.targetAccessors = new Set<IAccessor>();\n    this.i18n.subscribeLocaleChange(this);\n  }\n\n  public static create({\n    parser,\n    observerLocator,\n    context,\n    controller,\n    target,\n    instruction,\n    platform,\n    isParameterContext,\n  }: TranslationBindingCreationContext) {\n    const binding = this.getBinding({ observerLocator, context, controller, target, platform });\n    const expr = typeof instruction.from === 'string'\n      ? parser.parse(instruction.from, BindingType.BindCommand)\n      : instruction.from as IsBindingBehavior;\n    if (isParameterContext) {\n      binding.useParameter(expr);\n    } else {\n      const interpolation = expr instanceof CustomExpression ? parser.parse(expr.value, BindingType.Interpolation) : undefined;\n      binding.expr = interpolation || expr;\n    }\n  }\n  private static getBinding({\n    observerLocator,\n    context,\n    controller,\n    target,\n    platform,\n  }: Omit<TranslationBindingCreationContext, 'parser' | 'instruction' | 'isParameterContext'>): TranslationBinding {\n    let binding: TranslationBinding | null = controller.bindings && controller.bindings.find((b) => b instanceof TranslationBinding && b.target === target) as TranslationBinding;\n    if (!binding) {\n      binding = new TranslationBinding(target, observerLocator, context, platform);\n      controller.addBinding(binding);\n    }\n    return binding;\n  }\n\n  public $bind(flags: LifecycleFlags, scope: Scope, hostScope: Scope | null): void {\n    if (!this.expr) { throw new Error('key expression is missing'); }\n    this.scope = scope;\n    this.hostScope = hostScope;\n    this.isInterpolation = this.expr instanceof Interpolation;\n\n    this.keyExpression = this.expr.evaluate(flags, scope, hostScope, this.locator, this) as string;\n    this.ensureKeyExpression();\n    this.parameter?.$bind(flags, scope, hostScope);\n\n    this.updateTranslations(flags);\n    this.isBound = true;\n  }\n\n  public $unbind(flags: LifecycleFlags): void {\n    if (!this.isBound) {\n      return;\n    }\n\n    if (this.expr.hasUnbind) {\n      this.expr.unbind(flags, this.scope, this.hostScope, this as any);\n    }\n\n    this.parameter?.$unbind(flags);\n    this.targetAccessors.clear();\n    if (this.task !== null) {\n      this.task.cancel();\n      this.task = null;\n    }\n\n    this.scope = (void 0)!;\n    this.obs.clear(true);\n  }\n\n  public handleChange(newValue: string | i18next.TOptions, _previousValue: string | i18next.TOptions, flags: LifecycleFlags): void {\n    this.obs.version++;\n    this.keyExpression = this.isInterpolation\n        ? this.expr.evaluate(flags, this.scope, this.hostScope, this.locator, this) as string\n        : newValue as string;\n    this.obs.clear(false);\n    this.ensureKeyExpression();\n    this.updateTranslations(flags);\n  }\n\n  public handleLocaleChange() {\n    // todo:\n    // no flag passed, so if a locale is updated during binding of a component\n    // and the author wants to signal that locale change fromBind, then it's a bug\n    this.updateTranslations(LifecycleFlags.none);\n  }\n\n  public useParameter(expr: IsExpression) {\n    if (this.parameter != null) {\n      throw new Error('This translation parameter has already been specified.');\n    }\n    this.parameter = new ParameterBinding(this, expr, (flags: LifecycleFlags) => this.updateTranslations(flags));\n  }\n\n  private updateTranslations(flags: LifecycleFlags) {\n    const results = this.i18n.evaluate(this.keyExpression!, this.parameter?.value);\n    const content: ContentValue = Object.create(null);\n    const accessorUpdateTasks: AccessorUpdateTask[] = [];\n    const task = this.task;\n    this.targetAccessors.clear();\n\n    for (const item of results) {\n      const value = item.value;\n      const attributes = this.preprocessAttributes(item.attributes);\n      for (const attribute of attributes) {\n        if (this.isContentAttribute(attribute)) {\n          content[attribute] = value;\n        } else {\n          const controller = CustomElement.for(this.target, forOpts);\n          const accessor = controller && controller.viewModel\n            ? this.observerLocator.getAccessor(controller.viewModel, attribute)\n            : this.observerLocator.getAccessor(this.target, attribute);\n          const shouldQueueUpdate = (flags & LifecycleFlags.fromBind) === 0 && (accessor.type & AccessorType.Layout) > 0;\n          if (shouldQueueUpdate) {\n            accessorUpdateTasks.push(new AccessorUpdateTask(accessor, value, flags, this.target, attribute));\n          } else {\n            accessor.setValue(value, flags, this.target, attribute);\n          }\n          this.targetAccessors.add(accessor);\n        }\n      }\n    }\n\n    let shouldQueueContent = false;\n    if (Object.keys(content).length > 0) {\n      shouldQueueContent = (flags & LifecycleFlags.fromBind) === 0;\n      if (!shouldQueueContent) {\n        this.updateContent(content, flags);\n      }\n    }\n\n    if (accessorUpdateTasks.length > 0 || shouldQueueContent) {\n      this.task = this.platform.domWriteQueue.queueTask(() => {\n        this.task = null;\n        for (const updateTask of accessorUpdateTasks) {\n          updateTask.run();\n        }\n        if (shouldQueueContent) {\n          this.updateContent(content, flags);\n        }\n      }, taskQueueOpts);\n    }\n    task?.cancel();\n  }\n\n  private preprocessAttributes(attributes: string[]) {\n    if (attributes.length === 0) {\n      attributes = this.target.tagName === 'IMG' ? ['src'] : ['textContent'];\n    }\n\n    for (const [alias, attribute] of attributeAliases) {\n      const aliasIndex = attributes.findIndex((attr) => attr === alias);\n      if (aliasIndex > -1) {\n        attributes.splice(aliasIndex, 1, attribute);\n      }\n    }\n\n    return attributes;\n  }\n\n  private isContentAttribute(attribute: string): attribute is ContentAttribute {\n    return this.contentAttributes.includes(attribute);\n  }\n\n  private updateContent(content: ContentValue, flags: LifecycleFlags) {\n    const children = toArray(this.target.childNodes);\n    const fallBackContents = [];\n    const marker = 'au-i18n';\n\n    // extract the original content, not manipulated by au-i18n\n    for (const child of children) {\n      if (!Reflect.get(child, marker)) {\n        fallBackContents.push(child);\n      }\n    }\n\n    const template = this.prepareTemplate(content, marker, fallBackContents);\n\n    // difficult to use the set property approach in this case, as most of the properties of Node is readonly\n    // const observer = this.observerLocator.getAccessor(LifecycleFlags.none, this.target, '??');\n    // observer.setValue(??, flags);\n\n    this.target.innerHTML = '';\n    for (const child of toArray(template.content.childNodes)) {\n      this.target.appendChild(child);\n    }\n  }\n\n  private prepareTemplate(content: ContentValue, marker: string, fallBackContents: ChildNode[]) {\n    const template = this.platform.document.createElement('template');\n\n    this.addContentToTemplate(template, content.prepend, marker);\n\n    // build content: prioritize [html], then textContent, and falls back to original content\n    if (!this.addContentToTemplate(template, content.innerHTML ?? content.textContent, marker)) {\n      for (const fallbackContent of fallBackContents) {\n        template.content.append(fallbackContent);\n      }\n    }\n\n    this.addContentToTemplate(template, content.append, marker);\n    return template;\n  }\n\n  private addContentToTemplate(template: HTMLTemplateElement, content: string | undefined, marker: string) {\n    if (content !== void 0 && content !== null) {\n      const parser = this.platform.document.createElement('div');\n      parser.innerHTML = content;\n      for (const child of toArray(parser.childNodes)) {\n        Reflect.set(child, marker, true);\n        template.content.append(child);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  private ensureKeyExpression() {\n    const expr = this.keyExpression ??= '';\n    const exprType = typeof expr;\n    if (exprType !== 'string') {\n      throw new Error(`Expected the i18n key to be a string, but got ${expr} of type ${exprType}`); // TODO use reporter/logger\n    }\n  }\n}\n\nclass AccessorUpdateTask {\n  public constructor(\n    private readonly accessor: IAccessor,\n    private readonly v: unknown,\n    private readonly f: LifecycleFlags,\n    private readonly el: HTMLElement,\n    private readonly attr: string\n  ) {}\n\n  public run(): void {\n    this.accessor.setValue(this.v, this.f, this.el, this.attr);\n  }\n}\n\ninterface ParameterBinding extends IConnectableBinding {}\n\n@connectable()\nclass ParameterBinding {\n\n  public interceptor = this;\n\n  public value!: i18next.TOptions;\n  public readonly observerLocator: IObserverLocator;\n  public readonly locator: IServiceLocator;\n  public isBound: boolean = false;\n\n  private scope!: Scope;\n  private hostScope: Scope | null = null;\n\n  public constructor(\n    public readonly owner: TranslationBinding,\n    public readonly expr: IsExpression,\n    public readonly updater: (flags: LifecycleFlags) => void,\n  ) {\n    this.observerLocator = owner.observerLocator;\n    this.locator = owner.locator;\n  }\n\n  public handleChange(newValue: string | i18next.TOptions, _previousValue: string | i18next.TOptions, flags: LifecycleFlags): void {\n    this.obs.version++;\n    this.value = this.expr.evaluate(flags, this.scope, this.hostScope, this.locator, this) as i18next.TOptions;\n    this.obs.clear(false);\n    this.updater(flags);\n  }\n\n  public $bind(flags: LifecycleFlags, scope: Scope, hostScope: Scope | null): void {\n    if (this.isBound) {\n      return;\n    }\n    this.scope = scope;\n    this.hostScope = hostScope;\n\n    if (this.expr.hasBind) {\n      this.expr.bind(flags, scope, hostScope, this);\n    }\n\n    this.value = this.expr.evaluate(flags, scope, hostScope, this.locator, this) as i18next.TOptions;\n    this.isBound = true;\n  }\n\n  public $unbind(flags: LifecycleFlags) {\n    if (!this.isBound) {\n      return;\n    }\n\n    if (this.expr.hasUnbind) {\n      this.expr.unbind(flags, this.scope, this.hostScope, this);\n    }\n\n    this.scope = (void 0)!;\n    this.obs.clear(true);\n  }\n}\n","import { camelCase } from '@aurelia/kernel';\nimport { TranslationBinding } from './translation-binding.js';\nimport {\n  BindingMode,\n  BindingType,\n  IHydratableController,\n  IExpressionParser,\n  IRenderer,\n  renderer,\n  IObserverLocator,\n  IsBindingBehavior,\n  LifecycleFlags,\n  attributePattern,\n  AttrSyntax,\n  bindingCommand,\n  IPlatform,\n  IAttrMapper,\n  ICompiledRenderContext,\n  ICommandBuildInfo,\n} from '@aurelia/runtime-html';\n\nimport type {\n  CallBindingInstruction,\n  BindingCommandInstance,\n} from '@aurelia/runtime-html';\n\nexport const TranslationParametersInstructionType = 'tpt';\n// `.bind` part is needed here only for vCurrent compliance\nconst attribute = 't-params.bind';\n\n@attributePattern({ pattern: attribute, symbols: '' })\nexport class TranslationParametersAttributePattern {\n  public [attribute](rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, '', attribute);\n  }\n}\n\nexport class TranslationParametersBindingInstruction {\n  public readonly type: string = TranslationParametersInstructionType;\n  public mode: BindingMode.toView = BindingMode.toView;\n\n  public constructor(\n    public from: IsBindingBehavior,\n    public to: string,\n  ) {}\n}\n\n@bindingCommand(attribute)\nexport class TranslationParametersBindingCommand implements BindingCommandInstance {\n  public readonly bindingType: BindingType.BindCommand = BindingType.BindCommand;\n\n  public static get inject() { return [IAttrMapper]; }\n  public constructor(private readonly m: IAttrMapper) {}\n\n  public build(info: ICommandBuildInfo): TranslationParametersBindingInstruction {\n    let target: string;\n    if (info.bindable == null) {\n      target = this.m.map(info.node, info.attr.target)\n        // if the transformer doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(info.attr.target);\n    } else {\n      target = info.bindable.property;\n    }\n    return new TranslationParametersBindingInstruction(info.expr as IsBindingBehavior, target);\n  }\n}\n\n@renderer(TranslationParametersInstructionType)\nexport class TranslationParametersBindingRenderer implements IRenderer {\n  public constructor(\n    @IExpressionParser private readonly parser: IExpressionParser,\n    @IObserverLocator private readonly observerLocator: IObserverLocator,\n    @IPlatform private readonly platform: IPlatform,\n  ) { }\n\n  public render(\n    flags: LifecycleFlags,\n    context: ICompiledRenderContext,\n    renderingController: IHydratableController,\n    target: HTMLElement,\n    instruction: CallBindingInstruction,\n  ): void {\n    TranslationBinding.create({\n      parser: this.parser,\n      observerLocator: this.observerLocator,\n      context: renderingController.container,\n      controller: renderingController,\n      target,\n      instruction,\n      isParameterContext: true,\n      platform: this.platform\n    });\n  }\n}\n","import { camelCase } from '@aurelia/kernel';\nimport { TranslationBinding } from './translation-binding.js';\nimport {\n  BindingMode,\n  BindingType,\n  IExpressionParser,\n  IRenderer,\n  renderer,\n  IObserverLocator,\n  IsBindingBehavior,\n  LifecycleFlags,\n  IHydratableController,\n  AttrSyntax,\n  IPlatform,\n  IAttrMapper,\n  ICompiledRenderContext,\n  ICommandBuildInfo,\n} from '@aurelia/runtime-html';\n\nimport type {\n  CallBindingInstruction,\n  BindingCommandInstance,\n} from '@aurelia/runtime-html';\n\nexport const TranslationInstructionType = 'tt';\n\nexport class TranslationAttributePattern {\n  [key: string]: ((rawName: string, rawValue: string, parts: string[]) => AttrSyntax);\n\n  public static registerAlias(alias: string) {\n    this.prototype[alias] = function (rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n      return new AttrSyntax(rawName, rawValue, '', alias);\n    };\n  }\n}\n\nexport class TranslationBindingInstruction {\n  public readonly type: string = TranslationInstructionType;\n  public mode: BindingMode.toView = BindingMode.toView;\n\n  public constructor(\n    public from: IsBindingBehavior,\n    public to: string,\n  ) { }\n}\n\nexport class TranslationBindingCommand implements BindingCommandInstance {\n  public readonly bindingType: BindingType.CustomCommand = BindingType.CustomCommand;\n\n  public static get inject() { return [IAttrMapper]; }\n  public constructor(private readonly m: IAttrMapper) {}\n\n  public build(info: ICommandBuildInfo): TranslationBindingInstruction {\n    let target: string;\n    if (info.bindable == null) {\n      target = this.m.map(info.node, info.attr.target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(info.attr.target);\n    } else {\n      target = info.bindable.property;\n    }\n    return new TranslationBindingInstruction(info.expr as IsBindingBehavior, target);\n  }\n}\n\n@renderer(TranslationInstructionType)\nexport class TranslationBindingRenderer implements IRenderer {\n  public constructor(\n    @IExpressionParser private readonly parser: IExpressionParser,\n    @IObserverLocator private readonly observerLocator: IObserverLocator,\n    @IPlatform private readonly platform: IPlatform,\n  ) { }\n\n  public render(\n    flags: LifecycleFlags,\n    context: ICompiledRenderContext,\n    renderingController: IHydratableController,\n    target: HTMLElement,\n    instruction: CallBindingInstruction,\n  ): void {\n    TranslationBinding.create({\n      parser: this.parser,\n      observerLocator: this.observerLocator,\n      context: renderingController.container,\n      controller: renderingController,\n      target,\n      instruction,\n      platform: this.platform,\n    });\n  }\n}\n\nexport const TranslationBindInstructionType = 'tbt';\n\nexport class TranslationBindAttributePattern {\n  [key: string]: ((rawName: string, rawValue: string, parts: string[]) => AttrSyntax);\n\n  public static registerAlias(alias: string) {\n    const bindPattern = `${alias}.bind`;\n    this.prototype[bindPattern] = function (rawName: string, rawValue: string, parts: string[]): AttrSyntax {\n      return new AttrSyntax(rawName, rawValue, parts[1], bindPattern);\n    };\n  }\n}\n\nexport class TranslationBindBindingInstruction {\n  public readonly type: string = TranslationBindInstructionType;\n  public mode: BindingMode.toView = BindingMode.toView;\n\n  public constructor(\n    public from: IsBindingBehavior,\n    public to: string,\n  ) { }\n}\n\nexport class TranslationBindBindingCommand implements BindingCommandInstance {\n  public readonly bindingType: BindingType.BindCommand = BindingType.BindCommand;\n\n  public static get inject() { return [IAttrMapper]; }\n  public constructor(private readonly m: IAttrMapper) {}\n\n  public build(info: ICommandBuildInfo): TranslationBindingInstruction {\n    let target: string;\n    if (info.bindable == null) {\n      target = this.m.map(info.node, info.attr.target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(info.attr.target);\n    } else {\n      target = info.bindable.property;\n    }\n    return new TranslationBindBindingInstruction(info.expr as IsBindingBehavior, target);\n  }\n}\n\n@renderer(TranslationBindInstructionType)\nexport class TranslationBindBindingRenderer implements IRenderer {\n  public constructor(\n    @IExpressionParser private readonly parser: IExpressionParser,\n    @IObserverLocator private readonly observerLocator: IObserverLocator,\n    @IPlatform private readonly platform: IPlatform,\n  ) { }\n\n  public render(\n    flags: LifecycleFlags,\n    context: ICompiledRenderContext,\n    renderingController: IHydratableController,\n    target: HTMLElement,\n    instruction: CallBindingInstruction,\n  ): void {\n    TranslationBinding.create({\n      parser: this.parser,\n      observerLocator: this.observerLocator,\n      context: renderingController.container,\n      controller: renderingController,\n      target,\n      instruction,\n      platform: this.platform\n    });\n  }\n}\n","import { valueConverter } from '@aurelia/runtime-html';\nimport i18next from 'i18next';\nimport { I18N } from '../i18n.js';\nimport { Signals, ValueConverters } from '../utils.js';\n\n@valueConverter(ValueConverters.translationValueConverterName)\nexport class TranslationValueConverter {\n  public readonly signals: string[] = [Signals.I18N_SIGNAL];\n\n  public constructor(\n    @I18N private readonly i18n: I18N,\n  ) {}\n\n  public toView(value: string, options?: i18next.TOptions) {\n    return this.i18n.tr(value, options);\n  }\n}\n","import { IContainer, Registration } from '@aurelia/kernel';\nimport { AppTask, AttributePatternDefinition, BindingCommand, AttributePattern } from '@aurelia/runtime-html';\nimport { DateFormatBindingBehavior } from './df/date-format-binding-behavior.js';\nimport { DateFormatValueConverter } from './df/date-format-value-converter.js';\nimport { I18N, I18nService } from './i18n.js';\nimport { I18nConfigurationOptions, I18nInitOptions } from './i18n-configuration-options.js';\nimport { I18nextWrapper, I18nWrapper } from './i18next-wrapper.js';\nimport { NumberFormatBindingBehavior } from './nf/number-format-binding-behavior.js';\nimport { NumberFormatValueConverter } from './nf/number-format-value-converter.js';\nimport { RelativeTimeBindingBehavior } from './rt/relative-time-binding-behavior.js';\nimport { RelativeTimeValueConverter } from './rt/relative-time-value-converter.js';\nimport { TranslationBindingBehavior } from './t/translation-binding-behavior.js';\nimport {\n  TranslationParametersAttributePattern,\n  TranslationParametersBindingCommand,\n  TranslationParametersBindingRenderer\n} from './t/translation-parameters-renderer.js';\nimport {\n  TranslationAttributePattern,\n  TranslationBindAttributePattern,\n  TranslationBindBindingCommand,\n  TranslationBindBindingRenderer,\n  TranslationBindingCommand,\n  TranslationBindingRenderer\n} from './t/translation-renderer.js';\nimport { TranslationValueConverter } from './t/translation-value-converter.js';\n\nexport type I18NConfigOptionsProvider = (options: I18nConfigurationOptions) => void;\n\nconst translation = [\n  TranslationValueConverter,\n  TranslationBindingBehavior,\n];\n\nfunction coreComponents(options: I18nConfigurationOptions) {\n  const configuredAliases = options.translationAttributeAliases;\n  const aliases = Array.isArray(configuredAliases) ? configuredAliases : ['t'];\n\n  const patterns: AttributePatternDefinition[] = [];\n  const bindPatterns: AttributePatternDefinition[] = [];\n  const commandAliases: string[] = [];\n  const bindCommandAliases: string[] = [];\n  for (const alias of aliases) {\n    const bindAlias = `${alias}.bind`;\n\n    patterns.push({ pattern: alias, symbols: '' });\n    TranslationAttributePattern.registerAlias(alias);\n\n    bindPatterns.push({ pattern: bindAlias, symbols: '.' });\n    TranslationBindAttributePattern.registerAlias(alias);\n\n    if (alias !== 't') {\n      commandAliases.push(alias);\n      bindCommandAliases.push(bindAlias);\n    }\n  }\n  const renderers = [\n    AttributePattern.define(patterns, TranslationAttributePattern),\n    BindingCommand.define({name:'t', aliases: commandAliases}, TranslationBindingCommand),\n    TranslationBindingRenderer,\n    AttributePattern.define(bindPatterns, TranslationBindAttributePattern),\n    BindingCommand.define({name:'t.bind', aliases: bindCommandAliases}, TranslationBindBindingCommand),\n    TranslationBindBindingRenderer,\n    TranslationParametersAttributePattern,\n    TranslationParametersBindingCommand,\n    TranslationParametersBindingRenderer\n  ];\n\n  return {\n    register(container: IContainer) {\n      return container.register(\n        Registration.callback(I18nInitOptions, () => options.initOptions),\n        AppTask.beforeActivate(I18N, i18n => i18n.initPromise),\n        Registration.singleton(I18nWrapper, I18nextWrapper),\n        Registration.singleton(I18N, I18nService),\n\n        ...renderers,\n        ...translation);\n    }\n  };\n}\n\nconst dateFormat = [\n  DateFormatValueConverter,\n  DateFormatBindingBehavior,\n];\n\nconst numberFormat = [\n  NumberFormatValueConverter,\n  NumberFormatBindingBehavior,\n];\n\nconst relativeTimeFormat = [\n  RelativeTimeValueConverter,\n  RelativeTimeBindingBehavior,\n];\n\nfunction createI18nConfiguration(optionsProvider: I18NConfigOptionsProvider) {\n  return {\n    optionsProvider,\n    register(container: IContainer) {\n      const options: I18nConfigurationOptions = { initOptions: Object.create(null) };\n      optionsProvider(options);\n\n      return container.register(\n        coreComponents(options),\n        ...dateFormat,\n        ...numberFormat,\n        ...relativeTimeFormat\n      );\n    },\n    customize(cb?: I18NConfigOptionsProvider) {\n      return createI18nConfiguration(cb || optionsProvider);\n    },\n  };\n}\n\nexport const I18nConfiguration = createI18nConfiguration(() => { /* noop */ });\n"],"names":["ValueConverterExpression","bindingBehavior","valueConverter"],"mappings":"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"}