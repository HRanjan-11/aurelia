'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var kernel = require('@aurelia/kernel');
var typescript = require('typescript');
var jsdom = require('jsdom');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

const normalizePath = (function () {
    const cache = Object.create(null);
    const regex = /\\/g;
    return function (path) {
        let normalized = cache[path];
        if (normalized === void 0) {
            normalized = cache[path] = path.replace(regex, '/');
        }
        return normalized;
    };
})();
function joinPath(...paths) {
    return normalizePath(path.join(...paths));
}
function resolvePath(...paths) {
    return normalizePath(path.resolve(...paths));
}
/**
 * Returns `true` if this is an absolute POSIX, UNC or DOS path.
 *
 * Assumes path has already been normalized with `normalizePath`
 */
function isRootedDiskPath(path) {
    const ch0 = path.charCodeAt(0);
    return (ch0 === 47 /* Slash */
        || (ch0 >= 97 /* LowerA */
            && ch0 <= 122 /* LowerZ */
            && path.charCodeAt(1) === 58 /* Colon */));
}
function isRelativeModulePath(path) {
    const ch0 = path.charCodeAt(0);
    if (ch0 === 46 /* Dot */) {
        const ch1 = path.charCodeAt(1);
        if (ch1 === 46 /* Dot */) {
            return path.charCodeAt(2) === 47 /* Slash */ || path.length === 2;
        }
        return ch1 === 47 /* Slash */ || path.length === 1;
    }
    return isRootedDiskPath(path);
}

const { access, lstat, mkdir, readdir, readFile, realpath, rmdir, stat, unlink, writeFile, } = fs.promises;
function compareFilePath(a, b) {
    return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;
}
function shouldTraverse(path) {
    // By default convention we don't traverse any path that starts with a dot because those shouldn't contain application code
    // For example: .git, .vscode, .circleci, etc.
    // We also exclude node_modules. But everything else is traversed by default.
    // TODO: make this configurable
    return path.charCodeAt(0) !== 46 /* Dot */ && path !== 'node_modules';
}
class File {
    constructor(fs, 
    /**
     * The full, absolute, real path to the file.
     *
     * @example
     * 'd:/foo/bar.ts' // 'd:/foo/bar.ts' is the path
     */
    path, 
    /**
     * The full, absolute, real path to the folder containing the file.
     *
     * @example
     * 'd:/foo/bar.ts' // 'd:/foo' is the path
     */
    dir, 
    /**
     * A loosely defined human-readable identifier for the file, usually with the common root directory removed for improved clarity in logs.
     */
    rootlessPath, 
    /**
     * The leaf file name, including the extension.
     *
     * @example
     * './foo/bar.ts' // 'bar.ts' is the name
     */
    name, 
    /**
     * The leaf file name, excluding the extension.
     *
     * @example
     * './foo/bar.ts' // 'bar' is the shortName
     */
    shortName, 
    /**
     * The file extension, including the period. For .d.ts files, the whole part ".d.ts" must be included.
     *
     * @example
     * './foo/bar.ts' // '.ts' is the extension
     * './foo/bar.d.ts' // '.d.ts' is the extension
     */
    ext) {
        this.fs = fs;
        this.path = path;
        this.dir = dir;
        this.rootlessPath = rootlessPath;
        this.name = name;
        this.shortName = shortName;
        this.ext = ext;
        this.shortPath = `${dir}/${shortName}`;
        switch (ext) {
            case '.js':
            case '.ts':
            case '.d.ts':
            case '.jsx':
            case '.tsx':
                this.kind = 1 /* Script */;
                break;
            case '.html':
                this.kind = 2 /* Markup */;
                break;
            case '.css':
                this.kind = 3 /* Style */;
                break;
            case '.json':
                this.kind = 4 /* JSON */;
                break;
            default:
                this.kind = 0 /* Unknown */;
        }
    }
    static getExtension(name) {
        const lastDotIndex = name.lastIndexOf('.');
        if (lastDotIndex <= 0) {
            return void 0;
        }
        const lastPart = name.slice(lastDotIndex);
        switch (lastPart) {
            case '.ts':
                return name.endsWith('.d.ts') ? '.d.ts' : '.ts';
            case '.map': {
                const extensionlessName = name.slice(0, lastDotIndex);
                const secondDotIndex = extensionlessName.lastIndexOf('.');
                if (secondDotIndex === -1) {
                    return void 0;
                }
                return name.slice(secondDotIndex);
            }
            default:
                return lastPart;
        }
    }
    getContent(cache = false, force = false) {
        return this.fs.readFile(this.path, "utf8" /* utf8 */, cache, force);
    }
    getContentSync(cache = false, force = false) {
        return this.fs.readFileSync(this.path, "utf8" /* utf8 */, cache, force);
    }
}
const tick = {
    current: void 0,
    wait() {
        if (tick.current === void 0) {
            tick.current = new Promise(function (resolve) {
                setTimeout(function () {
                    tick.current = void 0;
                    resolve();
                });
            });
        }
        return tick.current;
    }
};
exports.NodeFileSystem = class NodeFileSystem {
    constructor(logger) {
        this.logger = logger;
        this.childrenCache = new Map();
        this.realPathCache = new Map();
        this.contentCache = new Map();
        this.pendingReads = 0;
        this.maxConcurrentReads = 0;
        this.logger = logger.scopeTo(this.constructor.name);
        this.logger.info('constructor');
    }
    async realpath(path) {
        this.logger.trace(`realpath(path: ${path})`);
        return realpath(path);
    }
    realpathSync(path) {
        this.logger.trace(`realpathSync(path: ${path})`);
        return fs.realpathSync(path);
    }
    async readdir(path, withFileTypes) {
        this.logger.trace(`readdir(path: ${path}, withFileTypes: ${withFileTypes})`);
        if (withFileTypes === true) {
            return readdir(path, { withFileTypes: true });
        }
        return readdir(path);
    }
    readdirSync(path, withFileTypes) {
        this.logger.trace(`readdirSync(path: ${path}, withFileTypes: ${withFileTypes})`);
        if (withFileTypes === true) {
            return fs.readdirSync(path, { withFileTypes: true });
        }
        return fs.readdirSync(path);
    }
    async mkdir(path) {
        this.logger.trace(`mkdir(path: ${path})`);
        return mkdir(path, { recursive: true });
    }
    mkdirSync(path) {
        this.logger.trace(`mkdirSync(path: ${path})`);
        fs.mkdirSync(path, { recursive: true });
    }
    async isReadable(path) {
        this.logger.trace(`isReadable(path: ${path})`);
        try {
            await access(path, fs.constants.F_OK);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    isReadableSync(path) {
        this.logger.trace(`isReadableSync(path: ${path})`);
        try {
            fs.accessSync(path, fs.constants.F_OK);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    async fileExists(path) {
        this.logger.trace(`fileExists(path: ${path})`);
        try {
            return (await stat(path)).isFile();
        }
        catch (err) {
            return false;
        }
    }
    fileExistsSync(path) {
        this.logger.trace(`fileExistsSync(path: ${path})`);
        try {
            return fs.statSync(path).isFile();
        }
        catch (err) {
            return false;
        }
    }
    async stat(path) {
        this.logger.trace(`stat(path: ${path})`);
        return stat(path);
    }
    statSync(path) {
        this.logger.trace(`statSync(path: ${path})`);
        return fs.statSync(path);
    }
    async lstat(path) {
        this.logger.trace(`lstat(path: ${path})`);
        return lstat(path);
    }
    lstatSync(path) {
        this.logger.trace(`lstatSync(path: ${path})`);
        return fs.lstatSync(path);
    }
    async readFile(path, encoding, cache = false, force = false) {
        this.logger.trace(`readFile(path: ${path}, encoding: ${encoding}, cache: ${cache}, force: ${force})`);
        const contentCache = this.contentCache;
        let content = contentCache.get(path);
        if (content === void 0 || force) {
            try {
                while (this.maxConcurrentReads > 0 && this.maxConcurrentReads < this.pendingReads) {
                    // eslint-disable-next-line no-await-in-loop
                    await tick.wait();
                }
                ++this.pendingReads;
                content = await readFile(path, encoding);
                --this.pendingReads;
            }
            catch (err) {
                if (err.code === 'EMFILE') {
                    --this.pendingReads;
                    this.maxConcurrentReads = this.pendingReads;
                    await tick.wait();
                    return this.readFile(path, encoding, cache, force);
                }
                throw err;
            }
            if (cache) {
                contentCache.set(path, content);
            }
        }
        return content;
    }
    readFileSync(path, encoding, cache = false, force = false) {
        this.logger.trace(`readFileSync(path: ${path}, encoding: ${encoding}, cache: ${cache}, force: ${force})`);
        const contentCache = this.contentCache;
        let content = contentCache.get(path);
        if (content === void 0 || force) {
            content = fs.readFileSync(path, encoding);
            if (cache) {
                contentCache.set(path, content);
            }
        }
        return content;
    }
    async ensureDir(path) {
        this.logger.trace(`ensureDir(path: ${path})`);
        if (await new Promise(res => { fs.exists(path, res); })) {
            return;
        }
        return this.mkdir(path);
    }
    ensureDirSync(path) {
        this.logger.trace(`ensureDirSync(path: ${path})`);
        if (fs.existsSync(path)) {
            return;
        }
        this.mkdirSync(path);
    }
    async writeFile(path$1, content, encoding) {
        this.logger.trace(`writeFile(path: ${path$1}, content: ${content}, encoding: ${encoding})`);
        await this.ensureDir(path.dirname(path$1));
        return writeFile(path$1, content, { encoding: encoding });
    }
    writeFileSync(path$1, content, options) {
        this.logger.trace(`readFileSync(path: ${path$1}, content: ${content}, encoding: ${options})`);
        this.ensureDirSync(path.dirname(path$1));
        fs.writeFileSync(path$1, content, options);
    }
    async rimraf(path$1) {
        this.logger.trace(`rimraf(path: ${path$1})`);
        try {
            const stats = await lstat(path$1);
            if (stats.isDirectory()) {
                await Promise.all((await readdir(path$1)).map(async (x) => this.rimraf(path.join(path$1, x))));
                await rmdir(path$1);
            }
            else if (stats.isFile() || stats.isSymbolicLink()) {
                await unlink(path$1);
            }
        }
        catch (err) {
            this.logger.error(`rimraf failed`, err);
        }
    }
    async getRealPath(path) {
        path = normalizePath(path);
        const realPathCache = this.realPathCache;
        let real = realPathCache.get(path);
        if (real === void 0) {
            real = normalizePath(await realpath(path));
            realPathCache.set(path, real);
        }
        return real;
    }
    getRealPathSync(path) {
        path = normalizePath(path);
        const realPathCache = this.realPathCache;
        let real = realPathCache.get(path);
        if (real === void 0) {
            real = normalizePath(fs.realpathSync(path));
            realPathCache.set(path, real);
        }
        return real;
    }
    async getChildren(path) {
        const childrenCache = this.childrenCache;
        let children = childrenCache.get(path);
        if (children === void 0) {
            children = (await readdir(path)).filter(shouldTraverse);
            childrenCache.set(path, children);
        }
        return children;
    }
    getChildrenSync(path) {
        const childrenCache = this.childrenCache;
        let children = childrenCache.get(path);
        if (children === void 0) {
            children = fs.readdirSync(path).filter(shouldTraverse);
            childrenCache.set(path, children);
        }
        return children;
    }
    async getFiles(root, loadContent = false) {
        const files = [];
        const seen = {};
        const walk = async (dir, name) => {
            const path$1 = await this.getRealPath(joinPath(dir, name));
            if (seen[path$1] === void 0) {
                seen[path$1] = true;
                const stats = await stat(path$1);
                if (stats.isFile()) {
                    const ext = File.getExtension(path$1);
                    if (ext !== void 0) {
                        const rootlessPath = path$1.slice(path.dirname(root).length);
                        const shortName = name.slice(0, -ext.length);
                        const file = new File(this, path$1, dir, rootlessPath, name, shortName, ext);
                        if (loadContent) {
                            await this.readFile(path$1, "utf8" /* utf8 */, true);
                        }
                        files.push(file);
                    }
                }
                else if (stats.isDirectory()) {
                    await Promise.all((await this.getChildren(path$1)).map(async (x) => walk(path$1, x)));
                }
            }
        };
        await Promise.all((await this.getChildren(root)).map(async (x) => walk(root, x)));
        return files.sort(compareFilePath);
    }
    getFilesSync(root, loadContent = false) {
        const files = [];
        const seen = {};
        const walk = (dir, name) => {
            const path$1 = this.getRealPathSync(joinPath(dir, name));
            if (seen[path$1] === void 0) {
                seen[path$1] = true;
                const stats = fs.statSync(path$1);
                if (stats.isFile()) {
                    const ext = File.getExtension(path$1);
                    if (ext !== void 0) {
                        const rootlessPath = path$1.slice(path.dirname(root).length);
                        const shortName = name.slice(0, -ext.length);
                        const file = new File(this, path$1, dir, rootlessPath, name, shortName, ext);
                        if (loadContent) {
                            this.readFileSync(path$1, "utf8" /* utf8 */, true);
                        }
                        files.push(file);
                    }
                }
                else if (stats.isDirectory()) {
                    this.getChildrenSync(path$1).forEach(x => { walk(path$1, x); });
                }
            }
        };
        this.getChildrenSync(root).forEach(x => { walk(root, x); });
        return files.sort(compareFilePath);
    }
};
exports.NodeFileSystem = __decorate([
    __param(0, kernel.ILogger)
], exports.NodeFileSystem);

exports.Encoding = void 0;
(function (Encoding) {
    Encoding["utf8"] = "utf8";
    Encoding["utf16le"] = "utf16le";
    Encoding["latin1"] = "latin1";
    Encoding["base64"] = "base64";
    Encoding["ascii"] = "ascii";
    Encoding["hex"] = "hex";
    Encoding["raw"] = "raw";
})(exports.Encoding || (exports.Encoding = {}));
exports.FileKind = void 0;
(function (FileKind) {
    FileKind[FileKind["Unknown"] = 0] = "Unknown";
    FileKind[FileKind["Script"] = 1] = "Script";
    FileKind[FileKind["Markup"] = 2] = "Markup";
    FileKind[FileKind["Style"] = 3] = "Style";
    FileKind[FileKind["JSON"] = 4] = "JSON";
})(exports.FileKind || (exports.FileKind = {}));
const IFileSystem = kernel.DI.createInterface('IFileSystem');

var CompletionType;
(function (CompletionType) {
    CompletionType[CompletionType["normal"] = 1] = "normal";
    CompletionType[CompletionType["break"] = 2] = "break";
    CompletionType[CompletionType["continue"] = 3] = "continue";
    CompletionType[CompletionType["return"] = 4] = "return";
    CompletionType[CompletionType["throw"] = 5] = "throw";
})(CompletionType || (CompletionType = {}));
const nextValueId = (function () {
    let id = 0;
    return function () {
        return ++id;
    };
})();
const Int32 = (function () {
    const $ = new Int32Array(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
const Uint32 = (function () {
    const $ = new Uint32Array(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
const Int16 = (function () {
    const $ = new Int16Array(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
const Uint16 = (function () {
    const $ = new Uint16Array(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
const Int8 = (function () {
    const $ = new Int8Array(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
const Uint8 = (function () {
    const $ = new Uint8Array(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
const Uint8Clamp = (function () {
    const $ = new Uint8ClampedArray(1);
    return function (value) {
        $[0] = Number(value);
        return $[0];
    };
})();
// Sort two strings numerically instead of alphabetically
function compareIndices(a, b) {
    // Rely on coercion as natively subtracting strings has some shortcuts (for better perf) compared to explicitly converting to number first
    return a['[[Value]]'] - b['[[Value]]'];
}

let descriptorId = 0;
// http://www.ecma-international.org/ecma-262/#sec-property-descriptor-specification-type
class $PropertyDescriptor {
    constructor(realm, name, config) {
        this.realm = realm;
        this.name = name;
        this.id = ++descriptorId;
        const $empty = realm['[[Intrinsics]]'].empty;
        this['[[Enumerable]]'] = $empty;
        this['[[Configurable]]'] = $empty;
        this['[[Get]]'] = $empty;
        this['[[Set]]'] = $empty;
        this['[[Value]]'] = $empty;
        this['[[Writable]]'] = $empty;
        Object.assign(this, config);
    }
    get isAbrupt() { return false; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isFunction() { return false; }
    // http://www.ecma-international.org/ecma-262/#sec-isaccessordescriptor
    // 6.2.5.1 IsAccessorDescriptor ( Desc )
    get isAccessorDescriptor() {
        // 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.
        return !this['[[Get]]'].isEmpty || !this['[[Set]]'].isEmpty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-isdatadescriptor
    // 6.2.5.2 IsDataDescriptor ( Desc )
    get isDataDescriptor() {
        // 2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.
        return !this['[[Value]]'].isEmpty || !this['[[Writable]]'].isEmpty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-isgenericdescriptor
    // 6.2.5.3 IsGenericDescriptor ( Desc )
    get isGenericDescriptor() {
        // 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.
        return (this['[[Get]]'].isEmpty &&
            this['[[Set]]'].isEmpty &&
            this['[[Value]]'].isEmpty &&
            this['[[Writable]]'].isEmpty);
    }
    // http://www.ecma-international.org/ecma-262/#sec-completepropertydescriptor
    // 6.2.5.6 CompletePropertyDescriptor ( Desc )
    Complete(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: Desc is a Property Descriptor.
        // 2. Let like be Record { [[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false }.
        // 3. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then
        if (this.isGenericDescriptor || this.isDataDescriptor) {
            // 3. a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].
            if (this['[[Value]]'].isEmpty) {
                this['[[Value]]'] = intrinsics.undefined;
            }
            // 3. b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].
            if (this['[[Writable]]'].isEmpty) {
                this['[[Writable]]'] = intrinsics.false;
            }
        }
        // 4. Else,
        else {
            // 4. a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].
            if (this['[[Get]]'].isEmpty) {
                this['[[Get]]'] = intrinsics.undefined;
            }
            // 4. b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].
            if (this['[[Set]]'].isEmpty) {
                this['[[Set]]'] = intrinsics.undefined;
            }
        }
        // 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].
        if (this['[[Enumerable]]'].isEmpty) {
            this['[[Enumerable]]'] = intrinsics.false;
        }
        // 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].
        if (this['[[Configurable]]'].isEmpty) {
            this['[[Configurable]]'] = intrinsics.false;
        }
        // 7. Return Desc.
        return this;
    }
    dispose() {
        this['[[Enumerable]]'] = void 0;
        this['[[Configurable]]'] = void 0;
        this['[[Get]]'] = void 0;
        this['[[Set]]'] = void 0;
        this['[[Writable]]'] = void 0;
        this['[[Value]]'] = void 0;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-isdatadescriptor
function $IsDataDescriptor(Desc) {
    // 1. If Desc is undefined, return false.
    if (Desc.isUndefined) {
        return false;
    }
    // 2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.
    // 3. Return true.
    return Desc.isDataDescriptor;
}

// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-number-type
class $Number {
    constructor(realm, value, type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty, sourceNode = null, conversionSource = null) {
        this.realm = realm;
        this.sourceNode = sourceNode;
        this.conversionSource = conversionSource;
        this.id = nextValueId();
        this.IntrinsicName = 'number';
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Value]]'] = value;
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'Number'; }
    get isNaN() { return isNaN(this['[[Value]]']); }
    get isPositiveZero() { return Object.is(this['[[Value]]'], +0); }
    get isNegativeZero() { return Object.is(this['[[Value]]'], -0); }
    get isPositiveInfinity() { return Object.is(this['[[Value]]'], +Infinity); }
    get isNegativeInfinity() { return Object.is(this['[[Value]]'], -Infinity); }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return true; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return this['[[Value]]'] !== 0 && !isNaN(this['[[Value]]']); }
    get isFalsey() { return this['[[Value]]'] === 0 || isNaN(this['[[Value]]']); }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    get isList() { return false; }
    is(other) {
        return other instanceof $Number && Object.is(this['[[Value]]'], other['[[Value]]']);
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    equals(other) {
        return Object.is(this['[[Value]]'], other['[[Value]]']);
    }
    // http://www.ecma-international.org/ecma-262/#sec-isinteger
    // 7.2.6 IsInteger ( argument )
    get IsInteger() {
        if (isNaN(this['[[Value]]']) || Object.is(this['[[Value]]'], Infinity) || Object.is(this['[[Value]]'], -Infinity)) {
            return false;
        }
        return Math.floor(Math.abs(this['[[Value]]'])) === Math.abs(this['[[Value]]']);
    }
    ToObject(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        return $Object.ObjectCreate(ctx, 'number', intrinsics['%NumberPrototype%'], {
            '[[NumberData]]': this,
        });
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return new $Boolean(
        /* realm */ this.realm, 
        /* value */ Boolean(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToNumber(ctx) {
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-tointeger
    // 7.1.4 ToInteger ( argument )
    ToInteger(ctx) {
        // 1. Let number be ? ToNumber(argument).
        const value = this['[[Value]]'];
        if (isNaN(value)) {
            // 2. If number is NaN, return +0.
            return new $Number(
            /* realm */ this.realm, 
            /* value */ 0, 
            /* type */ this['[[Type]]'], 
            /* target */ this['[[Target]]'], 
            /* sourceNode */ null, 
            /* conversionSource */ this);
        }
        // 3. If number is +0, -0, +∞, or -∞, return number.
        if (Object.is(value, +0) || Object.is(value, -0) || Object.is(value, +Infinity) || Object.is(value, -Infinity)) {
            return this;
        }
        // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).
        const sign = value < 0 ? -1 : 1;
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Math.floor(Math.abs(value)) * sign, 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-tolength
    // 7.1.15 ToLength ( argument )
    ToLength(ctx) {
        // 1. Let len be ? ToInteger(argument).
        const len = this.ToInteger(ctx);
        if (len.isAbrupt) {
            return len;
        }
        // 2. If len ≤ +0, return +0.
        if (len['[[Value]]'] < 0) {
            return new $Number(
            /* realm */ this.realm, 
            /* value */ 0, 
            /* type */ this['[[Type]]'], 
            /* target */ this['[[Target]]'], 
            /* sourceNode */ null, 
            /* conversionSource */ this);
        }
        // 3. Return min(len, 253 - 1).
        if (len['[[Value]]'] > (2 ** 53 - 1)) {
            return new $Number(
            /* realm */ this.realm, 
            /* value */ (2 ** 53 - 1), 
            /* type */ this['[[Type]]'], 
            /* target */ this['[[Target]]'], 
            /* sourceNode */ null, 
            /* conversionSource */ this);
        }
        return this;
    }
    ToInt32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8Clamp(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8Clamp(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToString(ctx) {
        return new $String(
        /* realm */ this.realm, 
        /* value */ String(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    GetValue(ctx) {
        return this;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-string-type
class $String {
    constructor(realm, value, type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty, sourceNode = null, conversionSource = null) {
        this.realm = realm;
        this.sourceNode = sourceNode;
        this.conversionSource = conversionSource;
        this.id = nextValueId();
        this.IntrinsicName = 'string';
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Value]]'] = value;
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'String'; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return true; }
    get isSymbol() { return false; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return this['[[Value]]'].length > 0; }
    get isFalsey() { return this['[[Value]]'].length === 0; }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    // Only used in contexts where a value is always 'ambiguous' if it is a $String
    get isAmbiguous() {
        if (this['[[Value]]'] !== 'ambiguous') {
            // Just make sure that we don't actually violate that invariant
            throw new Error(`Expected "${this['[[Value]]']}" to be "ambiguous"`);
        }
        return true;
    }
    get isList() { return false; }
    // http://www.ecma-international.org/ecma-262/#sec-canonicalnumericindexstring
    // 7.1.16 CanonicalNumericIndexString ( argument )
    CanonicalNumericIndexString(ctx) {
        if (this['[[Value]]'] === '-0') {
            return this.realm['[[Intrinsics]]']['-0'];
        }
        const n = this.ToNumber(ctx);
        if (n.ToString(ctx).is(this)) {
            return n;
        }
        return this.realm['[[Intrinsics]]'].undefined;
    }
    get IsArrayIndex() {
        if (this['[[Value]]'] === '-0') {
            return false;
        }
        const num = Number(this['[[Value]]']);
        if (num.toString() === this['[[Value]]']) {
            return num >= 0 && num <= (2 ** 32 - 1);
        }
        return false;
    }
    is(other) {
        return other instanceof $String && this['[[Value]]'] === other['[[Value]]'];
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return `"${this['[[Value]]']}"`;
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        return $Object.ObjectCreate(ctx, 'string', intrinsics['%StringPrototype%'], {
            '[[StringData]]': this,
        });
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToLength(ctx) {
        return this.ToNumber(ctx).ToLength(ctx);
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return new $Boolean(
        /* realm */ this.realm, 
        /* value */ Boolean(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToNumber(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Number(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8Clamp(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8Clamp(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToString(ctx) {
        return this;
    }
    GetValue(ctx) {
        return this;
    }
}

class $Error {
    constructor(realm, err, intrinsicName) {
        this.realm = realm;
        this.id = nextValueId();
        this['[[Type]]'] = 5 /* throw */;
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this.IntrinsicName = intrinsicName;
        this['[[Value]]'] = err;
        this['[[Target]]'] = realm['[[Intrinsics]]'].empty;
    }
    get isAbrupt() { return true; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return true; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return this['[[Value]]']; }
    get isFalsey() { return !this['[[Value]]']; }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    get isList() { return false; }
    is(other) {
        return other instanceof $Error && other.id === this.id;
    }
    enrichWith(ctx, node) {
        this.nodeStack.push(node);
        if (this.ctx === null) {
            this.ctx = ctx;
            this.stack = ctx.Realm.stack.toString();
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getvalue
    // 6.2.4.8 GetValue ( V )
    GetValue(ctx) {
        // 1. ReturnIfAbrupt(V)
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        return this;
    }
    ToPropertyKey(ctx) {
        return this;
    }
    ToLength(ctx) {
        return this;
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return this;
    }
    ToNumber(ctx) {
        return this;
    }
    ToInt32(ctx) {
        return this;
    }
    ToUint32(ctx) {
        return this;
    }
    ToInt16(ctx) {
        return this;
    }
    ToUint16(ctx) {
        return this;
    }
    ToInt8(ctx) {
        return this;
    }
    ToUint8(ctx) {
        return this;
    }
    ToUint8Clamp(ctx) {
        return this;
    }
    ToString(ctx) {
        return this;
    }
}
class $SyntaxError extends $Error {
    constructor(realm, message = void 0) {
        super(realm, new SyntaxError(message), 'SyntaxError');
    }
}
class $TypeError extends $Error {
    constructor(realm, message = void 0) {
        super(realm, new TypeError(message), 'TypeError');
    }
}
class $ReferenceError extends $Error {
    constructor(realm, message = void 0) {
        super(realm, new ReferenceError(message), 'ReferenceError');
    }
}
class $RangeError extends $Error {
    constructor(realm, message = void 0) {
        super(realm, new RangeError(message), 'RangeError');
    }
}
class $URIError extends $Error {
    constructor(realm, message = void 0) {
        super(realm, new URIError(message), 'URIError');
    }
}

class $List extends Array {
    get isAbrupt() { return false; }
    get isList() { return true; }
    constructor(...items) {
        super(...items);
    }
    $copy() {
        return new $List(...this);
    }
    $contains(item) {
        return this.some(x => x.is(item));
    }
    GetValue(ctx) {
        return this;
    }
    enrichWith(ctx, node) {
        return this;
    }
    is(other) {
        return this === other;
    }
}

const empty = Symbol('empty');
class $Empty {
    constructor(realm, type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty, sourceNode = null) {
        this.realm = realm;
        this.sourceNode = sourceNode;
        this.id = nextValueId();
        this.IntrinsicName = 'empty';
        this['[[Value]]'] = empty;
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return new $TypeError(this.realm, `[[empty]] has no Type`); }
    get isEmpty() { return true; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return false; }
    get isFalsey() { return true; }
    get isSpeculative() { return false; }
    get hasValue() { return false; }
    get isList() { return false; }
    is(other) {
        return other instanceof $Empty;
    }
    enrichWith(ctx, node) {
        return this;
    }
    [Symbol.toPrimitive]() {
        return '[[empty]]';
    }
    [Symbol.toStringTag]() {
        return '[object [[empty]]]';
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
        return value.ToCompletion(this['[[Type]]'], this['[[Target]]']);
    }
    ToObject(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to object`);
    }
    ToPropertyKey(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to property key`);
    }
    ToLength(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to length`);
    }
    ToPrimitive(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to primitive`);
    }
    ToBoolean(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to boolean`);
    }
    ToNumber(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to number`);
    }
    ToInt32(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Int32`);
    }
    ToUint32(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint32`);
    }
    ToInt16(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Int16`);
    }
    ToUint16(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint16`);
    }
    ToInt8(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Int8`);
    }
    ToUint8(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint8`);
    }
    ToUint8Clamp(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint8Clamp`);
    }
    ToString(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to string`);
    }
    GetValue(ctx) {
        return new $TypeError(ctx.Realm, `[[empty]] has no value`);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-set-o-p-v-throw
function $Set(ctx, O, P, V, Throw) {
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    // 3. Assert: Type(Throw) is Boolean.
    // 4. Let success be ? O.[[Set]](P, V, O).
    const success = O['[[Set]]'](ctx, P, V, O);
    if (success.isAbrupt) {
        return success;
    }
    // 5. If success is false and Throw is true, throw a TypeError exception.
    if (success.isFalsey && Throw.isTruthy) {
        return new $TypeError(ctx.Realm, `Cannot set property ${P}`);
    }
    // 6. Return success.
    return success;
}
// http://www.ecma-international.org/ecma-262/#sec-getv
// 7.3.2 GetV ( V , P )
function $GetV(ctx, V, P) {
    // 1. Assert: IsPropertyKey(P) is true.
    // 2. Let O be ? ToObject(V).
    const O = V.ToObject(ctx);
    if (O.isAbrupt) {
        return O;
    }
    // 3. Return ? O.[[Get]](P, V).
    return O['[[Get]]'](ctx, P, V);
}
// http://www.ecma-international.org/ecma-262/#sec-getmethod
// 7.3.9 GetMethod ( V , P )
function $GetMethod(ctx, V, P) {
    // 1. Assert: IsPropertyKey(P) is true.
    // 2. Let func be ? GetV(V, P).
    const func = $GetV(ctx, V, P);
    if (func.isAbrupt) {
        return func;
    }
    // 3. If func is either undefined or null, return undefined.
    if (func.isNil) {
        return ctx.Realm['[[Intrinsics]]'].undefined;
    }
    // 4. If IsCallable(func) is false, throw a TypeError exception.
    if (!func.isFunction) {
        return new $TypeError(ctx.Realm, `Property ${P} of ${V} is ${func}, but expected a callable function`);
    }
    // 5. Return func.
    return func;
}
// http://www.ecma-international.org/ecma-262/#sec-createdataproperty
function $CreateDataProperty(ctx, O, P, V) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    // 3. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
    const newDesc = new $PropertyDescriptor(realm, P);
    newDesc['[[Value]]'] = V;
    newDesc['[[Writable]]'] = intrinsics.true;
    newDesc['[[Enumerable]]'] = intrinsics.true;
    newDesc['[[Configurable]]'] = intrinsics.true;
    // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).
    return O['[[DefineOwnProperty]]'](ctx, P, newDesc);
}
// http://www.ecma-international.org/ecma-262/#sec-ordinarysetwithowndescriptor
function $OrdinarySetWithOwnDescriptor(ctx, O, P, V, Receiver, ownDesc) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: IsPropertyKey(P) is true.
    // 2. If ownDesc is undefined, then
    if (ownDesc.isUndefined) {
        // 2. a. Let parent be ? O.[[GetPrototypeOf]]().
        const parent = O['[[GetPrototypeOf]]'](ctx);
        if (parent.isAbrupt) {
            return parent;
        }
        // 2. b. If parent is not null, then
        if (!parent.isNull) {
            // 2. b. i. Return ? parent.[[Set]](P, V, Receiver).
            return parent['[[Set]]'](ctx, P, V, Receiver);
        }
        // 2. c. Else,
        else {
            // 2. c. i. Set ownDesc to the PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
            ownDesc = new $PropertyDescriptor(realm, P);
            ownDesc['[[Value]]'] = intrinsics.undefined;
            ownDesc['[[Writable]]'] = intrinsics.true;
            ownDesc['[[Enumerable]]'] = intrinsics.true;
            ownDesc['[[Configurable]]'] = intrinsics.true;
        }
    }
    // 3. If IsDataDescriptor(ownDesc) is true, then
    if (ownDesc.isDataDescriptor) {
        // 3. a. If ownDesc.[[Writable]] is false, return false.
        if (ownDesc['[[Writable]]'].isFalsey) {
            return intrinsics.false;
        }
        // 3. b. If Type(Receiver) is not Object, return false.
        if (!Receiver.isObject) {
            return intrinsics.false;
        }
        // 3. c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).
        const existingDescriptor = Receiver['[[GetOwnProperty]]'](ctx, P);
        if (existingDescriptor.isAbrupt) {
            return existingDescriptor;
        }
        // 3. d. If existingDescriptor is not undefined, then
        if (!existingDescriptor.isUndefined) {
            // 3. d. i. If IsAccessorDescriptor(existingDescriptor) is true, return false.
            if (existingDescriptor.isAccessorDescriptor) {
                return intrinsics.false;
            }
            // 3. d. ii. If existingDescriptor.[[Writable]] is false, return false.
            if (existingDescriptor['[[Writable]]'].isFalsey) {
                return intrinsics.false;
            }
            // 3. d. iii. Let valueDesc be the PropertyDescriptor { [[Value]]: V }.
            const valueDesc = new $PropertyDescriptor(realm, P);
            valueDesc['[[Value]]'] = V;
            // 3. d. iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).
            return Receiver['[[DefineOwnProperty]]'](ctx, P, valueDesc);
        }
        // 3. e. Else Receiver does not currently have a property P,
        else {
            // 3. e. i. Return ? CreateDataProperty(Receiver, P, V).
            return $CreateDataProperty(ctx, Receiver, P, V);
        }
    }
    // 4. Assert: IsAccessorDescriptor(ownDesc) is true.
    // 5. Let setter be ownDesc.[[Set]].
    const setter = ownDesc['[[Set]]'];
    // 6. If setter is undefined, return false.
    if (setter.isUndefined) {
        return intrinsics.false;
    }
    // 7. Perform ? Call(setter, Receiver, « V »).
    $Call(ctx, setter, Receiver, new $List(V));
    // 8. Return true.
    return intrinsics.true;
}
// http://www.ecma-international.org/ecma-262/#sec-hasownproperty
function $HasOwnProperty(ctx, O, P) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    // 3. Let desc be ? O.[[GetOwnProperty]](P).
    const desc = O['[[GetOwnProperty]]'](ctx, P);
    if (desc.isAbrupt) {
        return desc;
    }
    // 4. If desc is undefined, return false.
    if (desc.isUndefined) {
        return intrinsics.false;
    }
    // 5. Return true.
    return intrinsics.true;
}
// http://www.ecma-international.org/ecma-262/#sec-call
function $Call(ctx, F, V, argumentsList) {
    // 1. If argumentsList is not present, set argumentsList to a new empty List.
    if (!argumentsList.isList) {
        argumentsList = new $List();
    }
    // 2. If IsCallable(F) is false, throw a TypeError exception.
    if (!F.isFunction) {
        return new $TypeError(ctx.Realm, `${F} is not callable`);
    }
    // 3. Return ? F.[[Call]](V, argumentsList).
    return F['[[Call]]'](ctx, V, argumentsList);
}
// http://www.ecma-international.org/ecma-262/#sec-construct
function $Construct(ctx, F, argumentsList, newTarget) {
    // 1. If newTarget is not present, set newTarget to F.
    if (newTarget.isUndefined) {
        newTarget = F;
    }
    // 2. If argumentsList is not present, set argumentsList to a new empty List.
    if (!argumentsList.isList) {
        argumentsList = new $List();
    }
    // 3. Assert: IsConstructor(F) is true.
    // 4. Assert: IsConstructor(newTarget) is true.
    // 5. Return ? F.[[Construct]](argumentsList, newTarget).
    return F['[[Construct]]'](ctx, argumentsList, newTarget);
}
// http://www.ecma-international.org/ecma-262/#sec-definepropertyorthrow
function $DefinePropertyOrThrow(ctx, O, P, desc) {
    // 1. Assert: Type(O) is Object.
    // 2. Assert: IsPropertyKey(P) is true.
    // 3. Let success be ? O.[[DefineOwnProperty]](P, desc).
    const success = O['[[DefineOwnProperty]]'](ctx, P, desc);
    if (success.isAbrupt) {
        return success;
    }
    // 4. If success is false, throw a TypeError exception.
    if (success.isFalsey) {
        return new $TypeError(ctx.Realm, `Failed to define property ${P} on ${O}`);
    }
    // 5. Return success.
    return success;
}
// http://www.ecma-international.org/ecma-262/#sec-validateandapplypropertydescriptor
function $ValidateAndApplyPropertyDescriptor(ctx, O, P, extensible, Desc, current) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.
    // 2. If current is undefined, then
    if (current.isUndefined) {
        // 2. a. If extensible is false, return false.
        if (extensible.isFalsey) {
            return intrinsics.false;
        }
        // 2. b. Assert: extensible is true.
        // 2. c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then
        if (Desc.isGenericDescriptor || Desc.isDataDescriptor) {
            // 2. c. i. If O is not undefined, create an own data property named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.
            if (!O.isUndefined) {
                const newDesc = new $PropertyDescriptor(realm, P);
                if (Desc['[[Value]]'].isEmpty) {
                    newDesc['[[Value]]'] = intrinsics.undefined;
                }
                else {
                    newDesc['[[Value]]'] = Desc['[[Value]]'];
                }
                if (Desc['[[Writable]]'].isEmpty) {
                    newDesc['[[Writable]]'] = intrinsics.false;
                }
                else {
                    newDesc['[[Writable]]'] = Desc['[[Writable]]'];
                }
                if (Desc['[[Enumerable]]'].isEmpty) {
                    newDesc['[[Enumerable]]'] = intrinsics.false;
                }
                else {
                    newDesc['[[Enumerable]]'] = Desc['[[Enumerable]]'];
                }
                if (Desc['[[Configurable]]'].isEmpty) {
                    newDesc['[[Configurable]]'] = intrinsics.false;
                }
                else {
                    newDesc['[[Configurable]]'] = Desc['[[Configurable]]'];
                }
                O['setProperty'](newDesc);
            }
        }
        // 2. d. Else Desc must be an accessor Property Descriptor,
        else {
            // 2. d. i. If O is not undefined, create an own accessor property named P of object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.
            if (!O.isUndefined) {
                const newDesc = new $PropertyDescriptor(realm, P);
                if (Desc['[[Get]]'].isEmpty) {
                    newDesc['[[Get]]'] = intrinsics.undefined;
                }
                else {
                    newDesc['[[Get]]'] = Desc['[[Get]]'];
                }
                if (Desc['[[Set]]'].isEmpty) {
                    newDesc['[[Set]]'] = intrinsics.undefined;
                }
                else {
                    newDesc['[[Set]]'] = Desc['[[Set]]'];
                }
                if (Desc['[[Enumerable]]'].isEmpty) {
                    newDesc['[[Enumerable]]'] = intrinsics.false;
                }
                else {
                    newDesc['[[Enumerable]]'] = Desc['[[Enumerable]]'];
                }
                if (Desc['[[Configurable]]'].isEmpty) {
                    newDesc['[[Configurable]]'] = intrinsics.false;
                }
                else {
                    newDesc['[[Configurable]]'] = Desc['[[Configurable]]'];
                }
                O['setProperty'](newDesc);
            }
        }
        // 2. e. Return true.
        return intrinsics.true;
    }
    // 3. If every field in Desc is absent, return true.
    if (Desc['[[Configurable]]'].isEmpty &&
        Desc['[[Enumerable]]'].isEmpty &&
        Desc['[[Writable]]'].isEmpty &&
        Desc['[[Value]]'].isEmpty &&
        Desc['[[Get]]'].isEmpty &&
        Desc['[[Set]]'].isEmpty) {
        return intrinsics.true;
    }
    // 4. If current.[[Configurable]] is false, then
    if (current['[[Configurable]]'].isFalsey) {
        // 4. a. If Desc.[[Configurable]] is present and its value is true, return false.
        if (Desc['[[Configurable]]'].isTruthy) {
            return intrinsics.false;
        }
        // 4. b. If Desc.[[Enumerable]] is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other, return false.
        if (!Desc['[[Enumerable]]'].isEmpty && current['[[Enumerable]]'].isTruthy === Desc['[[Enumerable]]'].isFalsey) {
            return intrinsics.false;
        }
    }
    // 5. If IsGenericDescriptor(Desc) is true, no further validation is required.
    // eslint-disable-next-line no-empty
    if (Desc.isGenericDescriptor) ;
    // 6. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then
    else if (current.isDataDescriptor !== Desc.isDataDescriptor) {
        // 6. a. If current.[[Configurable]] is false, return false.
        if (current['[[Configurable]]'].isFalsey) {
            return intrinsics.false;
        }
        // 6. b. If IsDataDescriptor(current) is true, then
        if (current.isDataDescriptor) {
            // 6. b. i. If O is not undefined, convert the property named P of object O from a data property to an accessor property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.
            if (!O.isUndefined) {
                const existingDesc = O['getProperty'](P);
                const newDesc = new $PropertyDescriptor(realm, P);
                newDesc['[[Configurable]]'] = existingDesc['[[Configurable]]'];
                newDesc['[[Enumerable]]'] = existingDesc['[[Enumerable]]'];
                newDesc['[[Get]]'] = intrinsics.undefined;
                newDesc['[[Set]]'] = intrinsics.undefined;
                O['setProperty'](newDesc);
            }
        }
        // 6. c. Else,
        else {
            // 6. c. i. If O is not undefined, convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.
            if (!O.isUndefined) {
                const existingDesc = O['getProperty'](P);
                const newDesc = new $PropertyDescriptor(realm, P);
                newDesc['[[Configurable]]'] = existingDesc['[[Configurable]]'];
                newDesc['[[Enumerable]]'] = existingDesc['[[Enumerable]]'];
                newDesc['[[Writable]]'] = intrinsics.false;
                newDesc['[[Value]]'] = intrinsics.undefined;
                O['setProperty'](newDesc);
            }
        }
    }
    // 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then
    else if (current.isDataDescriptor && Desc.isDataDescriptor) {
        // 7. a. If current.[[Configurable]] is false and current.[[Writable]] is false, then
        if (current['[[Configurable]]'].isFalsey && current['[[Writable]]'].isFalsey) {
            // 7. a. i. If Desc.[[Writable]] is present and Desc.[[Writable]] is true, return false.
            if (Desc['[[Writable]]'].isTruthy) {
                return intrinsics.false;
            }
            // 7. a. ii. If Desc.[[Value]] is present and SameValue(Desc.[[Value]], current.[[Value]]) is false, return false.
            if (!Desc['[[Value]]'].isEmpty && !Desc['[[Value]]'].is(current['[[Value]]'])) {
                return intrinsics.false;
            }
            // 7. a. iii. Return true.
            return intrinsics.true;
        }
    }
    // 8. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,
    else {
        // 8. a. If current.[[Configurable]] is false, then
        if (current['[[Configurable]]'].isFalsey) {
            // 8. a. i. If Desc.[[Set]] is present and SameValue(Desc.[[Set]], current.[[Set]]) is false, return false.
            if (!Desc['[[Set]]'].isEmpty && !Desc['[[Set]]'].is(current['[[Set]]'])) {
                return intrinsics.false;
            }
            // 8. a. ii. If Desc.[[Get]] is present and SameValue(Desc.[[Get]], current.[[Get]]) is false, return false.
            if (!Desc['[[Get]]'].isEmpty && !Desc['[[Get]]'].is(current['[[Get]]'])) {
                return intrinsics.false;
            }
            // 8. a. iii. Return true.
            return intrinsics.true;
        }
    }
    // 9. If O is not undefined, then
    if (!O.isUndefined) {
        const existingDesc = O['getProperty'](P);
        // 9. a. For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.
        if (!Desc['[[Configurable]]'].isEmpty) {
            existingDesc['[[Configurable]]'] = Desc['[[Configurable]]'];
        }
        if (!Desc['[[Enumerable]]'].isEmpty) {
            existingDesc['[[Enumerable]]'] = Desc['[[Enumerable]]'];
        }
        if (!Desc['[[Writable]]'].isEmpty) {
            existingDesc['[[Writable]]'] = Desc['[[Writable]]'];
        }
        if (!Desc['[[Value]]'].isEmpty) {
            existingDesc['[[Value]]'] = Desc['[[Value]]'];
        }
        if (!Desc['[[Get]]'].isEmpty) {
            existingDesc['[[Get]]'] = Desc['[[Get]]'];
        }
        if (!Desc['[[Set]]'].isEmpty) {
            existingDesc['[[Set]]'] = Desc['[[Set]]'];
        }
    }
    // 10. Return true.
    return intrinsics.true;
}
// http://www.ecma-international.org/ecma-262/#sec-set-immutable-prototype
function $SetImmutablePrototype(ctx, O, V) {
    const intrinsics = O.realm['[[Intrinsics]]'];
    // 1. Assert: Either Type(V) is Object or Type(V) is Null.
    // 2. Let current be ? O.[[GetPrototypeOf]]().
    const current = O['[[GetPrototypeOf]]'](ctx);
    if (current.isAbrupt) {
        return current;
    }
    // 3. If SameValue(V, current) is true, return true.
    if (V.is(current)) {
        return intrinsics.true;
    }
    // 4. Return false.
    return intrinsics.false;
}
// http://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison
function $AbstractRelationalComparison(ctx, leftFirst, x, y) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    let px;
    let py;
    // 1. If the LeftFirst flag is true, then
    if (leftFirst) {
        // 1. a. Let px be ? ToPrimitive(x, hint Number).
        px = x.ToPrimitive(ctx, 'number');
        if (px.isAbrupt) {
            return px;
        }
        // 1. b. Let py be ? ToPrimitive(y, hint Number).
        py = y.ToPrimitive(ctx, 'number');
        if (py.isAbrupt) {
            return py;
        }
    }
    // 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation,
    else {
        // 2. a. Let py be ? ToPrimitive(y, hint Number).
        py = y.ToPrimitive(ctx, 'number');
        if (py.isAbrupt) {
            return py;
        }
        // 2. b. Let px be ? ToPrimitive(x, hint Number).
        px = x.ToPrimitive(ctx, 'number');
        if (px.isAbrupt) {
            return px;
        }
    }
    // 3. If Type(px) is String and Type(py) is String, then
    if (px.isString && py.isString) {
        // 3. a. If IsStringPrefix(py, px) is true, return false.
        // 3. b. If IsStringPrefix(px, py) is true, return true.
        // 3. c. Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)
        // 3. d. Let m be the integer that is the numeric value of the code unit at index k within px.
        // 3. e. Let n be the integer that is the numeric value of the code unit at index k within py.
        // 3. f. If m < n, return true. Otherwise, return false.
        if (px['[[Value]]'] < py['[[Value]]']) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 4. Else,
    // 4. a. NOTE: Because px and py are primitive values evaluation order is not important.
    // 4. b. Let nx be ? ToNumber(px).
    const nx = px.ToNumber(ctx);
    if (nx.isAbrupt) {
        return nx;
    }
    // 4. c. Let ny be ? ToNumber(py).
    const ny = py.ToNumber(ctx);
    if (ny.isAbrupt) {
        return ny;
    }
    // 4. d. If nx is NaN, return undefined.
    if (nx.isNaN) {
        return intrinsics.undefined;
    }
    // 4. e. If ny is NaN, return undefined.
    if (ny.isNaN) {
        return intrinsics.undefined;
    }
    // 4. f. If nx and ny are the same Number value, return false.
    if (nx.equals(ny)) {
        return intrinsics.false;
    }
    // 4. g. If nx is +0 and ny is -0, return false.
    if (nx.isPositiveZero && ny.isNegativeZero) {
        return intrinsics.false;
    }
    // 4. h. If nx is -0 and ny is +0, return false.
    if (nx.isNegativeZero && ny.isPositiveZero) {
        return intrinsics.false;
    }
    // 4. i. If nx is +∞, return false.
    if (nx.isPositiveInfinity) {
        return intrinsics.false;
    }
    // 4. j. If ny is +∞, return true.
    if (ny.isPositiveInfinity) {
        return intrinsics.true;
    }
    // 4. k. If ny is -∞, return false.
    if (ny.isNegativeInfinity) {
        return intrinsics.false;
    }
    // 4. l. If nx is -∞, return true.
    if (nx.isNegativeInfinity) {
        return intrinsics.true;
    }
    // 4. m. If the mathematical value of nx is less than the mathematical value of ny—note that these mathematical values are both finite and not both zero—return true. Otherwise, return false.
    if (px['[[Value]]'] < py['[[Value]]']) {
        return intrinsics.true;
    }
    return intrinsics.false;
}
// http://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison
function $AbstractEqualityComparison(ctx, x, y) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If Type(x) is the same as Type(y), then
    if (x.constructor === y.constructor) {
        // 1. a. Return the result of performing Strict Equality Comparison x === y.
        return $StrictEqualityComparison(ctx, x, y);
    }
    // 2. If x is null and y is undefined, return true.
    // 3. If x is undefined and y is null, return true.
    if (x.isNil && y.isNil) {
        return intrinsics.true;
    }
    // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).
    if (x.isNumber && y.isString) {
        if (x.is(y.ToNumber(ctx))) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.
    if (x.isString && y.isNumber) {
        if (x.ToNumber(ctx).is(y)) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 6. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.
    if (x.isBoolean) {
        if (x.ToNumber(ctx).is(y)) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 7. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).
    if (y.isBoolean) {
        if (x.is(y.ToNumber(ctx))) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 8. If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).
    if ((x.isString || x.isNumber || x.isSymbol) && y.isObject) {
        const yPrim = y.ToPrimitive(ctx);
        if (yPrim.isAbrupt) {
            return yPrim;
        }
        if (x.is(yPrim)) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 9. If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.
    if (x.isObject && (y.isString || y.isNumber || y.isSymbol)) {
        if (x.ToPrimitive(ctx).is(y)) {
            return intrinsics.true;
        }
        return intrinsics.false;
    }
    // 10. Return false.
    return intrinsics.false;
}
// http://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison
function $StrictEqualityComparison(ctx, x, y) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If Type(x) is different from Type(y), return false.
    // 2. If Type(x) is Number, then
    // 2. a. If x is NaN, return false.
    // 2. b. If y is NaN, return false.
    // 2. c. If x is the same Number value as y, return true.
    // 2. d. If x is +0 and y is -0, return true.
    // 2. e. If x is -0 and y is +0, return true.
    // 2. f. Return false.
    // 3. Return SameValueNonNumber(x, y).
    if (x.is(y)) {
        return intrinsics.true;
    }
    return intrinsics.false;
}
// http://www.ecma-international.org/ecma-262/#sec-instanceofoperator
function $InstanceOfOperator(ctx, V, target) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If Type(target) is not Object, throw a TypeError exception.
    if (!target.isObject) {
        return new $TypeError(realm, `Right-hand side of 'instanceof' operator is ${target}, but expected an object`);
    }
    // 2. Let instOfHandler be ? GetMethod(target, @@hasInstance).
    const instOfhandler = target.GetMethod(ctx, intrinsics['@@hasInstance']);
    if (instOfhandler.isAbrupt) {
        return instOfhandler;
    }
    // 3. If instOfHandler is not undefined, then
    if (!instOfhandler.isUndefined) {
        // 3. a. Return ToBoolean(? Call(instOfHandler, target, « V »)).
        return $Call(ctx, instOfhandler, target, new $List(V)).ToBoolean(ctx);
    }
    // 4. If IsCallable(target) is false, throw a TypeError exception.
    if (!target.isFunction) {
        return new $TypeError(realm, `Right-hand side of 'instanceof' operator is ${target}, but expected a callable function`);
    }
    // 5. Return ? OrdinaryHasInstance(target, V).
    return $OrdinaryHasInstance(ctx, target, V);
}
// http://www.ecma-international.org/ecma-262/#sec-ordinaryhasinstance
function $OrdinaryHasInstance(ctx, C, O) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If IsCallable(C) is false, return false.
    if (!C.isFunction) {
        return intrinsics.false;
    }
    // 2. If C has a [[BoundTargetFunction]] internal slot, then
    if (C.isBoundFunction) {
        // 2. a. Let BC be C.[[BoundTargetFunction]].
        const BC = C['[[BoundTargetFunction]]'];
        // 2. b. Return ? InstanceofOperator(O, BC).
        return $InstanceOfOperator(ctx, O, BC);
    }
    // 3. If Type(O) is not Object, return false.
    if (!O.isObject) {
        return intrinsics.false;
    }
    // 4. Let P be ? Get(C, "prototype").
    const P = C['[[Get]]'](ctx, intrinsics.$prototype, C);
    if (P.isAbrupt) {
        return P;
    }
    // 5. If Type(P) is not Object, throw a TypeError exception.
    if (!P.isObject) {
        return new $TypeError(realm, `Prototype of right-hand side of 'instanceof' operator ${O} is ${P}, but expected an object`);
    }
    // 6. Repeat,
    while (true) {
        // 6. a. Set O to ? O.[[GetPrototypeOf]]().
        const $O = O['[[GetPrototypeOf]]'](ctx);
        if ($O.isAbrupt) {
            return $O;
        }
        O = $O;
        // 6. b. If O is null, return false.
        if (O.isNull) {
            return intrinsics.false;
        }
        // 6. c. If SameValue(P, O) is true, return true.
        if (P.is(O)) {
            return intrinsics.true;
        }
    }
}
// http://www.ecma-international.org/ecma-262/#sec-topropertydescriptor
function $ToPropertyDescriptor(ctx, Obj, key) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If Type(Obj) is not Object, throw a TypeError exception.
    if (!Obj.isObject) {
        return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: expected an object`);
    }
    // 2. Let desc be a new Property Descriptor that initially has no fields.
    const desc = new $PropertyDescriptor(Obj.realm, key);
    // 3. Let hasEnumerable be ? HasProperty(Obj, "enumerable").
    const hasEnumerable = Obj['[[HasProperty]]'](ctx, intrinsics.$enumerable);
    if (hasEnumerable.isAbrupt) {
        return hasEnumerable;
    }
    // 4. If hasEnumerable is true, then
    if (hasEnumerable.isTruthy) {
        // 4. a. Let enumerable be ToBoolean(? Get(Obj, "enumerable")).
        const enumerable = Obj['[[Get]]'](ctx, intrinsics.$enumerable, Obj).ToBoolean(ctx);
        if (enumerable.isAbrupt) {
            return enumerable;
        }
        // 4. b. Set desc.[[Enumerable]] to enumerable.
        desc['[[Enumerable]]'] = enumerable;
    }
    // 5. Let hasConfigurable be ? HasProperty(Obj, "configurable").
    const hasConfigurable = Obj['[[HasProperty]]'](ctx, intrinsics.$configurable);
    if (hasConfigurable.isAbrupt) {
        return hasConfigurable;
    }
    // 6. If hasConfigurable is true, then
    if (hasConfigurable.isTruthy) {
        // 6. a. Let configurable be ToBoolean(? Get(Obj, "configurable")).
        const configurable = Obj['[[Get]]'](ctx, intrinsics.$configurable, Obj).ToBoolean(ctx);
        if (configurable.isAbrupt) {
            return configurable;
        }
        // 6. b. Set desc.[[Configurable]] to configurable.
        desc['[[Enumerable]]'] = configurable;
    }
    // 7. Let hasValue be ? HasProperty(Obj, "value").
    const hasValue = Obj['[[HasProperty]]'](ctx, intrinsics.$value);
    if (hasValue.isAbrupt) {
        return hasValue;
    }
    // 8. If hasValue is true, then
    if (hasValue.isTruthy) {
        // 8. a. Let value be ? Get(Obj, "value").
        const value = Obj['[[Get]]'](ctx, intrinsics.$value, Obj).ToBoolean(ctx);
        if (value.isAbrupt) {
            return value;
        }
        // 8. b. Set desc.[[Value]] to value.
        desc['[[Enumerable]]'] = value;
    }
    // 9. Let hasWritable be ? HasProperty(Obj, "writable").
    const hasWritable = Obj['[[HasProperty]]'](ctx, intrinsics.$writable);
    if (hasWritable.isAbrupt) {
        return hasWritable;
    }
    // 10. If hasWritable is true, then
    if (hasWritable.isTruthy) {
        // 10. a. Let writable be ToBoolean(? Get(Obj, "writable")).
        const writable = Obj['[[Get]]'](ctx, intrinsics.$writable, Obj).ToBoolean(ctx);
        if (writable.isAbrupt) {
            return writable;
        }
        // 10. b. Set desc.[[Writable]] to writable.
        desc['[[Enumerable]]'] = writable;
    }
    // 11. Let hasGet be ? HasProperty(Obj, "get").
    const hasGet = Obj['[[HasProperty]]'](ctx, intrinsics.$get);
    if (hasGet.isAbrupt) {
        return hasGet;
    }
    // 12. If hasGet is true, then
    if (hasGet.isTruthy) {
        // 12. a. Let getter be ? Get(Obj, "get").
        const getter = Obj['[[Get]]'](ctx, intrinsics.$get, Obj);
        if (getter.isAbrupt) {
            return getter;
        }
        // 12. b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.
        if (!getter.isFunction && !getter.isUndefined) {
            return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: the getter is neither a callable function nor undefined`);
        }
        // 12. c. Set desc.[[Get]] to getter.
        desc['[[Get]]'] = getter;
    }
    // 13. Let hasSet be ? HasProperty(Obj, "set").
    const hasSet = Obj['[[HasProperty]]'](ctx, intrinsics.$set);
    if (hasSet.isAbrupt) {
        return hasSet;
    }
    // 14. If hasSet is true, then
    if (hasSet.isTruthy) {
        // 14. a. Let setter be ? Get(Obj, "set").
        const setter = Obj['[[Get]]'](ctx, intrinsics.$set, Obj);
        if (setter.isAbrupt) {
            return setter;
        }
        // 14. b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.
        if (!setter.isFunction && !setter.isUndefined) {
            return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: the setter is neither a callable function nor undefined`);
        }
        // 14. c. Set desc.[[Set]] to setter.
        desc['[[Set]]'] = setter;
    }
    // 15. If desc.[[Get]] is present or desc.[[Set]] is present, then
    if (desc['[[Get]]'].hasValue || desc['[[Set]]'].hasValue) {
        // 15. a. If desc.[[Value]] is present or desc.[[Writable]] is present, throw a TypeError exception.
        if (desc['[[Value]]'].hasValue || desc['[[Writable]]'].hasValue) {
            return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: there is a getter and/or setter, as well as a writable and/or value property`);
        }
    }
    // 16. Return desc.
    return desc;
}
function $FromPropertyDescriptor(ctx, Desc) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If Desc is undefined, return undefined.
    if (Desc.isUndefined) {
        return intrinsics.undefined;
    }
    // 2. Let obj be ObjectCreate(%ObjectPrototype%).
    const obj = $Object.ObjectCreate(ctx, 'PropertyDescriptor', intrinsics['%ObjectPrototype%']);
    // 3. Assert: obj is an extensible ordinary object with no own properties.
    // 4. If Desc has a [[Value]] field, then
    if (Desc['[[Value]]'].hasValue) {
        // 4. a. Perform CreateDataProperty(obj, "value", Desc.[[Value]]).
        $CreateDataProperty(ctx, obj, intrinsics.$value, Desc['[[Value]]']);
    }
    // 5. If Desc has a [[Writable]] field, then
    if (Desc['[[Writable]]'].hasValue) {
        // 5. a. Perform CreateDataProperty(obj, "writable", Desc.[[Writable]]).
        $CreateDataProperty(ctx, obj, intrinsics.$writable, Desc['[[Writable]]']);
    }
    // 6. If Desc has a [[Get]] field, then
    if (Desc['[[Get]]'].hasValue) {
        // 6. a. Perform CreateDataProperty(obj, "get", Desc.[[Get]]).
        $CreateDataProperty(ctx, obj, intrinsics.$get, Desc['[[Get]]']);
    }
    // 7. If Desc has a [[Set]] field, then
    if (Desc['[[Set]]'].hasValue) {
        // 7. a. Perform CreateDataProperty(obj, "set", Desc.[[Set]]).
        $CreateDataProperty(ctx, obj, intrinsics.$set, Desc['[[Set]]']);
    }
    // 8. If Desc has an [[Enumerable]] field, then
    if (Desc['[[Enumerable]]'].hasValue) {
        // 8. a. Perform CreateDataProperty(obj, "enumerable", Desc.[[Enumerable]]).
        $CreateDataProperty(ctx, obj, intrinsics.$enumerable, Desc['[[Enumerable]]']);
    }
    // 9. If Desc has a [[Configurable]] field, then
    if (Desc['[[Configurable]]'].hasValue) {
        // 9. a. Perform CreateDataProperty(obj, "configurable", Desc.[[Configurable]]).
        $CreateDataProperty(ctx, obj, intrinsics.$configurable, Desc['[[Configurable]]']);
    }
    // 10. Assert: All of the above CreateDataProperty operations return true.
    // 11. Return obj.
    return obj;
}
const defaultElementTypes = [
    'Undefined',
    'Null',
    'Boolean',
    'String',
    'Symbol',
    'Number',
    'Object',
];
// http://www.ecma-international.org/ecma-262/#sec-createlistfromarraylike
function $CreateListFromArrayLike(ctx, obj, elementTypes = defaultElementTypes) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If elementTypes is not present, set elementTypes to « Undefined, Null, Boolean, String, Symbol, Number, Object ».
    // 2. If Type(obj) is not Object, throw a TypeError exception.
    if (!obj.isObject) {
        return new $TypeError(realm, `Cannot convert ${obj} to list: expected an object`);
    }
    // 3. Let len be ? ToLength(? Get(obj, "length")).
    const len = obj['[[Get]]'](ctx, intrinsics.length, obj).ToLength(ctx);
    if (len.isAbrupt) {
        return len;
    }
    // 4. Let list be a new empty List.
    const list = new $List();
    // 5. Let index be 0.
    let index = 0;
    // 6. Repeat, while index < len
    while (index < len['[[Value]]']) {
        // 6. a. Let indexName be ! ToString(index).
        const indexName = new $String(realm, index.toString());
        // 6. b. Let next be ? Get(obj, indexName).
        const next = obj['[[Get]]'](ctx, indexName, obj);
        if (next.isAbrupt) {
            return next;
        }
        // 6. c. If Type(next) is not an element of elementTypes, throw a TypeError exception.
        if (!elementTypes.includes(next.Type)) {
            return new $TypeError(realm, `Cannot convert ${obj} to list: one of the elements (${next}) is of type ${next.Type}, but expected one of: ${elementTypes}`);
        }
        // 6. d. Append next as the last element of list.
        list[index++] = next;
        // 6. e. Increase index by 1.
    }
    // 7. Return list.
    return list;
}
// http://www.ecma-international.org/ecma-262/#sec-copydataproperties
// 7.3.23 CopyDataProperties ( target , source , excludedItems )
function $CopyDataProperties(ctx, target, source, excludedItems) {
    // 1. Assert: Type(target) is Object.
    // 2. Assert: excludedItems is a List of property keys.
    // 3. If source is undefined or null, return target.
    if (source.isNil) {
        return target;
    }
    // 4. Let from be ! ToObject(source).
    const from = source.ToObject(ctx);
    // 5. Let keys be ? from.[[OwnPropertyKeys]]().
    const keys = from['[[OwnPropertyKeys]]'](ctx);
    if (keys.isAbrupt) {
        return keys;
    }
    // 6. For each element nextKey of keys in List order, do
    for (const nextKey of keys) {
        // 6. a. Let excluded be false.
        // 6. b. For each element e of excludedItems in List order, do
        // 6. b. i. If SameValue(e, nextKey) is true, then
        // 6. b. i. 1. Set excluded to true.
        // 6. c. If excluded is false, then
        if (!excludedItems.some(x => x.is(nextKey))) {
            // 6. c. i. Let desc be ? from.[[GetOwnProperty]](nextKey).
            const desc = from['[[GetOwnProperty]]'](ctx, nextKey);
            if (desc.isAbrupt) {
                return desc;
            }
            // 6. c. ii. If desc is not undefined and desc.[[Enumerable]] is true, then
            if (!desc.isUndefined && desc['[[Enumerable]]'].isTruthy) {
                // 6. c. ii. 1. Let propValue be ? Get(from, nextKey).
                const propValue = from['[[Get]]'](ctx, nextKey, from);
                if (propValue.isAbrupt) {
                    return propValue;
                }
                // 6. c. ii. 2. Perform ! CreateDataProperty(target, nextKey, propValue).
                $CreateDataProperty(ctx, target, nextKey, propValue);
            }
        }
    }
    // 7. Return target.
    return target;
}
// http://www.ecma-international.org/ecma-262/#sec-loopcontinues
// 13.7.1.2 Runtime Semantics: LoopContinues ( completion , labelSet )
function $LoopContinues(ctx, completion, labelSet) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If completion.[[Type]] is normal, return true.
    if (completion['[[Type]]'] === 1 /* normal */) {
        return intrinsics.true;
    }
    // 2. If completion.[[Type]] is not continue, return false.
    if (completion['[[Type]]'] !== 3 /* continue */) {
        return intrinsics.false;
    }
    // 3. If completion.[[Target]] is empty, return true.
    if (completion['[[Target]]'].isEmpty) {
        return intrinsics.true;
    }
    // 4. If completion.[[Target]] is an element of labelSet, return true.
    if (labelSet.has(completion['[[Target]]'])) {
        return intrinsics.true;
    }
    // 5. Return false.
    return intrinsics.false;
}
// http://www.ecma-international.org/ecma-262/#sec-hostensurecancompilestrings
// 18.2.1.2 HostEnsureCanCompileStrings ( callerRealm , calleeRealm )
function $HostEnsureCanCompileStrings(ctx, callerRealm, calleeRealm) {
    // HostEnsureCanCompileStrings is an implementation-defined abstract operation that allows host environments
    // to block certain ECMAScript functions which allow developers to compile strings into ECMAScript code.
    // An implementation of HostEnsureCanCompileStrings may complete normally or abruptly.
    // Any abrupt completions will be propagated to its callers.
    // The default implementation of HostEnsureCanCompileStrings is to unconditionally return an empty normal completion.
    return new $Empty(calleeRealm);
}
// http://www.ecma-international.org/ecma-262/#sec-invoke
// 7.3.18 Invoke ( V , P [ , argumentsList ] )
function $Invoke(ctx, V, P, argumentsList) {
    // 1. Assert: IsPropertyKey(P) is true.
    // 2. If argumentsList is not present, set argumentsList to a new empty List.
    if (!argumentsList.isList) {
        argumentsList = new $List();
    }
    // 3. Let func be ? GetV(V, P).
    const func = $GetV(ctx, V, P);
    if (func.isAbrupt) {
        return func;
    }
    // 4. Return ? Call(func, V, argumentsList).
    return $Call(ctx, func, V, argumentsList);
}
// http://www.ecma-international.org/ecma-262/#sec-speciesconstructor
// 7.3.20 SpeciesConstructor ( O , defaultConstructor )
function $SpeciesConstructor(ctx, O, defaultConstructor) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(O) is Object.
    // 2. Let C be ? Get(O, "constructor").
    const C = O['[[Get]]'](ctx, intrinsics.$constructor, O);
    if (C.isAbrupt) {
        return C;
    }
    // 3. If C is undefined, return defaultConstructor.
    if (C.isUndefined) {
        return defaultConstructor;
    }
    // 4. If Type(C) is not Object, throw a TypeError exception.
    if (!C.isObject) {
        return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);
    }
    // 5. Let S be ? Get(C, @@species).
    const S = C['[[Get]]'](ctx, intrinsics['@@species'], C);
    if (S.isAbrupt) {
        return S;
    }
    // 6. If S is either undefined or null, return defaultConstructor.
    if (S.isNil) {
        return defaultConstructor;
    }
    // 7. If IsConstructor(S) is true, return S.
    if (S.isFunction) {
        return S;
    }
    // 8. Throw a TypeError exception.
    return new $TypeError(realm, `Expected return value of @@species to be null, undefined or a function, but got: ${S}`);
}

// http://www.ecma-international.org/ecma-262/#sec-object-type
class $Object {
    constructor(realm, IntrinsicName, proto, type, target) {
        this.realm = realm;
        this.IntrinsicName = IntrinsicName;
        this.disposed = false;
        this.id = nextValueId();
        this.propertyMap = new Map();
        this.propertyDescriptors = [];
        this.propertyKeys = [];
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Prototype]]'] = proto;
        this['[[Extensible]]'] = realm['[[Intrinsics]]'].true;
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    get '[[Value]]'() {
        const obj = {};
        for (const pd of this.propertyDescriptors) {
            // Reflect.defineProperty(obj, pd.name['[[Value]]'], {
            // TODO: materialize
            // })
        }
        return obj;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'Object'; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return true; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return true; }
    get isFalsey() { return false; }
    get isSpeculative() { return false; }
    get hasValue() { return false; }
    get isList() { return false; }
    // http://www.ecma-international.org/ecma-262/#sec-objectcreate
    // 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] )
    static ObjectCreate(ctx, IntrinsicName, proto, internalSlotsList) {
        const realm = ctx.Realm;
        // 1. If internalSlotsList is not present, set internalSlotsList to a new empty List.
        // 2. Let obj be a newly created object with an internal slot for each name in internalSlotsList.
        const obj = new $Object(realm, IntrinsicName, proto, 1 /* normal */, realm['[[Intrinsics]]'].empty);
        Object.assign(obj, internalSlotsList);
        // 3. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.
        // 4. Set obj.[[Prototype]] to proto.
        // 5. Set obj.[[Extensible]] to true.
        // 6. Return obj.
        return obj;
    }
    is(other) {
        return this.id === other.id;
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        return this;
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToLength(ctx) {
        return this.ToNumber(ctx).ToLength(ctx);
    }
    ToBoolean(ctx) {
        return this.ToPrimitive(ctx, 'number').ToBoolean(ctx);
    }
    ToNumber(ctx) {
        return this.ToPrimitive(ctx, 'number').ToNumber(ctx);
    }
    ToInt32(ctx) {
        return this.ToPrimitive(ctx, 'number').ToInt32(ctx);
    }
    ToUint32(ctx) {
        return this.ToPrimitive(ctx, 'number').ToUint32(ctx);
    }
    ToInt16(ctx) {
        return this.ToPrimitive(ctx, 'number').ToInt16(ctx);
    }
    ToUint16(ctx) {
        return this.ToPrimitive(ctx, 'number').ToUint16(ctx);
    }
    ToInt8(ctx) {
        return this.ToPrimitive(ctx, 'number').ToInt8(ctx);
    }
    ToUint8(ctx) {
        return this.ToPrimitive(ctx, 'number').ToUint8(ctx);
    }
    ToUint8Clamp(ctx) {
        return this.ToPrimitive(ctx, 'number').ToUint8Clamp(ctx);
    }
    ToString(ctx) {
        return this.ToPrimitive(ctx, 'string').ToString(ctx);
    }
    // http://www.ecma-international.org/ecma-262/#sec-toprimitive
    // 7.1.1 ToPrimitive ( input [ , PreferredType ] )
    ToPrimitive(ctx, PreferredType = 'default') {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const input = this;
        // 1. Assert: input is an ECMAScript language value.
        // 2. If Type(input) is Object, then
        // 2. a. If PreferredType is not present, let hint be "default".
        // 2. b. Else if PreferredType is hint String, let hint be "string".
        // 2. c. Else PreferredType is hint Number, let hint be "number".
        let hint = intrinsics[PreferredType];
        // 2. d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).
        const exoticToPrim = input.GetMethod(ctx, intrinsics['@@toPrimitive']);
        if (exoticToPrim.isAbrupt) {
            return exoticToPrim;
        }
        // 2. e. If exoticToPrim is not undefined, then
        if (!exoticToPrim.isUndefined) {
            // 2. e. i. Let result be ? Call(exoticToPrim, input, « hint »).
            const result = $Call(ctx, exoticToPrim, input, new $List(hint));
            if (result.isAbrupt) {
                return result;
            }
            // 2. e. ii. If Type(result) is not Object, return result.
            if (result.isPrimitive) {
                return result;
            }
            // 2. e. iii. Throw a TypeError exception.
            return new $TypeError(realm, `Symbol.toPrimitive returned ${result}, but expected a primitive`);
        }
        // 2. f. If hint is "default", set hint to "number".
        if (hint['[[Value]]'] === 'default') {
            hint = intrinsics.number;
        }
        // 2. g. Return ? OrdinaryToPrimitive(input, hint).
        return input.OrdinaryToPrimitive(ctx, hint['[[Value]]']);
        // 3. Return input.
        // N/A since this is always an object
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinarytoprimitive
    // 7.1.1.1 OrdinaryToPrimitive ( O , hint )
    OrdinaryToPrimitive(ctx, hint) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const O = this;
        // 1. Assert: Type(O) is Object.
        // 2. Assert: Type(hint) is String and its value is either "string" or "number".
        // 3. If hint is "string", then
        if (hint === 'string') {
            // 3. a. Let methodNames be « "toString", "valueOf" ».
            // 5. For each name in methodNames in List order, do
            // 5. a. Let method be ? Get(O, name).
            let method = O['[[Get]]'](ctx, intrinsics.$toString, O);
            if (method.isAbrupt) {
                return method;
            }
            // 5. b. If IsCallable(method) is true, then
            if (method.isFunction) {
                // 5. b. i. Let result be ? Call(method, O).
                const result = $Call(ctx, method, O, intrinsics.undefined);
                if (result.isAbrupt) {
                    return result;
                }
                // 5. b. ii. If Type(result) is not Object, return result.
                if (result.isPrimitive) {
                    return result;
                }
            }
            method = O['[[Get]]'](ctx, intrinsics.$valueOf, O);
            if (method.isAbrupt) {
                return method;
            }
            // 5. b. If IsCallable(method) is true, then
            if (method.isFunction) {
                // 5. b. i. Let result be ? Call(method, O).
                const result = $Call(ctx, method, O, intrinsics.undefined);
                if (result.isAbrupt) {
                    return result;
                }
                // 5. b. ii. If Type(result) is not Object, return result.
                if (result.isPrimitive) {
                    return result;
                }
                // 6. Throw a TypeError exception.
                return new $TypeError(realm, `valueOf returned ${result}, but expected a primitive`);
            }
            // 6. Throw a TypeError exception.
            return new $TypeError(realm, `${this} has neither a toString nor a valueOf method that returns a primitive`);
        }
        // 4. Else,
        else {
            // 4. a. Let methodNames be « "valueOf", "toString" ».
            // 5. For each name in methodNames in List order, do
            // 5. a. Let method be ? Get(O, name).
            let method = O['[[Get]]'](ctx, intrinsics.$valueOf, O);
            if (method.isAbrupt) {
                return method;
            }
            // 5. b. If IsCallable(method) is true, then
            if (method.isFunction) {
                // 5. b. i. Let result be ? Call(method, O).
                const result = $Call(ctx, method, O, intrinsics.undefined);
                if (result.isAbrupt) {
                    return result;
                }
                // 5. b. ii. If Type(result) is not Object, return result.
                if (result.isPrimitive) {
                    return result;
                }
            }
            method = O['[[Get]]'](ctx, intrinsics.$toString, O);
            if (method.isAbrupt) {
                return method;
            }
            // 5. b. If IsCallable(method) is true, then
            if (method.isFunction) {
                // 5. b. i. Let result be ? Call(method, O).
                const result = $Call(ctx, method, O, intrinsics.undefined);
                if (result.isAbrupt) {
                    return result;
                }
                // 5. b. ii. If Type(result) is not Object, return result.
                if (result.isPrimitive) {
                    return result;
                }
                // 6. Throw a TypeError exception.
                return new $TypeError(realm, `toString returned ${result}, but expected a primitive`);
            }
            // 6. Throw a TypeError exception.
            return new $TypeError(realm, `${this} has neither a valueOf nor a toString method that returns a primitive`);
        }
    }
    GetValue(ctx) {
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getmethod
    // 7.3.9 GetMethod ( V , P )
    GetMethod(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const V = this;
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let func be ? GetV(V, P).
        const func = V['[[Get]]'](ctx, P, V);
        if (func.isAbrupt) {
            return func;
        }
        // 3. If func is either undefined or null, return undefined.
        if (func.isNil) {
            return intrinsics.undefined;
        }
        // 4. If IsCallable(func) is false, throw a TypeError exception.
        if (!func.isFunction) {
            return new $TypeError(realm, `Return value from GetMethod is ${func}, but expected a callable function`);
        }
        // 5. Return func.
        return func;
    }
    hasProperty(key) {
        return this.propertyMap.has(key['[[Value]]']);
    }
    getProperty(key) {
        return this.propertyDescriptors[this.propertyMap.get(key['[[Value]]'])];
    }
    setProperty(desc) {
        if (this.propertyMap.has(desc.name['[[Value]]'])) {
            const idx = this.propertyMap.get(desc.name['[[Value]]']);
            this.propertyDescriptors[idx] = desc;
            this.propertyKeys[idx] = desc.name;
        }
        else {
            const idx = this.propertyDescriptors.length;
            this.propertyDescriptors[idx] = desc;
            this.propertyKeys[idx] = desc.name;
            this.propertyMap.set(desc.name['[[Value]]'], idx);
        }
    }
    deleteProperty(key) {
        const idx = this.propertyMap.get(key['[[Value]]']);
        this.propertyMap.delete(key['[[Value]]']);
        this.propertyDescriptors.splice(idx, 1);
        this.propertyKeys.splice(idx, 1);
    }
    setDataProperty(name, value, writable = true, enumerable = false, configurable = true) {
        const realm = this.realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const desc = new $PropertyDescriptor(realm, name);
        desc['[[Value]]'] = value;
        desc['[[Writable]]'] = writable ? intrinsics.true : intrinsics.false;
        desc['[[Enumerable]]'] = enumerable ? intrinsics.true : intrinsics.false;
        desc['[[Configurable]]'] = configurable ? intrinsics.true : intrinsics.false;
        const idx = this.propertyDescriptors.length;
        this.propertyDescriptors[idx] = desc;
        this.propertyKeys[idx] = name;
        this.propertyMap.set(name['[[Value]]'], idx);
    }
    setAccessorProperty(name, getter, setter, enumerable = false, configurable = true) {
        const realm = this.realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const desc = new $PropertyDescriptor(realm, name);
        desc['[[Enumerable]]'] = enumerable ? intrinsics.true : intrinsics.false;
        desc['[[Configurable]]'] = configurable ? intrinsics.true : intrinsics.false;
        if (getter !== null) {
            desc['[[Get]]'] = getter;
        }
        if (setter !== null) {
            desc['[[Set]]'] = setter;
        }
        const idx = this.propertyDescriptors.length;
        this.propertyDescriptors[idx] = desc;
        this.propertyKeys[idx] = name;
        this.propertyMap.set(name['[[Value]]'], idx);
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof
    // 9.1.1 [[GetPrototypeOf]] ( )
    '[[GetPrototypeOf]]'(ctx) {
        // 1. Return ! OrdinaryGetPrototypeOf(O)
        // http://www.ecma-international.org/ecma-262/#sec-ordinarygetprototypeof
        // 9.1.1.1 OrdinaryGetPrototypeOf ( O )
        const O = this;
        // 1. Return O.[[Prototype]].
        return O['[[Prototype]]'];
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v
    // 9.1.2 [[SetPrototypeOf]] ( V )
    '[[SetPrototypeOf]]'(ctx, V) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return ! OrdinarySetPrototypeOf(O, V).
        // http://www.ecma-international.org/ecma-262/#sec-ordinarysetprototypeof
        // 9.1.2.1 OrdinarySetPrototypeOf ( O , V )
        const O = this;
        // 1. Assert: Either Type(V) is Object or Type(V) is Null.
        // 2. Let extensible be O.[[Extensible]].
        const extensible = O['[[Extensible]]']['[[Value]]'];
        // 3. Let current be O.[[Prototype]].
        const current = O['[[Prototype]]'];
        // 4. If SameValue(V, current) is true, return true.
        if (V.is(current)) {
            return intrinsics.true;
        }
        // 5. If extensible is false, return false.
        if (!extensible) {
            return intrinsics.false;
        }
        // 6. Let p be V.
        let p = V;
        // 7. Let done be false.
        let done = false;
        // 8. Repeat, while done is false,
        while (!done) {
            // 8. a. If p is null, set done to true.
            if (p.isNull) {
                done = true;
            }
            // 8. b. Else if SameValue(p, O) is true, return false.
            else if (p.is(O)) {
                return intrinsics.false;
            }
            // 8. c. Else,
            else {
                // 8. c. i. If p.[[GetPrototypeOf]] is not the ordinary object internal method defined in 9.1.1, set done to true.
                if (p['[[GetPrototypeOf]]'] !== $Object.prototype['[[GetPrototypeOf]]']) {
                    done = true;
                }
                // 8. c. ii. Else, set p to p.[[Prototype]].
                else {
                    p = p['[[Prototype]]'];
                }
            }
        }
        // 9. Set O.[[Prototype]] to V.
        O['[[Prototype]]'] = V;
        // 10. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-isextensible
    // 9.1.3 [[IsExtensible]] ( )
    '[[IsExtensible]]'(ctx) {
        // 1. Return ! OrdinaryIsExtensible(O).
        // http://www.ecma-international.org/ecma-262/#sec-ordinaryisextensible
        // 9.1.3.1 OrdinaryIsExtensible ( O )
        const O = this;
        // 1. Return O.[[Extensible]].
        return O['[[Extensible]]'];
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-preventextensions
    // 9.1.4 [[PreventExtensions]] ( )
    '[[PreventExtensions]]'(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return ! OrdinaryPreventExtensions(O).
        // http://www.ecma-international.org/ecma-262/#sec-ordinarypreventextensions
        // 9.1.4.1 OrdinaryPreventExtensions ( O )
        const O = this;
        // 1. Set O.[[Extensible]] to false.
        O['[[Extensible]]'] = intrinsics.false;
        // 2. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p
    // 9.1.5 [[GetOwnProperty]] ( P )
    '[[GetOwnProperty]]'(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Return ! OrdinaryGetOwnProperty(O, P).
        // http://www.ecma-international.org/ecma-262/#sec-ordinarygetownproperty
        // 9.1.5.1 OrdinaryGetOwnProperty ( O , P )
        const O = this;
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. If O does not have an own property with key P, return undefined.
        if (!O.hasProperty(P)) {
            return intrinsics.undefined;
        }
        // 3. Let D be a newly created Property Descriptor with no fields.
        const D = new $PropertyDescriptor(realm, P);
        // 4. Let X be O's own property whose key is P.
        const X = O.getProperty(P);
        // 5. If X is a data property, then
        if (X.isDataDescriptor) {
            // 5. a. Set D.[[Value]] to the value of X's [[Value]] attribute.
            D['[[Value]]'] = X['[[Value]]'];
            // 5. b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.
            D['[[Writable]]'] = X['[[Writable]]'];
        }
        // 6. Else X is an accessor property,
        else {
            // 6. a. Set D.[[Get]] to the value of X's [[Get]] attribute.
            D['[[Get]]'] = X['[[Get]]'];
            // 6. b. Set D.[[Set]] to the value of X's [[Set]] attribute.
            D['[[Set]]'] = X['[[Set]]'];
        }
        // 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.
        D['[[Enumerable]]'] = X['[[Enumerable]]'];
        // 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.
        D['[[Configurable]]'] = X['[[Configurable]]'];
        // 9. Return D.
        return D;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc
    // 9.1.6 [[DefineOwnProperty]] ( P , Desc )
    '[[DefineOwnProperty]]'(ctx, P, Desc) {
        // 1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).
        const O = this;
        // http://www.ecma-international.org/ecma-262/#sec-ordinarydefineownproperty
        // 9.1.6.1 OrdinaryDefineOwnProperty ( O , P , Desc )
        // 1. Let current be ? O.[[GetOwnProperty]](P).
        const current = O['[[GetOwnProperty]]'](ctx, P);
        if (current.isAbrupt) {
            return current;
        }
        // 2. Let extensible be ? IsExtensible(O).
        const extensible = O['[[IsExtensible]]'](ctx);
        if (extensible.isAbrupt) {
            return extensible;
        }
        // 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).
        return $ValidateAndApplyPropertyDescriptor(ctx, O, P, extensible, Desc, current);
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p
    // 9.1.7 [[HasProperty]] ( P )
    '[[HasProperty]]'(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Return ? OrdinaryHasProperty(O, P).
        // http://www.ecma-international.org/ecma-262/#sec-ordinaryhasproperty
        // 9.1.7.1 OrdinaryHasProperty ( O , P )
        const O = this;
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let hasOwn be ? O.[[GetOwnProperty]](P).
        const hasOwn = O['[[GetOwnProperty]]'](ctx, P);
        if (hasOwn.isAbrupt) {
            return hasOwn;
        }
        // 3. If hasOwn is not undefined, return true.
        if (!hasOwn.isUndefined) {
            return intrinsics.true;
        }
        // 4. Let parent be ? O.[[GetPrototypeOf]]().
        const parent = O['[[GetPrototypeOf]]'](ctx);
        if (parent.isAbrupt) {
            return parent;
        }
        // 5. If parent is not null, then
        if (!parent.isNull) {
            // 5. a. Return ? parent.[[HasProperty]](P).
            return parent['[[HasProperty]]'](ctx, P);
        }
        // 6. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    // 9.1.8 [[Get]] ( P , Receiver )
    '[[Get]]'(ctx, P, Receiver) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Return ? OrdinaryGet(O, P, Receiver).
        // http://www.ecma-international.org/ecma-262/#sec-ordinaryget
        // 9.1.8.1 OrdinaryGet ( O , P , Receiver )
        const O = this;
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let desc be ? O.[[GetOwnProperty]](P).
        const desc = O['[[GetOwnProperty]]'](ctx, P);
        if (desc.isAbrupt) {
            return desc;
        }
        // 3. If desc is undefined, then
        if (desc.isUndefined) {
            // 3. a. Let parent be ? O.[[GetPrototypeOf]]().
            const parent = O['[[GetPrototypeOf]]'](ctx);
            if (parent.isAbrupt) {
                return parent;
            }
            // 3. b. If parent is null, return undefined.
            if (parent.isNull) {
                return intrinsics.undefined;
            }
            // 3. c. Return ? parent.[[Get]](P, Receiver).
            return parent['[[Get]]'](ctx, P, Receiver);
        }
        // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].
        if (desc.isDataDescriptor) {
            return desc['[[Value]]'];
        }
        // 5. Assert: IsAccessorDescriptor(desc) is true.
        // 6. Let getter be desc.[[Get]].
        const getter = desc['[[Get]]'];
        // 7. If getter is undefined, return undefined.
        if (getter.isUndefined) {
            return getter;
        }
        // 8. Return ? Call(getter, Receiver).
        return $Call(ctx, getter, Receiver, intrinsics.undefined);
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver
    // 9.1.9 [[Set]] ( P , V , Receiver )
    '[[Set]]'(ctx, P, V, Receiver) {
        // 1. Return ? OrdinarySet(O, P, V, Receiver).
        // http://www.ecma-international.org/ecma-262/#sec-ordinaryset
        // 9.1.9.1 OrdinarySet ( O , P , V , Receiver )
        const O = this;
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let ownDesc be ? O.[[GetOwnProperty]](P).
        const ownDesc = O['[[GetOwnProperty]]'](ctx, P);
        if (ownDesc.isAbrupt) {
            return ownDesc;
        }
        // 3. Return OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).
        return $OrdinarySetWithOwnDescriptor(ctx, O, P, V, Receiver, ownDesc);
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-delete-p
    // 9.1.10 [[Delete]] ( P )
    '[[Delete]]'(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Return ? OrdinaryDelete(O, P).
        // http://www.ecma-international.org/ecma-262/#sec-ordinarydelete
        // 9.1.10.1 OrdinaryDelete ( O , P )
        const O = this;
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let desc be ? O.[[GetOwnProperty]](P).
        const desc = O['[[GetOwnProperty]]'](ctx, P);
        if (desc.isAbrupt) {
            return desc;
        }
        // 3. If desc is undefined, return true.
        if (desc.isUndefined) {
            return intrinsics.true;
        }
        // 4. If desc.[[Configurable]] is true, then
        if (desc['[[Configurable]]'].isTruthy) {
            // 4. a. Remove the own property with name P from O.
            O.deleteProperty(P);
            // 4. b. Return true.
            return intrinsics.true;
        }
        // 5. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys
    // 9.1.11 [[OwnPropertyKeys]] ( )
    '[[OwnPropertyKeys]]'(ctx) {
        // 1. Return ! OrdinaryOwnPropertyKeys(O).
        // http://www.ecma-international.org/ecma-262/#sec-ordinaryownpropertykeys
        // 9.1.11.1 OrdinaryOwnPropertyKeys ( O )
        // 1. Let keys be a new empty List.
        const keys = new $List();
        let arrayIndexLen = 0;
        let stringLen = 0;
        let symbolLen = 0;
        const arrayIndexProps = [];
        const stringProps = [];
        const symbolProps = [];
        const ownPropertyKeys = this.propertyKeys;
        let ownPropertyKey;
        for (let i = 0, ii = ownPropertyKeys.length; i < ii; ++i) {
            ownPropertyKey = ownPropertyKeys[i];
            if (ownPropertyKey.isString) {
                if (ownPropertyKey.IsArrayIndex) {
                    arrayIndexProps[arrayIndexLen++] = ownPropertyKey;
                }
                else {
                    stringProps[stringLen++] = ownPropertyKey;
                }
            }
            else {
                symbolProps[symbolLen++] = ownPropertyKey;
            }
        }
        arrayIndexProps.sort(compareIndices);
        let i = 0;
        let keysLen = 0;
        // 2. For each own property key P of O that is an array index, in ascending numeric index order, do
        for (i = 0; i < arrayIndexLen; ++i) {
            // 2. a. Add P as the last element of keys.
            keys[keysLen++] = arrayIndexProps[i];
        }
        // 3. For each own property key P of O that is a String but is not an array index, in ascending chronological order of property creation, do
        for (i = 0; i < stringLen; ++i) {
            // 3. a. Add P as the last element of keys.
            keys[keysLen++] = stringProps[i];
        }
        // 4. For each own property key P of O that is a Symbol, in ascending chronological order of property creation, do
        for (i = 0; i < symbolLen; ++i) {
            // 4. a. Add P as the last element of keys.
            keys[keysLen++] = symbolProps[i];
        }
        // 5. Return keys.
        return keys;
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        this.propertyDescriptors.forEach(x => { x.dispose(); });
        this.propertyDescriptors = void 0;
        this.propertyKeys = void 0;
        this.propertyMap = void 0;
        this['[[Target]]'] = void 0;
        this['[[Prototype]]'] = void 0;
        this['[[Extensible]]'] = void 0;
        this.realm = void 0;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-boolean-type
class $Boolean {
    constructor(realm, value, type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty, sourceNode = null, conversionSource = null) {
        this.realm = realm;
        this.sourceNode = sourceNode;
        this.conversionSource = conversionSource;
        this.id = nextValueId();
        this.IntrinsicName = 'boolean';
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Value]]'] = value;
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'Boolean'; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return true; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return this['[[Value]]']; }
    get isFalsey() { return !this['[[Value]]']; }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    get isList() { return false; }
    is(other) {
        return other instanceof $Boolean && this['[[Value]]'] === other['[[Value]]'];
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        return $Object.ObjectCreate(ctx, 'boolean', intrinsics['%BooleanPrototype%'], {
            '[[BooleanData]]': this,
        });
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToLength(ctx) {
        return this.ToNumber(ctx).ToLength(ctx);
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return this;
    }
    ToNumber(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Number(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8Clamp(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8Clamp(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToString(ctx) {
        return new $String(
        /* realm */ this.realm, 
        /* value */ String(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    GetValue(ctx) {
        return this;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-null-type
class $Null {
    constructor(realm, type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty, sourceNode = null) {
        this.realm = realm;
        this.sourceNode = sourceNode;
        this.id = nextValueId();
        this.IntrinsicName = 'null';
        this['[[Value]]'] = null;
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'Null'; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return true; }
    get isNil() { return true; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return false; }
    get isFalsey() { return true; }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    get isAmbiguous() { return false; }
    get isList() { return false; }
    is(other) {
        return other instanceof $Null;
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        return new $TypeError(ctx.Realm, `${this} cannot be converted to object`);
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToLength(ctx) {
        return this.ToNumber(ctx).ToLength(ctx);
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return new $Boolean(
        /* realm */ this.realm, 
        /* value */ Boolean(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToNumber(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Number(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8Clamp(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8Clamp(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToString(ctx) {
        return new $String(
        /* realm */ this.realm, 
        /* value */ String(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    GetValue(ctx) {
        return this;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-symbol-type
class $Symbol {
    constructor(realm, Description, value = Symbol(Description['[[Value]]']), type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty) {
        this.realm = realm;
        this.Description = Description;
        this.id = nextValueId();
        this.IntrinsicName = 'symbol';
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Value]]'] = value;
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'Symbol'; }
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return true; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return true; }
    get isFalsey() { return false; }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    get isList() { return false; }
    get IsArrayIndex() { return false; }
    is(other) {
        return other instanceof $Symbol && this['[[Value]]'] === other['[[Value]]'];
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        return $Object.ObjectCreate(ctx, 'symbol', intrinsics['%SymbolPrototype%'], {
            '[[SymbolData]]': this,
        });
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToLength(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return new $Boolean(
        /* realm */ this.realm, 
        /* value */ Boolean(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToNumber(ctx) {
        return new $TypeError(ctx.Realm, `${this} cannot be converted to number`);
    }
    ToInt32(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToUint32(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToInt16(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToUint16(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToInt8(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToUint8(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToUint8Clamp(ctx) {
        // Short circuit
        return this.ToNumber(ctx);
    }
    ToString(ctx) {
        return new $String(
        /* realm */ this.realm, 
        /* value */ String(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    GetValue(ctx) {
        return this;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-undefined-type
class $Undefined {
    constructor(realm, type = 1 /* normal */, target = realm['[[Intrinsics]]'].empty, sourceNode = null) {
        this.realm = realm;
        this.sourceNode = sourceNode;
        this.id = nextValueId();
        this.IntrinsicName = 'undefined';
        this['[[Value]]'] = void 0;
        this.nodeStack = [];
        this.ctx = null;
        this.stack = '';
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return (this['[[Type]]'] !== 1 /* normal */); }
    get Type() { return 'Undefined'; }
    get isEmpty() { return false; }
    get isUndefined() { return true; }
    get isNull() { return false; }
    get isNil() { return true; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return true; }
    get isObject() { return false; }
    get isArray() { return false; }
    get isProxy() { return false; }
    get isFunction() { return false; }
    get isBoundFunction() { return false; }
    get isTruthy() { return false; }
    get isFalsey() { return true; }
    get isSpeculative() { return false; }
    get hasValue() { return true; }
    get isList() { return false; }
    get IsArrayIndex() { return false; }
    is(other) {
        return other instanceof $Undefined;
    }
    enrichWith(ctx, node) {
        if (this['[[Type]]'] === 5 /* throw */) {
            this.nodeStack.push(node);
            if (this.ctx === null) {
                this.ctx = ctx;
                this.stack = ctx.Realm.stack.toString();
            }
        }
        return this;
    }
    [Symbol.toPrimitive]() {
        return String(this['[[Value]]']);
    }
    [Symbol.toStringTag]() {
        return Object.prototype.toString.call(this['[[Value]]']);
    }
    ToCompletion(type, target) {
        this['[[Type]]'] = type;
        this['[[Target]]'] = target;
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-updateempty
    // 6.2.3.4 UpdateEmpty ( completionRecord , value )
    UpdateEmpty(value) {
        // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.
        // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).
        return this;
        // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.
    }
    ToObject(ctx) {
        return new $TypeError(ctx.Realm, `${this} cannot be converted to object`);
    }
    ToPropertyKey(ctx) {
        return this.ToString(ctx);
    }
    ToLength(ctx) {
        return this.ToNumber(ctx).ToLength(ctx);
    }
    ToPrimitive(ctx) {
        return this;
    }
    ToBoolean(ctx) {
        return new $Boolean(
        /* realm */ this.realm, 
        /* value */ Boolean(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToNumber(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Number(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint32(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint32(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint16(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint16(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToInt8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Int8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToUint8Clamp(ctx) {
        return new $Number(
        /* realm */ this.realm, 
        /* value */ Uint8Clamp(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    ToString(ctx) {
        return new $String(
        /* realm */ this.realm, 
        /* value */ String(this['[[Value]]']), 
        /* type */ this['[[Type]]'], 
        /* target */ this['[[Target]]'], 
        /* sourceNode */ null, 
        /* conversionSource */ this);
    }
    GetValue(ctx) {
        return this;
    }
}

// http://www.ecma-international.org/ecma-262/#table-25
class Job {
    constructor(logger, realm, scriptOrModule) {
        this.logger = logger;
        this.logger = logger.scopeTo(`Job`);
        this['[[Realm]]'] = realm;
        this['[[ScriptOrModule]]'] = scriptOrModule;
    }
    dispose() {
        this['[[Realm]]'] = void 0;
        this['[[ScriptOrModule]]'] = void 0;
        this.logger = void 0;
    }
}
class JobQueue {
    constructor(logger, name) {
        this.logger = logger;
        this.name = name;
        this.queue = [];
        this.logger = logger.root.scopeTo(`JobQueue['${name}']`);
    }
    get isEmpty() {
        return this.queue.length === 0;
    }
    // http://www.ecma-international.org/ecma-262/#sec-enqueuejob
    // 8.4.1 EnqueueJob ( queueName , job , arguments )
    EnqueueJob(ctx, job) {
        const realm = ctx.Realm;
        this.logger.debug(`EnqueueJob(#${ctx.id}) currentQueueLength=${this.queue.length}`);
        // 1. Assert: Type(queueName) is String and its value is the name of a Job Queue recognized by this implementation.
        // 2. Assert: job is the name of a Job.
        // 3. Assert: arguments is a List that has the same number of elements as the number of parameters required by job.
        // 4. Let callerContext be the running execution context.
        // 5. Let callerRealm be callerContext's Realm.
        // 6. Let callerScriptOrModule be callerContext's ScriptOrModule.
        // 7. Let pending be PendingJob { [[Job]]: job, [[Arguments]]: arguments, [[Realm]]: callerRealm, [[ScriptOrModule]]: callerScriptOrModule, [[HostDefined]]: undefined }.
        // 8. Perform any implementation or host environment defined processing of pending. This may include modifying the [[HostDefined]] field or any other field of pending.
        // 9. Add pending at the back of the Job Queue named by queueName.
        this.queue.push(job);
        // 10. Return NormalCompletion(empty).
        return new $Empty(realm);
    }
    dispose() {
        this.queue.forEach(x => { x.dispose(); });
        this.queue = void 0;
        this.logger = void 0;
    }
}

let bindingId = 0;
class $Binding {
    constructor(isMutable, isStrict, isInitialized, canBeDeleted, value, name, origin, M = null, N2 = null) {
        this.isMutable = isMutable;
        this.isStrict = isStrict;
        this.isInitialized = isInitialized;
        this.canBeDeleted = canBeDeleted;
        this.value = value;
        this.name = name;
        this.origin = origin;
        this.M = M;
        this.N2 = N2;
        this.id = ++bindingId;
    }
    get isIndirect() {
        return this.M !== null;
    }
    dispose() {
        this.value = void 0;
        this.origin = void 0;
        this.M = void 0;
        this.N2 = void 0;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records
class $DeclarativeEnvRec {
    // http://www.ecma-international.org/ecma-262/#sec-newdeclarativeenvironment
    // 8.1.2.2 NewDeclarativeEnvironment ( E )
    constructor(logger, realm, outer) {
        this.logger = logger;
        this.realm = realm;
        this.outer = outer;
        this.bindings = new Map();
        this.logger = logger.scopeTo('DeclarativeEnvRec');
        // 1. Let env be a new Lexical Environment.
        // 2. Let envRec be a new declarative Environment Record containing no bindings.
        // 3. Set env's EnvironmentRecord to envRec.
        // 4. Set the outer lexical environment reference of env to E.
        // 5. Return env.
    }
    // Everything is false because an environment record should not appear like any kind of normal ES value.
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isFunction() { return false; }
    // Overrides
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasbinding-n
    // 8.1.1.1.1 HasBinding ( N )
    HasBinding(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        // 2. If envRec has a binding for the name that is the value of N, return true.
        if (envRec.bindings.has(N['[[Value]]'])) {
            return intrinsics.true;
        }
        // 3. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createmutablebinding-n-d
    // 8.1.1.1.2 CreateMutableBinding ( N , D )
    CreateMutableBinding(ctx, N, D) {
        this.logger.debug(`CreateMutableBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec does not already have a binding for N.
        // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.
        const binding = new $Binding(
        /* isMutable */ true, 
        /* isStrict */ false, 
        /* isInitialized */ false, 
        /* canBeDeleted */ D['[[Value]]'], 
        /* value */ intrinsics.empty, 
        /* name */ N['[[Value]]'], 
        /* origin */ this);
        envRec.bindings.set(N['[[Value]]'], binding);
        // 4. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createimmutablebinding-n-s
    // 8.1.1.1.3 CreateImmutableBinding ( N , S )
    CreateImmutableBinding(ctx, N, S) {
        this.logger.debug(`CreateImmutableBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec does not already have a binding for N.
        // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.
        const binding = new $Binding(
        /* isMutable */ false, 
        /* isStrict */ S['[[Value]]'], 
        /* isInitialized */ false, 
        /* canBeDeleted */ false, 
        /* value */ intrinsics.empty, 
        /* name */ N['[[Value]]'], 
        /* origin */ this);
        envRec.bindings.set(N['[[Value]]'], binding);
        // 4. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-initializebinding-n-v
    // 8.1.1.1.4 InitializeBinding ( N , V )
    InitializeBinding(ctx, N, V) {
        this.logger.debug(`InitializeBinding(#${ctx.id}, ${N['[[Value]]']}, ${JSON.stringify(V['[[Value]]'])})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec must have an uninitialized binding for N.
        const binding = envRec.bindings.get(N['[[Value]]']);
        // 3. Set the bound value for N in envRec to V.
        binding.value = V;
        // 4. Record that the binding for N in envRec has been initialized.
        binding.isInitialized = true;
        // 5. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-setmutablebinding-n-v-s
    // 8.1.1.1.5 SetMutableBinding ( N , V , S )
    SetMutableBinding(ctx, N, V, S) {
        this.logger.debug(`SetMutableBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        // 2. If envRec does not have a binding for N, then
        const bindings = this.bindings;
        const binding = bindings.get(N['[[Value]]']);
        if (binding === void 0) {
            // 2. a. If S is true, throw a ReferenceError exception.
            if (S.isTruthy) {
                return new $ReferenceError(ctx.Realm, `Cannot assign to non-existing binding ${N['[[Value]]']} in strict mode code.`);
            }
            // 2. b. Perform envRec.CreateMutableBinding(N, true).
            envRec.CreateMutableBinding(ctx, N, intrinsics.true);
            // 2. c. Perform envRec.InitializeBinding(N, V).
            envRec.InitializeBinding(ctx, N, V);
            // 2. d. Return NormalCompletion(empty).
            return intrinsics.empty;
        }
        // 3. If the binding for N in envRec is a strict binding, set S to true.
        if (binding.isStrict) {
            S = intrinsics.true;
        }
        // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.
        if (!binding.isInitialized) {
            return new $ReferenceError(ctx.Realm, `Binding ${N['[[Value]]']} is not yet initialized.`);
        }
        // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.
        else if (binding.isMutable) {
            binding.value = V;
        }
        // 6. Else,
        else {
            // 6. a. Assert: This is an attempt to change the value of an immutable binding.
            // 6. b. If S is true, throw a TypeError exception.
            if (S.isTruthy) {
                return new $TypeError(ctx.Realm, `Cannot change the value of immutable binding ${N}`);
            }
        }
        // 7. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-getbindingvalue-n-s
    // 8.1.1.1.6 GetBindingValue ( N , S )
    GetBindingValue(ctx, N, S) {
        this.logger.debug(`GetBindingValue(${N['[[Value]]']})`);
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec has a binding for N.
        const binding = envRec.bindings.get(N['[[Value]]']);
        // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.
        if (!binding.isInitialized) {
            return new $ReferenceError(ctx.Realm, `No binding exists for: ${N['[[Value]]']}.`);
        }
        // 4. Return the value currently bound to N in envRec.
        return binding.value;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-deletebinding-n
    // 8.1.1.1.7 DeleteBinding ( N )
    DeleteBinding(ctx, N) {
        this.logger.debug(`DeleteBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the declarative Environment Record for which the method was invoked.
        const envRec = this;
        const bindings = envRec.bindings;
        // 2. Assert: envRec has a binding for the name that is the value of N.
        const binding = bindings.get(N['[[Value]]']);
        // 3. If the binding for N in envRec cannot be deleted, return false.
        if (!binding.canBeDeleted) {
            return intrinsics.false;
        }
        // 4. Remove the binding for N from envRec.
        bindings.delete(N['[[Value]]']);
        // 5. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasthisbinding
    // 8.1.1.1.8 HasThisBinding ( )
    HasThisBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hassuperbinding
    // 8.1.1.1.9 HasSuperBinding ( )
    HasSuperBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-withbaseobject
    // 8.1.1.1.10 WithBaseObject ( )
    WithBaseObject(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return undefined.
        return intrinsics.undefined;
    }
    dispose() {
        for (const binding of this.bindings.values()) {
            binding.dispose();
        }
        this.bindings.clear();
        this.bindings = void 0;
        this.logger = void 0;
        this.realm = void 0;
        this.outer = void 0;
    }
}
class $ObjectEnvRec {
    // http://www.ecma-international.org/ecma-262/#sec-newobjectenvironment
    // 8.1.2.3 NewObjectEnvironment ( O , E )
    constructor(logger, realm, outer, bindingObject) {
        this.logger = logger;
        this.realm = realm;
        this.outer = outer;
        this.bindingObject = bindingObject;
        this.withEnvironment = false;
        this.logger = logger.scopeTo('ObjectEnvRec');
        // 1. Let env be a new Lexical Environment.
        // 2. Let envRec be a new object Environment Record containing O as the binding object.
        // 3. Set env's EnvironmentRecord to envRec.
        // 4. Set the outer lexical environment reference of env to E.
        // 5. Return env.
    }
    // Everything is false because an environment record should not appear like any kind of normal ES value.
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isFunction() { return false; }
    // Overrides
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-hasbinding-n
    // 8.1.1.2.1 HasBinding ( N )
    HasBinding(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let bindings be the binding object for envRec.
        const bindings = envRec.bindingObject;
        // 3. Let foundBinding be ? HasProperty(bindings, N).
        const foundBinding = bindings['[[HasProperty]]'](ctx, N);
        if (foundBinding.isAbrupt) {
            return foundBinding;
        }
        // 4. If foundBinding is false, return false.
        if (foundBinding.isFalsey) {
            return intrinsics.false;
        }
        // 5. If the withEnvironment flag of envRec is false, return true.
        if (!envRec.withEnvironment) {
            return intrinsics.true;
        }
        // 6. Let unscopables be ? Get(bindings, @@unscopables).
        const unscopables = bindings['[[Get]]'](ctx, intrinsics['@@unscopables'], bindings);
        if (unscopables.isAbrupt) {
            return unscopables;
        }
        // 7. If Type(unscopables) is Object, then
        if (unscopables.isObject) {
            // 7. a. Let blocked be ToBoolean(? Get(unscopables, N)).
            const _blocked = unscopables['[[Get]]'](ctx, N, unscopables);
            if (_blocked.isAbrupt) {
                return _blocked;
            }
            const blocked = _blocked.ToBoolean(ctx);
            if (blocked.isAbrupt) {
                return blocked;
            }
            // 7. b. If blocked is true, return false.
            if (blocked.isTruthy) {
                return intrinsics.false;
            }
        }
        // 8. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-createmutablebinding-n-d
    // 8.1.1.2.2 CreateMutableBinding ( N , D )
    CreateMutableBinding(ctx, N, D) {
        this.logger.debug(`CreateMutableBinding(${N['[[Value]]']})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let bindings be the binding object for envRec.
        const bindings = envRec.bindingObject;
        // 3. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }).
        const Desc = new $PropertyDescriptor(realm, N);
        Desc['[[Value]]'] = intrinsics.undefined;
        Desc['[[Writable]]'] = intrinsics.true;
        Desc['[[Enumerable]]'] = intrinsics.true;
        Desc['[[Configurable]]'] = D;
        return $DefinePropertyOrThrow(ctx, bindings, N, Desc);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-createimmutablebinding-n-s
    // 8.1.1.2.3 CreateImmutableBinding ( N , S )
    CreateImmutableBinding(ctx, N, S) {
        // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.
        throw new Error('Should not be called');
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-initializebinding-n-v
    // 8.1.1.2.4 InitializeBinding ( N , V )
    InitializeBinding(ctx, N, V) {
        this.logger.debug(`InitializeBinding(#${ctx.id}, ${N['[[Value]]']}, ${JSON.stringify(V['[[Value]]'])})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec must have an uninitialized binding for N.
        // 3. Record that the binding for N in envRec has been initialized.
        // TODO: record
        // 4. Return ? envRec.SetMutableBinding(N, V, false).
        return envRec.SetMutableBinding(ctx, N, V, intrinsics.false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-setmutablebinding-n-v-s
    // 8.1.1.2.5 SetMutableBinding ( N , V , S )
    SetMutableBinding(ctx, N, V, S) {
        this.logger.debug(`SetMutableBinding(${N['[[Value]]']})`);
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let bindings be the binding object for envRec.
        const bindings = envRec.bindingObject;
        // 3. Return ? Set(bindings, N, V, S).
        return $Set(ctx, bindings, N, V, S);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-getbindingvalue-n-s
    // 8.1.1.2.6 GetBindingValue ( N , S )
    GetBindingValue(ctx, N, S) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let bindings be the binding object for envRec.
        const bindings = envRec.bindingObject;
        // 3. Let value be ? HasProperty(bindings, N).
        const value = bindings['[[HasProperty]]'](ctx, N);
        if (value.isAbrupt) {
            return value;
        }
        // 4. If value is false, then
        if (value.isFalsey) {
            // 4. a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.
            if (S.isFalsey) {
                return intrinsics.undefined;
            }
            return new $ReferenceError(ctx.Realm, `Cannot read from non-existing binding ${N['[[Value]]']} in strict mode code.`);
        }
        // 5. Return ? Get(bindings, N).
        return bindings['[[Get]]'](ctx, N, bindings);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-deletebinding-n
    // 8.1.1.2.7 DeleteBinding ( N )
    DeleteBinding(ctx, N) {
        this.logger.debug(`DeleteBinding(${N['[[Value]]']})`);
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let bindings be the binding object for envRec.
        const bindings = envRec.bindingObject;
        // 3. Return ? bindings.[[Delete]](N).
        return bindings['[[Delete]]'](ctx, N);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-hasthisbinding
    // 8.1.1.2.8 HasThisBinding ( )
    HasThisBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-hassuperbinding
    // 8.1.1.2.9 HasSuperBinding ( )
    HasSuperBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-withbaseobject
    // 8.1.1.2.10 WithBaseObject ( )
    WithBaseObject(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the object Environment Record for which the method was invoked.
        const envRec = this;
        // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.
        if (envRec.withEnvironment) {
            return envRec.bindingObject;
        }
        // 3. Otherwise, return undefined.
        return intrinsics.undefined;
    }
    dispose() {
        this.bindingObject.dispose();
        this.bindingObject = void 0;
        this.logger = void 0;
        this.realm = void 0;
        this.outer = void 0;
    }
}
class $FunctionEnvRec extends $DeclarativeEnvRec {
    // http://www.ecma-international.org/ecma-262/#sec-newfunctionenvironment
    // 8.1.2.4 NewFunctionEnvironment ( F , newTarget )
    constructor(logger, realm, F, newTarget) {
        super(logger, realm, F['[[Environment]]']);
        this.logger = logger;
        this.logger = logger.scopeTo('FunctionEnvRec');
        // 1. Assert: F is an ECMAScript function.
        // 2. Assert: Type(newTarget) is Undefined or Object.
        // 3. Let env be a new Lexical Environment.
        // 4. Let envRec be a new function Environment Record containing no bindings.
        const envRec = this;
        // 5. Set envRec.[[FunctionObject]] to F.
        envRec['[[FunctionObject]]'] = F;
        // 6. If F.[[ThisMode]] is lexical, set envRec.[[ThisBindingStatus]] to "lexical".
        if (F['[[ThisMode]]'] === 'lexical') {
            envRec['[[ThisBindingStatus]]'] = 'lexical';
        }
        // 7. Else, set envRec.[[ThisBindingStatus]] to "uninitialized".
        else {
            envRec['[[ThisBindingStatus]]'] = 'uninitialized';
        }
        // 8. Let home be F.[[HomeObject]].
        const home = F['[[HomeObject]]'];
        // 9. Set envRec.[[HomeObject]] to home.
        envRec['[[HomeObject]]'] = home;
        // 10. Set envRec.[[NewTarget]] to newTarget.
        envRec['[[NewTarget]]'] = newTarget;
        // 11. Set env's EnvironmentRecord to envRec.
        // 12. Set the outer lexical environment reference of env to F.[[Environment]].
        // See super(realm, F['[[Environment]]']);
        // 13. Return env.
    }
    // Everything is false because an environment record should not appear like any kind of normal ES value.
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isFunction() { return false; }
    // Overrides
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasthisbinding
    // 8.1.1.1.8 HasThisBinding ( )
    HasThisBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the function Environment Record for which the method was invoked.
        const envRec = this;
        // 2. If envRec.[[ThisBindingStatus]] is "lexical", return false; otherwise, return true.
        if (envRec['[[ThisBindingStatus]]'] === 'lexical') {
            return intrinsics.false;
        }
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hassuperbinding
    // 8.1.1.1.9 HasSuperBinding ( )
    HasSuperBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the function Environment Record for which the method was invoked.
        const envRec = this;
        // 2. If envRec.[[ThisBindingStatus]] is "lexical", return false.
        if (envRec['[[ThisBindingStatus]]'] === 'lexical') {
            return intrinsics.false;
        }
        // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.
        if (envRec['[[HomeObject]]'].isUndefined) {
            return intrinsics.false;
        }
        return intrinsics.true;
    }
    // Additions
    // http://www.ecma-international.org/ecma-262/#sec-bindthisvalue
    // 8.1.1.3.1 BindThisValue ( V )
    BindThisValue(ctx, V) {
        // 1. Let envRec be the function Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec.[[ThisBindingStatus]] is not "lexical".
        // 3. If envRec.[[ThisBindingStatus]] is "initialized", throw a ReferenceError exception.
        if (envRec['[[ThisBindingStatus]]'] === 'initialized') {
            return new $ReferenceError(ctx.Realm, `The 'this' binding is already initialized.`);
        }
        // 4. Set envRec.[[ThisValue]] to V.
        envRec['[[ThisValue]]'] = V;
        // 5. Set envRec.[[ThisBindingStatus]] to "initialized".
        envRec['[[ThisBindingStatus]]'] = 'initialized';
        // 6. Return V.
        return V;
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-environment-records-getthisbinding
    // 8.1.1.3.4 GetThisBinding ( )
    GetThisBinding(ctx) {
        // 1. Let envRec be the function Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec.[[ThisBindingStatus]] is not "lexical".
        // 3. If envRec.[[ThisBindingStatus]] is "uninitialized", throw a ReferenceError exception.
        if (envRec['[[ThisBindingStatus]]'] === 'uninitialized') {
            return new $ReferenceError(ctx.Realm, `The 'this' binding is not yet initialized.`);
        }
        // 4. Return envRec.[[ThisValue]].
        return envRec['[[ThisValue]]'];
    }
    // http://www.ecma-international.org/ecma-262/#sec-getsuperbase
    // 8.1.1.3.5 GetSuperBase ( )
    GetSuperBase(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the function Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let home be envRec.[[HomeObject]].
        const home = envRec['[[HomeObject]]'];
        // 3. If home has the value undefined, return undefined.
        if (home.isUndefined) {
            return intrinsics.undefined;
        }
        // 4. Assert: Type(home) is Object.
        // 5. Return ? home.[[GetPrototypeOf]]().
        return home['[[GetPrototypeOf]]'](ctx);
    }
    dispose() {
        super.dispose();
        this['[[ThisValue]]'] = void 0;
        this['[[FunctionObject]]'] = void 0;
        this['[[HomeObject]]'] = void 0;
        this['[[NewTarget]]'] = void 0;
    }
}
class $GlobalEnvRec {
    // http://www.ecma-international.org/ecma-262/#sec-newglobalenvironment
    // 8.1.2.5 NewGlobalEnvironment ( G , thisValue )
    constructor(logger, realm, G, thisValue) {
        this.logger = logger;
        this.realm = realm;
        this.logger = logger.scopeTo('GlobalEnvRec');
        this.outer = realm['[[Intrinsics]]'].null;
        // 1. Let env be a new Lexical Environment.
        // 2. Let objRec be a new object Environment Record containing G as the binding object.
        const objRec = new $ObjectEnvRec(logger, realm, realm['[[Intrinsics]]'].null, G);
        // 3. Let dclRec be a new declarative Environment Record containing no bindings.
        const dclRec = new $DeclarativeEnvRec(logger, realm, realm['[[Intrinsics]]'].null);
        // 4. Let globalRec be a new global Environment Record.
        const globalRec = this;
        // 5. Set globalRec.[[ObjectRecord]] to objRec.
        globalRec['[[ObjectRecord]]'] = objRec;
        // 6. Set globalRec.[[GlobalThisValue]] to thisValue.
        globalRec['[[GlobalThisValue]]'] = thisValue;
        // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.
        globalRec['[[DeclarativeRecord]]'] = dclRec;
        // 8. Set globalRec.[[VarNames]] to a new empty List.
        globalRec['[[VarNames]]'] = [];
        // 9. Set env's EnvironmentRecord to globalRec.
        // 10. Set the outer lexical environment reference of env to null.
        // 11. Return env.
    }
    // Everything is false because an environment record should not appear like any kind of normal ES value.
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isFunction() { return false; }
    // Overrides
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-hasbinding-n
    // 8.1.1.4.1 HasBinding ( N )
    HasBinding(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, return true.
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            return intrinsics.true;
        }
        // 4. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 5. Return ? ObjRec.HasBinding(N).
        return objRec.HasBinding(ctx, N);
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-createmutablebinding-n-d
    // 8.1.1.4.2 CreateMutableBinding ( N , D )
    CreateMutableBinding(ctx, N, D) {
        this.logger.debug(`CreateMutableBinding(${N['[[Value]]']})`);
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            return new $TypeError(ctx.Realm, `A global binding for ${N} already exists`);
        }
        // 4. Return DclRec.CreateMutableBinding(N, D).
        return dclRec.CreateMutableBinding(ctx, N, D);
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-createimmutablebinding-n-s
    // 8.1.1.4.3 CreateImmutableBinding ( N , S )
    CreateImmutableBinding(ctx, N, S) {
        this.logger.debug(`CreateImmutableBinding(${N['[[Value]]']})`);
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            return new $TypeError(ctx.Realm, `A global binding for ${N} already exists`);
        }
        // 4. Return DclRec.CreateImmutableBinding(N, S).
        return dclRec.CreateImmutableBinding(ctx, N, S);
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-initializebinding-n-v
    // 8.1.1.4.4 InitializeBinding ( N , V )
    InitializeBinding(ctx, N, V) {
        this.logger.debug(`InitializeBinding(#${ctx.id}, ${N['[[Value]]']}, ${JSON.stringify(V['[[Value]]'])})`);
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, then
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            // 3. a. Return DclRec.InitializeBinding(N, V).
            return dclRec.InitializeBinding(ctx, N, V);
        }
        // 4. Assert: If the binding exists, it must be in the object Environment Record.
        // 5. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 6. Return ? ObjRec.InitializeBinding(N, V).
        return objRec.InitializeBinding(ctx, N, V);
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-setmutablebinding-n-v-s
    // 8.1.1.4.5 SetMutableBinding ( N , V , S )
    SetMutableBinding(ctx, N, V, S) {
        this.logger.debug(`SetMutableBinding(${N['[[Value]]']})`);
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, then
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            // 3. a. Return DclRec.SetMutableBinding(N, V, S).
            return dclRec.SetMutableBinding(ctx, N, V, S);
        }
        // 4. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 5. Return ? ObjRec.SetMutableBinding(N, V, S).
        return objRec.SetMutableBinding(ctx, N, V, S);
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-getbindingvalue-n-s
    // 8.1.1.4.6 GetBindingValue ( N , S )
    GetBindingValue(ctx, N, S) {
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, then
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            // 3. a. Return DclRec.GetBindingValue(N, S).
            return dclRec.GetBindingValue(ctx, N, S);
        }
        // 4. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 5. Return ? ObjRec.GetBindingValue(N, S).
        return objRec.GetBindingValue(ctx, N, S);
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-deletebinding-n
    // 8.1.1.4.7 DeleteBinding ( N )
    DeleteBinding(ctx, N) {
        this.logger.debug(`DeleteBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. If DclRec.HasBinding(N) is true, then
        if (dclRec.HasBinding(ctx, N).isTruthy) {
            // 3. a. Return DclRec.DeleteBinding(N).
            return dclRec.DeleteBinding(ctx, N);
        }
        // 4. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 5. Let globalObject be the binding object for ObjRec.
        const globalObject = objRec.bindingObject;
        // 6. Let existingProp be ? HasOwnProperty(globalObject, N).
        const existingProp = $HasOwnProperty(ctx, globalObject, N);
        if (existingProp.isAbrupt) {
            return existingProp;
        }
        // 7. If existingProp is true, then
        if (existingProp.isTruthy) {
            // 7. a. Let status be ? ObjRec.DeleteBinding(N).
            const status = objRec.DeleteBinding(ctx, N);
            if (status.isAbrupt) {
                return status;
            }
            // 7. b. If status is true, then
            if (status.isTruthy) {
                // 7. b. i. Let varNames be envRec.[[VarNames]].
                const varNames = envRec['[[VarNames]]'];
                // 7. b. ii. If N is an element of varNames, remove that element from the varNames.
                const idx = varNames.indexOf(N['[[Value]]']);
                if (idx >= 0) {
                    varNames.splice(idx, 1);
                }
            }
            // 7. c. Return status.
            return status;
        }
        // 8. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-hasthisbinding
    // 8.1.1.4.8 HasThisBinding ( )
    HasThisBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-hassuperbinding
    // 8.1.1.4.9 HasSuperBinding ( )
    HasSuperBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-withbaseobject
    // 8.1.1.4.10 WithBaseObject ( )
    WithBaseObject(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return undefined.
        return intrinsics.undefined;
    }
    // Additions
    // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-getthisbinding
    // 8.1.1.4.11 GetThisBinding ( )
    GetThisBinding(ctx) {
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Return envRec.[[GlobalThisValue]].
        return envRec['[[GlobalThisValue]]'];
    }
    // http://www.ecma-international.org/ecma-262/#sec-hasvardeclaration
    // 8.1.1.4.12 HasVarDeclaration ( N )
    HasVarDeclaration(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let varDeclaredNames be envRec.[[VarNames]].
        const varDeclaredNames = envRec['[[VarNames]]'];
        // 3. If varDeclaredNames contains N, return true.
        if (varDeclaredNames.includes(N['[[Value]]'])) {
            return intrinsics.true;
        }
        // 4. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-haslexicaldeclaration
    // 8.1.1.4.13 HasLexicalDeclaration ( N )
    HasLexicalDeclaration(ctx, N) {
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let DclRec be envRec.[[DeclarativeRecord]].
        const dclRec = envRec['[[DeclarativeRecord]]'];
        // 3. Return DclRec.HasBinding(N).
        return dclRec.HasBinding(ctx, N);
    }
    // http://www.ecma-international.org/ecma-262/#sec-hasrestrictedglobalproperty
    // 8.1.1.4.14 HasRestrictedGlobalProperty ( N )
    HasRestrictedGlobalProperty(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 3. Let globalObject be the binding object for ObjRec.
        const globalObject = objRec.bindingObject;
        // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
        const existingProp = globalObject['[[GetOwnProperty]]'](ctx, N);
        if (existingProp.isAbrupt) {
            return existingProp;
        }
        // 5. If existingProp is undefined, return false.
        if (existingProp.isUndefined) {
            return intrinsics.false;
        }
        // 6. If existingProp.[[Configurable]] is true, return false.
        if (existingProp['[[Configurable]]'].isTruthy) {
            return intrinsics.false;
        }
        // 7. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-candeclareglobalvar
    // 8.1.1.4.15 CanDeclareGlobalVar ( N )
    CanDeclareGlobalVar(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 3. Let globalObject be the binding object for ObjRec.
        const globalObject = objRec.bindingObject;
        // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).
        const hasProperty = $HasOwnProperty(ctx, globalObject, N);
        if (hasProperty.isAbrupt) {
            return hasProperty;
        }
        // 5. If hasProperty is true, return true.
        if (hasProperty.isTruthy) {
            return intrinsics.true;
        }
        // 6. Return ? IsExtensible(globalObject).
        return globalObject['[[IsExtensible]]'](ctx);
    }
    // http://www.ecma-international.org/ecma-262/#sec-candeclareglobalfunction
    // 8.1.1.4.16 CanDeclareGlobalFunction ( N )
    CanDeclareGlobalFunction(ctx, N) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 3. Let globalObject be the binding object for ObjRec.
        const globalObject = objRec.bindingObject;
        // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
        const existingProp = globalObject['[[GetOwnProperty]]'](ctx, N);
        if (existingProp.isAbrupt) {
            return existingProp;
        }
        // 5. If existingProp is undefined, return ? IsExtensible(globalObject).
        if (existingProp.isUndefined) {
            return globalObject['[[IsExtensible]]'](ctx);
        }
        // 6. If existingProp.[[Configurable]] is true, return true.
        if (existingProp['[[Configurable]]'].isTruthy) {
            return intrinsics.true;
        }
        // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values { [[Writable]]: true, [[Enumerable]]: true }, return true.
        if (existingProp.isDataDescriptor && existingProp['[[Writable]]'].isTruthy && existingProp['[[Enumerable]]'].isTruthy) {
            return intrinsics.true;
        }
        // 8. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-createglobalvarbinding
    // 8.1.1.4.17 CreateGlobalVarBinding ( N , D )
    CreateGlobalVarBinding(ctx, N, D) {
        this.logger.debug(`CreateGlobalVarBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 3. Let globalObject be the binding object for ObjRec.
        const globalObject = objRec.bindingObject;
        // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).
        const hasProperty = $HasOwnProperty(ctx, globalObject, N);
        if (hasProperty.isAbrupt) {
            return hasProperty;
        }
        // 5. Let extensible be ? IsExtensible(globalObject).
        const extensible = globalObject['[[IsExtensible]]'](ctx);
        if (extensible.isAbrupt) {
            return extensible;
        }
        // 6. If hasProperty is false and extensible is true, then
        if (hasProperty.isFalsey && extensible.isTruthy) {
            // 6. a. Perform ? ObjRec.CreateMutableBinding(N, D).
            const $CreateMutableBinding = objRec.CreateMutableBinding(ctx, N, D);
            if ($CreateMutableBinding.isAbrupt) {
                return $CreateMutableBinding;
            }
            // 6. b. Perform ? ObjRec.InitializeBinding(N, undefined).
            const $InitializeBinding = objRec.InitializeBinding(ctx, N, intrinsics.undefined);
            if ($InitializeBinding.isAbrupt) {
                return $InitializeBinding;
            }
        }
        // 7. Let varDeclaredNames be envRec.[[VarNames]].
        const varDeclaredNames = envRec['[[VarNames]]'];
        // 8. If varDeclaredNames does not contain N, then
        if (!varDeclaredNames.includes(N['[[Value]]'])) {
            // 8. a. Append N to varDeclaredNames.
            varDeclaredNames.push(N['[[Value]]']);
        }
        // 9. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-createglobalfunctionbinding
    // 8.1.1.4.18 CreateGlobalFunctionBinding ( N , V , D )
    CreateGlobalFunctionBinding(ctx, N, V, D) {
        this.logger.debug(`CreateGlobalFunctionBinding(${N['[[Value]]']})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let envRec be the global Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Let ObjRec be envRec.[[ObjectRecord]].
        const objRec = envRec['[[ObjectRecord]]'];
        // 3. Let globalObject be the binding object for ObjRec.
        const globalObject = objRec.bindingObject;
        // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).
        const existingProp = globalObject['[[GetOwnProperty]]'](ctx, N);
        if (existingProp.isAbrupt) {
            return existingProp;
        }
        let desc;
        // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then
        if (existingProp.isUndefined || existingProp['[[Configurable]]'].isTruthy) {
            // 5. a. Let desc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }.
            desc = new $PropertyDescriptor(realm, N);
            desc['[[Enumerable]]'] = intrinsics.true;
            desc['[[Configurable]]'] = D;
            desc['[[Value]]'] = V;
            desc['[[Writable]]'] = intrinsics.true;
        }
        // 6. Else,
        else {
            // 6. a. Let desc be the PropertyDescriptor { [[Value]]: V }.
            desc = new $PropertyDescriptor(realm, N);
            desc['[[Value]]'] = V;
        }
        // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).
        const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(ctx, globalObject, N, desc);
        if ($DefinePropertyOrThrowResult.isAbrupt) {
            return $DefinePropertyOrThrowResult;
        }
        // 8. Record that the binding for N in ObjRec has been initialized.
        // TODO: record
        // 9. Perform ? Set(globalObject, N, V, false).
        const $SetResult = $Set(ctx, globalObject, N, V, intrinsics.false);
        if ($SetResult.isAbrupt) {
            return $SetResult;
        }
        // 10. Let varDeclaredNames be envRec.[[VarNames]].
        const varDeclaredNames = envRec['[[VarNames]]'];
        // 11. If varDeclaredNames does not contain N, then
        if (!varDeclaredNames.includes(N['[[Value]]'])) {
            // 11. a. Append N to varDeclaredNames.
            varDeclaredNames.push(N['[[Value]]']);
        }
        // 12. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    dispose() {
        this['[[ObjectRecord]]'] = void 0;
        this['[[GlobalThisValue]]'] = void 0;
        this['[[DeclarativeRecord]]'] = void 0;
        this['[[VarNames]]'] = void 0;
        this.logger = void 0;
        this.outer = void 0;
        this.realm = void 0;
    }
}
class $ModuleEnvRec extends $DeclarativeEnvRec {
    // http://www.ecma-international.org/ecma-262/#sec-newmoduleenvironment
    // 8.1.2.6 NewModuleEnvironment ( E )
    constructor(logger, realm, outer) {
        super(logger, realm, outer);
        this.logger = logger;
        this.logger = logger.scopeTo('ModuleEnvRec');
        // 1. Let env be a new Lexical Environment.
        // 2. Let envRec be a new module Environment Record containing no bindings.
        // 3. Set env's EnvironmentRecord to envRec.
        // 4. Set the outer lexical environment reference of env to E.
        // 5. Return env.
    }
    // Everything is false because an environment record should not appear like any kind of normal ES value.
    get isEmpty() { return false; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    get isNil() { return false; }
    get isBoolean() { return false; }
    get isNumber() { return false; }
    get isString() { return false; }
    get isSymbol() { return false; }
    get isPrimitive() { return false; }
    get isObject() { return false; }
    get isFunction() { return false; }
    // Overrides
    // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-getbindingvalue-n-s
    // 8.1.1.5.1 GetBindingValue ( N , S )
    GetBindingValue(ctx, N, S) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Assert: S is true.
        // 2. Let envRec be the module Environment Record for which the method was invoked.
        const envRec = this;
        // 3. Assert: envRec has a binding for N.
        const binding = envRec.bindings.get(N['[[Value]]']);
        // 4. If the binding for N is an indirect binding, then
        if (binding.isIndirect) {
            // 4. a. Let M and N2 be the indirection values provided when this binding for N was created.
            const M = binding.M;
            const N2 = binding.N2;
            // 4. b. Let targetEnv be M.[[Environment]].
            const targetER = M['[[Environment]]'];
            // 4. c. If targetEnv is undefined, throw a ReferenceError exception.
            if (targetER.isUndefined) {
                return new $ReferenceError(ctx.Realm, `Cannot resolve export: ${N['[[Value]]']}`);
            }
            // 4. d. Let targetER be targetEnv's EnvironmentRecord.
            // 4. e. Return ? targetER.GetBindingValue(N2, true).
            return targetER.GetBindingValue(ctx, N2, intrinsics.true);
        }
        // 5. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.
        if (!binding.isInitialized) {
            return new $ReferenceError(ctx.Realm, `Binding for ${N['[[Value]]']} is not yet initialized`);
        }
        // 6. Return the value currently bound to N in envRec.
        return binding.value;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-deletebinding-n
    // 8.1.1.5.2 DeleteBinding ( N )
    DeleteBinding(ctx, N) {
        // 1. Assert: This method is never invoked. See 12.5.3.1.
        throw new Error('1. Assert: This method is never invoked. See 12.5.3.1.');
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-hasthisbinding
    // 8.1.1.5.3 HasThisBinding ( )
    HasThisBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return true.
        return intrinsics.true;
    }
    // Additions
    // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-getthisbinding
    // 8.1.1.5.4 GetThisBinding ( )
    GetThisBinding(ctx) {
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Return undefined.
        return intrinsics.undefined;
    }
    // http://www.ecma-international.org/ecma-262/#sec-createimportbinding
    // 8.1.1.5.5 CreateImportBinding ( N , M , N2 )
    CreateImportBinding(ctx, N, M, N2) {
        this.logger.debug(`CreateImportBinding(${N['[[Value]]']})`);
        const intrinsics = this.realm['[[Intrinsics]]'];
        // 1. Let envRec be the module Environment Record for which the method was invoked.
        const envRec = this;
        // 2. Assert: envRec does not already have a binding for N.
        // 3. Assert: M is a Module Record.
        // 4. Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2.
        // 5. Create an immutable indirect binding in envRec for N that references M and N2 as its target binding and record that the binding is initialized.
        const binding = new $Binding(
        /* isMutable */ false, 
        /* isStrict */ true, 
        /* isInitialized */ true, 
        /* canBeDeleted */ false, 
        /* value */ intrinsics.empty, 
        /* name */ N['[[Value]]'], 
        /* origin */ this, 
        /* M */ M, 
        /* N2 */ N2);
        envRec.bindings.set(N['[[Value]]'], binding);
        // 6. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
}

// http://www.ecma-international.org/ecma-262/#table-6
// http://www.ecma-international.org/ecma-262/#sec-ecmascript-function-objects
class $Function extends $Object {
    constructor(realm, IntrinsicName, proto) {
        super(realm, IntrinsicName, proto, 1 /* normal */, realm['[[Intrinsics]]'].empty);
    }
    get isFunction() { return true; }
    // For error stack trace
    toString() {
        const code = this['[[ECMAScriptCode]]'];
        const sourceFile = code.mos.node;
        const node = code.node;
        const path = code.path;
        const text = this['[[SourceText]]']['[[Value]]'];
        const firstLine = text.split(/\r?\n/)[0];
        let line = -1;
        let character = -1;
        if (node.pos > -1) {
            ({ line, character } = typescript.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile)));
        }
        return `${firstLine}:${line + 1}:${character} (${path})`;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // 9.2.1 [[Call]] ( thisArgument , argumentsList )
    '[[Call]]'(ctx, thisArgument, argumentsList) {
        // 1. Assert: F is an ECMAScript function object.
        const F = this;
        const realm = F['[[Realm]]'];
        const intrinsics = realm['[[Intrinsics]]'];
        // 2. If F.[[FunctionKind]] is "classConstructor", throw a TypeError exception.
        if (F['[[FunctionKind]]'] === 2 /* classConstructor */) {
            return new $TypeError(realm, `Cannot call classConstructor (${F.propertyMap.has('name') ? F.propertyDescriptors[F.propertyMap.get('name')]['[[Value]]'] : 'anonymous'}) as a function`);
        }
        // 3. Let callerContext be the running execution context.
        // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).
        const calleeContext = $PrepareForOrdinaryCall(ctx, F, intrinsics.undefined);
        // 5. Assert: calleeContext is now the running execution context.
        // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
        $OrdinaryCallBindThis(ctx, F, calleeContext, thisArgument);
        // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).
        const result = F['[[ECMAScriptCode]]'].EvaluateBody(calleeContext, F, argumentsList);
        // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        realm.stack.pop();
        ctx.resume();
        // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).
        if (result['[[Type]]'] === 4 /* return */) {
            return result.ToCompletion(1 /* normal */, intrinsics.empty);
        }
        // 10. ReturnIfAbrupt(result).
        if (result.isAbrupt) {
            return result;
        }
        // 11. Return NormalCompletion(undefined).
        return new $Undefined(realm, 1 /* normal */, intrinsics.empty);
    }
    // http://www.ecma-international.org/ecma-262/#sec-ecmascript-function-objects-construct-argumentslist-newtarget
    // 9.2.2 [[Construct]] ( argumentsList , newTarget )
    '[[Construct]]'(ctx, argumentsList, newTarget) {
        // 1. Assert: F is an ECMAScript function object.
        const F = this;
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const stack = realm.stack;
        // 2. Assert: Type(newTarget) is Object.
        // 3. Let callerContext be the running execution context.
        // 4. Let kind be F.[[ConstructorKind]].
        const kind = F['[[ConstructorKind]]'];
        let thisArgument;
        // 5. If kind is "base", then
        if (kind === 'base') {
            // 5. a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, "%ObjectPrototype%").
            const $thisArgument = $OrdinaryCreateFromConstructor(ctx, newTarget, '%ObjectPrototype%');
            if ($thisArgument.isAbrupt) {
                return $thisArgument;
            }
            thisArgument = $thisArgument;
        }
        else {
            thisArgument = intrinsics.undefined;
        }
        // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).
        const calleeContext = $PrepareForOrdinaryCall(ctx, F, newTarget);
        // 7. Assert: calleeContext is now the running execution context.
        // 8. If kind is "base", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).
        if (kind === 'base') {
            $OrdinaryCallBindThis(ctx, F, calleeContext, thisArgument);
        }
        // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.
        // 10. Let envRec be constructorEnv's EnvironmentRecord.
        const envRec = calleeContext.LexicalEnvironment;
        // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).
        const result = F['[[ECMAScriptCode]]'].EvaluateBody(calleeContext, F, argumentsList);
        // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        stack.pop();
        ctx.resume();
        // 13. If result.[[Type]] is return, then
        if (result['[[Type]]'] === 4 /* return */) {
            // 13. a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).
            if (result.isObject) {
                return result.ToCompletion(1 /* normal */, intrinsics.empty);
            }
            // 13. b. If kind is "base", return NormalCompletion(thisArgument).
            if (kind === 'base') {
                return thisArgument.ToCompletion(1 /* normal */, intrinsics.empty);
            }
            // 13. c. If result.[[Value]] is not undefined, throw a TypeError exception.
            if (!result.isUndefined) {
                return new $TypeError(realm, `base constructor for ${F.propertyMap.has('name') ? F.propertyDescriptors[F.propertyMap.get('name')]['[[Value]]'] : 'anonymous'} returned ${result}, but expected undefined`);
            }
        }
        // 14. Else, ReturnIfAbrupt(result).
        else {
            if (result.isAbrupt) {
                return result;
            }
        }
        // 15. Return ? envRec.GetThisBinding().
        return envRec.GetThisBinding(ctx);
    }
    // http://www.ecma-international.org/ecma-262/#sec-functionallocate
    // 9.2.3 FunctionAllocate ( functionPrototype , strict , functionKind )
    static FunctionAllocate(ctx, functionPrototype, strict, functionKind) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: Type(functionPrototype) is Object.
        // 2. Assert: functionKind is either "normal", "non-constructor", "generator", "async", or "async generator".
        // 3. If functionKind is "normal", let needsConstruct be true.
        // 4. Else, let needsConstruct be false.
        const needsConstruct = functionKind === 0 /* normal */;
        // 5. If functionKind is "non-constructor", set functionKind to "normal".
        if (functionKind === 1 /* nonConstructor */) {
            functionKind = 0 /* normal */;
        }
        // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.
        const F = new $Function(realm, 'function', functionPrototype);
        // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.
        // 8. Set F.[[Call]] to the definition specified in 9.2.1.
        // 9. If needsConstruct is true, then
        if (needsConstruct) {
            // 9. a. Set F.[[Construct]] to the definition specified in 9.2.2.
            // 9. b. Set F.[[ConstructorKind]] to "base".
            F['[[ConstructorKind]]'] = 'base';
        }
        // 10. Set F.[[Strict]] to strict.
        F['[[Strict]]'] = strict;
        // 11. Set F.[[FunctionKind]] to functionKind.
        F['[[FunctionKind]]'] = functionKind;
        // 12. Set F.[[Prototype]] to functionPrototype.
        F['[[Prototype]]'] = functionPrototype;
        // 13. Set F.[[Extensible]] to true.
        F['[[Extensible]]'] = intrinsics.true;
        // 14. Set F.[[Realm]] to the current Realm Record.
        F['[[Realm]]'] = realm;
        // 15. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-functioninitialize
    // 9.2.4 FunctionInitialize ( F , kind , ParameterList , Body , Scope )
    static FunctionInitialize(ctx, F, kind, code, Scope) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let len be the ExpectedArgumentCount of ParameterList.
        const len = code.$parameters.ExpectedArgumentCount;
        // 2. Perform ! SetFunctionLength(F, len).
        const Desc = new $PropertyDescriptor(realm, intrinsics.length);
        Desc['[[Value]]'] = new $Number(realm, len);
        Desc['[[Writable]]'] = intrinsics.false;
        Desc['[[Enumerable]]'] = intrinsics.false;
        Desc['[[Configurable]]'] = intrinsics.true;
        $DefinePropertyOrThrow(ctx, F, intrinsics.length, Desc);
        // 3. Let Strict be F.[[Strict]].
        const Strict = F['[[Strict]]'];
        // 4. Set F.[[Environment]] to Scope.
        F['[[Environment]]'] = Scope;
        // 5. Set F.[[FormalParameters]] to ParameterList.
        // 6. Set F.[[ECMAScriptCode]] to Body.
        F['[[ECMAScriptCode]]'] = code;
        // 7. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().
        F['[[ScriptOrModule]]'] = realm.GetActiveScriptOrModule();
        // 8. If kind is Arrow, set F.[[ThisMode]] to lexical.
        if (kind === 'arrow') {
            F['[[ThisMode]]'] = 'lexical';
        }
        // 9. Else if Strict is true, set F.[[ThisMode]] to strict.
        else if (Strict.isTruthy) {
            F['[[ThisMode]]'] = 'strict';
        }
        // 10. Else, set F.[[ThisMode]] to global.
        else {
            F['[[ThisMode]]'] = 'global';
        }
        // 11. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-functioncreate
    // 9.2.5 FunctionCreate ( kind , ParameterList , Body , Scope , Strict [ , prototype ] )
    static FunctionCreate(ctx, kind, code, Scope, Strict, prototype) {
        code.logger.debug(`$Function.FunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If prototype is not present, then
        if (prototype === void 0) {
            // 1. a. Set prototype to the intrinsic object %FunctionPrototype%.
            prototype = intrinsics['%FunctionPrototype%'];
        }
        let allocKind;
        // 2. If kind is not Normal, let allocKind be "non-constructor".
        if (kind !== 'normal') {
            allocKind = 1 /* nonConstructor */;
        }
        // 3. Else, let allocKind be "normal".
        else {
            allocKind = 0 /* normal */;
        }
        // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).
        const F = this.FunctionAllocate(ctx, prototype, Strict, allocKind);
        // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).
        return this.FunctionInitialize(ctx, F, kind, code, Scope);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunctioncreate
    // 9.2.6 GeneratorFunctionCreate ( kind , ParameterList , Body , Scope , Strict )
    static GeneratorFunctionCreate(ctx, kind, code, Scope, Strict) {
        code.logger.debug(`$Function.GeneratorFunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let functionPrototype be the intrinsic object %Generator%.
        const functionPrototype = intrinsics['%Generator%'];
        // 2. Let F be FunctionAllocate(functionPrototype, Strict, "generator").
        const F = this.FunctionAllocate(ctx, functionPrototype, Strict, 4 /* generator */);
        // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).
        return this.FunctionInitialize(ctx, F, kind, code, Scope);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunctioncreate
    // 9.2.7 AsyncGeneratorFunctionCreate ( kind , ParameterList , Body , Scope , Strict )
    static AsyncGeneratorFunctionCreate(ctx, kind, code, Scope, Strict) {
        code.logger.debug(`$Function.AsyncGeneratorFunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let functionPrototype be the intrinsic object %AsyncGenerator%.
        const functionPrototype = intrinsics['%AsyncGenerator%'];
        // 2. Let F be ! FunctionAllocate(functionPrototype, Strict, "generator").
        const F = this.FunctionAllocate(ctx, functionPrototype, Strict, 4 /* generator */);
        // 3. Return ! FunctionInitialize(F, kind, ParameterList, Body, Scope).
        return this.FunctionInitialize(ctx, F, kind, code, Scope);
    }
    // http://www.ecma-international.org/ecma-262/#sec-async-functions-abstract-operations-async-function-create
    // 9.2.8 AsyncFunctionCreate ( kind , parameters , body , Scope , Strict )
    static AsyncFunctionCreate(ctx, kind, code, Scope, Strict) {
        code.logger.debug(`$Function.AsyncFunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let functionPrototype be the intrinsic object %AsyncFunctionPrototype%.
        const functionPrototype = intrinsics['%AsyncFunctionPrototype%'];
        // 2. Let F be ! FunctionAllocate(functionPrototype, Strict, "async").
        const F = this.FunctionAllocate(ctx, functionPrototype, Strict, 8 /* async */);
        // 3. Return ! FunctionInitialize(F, kind, parameters, body, Scope).
        return this.FunctionInitialize(ctx, F, kind, code, Scope);
    }
    // http://www.ecma-international.org/ecma-262/#sec-makeconstructor
    // 9.2.10 MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )
    MakeConstructor(ctx, writablePrototype, prototype) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const F = this;
        // 1. Assert: F is an ECMAScript function object.
        // 2. Assert: IsConstructor(F) is true.
        // 3. Assert: F is an extensible object that does not have a prototype own property.
        // 4. If writablePrototype is not present, set writablePrototype to true.
        if (writablePrototype === void 0) {
            writablePrototype = intrinsics.true;
        }
        // 5. If prototype is not present, then
        if (prototype === void 0) {
            // 5. a. Set prototype to ObjectCreate(%ObjectPrototype%).
            prototype = $Object.ObjectCreate(ctx, 'constructor', intrinsics['%ObjectPrototype%']);
            // 5. b. Perform ! DefinePropertyOrThrow(prototype, "constructor", PropertyDescriptor { [[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).
            const Desc = new $PropertyDescriptor(realm, intrinsics.$constructor);
            Desc['[[Value]]'] = F;
            Desc['[[Writable]]'] = writablePrototype;
            Desc['[[Enumerable]]'] = intrinsics.false;
            Desc['[[Configurable]]'] = intrinsics.true;
            $DefinePropertyOrThrow(ctx, prototype, intrinsics.$constructor, Desc);
        }
        // 6. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false }).
        const Desc = new $PropertyDescriptor(realm, intrinsics.$prototype);
        Desc['[[Value]]'] = prototype;
        Desc['[[Writable]]'] = writablePrototype;
        Desc['[[Enumerable]]'] = intrinsics.false;
        Desc['[[Configurable]]'] = intrinsics.false;
        $DefinePropertyOrThrow(ctx, F, intrinsics.$prototype, Desc);
        // 7. Return NormalCompletion(undefined).
        return intrinsics.undefined;
    }
    // http://www.ecma-international.org/ecma-262/#sec-setfunctionname
    // 9.2.13 SetFunctionName ( F , name [ , prefix ] )
    SetFunctionName(ctx, name, prefix) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: F is an extensible object that does not have a name own property.
        // 2. Assert: Type(name) is either Symbol or String.
        // 3. Assert: If prefix is present, then Type(prefix) is String.
        // 4. If Type(name) is Symbol, then
        if (name.isSymbol) {
            // 4. a. Let description be name's [[Description]] value.
            const description = name.Description;
            // 4. b. If description is undefined, set name to the empty String.
            if (description.isUndefined) {
                name = intrinsics[''];
            }
            // 4. c. Else, set name to the string-concatenation of "[", description, and "]".
            else {
                name = new $String(realm, `[${description['[[Value]]']}]`);
            }
        }
        // 5. If prefix is present, then
        if (prefix !== void 0) {
            // 5. a. Set name to the string-concatenation of prefix, the code unit 0x0020 (SPACE), and name.
            name = new $String(realm, `${prefix['[[Value]]']} ${name['[[Value]]']}`);
        }
        // 6. Return ! DefinePropertyOrThrow(F, "name", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).
        const Desc = new $PropertyDescriptor(realm, intrinsics.$name);
        Desc['[[Value]]'] = name;
        Desc['[[Writable]]'] = intrinsics.false;
        Desc['[[Enumerable]]'] = intrinsics.false;
        Desc['[[Configurable]]'] = intrinsics.true;
        return $DefinePropertyOrThrow(ctx, this, intrinsics.$name, Desc);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-ordinarycreatefromconstructor
function $OrdinaryCreateFromConstructor(ctx, constructor, intrinsicDefaultProto, internalSlotsList) {
    // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
    // 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).
    const proto = $GetPrototypeFromConstructor(ctx, constructor, intrinsicDefaultProto);
    if (proto.isAbrupt) {
        return proto;
    }
    // 3. Return ObjectCreate(proto, internalSlotsList).
    return $Object.ObjectCreate(ctx, intrinsicDefaultProto, proto, internalSlotsList);
}
// http://www.ecma-international.org/ecma-262/#sec-getprototypefromconstructor
function $GetPrototypeFromConstructor(ctx, constructor, intrinsicDefaultProto) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.
    // 2. Assert: IsCallable(constructor) is true.
    // 3. Let proto be ? Get(constructor, "prototype").
    let proto = constructor['[[Get]]'](ctx, intrinsics.$prototype, constructor);
    if (proto.isAbrupt) {
        return proto;
    }
    // 4. If Type(proto) is not Object, then
    if (!proto.isObject) {
        // 4. a. Let realm be ? GetFunctionRealm(constructor).
        // 4. b. Set proto to realm's intrinsic object named intrinsicDefaultProto.
        proto = intrinsics[intrinsicDefaultProto];
    }
    // 5. Return proto.
    return proto;
}
// http://www.ecma-international.org/ecma-262/#sec-prepareforordinarycall
function $PrepareForOrdinaryCall(ctx, F, newTarget) {
    // 1. Assert: Type(newTarget) is Undefined or Object.
    // 2. Let callerContext be the running execution context.
    const callerContext = ctx;
    // 3. Let calleeContext be a new ECMAScript code execution context.
    const calleeRealm = F['[[Realm]]'];
    const calleeContext = new ExecutionContext(calleeRealm);
    // 4. Set the Function of calleeContext to F.
    calleeContext.Function = F;
    // 5. Let calleeRealm be F.[[Realm]].
    // 6. Set the Realm of calleeContext to calleeRealm.
    // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
    calleeContext.ScriptOrModule = F['[[ScriptOrModule]]'];
    // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).
    const localEnv = new $FunctionEnvRec(F['[[ECMAScriptCode]]'].logger, calleeRealm, F, newTarget);
    // 9. Set the LexicalEnvironment of calleeContext to localEnv.
    calleeContext.LexicalEnvironment = localEnv;
    // 10. Set the VariableEnvironment of calleeContext to localEnv.
    calleeContext.VariableEnvironment = localEnv;
    // 11. If callerContext is not already suspended, suspend callerContext.
    if (!callerContext.suspended) {
        callerContext.suspend();
    }
    // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
    calleeRealm.stack.push(calleeContext);
    // 13. NOTE: Any exception objects produced after this point are associated with calleeRealm.
    // 14. Return calleeContext.
    return calleeContext;
}
// http://www.ecma-international.org/ecma-262/#sec-ordinarycallbindthis
function $OrdinaryCallBindThis(ctx, F, calleeContext, thisArgument) {
    // 1. Let thisMode be F.[[ThisMode]].
    const thisMode = F['[[ThisMode]]'];
    // 2. If thisMode is lexical, return NormalCompletion(undefined).
    if (thisMode === 'lexical') {
        return new $Undefined(ctx.Realm);
    }
    // 3. Let calleeRealm be F.[[Realm]].'];
    const calleeRealm = F['[[Realm]]'];
    // 4. Let localEnv be the LexicalEnvironment of calleeContext.
    const localEnv = calleeContext.LexicalEnvironment;
    let thisValue;
    // 5. If thisMode is strict, let thisValue be thisArgument.
    if (thisMode === 'strict') {
        thisValue = thisArgument;
    }
    // 6. Else,
    else {
        // 6. a. If thisArgument is undefined or null, then
        if (thisArgument.isNil) {
            // 6. a. i. Let globalEnv be calleeRealm.[[GlobalEnv]].
            // 6. a. ii. Let globalEnvRec be globalEnv's EnvironmentRecord.
            const globalEnvRec = calleeRealm['[[GlobalEnv]]'];
            // 6. a. iii. Assert: globalEnvRec is a global Environment Record.
            // 6. a. iv. Let thisValue be globalEnvRec.[[GlobalThisValue]].
            thisValue = globalEnvRec['[[GlobalThisValue]]'];
        }
        // 6. b. Else,
        else {
            // 6. b. i. Let thisValue be ! ToObject(thisArgument).
            thisValue = thisArgument.ToObject(ctx);
            // 6. b. ii. NOTE: ToObject produces wrapper objects using calleeRealm.
        }
    }
    // 7. Let envRec be localEnv's EnvironmentRecord.
    const envRec = localEnv;
    // 8. Assert: envRec is a function Environment Record.
    // 9. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not "initialized".
    // 10. Return envRec.BindThisValue(thisValue).
    return envRec.BindThisValue(ctx, thisValue);
}
// http://www.ecma-international.org/ecma-262/#sec-built-in-function-objects
class $BuiltinFunction extends $Function {
    // http://www.ecma-international.org/ecma-262/#sec-createbuiltinfunction
    // 9.3.3 CreateBuiltinFunction ( steps , internalSlotsList [ , realm [ , prototype ] ] )
    constructor(realm, IntrinsicName, proto) {
        super(realm, IntrinsicName, proto);
        // 1. Assert: steps is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.
        // 2. If realm is not present, set realm to the current Realm Record.
        // 3. Assert: realm is a Realm Record.
        // 4. If prototype is not present, set prototype to realm.[[Intrinsics]].[[%FunctionPrototype%]].
        // 5. Let func be a new built-in function object that when called performs the action described by steps. The new function object has internal slots whose names are the elements of internalSlotsList. The initial value of each of those internal slots is undefined.
        // 6. Set func.[[Realm]] to realm.
        this['[[Realm]]'] = realm;
        // 7. Set func.[[Prototype]] to prototype. // done by $Object
        // 8. Set func.[[Extensible]] to true. // done by $Object
        // 9. Set func.[[ScriptOrModule]] to null.
        this['[[ScriptOrModule]]'] = realm['[[Intrinsics]]'].null;
        // 10. Return func.
    }
    // http://www.ecma-international.org/ecma-262/#sec-built-in-function-objects-call-thisargument-argumentslist
    // 9.3.1 [[Call]] ( thisArgument , argumentsList )
    '[[Call]]'(ctx, thisArgument, argumentsList) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let callerContext be the running execution context.
        const callerContext = ctx;
        // 2. If callerContext is not already suspended, suspend callerContext.
        if (!callerContext.suspended) {
            callerContext.suspend();
        }
        // 3. Let calleeContext be a new ECMAScript code execution context.
        const calleeRealm = this['[[Realm]]'];
        const calleeContext = new ExecutionContext(calleeRealm);
        // 4. Set the Function of calleeContext to F.
        calleeContext.Function = this;
        // 5. Let calleeRealm be F.[[Realm]].
        // 6. Set the Realm of calleeContext to calleeRealm.
        // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
        calleeContext.ScriptOrModule = this['[[ScriptOrModule]]'];
        // 8. Perform any necessary implementation-defined initialization of calleeContext.
        // 9. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
        realm.stack.push(calleeContext);
        // 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that conforms to the specification of F. thisArgument is the this value, argumentsList provides the named parameters, and the NewTarget value is undefined.
        const result = this.performSteps(calleeContext, thisArgument, argumentsList, intrinsics.undefined);
        // 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        realm.stack.pop();
        callerContext.resume();
        // 12. Return result.
        return result;
    }
    // http://www.ecma-international.org/ecma-262/#sec-built-in-function-objects-construct-argumentslist-newtarget
    // 9.3.2 [[Construct]] ( argumentsList , newTarget )
    '[[Construct]]'(ctx, argumentsList, newTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let callerContext be the running execution context.
        const callerContext = ctx;
        // 2. If callerContext is not already suspended, suspend callerContext.
        if (!callerContext.suspended) {
            callerContext.suspend();
        }
        // 3. Let calleeContext be a new ECMAScript code execution context.
        const calleeRealm = this['[[Realm]]'];
        const calleeContext = new ExecutionContext(calleeRealm);
        // 4. Set the Function of calleeContext to F.
        calleeContext.Function = this;
        // 5. Let calleeRealm be F.[[Realm]].
        // 6. Set the Realm of calleeContext to calleeRealm.
        // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].
        calleeContext.ScriptOrModule = this['[[ScriptOrModule]]'];
        // 8. Perform any necessary implementation-defined initialization of calleeContext.
        // 9. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.
        realm.stack.push(calleeContext);
        // 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that conforms to the specification of F. The this value is uninitialized, argumentsList provides the named parameters, and newTarget provides the NewTarget value.
        const result = this.performSteps(calleeContext, intrinsics.undefined, argumentsList, newTarget);
        // 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.
        realm.stack.pop();
        callerContext.resume();
        // 12. Return result.
        return result;
    }
}

class $ValueRecord {
    constructor(value) {
        this['[[Value]]'] = value;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-get-regexp-@@species
// http://www.ecma-international.org/ecma-262/#sec-get-array-@@species
// http://www.ecma-international.org/ecma-262/#sec-get-%typedarray%-@@species
// http://www.ecma-international.org/ecma-262/#sec-get-map-@@species
// http://www.ecma-international.org/ecma-262/#sec-get-set-@@species
// http://www.ecma-international.org/ecma-262/#sec-get-arraybuffer-@@species
// http://www.ecma-international.org/ecma-262/#sec-sharedarraybuffer-@@species
// http://www.ecma-international.org/ecma-262/#sec-get-promise-@@species
class $GetSpecies extends $BuiltinFunction {
    constructor(realm) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'get [@@species]', intrinsics['%FunctionPrototype%']);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        return thisArgument;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-array-exotic-objects
class $ArrayExoticObject extends $Object {
    get isArray() { return true; }
    // http://www.ecma-international.org/ecma-262/#sec-arraycreate
    // 9.4.2.2 ArrayCreate ( length [ , proto ] )
    constructor(realm, length, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        if (proto === void 0) {
            proto = intrinsics['%ArrayPrototype%'];
        }
        super(realm, 'ArrayExoticObject', proto, 1 /* normal */, intrinsics.empty);
        // 1. Assert: length is an integer Number ≥ 0.
        // 2. If length is -0, set length to +0.
        if (length.is(intrinsics['-0'])) {
            length = intrinsics['0'];
        }
        // 3. If length > 232 - 1, throw a RangeError exception.
        if (length['[[Value]]'] > (2 ** 32 - 1)) {
            // TODO: move logic to static method so we can return an error completion
            throw new RangeError('3. If length > 2^32 - 1, throw a RangeError exception.');
        }
        // 4. If proto is not present, set proto to the intrinsic object %ArrayPrototype%.
        // 5. Let A be a newly created Array exotic object.
        // 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.
        // 7. Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.
        // 8. Set A.[[Prototype]] to proto.
        // 9. Set A.[[Extensible]] to true.
        // 10. Perform ! OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        super['[[DefineOwnProperty]]'](realm.stack.top, intrinsics.length, new $PropertyDescriptor(realm, intrinsics.length, {
            '[[Value]]': length,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
        // 11. Return A.
    }
    // http://www.ecma-international.org/ecma-262/#sec-array-exotic-objects-defineownproperty-p-desc
    // 9.4.2.1 [[DefineOwnProperty]] ( P , Desc )
    '[[DefineOwnProperty]]'(ctx, P, Desc) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. If P is "length", then
        if (P.is(intrinsics.length)) {
            // 2. a. Return ? ArraySetLength(A, Desc).
            return this.ArraySetLength(ctx, Desc);
        }
        // 3. Else if P is an array index, then
        else if (P.IsArrayIndex) {
            // 3. a. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").
            const oldLenDesc = super['[[GetOwnProperty]]'](ctx, intrinsics.length);
            // 3. b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.
            // 3. c. Let oldLen be oldLenDesc.[[Value]].
            const oldLen = oldLenDesc['[[Value]]'];
            // 3. d. Let index be ! ToUint32(P).
            const index = P.ToUint32(ctx);
            // 3. e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.
            if (index['[[Value]]'] >= oldLen['[[Value]]'] && oldLenDesc['[[Writable]]'].isFalsey) {
                return intrinsics.false;
            }
            // 3. f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).
            const succeeded = super['[[DefineOwnProperty]]'](ctx, P, Desc);
            // 3. g. If succeeded is false, return false.
            if (succeeded.isFalsey) {
                return intrinsics.false;
            }
            // 3. h. If index ≥ oldLen, then
            if (index['[[Value]]'] >= oldLen['[[Value]]']) {
                // 3. h. i. Set oldLenDesc.[[Value]] to index + 1.
                oldLenDesc['[[Value]]'] = new $Number(realm, index['[[Value]]'] + 1);
                // 3. h. ii. Let succeeded be OrdinaryDefineOwnProperty(A, "length", oldLenDesc).
                super['[[DefineOwnProperty]]'](ctx, intrinsics.length, oldLenDesc);
                // 3. h. iii. Assert: succeeded is true.
            }
            // 3. i. Return true.
            return intrinsics.true;
        }
        // 4. Return OrdinaryDefineOwnProperty(A, P, Desc).
        return super['[[DefineOwnProperty]]'](ctx, P, Desc);
    }
    // http://www.ecma-international.org/ecma-262/#sec-arraysetlength
    // 9.4.2.4 ArraySetLength ( A , Desc )
    ArraySetLength(ctx, Desc) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If Desc.[[Value]] is absent, then
        if (Desc['[[Value]]'].isEmpty) {
            // 1. a. Return OrdinaryDefineOwnProperty(A, "length", Desc).
            return super['[[DefineOwnProperty]]'](ctx, intrinsics.length, Desc);
        }
        // 2. Let newLenDesc be a copy of Desc.
        const newLenDesc = new $PropertyDescriptor(Desc.realm, Desc.name, {
            '[[Writable]]': Desc['[[Writable]]'],
            '[[Enumerable]]': Desc['[[Enumerable]]'],
            '[[Configurable]]': Desc['[[Configurable]]'],
        });
        // 3. Let newLen be ? ToUint32(Desc.[[Value]]).
        const newLen = Desc['[[Value]]'].ToUint32(ctx);
        if (newLen.isAbrupt) {
            return newLen;
        }
        // 4. Let numberLen be ? ToNumber(Desc.[[Value]]).
        const numberLen = Desc['[[Value]]'].ToNumber(ctx);
        if (numberLen.isAbrupt) {
            return numberLen;
        }
        // 5. If newLen ≠ numberLen, throw a RangeError exception.
        if (!newLen.is(numberLen)) {
            return new $RangeError(ctx.Realm, '5. If newLen ≠ numberLen, throw a RangeError exception.');
        }
        // 6. Set newLenDesc.[[Value]] to newLen.
        newLenDesc['[[Value]]'] = newLen;
        // 7. Let oldLenDesc be OrdinaryGetOwnProperty(A, "length").
        const oldLenDesc = super['[[GetOwnProperty]]'](ctx, intrinsics.length);
        // 8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.
        // 9. Let oldLen be oldLenDesc.[[Value]].
        const oldLen = oldLenDesc['[[Value]]'];
        // 10. If newLen ≥ oldLen, then
        if (newLen['[[Value]]'] >= oldLen['[[Value]]']) {
            // 10. a. Return OrdinaryDefineOwnProperty(A, "length", newLenDesc).
            return super['[[DefineOwnProperty]]'](ctx, intrinsics.length, newLenDesc);
        }
        // 11. If oldLenDesc.[[Writable]] is false, return false.
        if (oldLenDesc['[[Writable]]'].isFalsey) {
            return intrinsics.false;
        }
        let newWritable;
        // 12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
        if (newLenDesc['[[Writable]]'].isEmpty || newLenDesc['[[Writable]]'].isTruthy) {
            newWritable = true;
        }
        // 13. Else,
        else {
            // 13. a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
            // 13. b. Let newWritable be false.
            newWritable = false;
            // 13. c. Set newLenDesc.[[Writable]] to true.
            newLenDesc['[[Writable]]'] = intrinsics.true;
        }
        // 14. Let succeeded be ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
        const succeeded = super['[[DefineOwnProperty]]'](ctx, intrinsics.length, newLenDesc);
        // 15. If succeeded is false, return false.
        if (succeeded.isFalsey) {
            return intrinsics.false;
        }
        const $newLen = newLen['[[Value]]'];
        let $oldLen = oldLen['[[Value]]'];
        // 16. Repeat, while newLen < oldLen,
        while ($newLen < $oldLen) {
            // 16. a. Decrease oldLen by 1.
            --$oldLen;
            // 16. b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).
            const deleteSucceeded = this['[[Delete]]'](ctx, new $Number(realm, $oldLen).ToString(ctx));
            // 16. c. If deleteSucceeded is false, then
            if (deleteSucceeded.isFalsey) {
                // 16. c. i. Set newLenDesc.[[Value]] to oldLen + 1.
                newLenDesc['[[Value]]'] = new $Number(realm, $oldLen + 1);
                // 16. c. ii. If newWritable is false, set newLenDesc.[[Writable]] to false.
                if (!newWritable) {
                    newLenDesc['[[Writable]]'] = intrinsics.false;
                }
                // 16. c. iii. Perform ! OrdinaryDefineOwnProperty(A, "length", newLenDesc).
                super['[[DefineOwnProperty]]'](ctx, intrinsics.length, newLenDesc);
                // 16. c. iv. Return false.
                return intrinsics.false;
            }
        }
        // 17. If newWritable is false, then
        if (!newWritable) {
            // 17. a. Return OrdinaryDefineOwnProperty(A, "length", PropertyDescriptor { [[Writable]]: false }). This call will always return true.
            return super['[[DefineOwnProperty]]'](ctx, intrinsics.length, new $PropertyDescriptor(realm, intrinsics.length, {
                '[[Writable]]': intrinsics.false,
            }));
        }
        // 18. Return true.
        return intrinsics.true;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-createarrayfromlist
function $CreateArrayFromList(ctx, elements) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: elements is a List whose elements are all ECMAScript language values.
    // 2. Let array be ! ArrayCreate(0).
    const array = new $ArrayExoticObject(realm, intrinsics['0']);
    // 3. Let n be 0.
    let n = 0;
    // 4. For each element e of elements, do
    for (const e of elements) {
        // 4. a. Let status be CreateDataProperty(array, ! ToString(n), e).
        $CreateDataProperty(ctx, array, new $String(realm, n.toString()), e);
        // 4. b. Assert: status is true.
        // 4. c. Increment n by 1.
        ++n;
    }
    // 5. Return array.
    return array;
}

// http://www.ecma-international.org/ecma-262/#sec-promise-abstract-operations
// #region 25.6.1 Promise Abstract Operation
// http://www.ecma-international.org/ecma-262/#sec-promisecapability-records
// 25.6.1.1 PromiseCapability Records
class $PromiseCapability {
    constructor(promise, resolve, reject) {
        this['[[Promise]]'] = promise;
        this['[[Resolve]]'] = resolve;
        this['[[Reject]]'] = reject;
    }
    get isUndefined() { return false; }
    get isAbrupt() { return false; }
}
// http://www.ecma-international.org/ecma-262/#sec-ifabruptrejectpromise
// 25.6.1.1.1 IfAbruptRejectPromise ( value , capability )
function $IfAbruptRejectPromise(ctx, value, capability) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If value is an abrupt completion, then
    if (value.isAbrupt) {
        // 1. a. Perform ? Call(capability.[[Reject]], undefined, « value.[[Value]] »).
        const $CallResult = $Call(ctx, capability['[[Reject]]'], intrinsics.undefined, new $List(value));
        if ($CallResult.isAbrupt) {
            return $CallResult;
        }
        // 1. b. Return capability.[[Promise]].
        return capability['[[Promise]]'];
    }
    // 2. Else if value is a Completion Record, set value to value.[[Value]].
    return value;
}
var PromiseReactionType;
(function (PromiseReactionType) {
    PromiseReactionType[PromiseReactionType["Fulfill"] = 1] = "Fulfill";
    PromiseReactionType[PromiseReactionType["Reject"] = 2] = "Reject";
})(PromiseReactionType || (PromiseReactionType = {}));
// http://www.ecma-international.org/ecma-262/#sec-promisereaction-records
// 25.6.1.2 PromiseReaction Records
class $PromiseReaction {
    constructor(capability, type, handler) {
        this['[[Capability]]'] = capability;
        this['[[Type]]'] = type;
        this['[[Handler]]'] = handler;
    }
    is(other) {
        return this === other;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-createresolvingfunctions
// 25.6.1.3 CreateResolvingFunctions ( promise )
class $PromiseResolvingFunctions {
    constructor(realm, promise) {
        // 1. Let alreadyResolved be a new Record { [[Value]]: false }.
        const alreadyResolved = new $ValueRecord(false);
        // 2. Let stepsResolve be the algorithm steps defined in Promise Resolve Functions (25.6.1.3.2).
        // 3. Let resolve be CreateBuiltinFunction(stepsResolve, « [[Promise]], [[AlreadyResolved]] »).
        // 4. Set resolve.[[Promise]] to promise.
        // 5. Set resolve.[[AlreadyResolved]] to alreadyResolved.
        this['[[Resolve]]'] = new $PromiseResolveFunction(realm, promise, alreadyResolved);
        // 6. Let stepsReject be the algorithm steps defined in Promise Reject Functions (25.6.1.3.1).
        // 7. Let reject be CreateBuiltinFunction(stepsReject, « [[Promise]], [[AlreadyResolved]] »).
        // 8. Set reject.[[Promise]] to promise.
        // 9. Set reject.[[AlreadyResolved]] to alreadyResolved.
        this['[[Reject]]'] = new $PromiseRejectFunction(realm, promise, alreadyResolved);
        // 10. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise-reject-functions
// 25.6.1.3.1 Promise Reject Functions
class $PromiseRejectFunction extends $BuiltinFunction {
    constructor(realm, promise, alreadyResolved) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'PromiseRejectFunction', intrinsics['%FunctionPrototype%']);
        this['[[Promise]]'] = promise;
        this['[[AlreadyResolved]]'] = alreadyResolved;
    }
    performSteps(ctx, thisArgument, [reason], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (reason === void 0) {
            reason = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Assert: F has a [[Promise]] internal slot whose value is an Object.
        // 3. Let promise be F.[[Promise]].
        const promise = F['[[Promise]]'];
        // 4. Let alreadyResolved be F.[[AlreadyResolved]].
        const alreadyResolved = F['[[AlreadyResolved]]'];
        // 5. If alreadyResolved.[[Value]] is true, return undefined.
        if (alreadyResolved['[[Value]]']) {
            return intrinsics.undefined;
        }
        // 6. Set alreadyResolved.[[Value]] to true.
        alreadyResolved['[[Value]]'] = true;
        // 7. Return RejectPromise(promise, reason).
        return $RejectPromise(ctx, promise, reason);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise-resolve-functions
// 25.6.1.3.2 Promise Resolve Functions
class $PromiseResolveFunction extends $BuiltinFunction {
    constructor(realm, promise, alreadyResolved) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'PromiseResolveFunction', intrinsics['%FunctionPrototype%']);
        this['[[Promise]]'] = promise;
        this['[[AlreadyResolved]]'] = alreadyResolved;
    }
    performSteps(ctx, thisArgument, [resolution], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (resolution === void 0) {
            resolution = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Assert: F has a [[Promise]] internal slot whose value is an Object.
        // 3. Let promise be F.[[Promise]].
        const promise = F['[[Promise]]'];
        // 4. Let alreadyResolved be F.[[AlreadyResolved]].
        const alreadyResolved = F['[[AlreadyResolved]]'];
        // 5. If alreadyResolved.[[Value]] is true, return undefined.
        if (alreadyResolved['[[Value]]']) {
            return intrinsics.undefined;
        }
        // 6. Set alreadyResolved.[[Value]] to true.
        alreadyResolved['[[Value]]'] = true;
        // 7. If SameValue(resolution, promise) is true, then
        if (resolution.is(promise)) {
            // 7. a. Let selfResolutionError be a newly created TypeError object.
            const selfResolutionError = new $TypeError(realm, `Failed to resolve self`); // ?
            // 7. b. Return RejectPromise(promise, selfResolutionError).
            return $RejectPromise(ctx, promise, selfResolutionError);
        }
        // 8. If Type(resolution) is not Object, then
        if (!resolution.isObject) {
            // 8. a. Return FulfillPromise(promise, resolution).
            return $FulfillPromise(ctx, promise, resolution);
        }
        // 9. Let then be Get(resolution, "then").
        const then = resolution['[[Get]]'](ctx, intrinsics.then, resolution);
        // 10. If then is an abrupt completion, then
        if (then.isAbrupt) {
            // 10. a. Return RejectPromise(promise, then.[[Value]]).
            return $RejectPromise(ctx, promise, then);
        }
        // 11. Let thenAction be then.[[Value]].
        // 12. If IsCallable(thenAction) is false, then
        if (!then.isFunction) {
            // 12. a. Return FulfillPromise(promise, resolution).
            return $FulfillPromise(ctx, promise, resolution);
        }
        // 13. Perform EnqueueJob("PromiseJobs", PromiseResolveThenableJob, « promise, resolution, thenAction »).
        const mos = ctx.ScriptOrModule;
        if (mos.isNull) {
            throw new Error(`No ScriptOrModule found in this realm`);
        }
        realm.PromiseJobs.EnqueueJob(ctx, new PromiseResolveThenableJob(realm, mos, promise, resolution, then));
        // 14. Return undefined.
        return new $Undefined(realm);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-fulfillpromise
// 25.6.1.4 FulfillPromise ( promise , value )
function $FulfillPromise(ctx, promise, value) {
    const realm = ctx.Realm;
    realm['[[Intrinsics]]'];
    // 1. Assert: The value of promise.[[PromiseState]] is "pending".
    // 2. Let reactions be promise.[[PromiseFulfillReactions]].
    const reactions = promise['[[PromiseFulfillReactions]]'];
    // 3. Set promise.[[PromiseResult]] to value.
    promise['[[PromiseResult]]'] = value;
    // 4. Set promise.[[PromiseFulfillReactions]] to undefined.
    promise['[[PromiseFulfillReactions]]'] = void 0;
    // 5. Set promise.[[PromiseRejectReactions]] to undefined.
    promise['[[PromiseRejectReactions]]'] = void 0;
    // 6. Set promise.[[PromiseState]] to "fulfilled".
    promise['[[PromiseState]]'] = 2 /* fulfilled */;
    // 7. Return TriggerPromiseReactions(reactions, value).
    return $TriggerPromiseReactions(ctx, reactions, value);
}
// http://www.ecma-international.org/ecma-262/#sec-newpromisecapability
// 25.6.1.5 NewPromiseCapability ( C )
function $NewPromiseCapability(ctx, C) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If IsConstructor(C) is false, throw a TypeError exception.
    if (!C.isFunction) {
        return new $TypeError(realm, `Expected constructor, but got: ${C}`);
    }
    // 2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.6.3.1).
    // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.
    const promiseCapability = new $PromiseCapability(intrinsics.undefined, intrinsics.undefined, intrinsics.undefined);
    // 4. Let steps be the algorithm steps defined in GetCapabilitiesExecutor Functions.
    // 5. Let executor be CreateBuiltinFunction(steps, « [[Capability]] »).
    // 6. Set executor.[[Capability]] to promiseCapability.
    const executor = new $GetCapabilitiesExecutor(realm, promiseCapability);
    // 7. Let promise be ? Construct(C, « executor »).
    const promise = $Construct(ctx, C, new $List(executor), intrinsics.undefined);
    // 8. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.
    if (!promiseCapability['[[Resolve]]'].isFunction) {
        return new $TypeError(realm, `Expected [[Resolve]] to be callable, but got: ${promiseCapability['[[Resolve]]']}`);
    }
    // 9. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.
    if (!promiseCapability['[[Reject]]'].isFunction) {
        return new $TypeError(realm, `Expected [[Reject]] to be callable, but got: ${promiseCapability['[[Reject]]']}`);
    }
    // 10. Set promiseCapability.[[Promise]] to promise.
    promiseCapability['[[Promise]]'] = promise;
    // 11. Return promiseCapability.
    return promiseCapability;
}
// http://www.ecma-international.org/ecma-262/#sec-getcapabilitiesexecutor-functions
// 25.6.1.5.1 GetCapabilitiesExecutor Functions
class $GetCapabilitiesExecutor extends $BuiltinFunction {
    constructor(realm, capability) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'GetCapabilitiesExecutor', intrinsics['%FunctionPrototype%']);
        this['[[Capability]]'] = capability;
    }
    performSteps(ctx, thisArgument, [resolve, reject], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (resolve === void 0) {
            resolve = intrinsics.undefined;
        }
        if (reject === void 0) {
            reject = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.
        // 3. Let promiseCapability be F.[[Capability]].
        const promiseCapability = F['[[Capability]]'];
        // 4. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.
        if (!promiseCapability['[[Resolve]]'].isUndefined) {
            return new $TypeError(realm, `[[Resolve]] is already defined`);
        }
        // 5. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.
        if (!promiseCapability['[[Reject]]'].isUndefined) {
            return new $TypeError(realm, `[[Reject]] is already defined`);
        }
        // 6. Set promiseCapability.[[Resolve]] to resolve.
        promiseCapability['[[Resolve]]'] = resolve;
        // 7. Set promiseCapability.[[Reject]] to reject.
        promiseCapability['[[Reject]]'] = reject;
        // 8. Return undefined.
        return intrinsics.undefined;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-rejectpromise
// 25.6.1.7 RejectPromise ( promise , reason )
function $RejectPromise(ctx, promise, reason) {
    const realm = ctx.Realm;
    realm['[[Intrinsics]]'];
    // 1. Assert: The value of promise.[[PromiseState]] is "pending".
    // 2. Let reactions be promise.[[PromiseRejectReactions]].
    const reactions = promise['[[PromiseRejectReactions]]'];
    // 3. Set promise.[[PromiseResult]] to reason.
    promise['[[PromiseResult]]'] = reason;
    // 4. Set promise.[[PromiseFulfillReactions]] to undefined.
    promise['[[PromiseFulfillReactions]]'] = void 0;
    // 5. Set promise.[[PromiseRejectReactions]] to undefined.
    promise['[[PromiseRejectReactions]]'] = void 0;
    // 6. Set promise.[[PromiseState]] to "rejected".
    promise['[[PromiseState]]'] = 3 /* rejected */;
    // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, "reject").
    if (!promise['[[PromiseIsHandled]]']) {
        $HostPromiseRejectionTracker(ctx, promise);
    }
    // 8. Return TriggerPromiseReactions(reactions, reason).
    return $TriggerPromiseReactions(ctx, reactions, reason);
}
// http://www.ecma-international.org/ecma-262/#sec-triggerpromisereactions
// 25.6.1.8 TriggerPromiseReactions ( reactions , argument )
function $TriggerPromiseReactions(ctx, reactions, argument) {
    const realm = ctx.Realm;
    realm['[[Intrinsics]]'];
    const promiseJobs = realm.PromiseJobs;
    const mos = ctx.ScriptOrModule;
    if (mos.isNull) {
        throw new Error(`No ScriptOrModule found in this realm`);
    }
    // 1. For each reaction in reactions, in original insertion order, do
    for (const reaction of reactions) {
        // 1. a. Perform EnqueueJob("PromiseJobs", PromiseReactionJob, « reaction, argument »).
        promiseJobs.EnqueueJob(ctx, new PromiseReactionJob(realm, mos, reaction, argument));
    }
    // 2. Return undefined.
    return new $Undefined(realm);
}
var PromiseRejectionOperation;
(function (PromiseRejectionOperation) {
    PromiseRejectionOperation[PromiseRejectionOperation["reject"] = 1] = "reject";
    PromiseRejectionOperation[PromiseRejectionOperation["handle"] = 2] = "handle";
})(PromiseRejectionOperation || (PromiseRejectionOperation = {}));
// http://www.ecma-international.org/ecma-262/#sec-host-promise-rejection-tracker
// 25.6.1.9 HostPromiseRejectionTracker ( promise , operation )
function $HostPromiseRejectionTracker(ctx, promise, operation) {
    ctx.logger.error(`Promise rejected: ${promise}`);
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-promise-jobs
// #region 25.6.2 Promise Jobs
class PromiseReactionJob extends Job {
    constructor(realm, scriptOrModule, reaction, argument) {
        super(realm.logger.root, realm, scriptOrModule);
        this.reaction = reaction;
        this.argument = argument;
    }
    // http://www.ecma-international.org/ecma-262/#sec-promisereactionjob
    // 25.6.2.1 PromiseReactionJob ( reaction , argument )
    Run(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`Run(#${ctx.id})`);
        const reaction = this.reaction;
        const argument = this.argument;
        // 1. Assert: reaction is a PromiseReaction Record.
        // 2. Let promiseCapability be reaction.[[Capability]].
        const promiseCapability = reaction['[[Capability]]'];
        // 3. Let type be reaction.[[Type]].
        const type = reaction['[[Type]]'];
        // 4. Let handler be reaction.[[Handler]].
        const handler = reaction['[[Handler]]'];
        let handlerResult;
        // 5. If handler is undefined, then
        if (handler.isUndefined) {
            // 5. a. If type is "Fulfill", let handlerResult be NormalCompletion(argument).
            if (type === 1 /* Fulfill */) {
                handlerResult = argument;
            }
            // 5. b. Else,
            else {
                // 5. b. i. Assert: type is "Reject".
                // 5. b. ii. Let handlerResult be ThrowCompletion(argument).
                handlerResult = argument.ToCompletion(5 /* throw */, intrinsics.empty);
            }
        }
        // 6. Else, let handlerResult be Call(handler, undefined, « argument »).
        else {
            handlerResult = $Call(ctx, handler, intrinsics.undefined, new $List(argument));
        }
        // 7. If promiseCapability is undefined, then
        if (promiseCapability.isUndefined) {
            // 7. a. Assert: handlerResult is not an abrupt completion.
            // 7. b. Return NormalCompletion(empty).
            return new $Empty(realm);
        }
        let status;
        // 8. If handlerResult is an abrupt completion, then
        if (handlerResult.isAbrupt) {
            // 8. a. Let status be Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).
            status = $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(handlerResult));
        }
        // 9. Else,
        else {
            // 9. a. Let status be Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »).
            status = $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(handlerResult));
        }
        // 10. Return Completion(status).
        return status;
    }
}
class PromiseResolveThenableJob extends Job {
    constructor(realm, scriptOrModule, promiseToResolve, thenable, then) {
        super(realm.logger.root, realm, scriptOrModule);
        this.promiseToResolve = promiseToResolve;
        this.thenable = thenable;
        this.then = then;
    }
    // http://www.ecma-international.org/ecma-262/#sec-promiseresolvethenablejob
    // 25.6.2.2 PromiseResolveThenableJob ( promiseToResolve , thenable , then )
    Run(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`Run(#${ctx.id})`);
        const promiseToResolve = this.promiseToResolve;
        const thenable = this.thenable;
        const then = this.then;
        // 1. Let resolvingFunctions be CreateResolvingFunctions(promiseToResolve).
        const resolvingFunctions = new $PromiseResolvingFunctions(realm, promiseToResolve);
        // 2. Let thenCallResult be Call(then, thenable, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).
        const thenCallResult = $Call(ctx, then, thenable, new $List(resolvingFunctions['[[Resolve]]'], resolvingFunctions['[[Reject]]']));
        // 3. If thenCallResult is an abrupt completion, then
        if (thenCallResult.isAbrupt) {
            // 3. a. Let status be Call(resolvingFunctions.[[Reject]], undefined, « thenCallResult.[[Value]] »).
            const status = $Call(ctx, resolvingFunctions['[[Reject]]'], intrinsics.undefined, new $List(thenCallResult));
            // 3. b. Return Completion(status).
            return status;
        }
        // 4. Return Completion(thenCallResult).
        return thenCallResult;
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-promise-constructor
// #region 25.6.3 The Promise Constructor
class $PromiseConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-promise.prototype
    // 25.6.4.2 Promise.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.all
    // 25.6.4.1 Promise.all ( iterable )
    get all() {
        return this.getProperty(this.realm['[[Intrinsics]]'].all)['[[Value]]'];
    }
    set all(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].all, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.race
    // 25.6.4.3 Promise.race ( iterable )
    get race() {
        return this.getProperty(this.realm['[[Intrinsics]]'].race)['[[Value]]'];
    }
    set race(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].race, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.reject
    // 25.6.4.4 Promise.reject ( r )
    get reject() {
        return this.getProperty(this.realm['[[Intrinsics]]'].reject)['[[Value]]'];
    }
    set reject(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].reject, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.resolve
    // 25.6.4.5 Promise.resolve ( x )
    get resolve() {
        return this.getProperty(this.realm['[[Intrinsics]]'].resolve)['[[Value]]'];
    }
    set resolve(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].resolve, value, false, false, false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-get-promise-@@species
    // 25.6.4.6 get Promise [ @@species ]
    get ['@@species']() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@species'])['[[Value]]'];
    }
    set ['@@species'](value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@species'], value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Promise%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise-executor
    // 25.6.3.1 Promise ( executor )
    performSteps(ctx, thisArgument, [executor], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, throw a TypeError exception.
        if (NewTarget.isUndefined) {
            return new $TypeError(realm, `Promise cannot be called as a function.`);
        }
        // 2. If IsCallable(executor) is false, throw a TypeError exception.
        if (executor === void 0 || !executor.isFunction) {
            return new $TypeError(realm, `The promise constructor requires an executor function`);
        }
        // 3. Let promise be ? OrdinaryCreateFromConstructor(NewTarget, "%PromisePrototype%", « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).
        const promise = $PromiseInstance.Create(ctx, NewTarget);
        if (promise.isAbrupt) {
            return promise;
        }
        // 4. Set promise.[[PromiseState]] to "pending".
        promise['[[PromiseState]]'] = 1 /* pending */;
        // 5. Set promise.[[PromiseFulfillReactions]] to a new empty List.
        promise['[[PromiseFulfillReactions]]'] = new $List();
        // 6. Set promise.[[PromiseRejectReactions]] to a new empty List.
        promise['[[PromiseRejectReactions]]'] = new $List();
        // 7. Set promise.[[PromiseIsHandled]] to false.
        promise['[[PromiseIsHandled]]'] = false;
        // 8. Let resolvingFunctions be CreateResolvingFunctions(promise).
        const resolvingFunctions = new $PromiseResolvingFunctions(realm, promise);
        // 9. Let completion be Call(executor, undefined, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).
        const completion = $Call(ctx, executor, intrinsics.undefined, new $List(resolvingFunctions['[[Resolve]]'], resolvingFunctions['[[Reject]]']));
        // 10. If completion is an abrupt completion, then
        if (completion.isAbrupt) {
            // 10. a. Perform ? Call(resolvingFunctions.[[Reject]], undefined, « completion.[[Value]] »).
            const $CallResult = $Call(ctx, resolvingFunctions['[[Reject]]'], intrinsics.undefined, new $List(completion));
            if ($CallResult.isAbrupt) {
                return $CallResult;
            }
        }
        // 11. Return promise.
        return promise;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-promise-constructor
// 25.6.4 Properties of the Promise Constructor
// http://www.ecma-international.org/ecma-262/#sec-promise.all
// 25.6.4.1 Promise.all ( iterable )
class $Promise_all extends $BuiltinFunction {
    constructor(realm, functionPrototype) {
        super(realm, '%Promise_all%', functionPrototype);
    }
    performSteps(ctx, thisArgument, [iterable], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (iterable === void 0) {
            iterable = intrinsics.undefined;
        }
        // 1. Let C be the this value.
        const C = thisArgument;
        // 2. If Type(C) is not Object, throw a TypeError exception.
        if (!C.isObject) {
            return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);
        }
        // 3. Let promiseCapability be ? NewPromiseCapability(C).
        const promiseCapability = $NewPromiseCapability(ctx, C);
        if (promiseCapability.isAbrupt) {
            return promiseCapability;
        }
        // 4. Let iteratorRecord be GetIterator(iterable).
        const iteratorRecord = $GetIterator(ctx, iterable);
        if (iteratorRecord.isAbrupt) {
            return iteratorRecord;
        } // TODO: we sure about this? spec doesn't say
        // 5. IfAbruptRejectPromise(iteratorRecord, promiseCapability).
        const maybeAbrupt = $IfAbruptRejectPromise(ctx, iteratorRecord, promiseCapability);
        if (maybeAbrupt.isAbrupt) {
            return maybeAbrupt;
        }
        // 6. Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability).
        let result = PerformPromiseAll(ctx, iteratorRecord, C, promiseCapability);
        // 7. If result is an abrupt completion, then
        if (result.isAbrupt) {
            // 7. a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).
            if (iteratorRecord['[[Done]]'].isFalsey) {
                result = $IteratorClose(ctx, iteratorRecord, result);
            }
            // 7. b. IfAbruptRejectPromise(result, promiseCapability).
            const maybeAbrupt = $IfAbruptRejectPromise(ctx, result, promiseCapability);
            if (maybeAbrupt.isAbrupt) {
                return maybeAbrupt;
            }
        }
        // 8. Return Completion(result).
        return result; // TODO: fix typings $Empty shenanigans
    }
}
// http://www.ecma-international.org/ecma-262/#sec-performpromiseall
// 25.6.4.1.1 Runtime Semantics: PerformPromiseAll ( iteratorRecord , constructor , resultCapability )
function PerformPromiseAll(ctx, iteratorRecord, constructor, resultCapability) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: IsConstructor(constructor) is true.
    // 2. Assert: resultCapability is a PromiseCapability Record.
    // 3. Let values be a new empty List.
    const values = new $List();
    // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.
    const remainingElementsCount = new $ValueRecord(1);
    // 5. Let index be 0.
    let index = 0;
    // 6. Repeat,
    while (true) {
        // 6. a. Let next be IteratorStep(iteratorRecord).
        const next = $IteratorStep(ctx, iteratorRecord);
        // 6. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        // 6. c. ReturnIfAbrupt(next).
        if (next.isAbrupt) {
            iteratorRecord['[[Done]]'] = intrinsics.true;
            return next;
        }
        // 6. d. If next is false, then
        if (next.isFalsey) {
            // 6. d. i. Set iteratorRecord.[[Done]] to true.
            iteratorRecord['[[Done]]'] = intrinsics.true;
            // 6. d. ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.
            // 6. d. iii. If remainingElementsCount.[[Value]] is 0, then
            if (--remainingElementsCount['[[Value]]'] === 0) {
                // 6. d. iii. 1. Let valuesArray be CreateArrayFromList(values).
                const valuesArray = $CreateArrayFromList(ctx, values);
                // 6. d. iii. 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).
                const $CallResult = $Call(ctx, resultCapability['[[Resolve]]'], intrinsics.undefined, new $List(valuesArray));
                if ($CallResult.isAbrupt) {
                    return $CallResult;
                }
            }
            // 6. d. iv. Return resultCapability.[[Promise]].
            return resultCapability['[[Promise]]'];
        }
        // 6. e. Let nextValue be IteratorValue(next).
        const nextValue = $IteratorValue(ctx, next);
        // 6. f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.
        // 6. g. ReturnIfAbrupt(nextValue).
        if (nextValue.isAbrupt) {
            iteratorRecord['[[Done]]'] = intrinsics.true;
            return nextValue;
        }
        // 6. h. Append undefined to values.
        values.push(new $Undefined(realm));
        // 6. i. Let nextPromise be ? Invoke(constructor, "resolve", « nextValue »).
        const nextPromise = $Invoke(ctx, constructor, intrinsics.resolve, new $List(nextValue)); // TODO: fix $Empty typing shenanigans
        if (nextPromise.isAbrupt) {
            return nextPromise;
        }
        // 6. j. Let steps be the algorithm steps defined in Promise.all Resolve Element Functions.
        // 6. k. Let resolveElement be CreateBuiltinFunction(steps, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
        // 6. l. Set resolveElement.[[AlreadyCalled]] to a new Record { [[Value]]: false }.
        // 6. m. Set resolveElement.[[Index]] to index.
        // 6. n. Set resolveElement.[[Values]] to values.
        // 6. o. Set resolveElement.[[Capability]] to resultCapability.
        // 6. p. Set resolveElement.[[RemainingElements]] to remainingElementsCount.
        const resolveElement = new $Promise_all_ResolveElement(realm, new $ValueRecord(false), index, values, resultCapability, remainingElementsCount);
        // 6. q. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.
        ++remainingElementsCount['[[Value]]'];
        // 6. r. Perform ? Invoke(nextPromise, "then", « resolveElement, resultCapability.[[Reject]] »).
        const $InvokeResult = $Invoke(ctx, nextPromise, intrinsics.then, new $List(resolveElement, resultCapability['[[Reject]]']));
        if ($InvokeResult.isAbrupt) {
            return $InvokeResult;
        }
        // 6. s. Increase index by 1.
        ++index;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.all-resolve-element-functions
// 25.6.4.1.2 Promise.all Resolve Element Functions
class $Promise_all_ResolveElement extends $BuiltinFunction {
    constructor(realm, alreadyCalled, index, values, capability, remainingElements) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'Promise.all Resolve Element', intrinsics['%FunctionPrototype%']);
        this['[[AlreadyCalled]]'] = alreadyCalled;
        this['[[Index]]'] = index;
        this['[[Values]]'] = values;
        this['[[Capability]]'] = capability;
        this['[[RemainingElements]]'] = remainingElements;
    }
    performSteps(ctx, thisArgument, [x], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (x === void 0) {
            x = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Let alreadyCalled be F.[[AlreadyCalled]].
        const alreadyCalled = F['[[AlreadyCalled]]'];
        // 3. If alreadyCalled.[[Value]] is true, return undefined.
        if (alreadyCalled['[[Value]]']) {
            return intrinsics.undefined;
        }
        // 4. Set alreadyCalled.[[Value]] to true.
        alreadyCalled['[[Value]]'] = true;
        // 5. Let index be F.[[Index]].
        const index = F['[[Index]]'];
        // 6. Let values be F.[[Values]].
        const values = F['[[Values]]'];
        // 7. Let promiseCapability be F.[[Capability]].
        const promiseCapability = F['[[Capability]]'];
        // 8. Let remainingElementsCount be F.[[RemainingElements]].
        const remainingElementsCount = F['[[RemainingElements]]'];
        // 9. Set values[index] to x.
        values[index] = x;
        // 10. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.
        // 11. If remainingElementsCount.[[Value]] is 0, then
        if (--remainingElementsCount['[[Value]]'] === 0) {
            // 11. a. Let valuesArray be CreateArrayFromList(values).
            const valuesArray = $CreateArrayFromList(ctx, values);
            // 11. b. Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).
            return $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(valuesArray));
        }
        // 12. Return undefined.
        return intrinsics.undefined;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.race
// 25.6.4.3 Promise.race ( iterable )
class $Promise_race extends $BuiltinFunction {
    constructor(realm, functionPrototype) {
        super(realm, '%Promise_race%', functionPrototype);
    }
    performSteps(ctx, thisArgument, [iterable], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (iterable === void 0) {
            iterable = intrinsics.undefined;
        }
        // 1. Let C be the this value.
        const C = thisArgument;
        // 2. If Type(C) is not Object, throw a TypeError exception.
        if (!C.isObject) {
            return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);
        }
        // 3. Let promiseCapability be ? NewPromiseCapability(C).
        const promiseCapability = $NewPromiseCapability(ctx, C);
        if (promiseCapability.isAbrupt) {
            return promiseCapability;
        }
        // 4. Let iteratorRecord be GetIterator(iterable).
        const iteratorRecord = $GetIterator(ctx, iterable);
        if (iteratorRecord.isAbrupt) {
            return iteratorRecord;
        } // TODO: we sure about this? spec doesn't say
        // 5. IfAbruptRejectPromise(iteratorRecord, promiseCapability).
        const maybeAbrupt = $IfAbruptRejectPromise(ctx, iteratorRecord, promiseCapability);
        if (maybeAbrupt.isAbrupt) {
            return maybeAbrupt;
        }
        // 6. Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability).
        let result = PerformPromiseAll(ctx, iteratorRecord, C, promiseCapability);
        // 7. If result is an abrupt completion, then
        if (result.isAbrupt) {
            // 7. a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).
            if (iteratorRecord['[[Done]]'].isFalsey) {
                result = $IteratorClose(ctx, iteratorRecord, result);
            }
            // 7. b. IfAbruptRejectPromise(result, promiseCapability).
            const maybeAbrupt = $IfAbruptRejectPromise(ctx, result, promiseCapability);
            if (maybeAbrupt.isAbrupt) {
                return maybeAbrupt;
            }
        }
        // 8. Return Completion(result).
        return result; // TODO: fix typings $Empty shenanigans
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.reject
// 25.6.4.4 Promise.reject ( r )
class $Promise_reject extends $BuiltinFunction {
    constructor(realm, functionPrototype) {
        super(realm, '%Promise_reject%', functionPrototype);
    }
    performSteps(ctx, thisArgument, [r], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (r === void 0) {
            r = intrinsics.undefined;
        }
        // 1. Let C be the this value.
        const C = thisArgument;
        // 2. If Type(C) is not Object, throw a TypeError exception.
        if (!C.isObject) {
            return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);
        }
        // 3. Let promiseCapability be ? NewPromiseCapability(C).
        const promiseCapability = $NewPromiseCapability(ctx, C);
        if (promiseCapability.isAbrupt) {
            return promiseCapability;
        }
        // 4. Perform ? Call(promiseCapability.[[Reject]], undefined, « r »).
        const $CallResult = $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(r));
        if ($CallResult.isAbrupt) {
            return $CallResult;
        }
        // 5. Return promiseCapability.[[Promise]].
        return promiseCapability['[[Promise]]']; // TODO: verify if cast is safe
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.resolve
// 25.6.4.5 Promise.resolve ( x )
class $Promise_resolve extends $BuiltinFunction {
    constructor(realm, functionPrototype) {
        super(realm, '%Promise_resolve%', functionPrototype);
    }
    performSteps(ctx, thisArgument, [x], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (x === void 0) {
            x = intrinsics.undefined;
        }
        // 1. Let C be the this value.
        const C = thisArgument;
        // 2. If Type(C) is not Object, throw a TypeError exception.
        if (!C.isObject) {
            return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);
        }
        // 3. Return ? PromiseResolve(C, x).
        return $PromiseResolve(ctx, C, x);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise-resolve
// 25.6.4.5.1 PromiseResolve ( C , x )
function $PromiseResolve(ctx, C, x) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(C) is Object.
    // 2. If IsPromise(x) is true, then
    if (x instanceof $PromiseInstance) {
        // 2. a. Let xConstructor be ? Get(x, "constructor").
        const xConstructor = x['[[Get]]'](ctx, intrinsics.$constructor, x);
        // 2. b. If SameValue(xConstructor, C) is true, return x.
        if (xConstructor.is(C)) {
            return x;
        }
    }
    // 3. Let promiseCapability be ? NewPromiseCapability(C).
    const promiseCapability = $NewPromiseCapability(ctx, C);
    if (promiseCapability.isAbrupt) {
        return promiseCapability;
    }
    // 4. Perform ? Call(promiseCapability.[[Resolve]], undefined, « x »).
    const $CallResult = $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(x));
    if ($CallResult.isAbrupt) {
        return $CallResult;
    }
    // 5. Return promiseCapability.[[Promise]].
    return promiseCapability['[[Promise]]']; // TODO: verify if cast is safe
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-promise-prototype-object
// #region 25.6.5 Properties of the Promise Prototype Object
class $PromisePrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch
    // 25.6.5.1 Promise.prototype.catch ( onRejected )
    get catch() {
        return this.getProperty(this.realm['[[Intrinsics]]'].catch)['[[Value]]'];
    }
    set catch(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].catch, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.constructor
    // 25.6.5.2 Promise.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.finally
    // 25.6.5.3 Promise.prototype.finally ( onFinally )
    get finally() {
        return this.getProperty(this.realm['[[Intrinsics]]'].finally)['[[Value]]'];
    }
    set finally(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].finally, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.then
    // 25.6.5.4 Promise.prototype.then ( onFulfilled , onRejected )
    get then() {
        return this.getProperty(this.realm['[[Intrinsics]]'].then)['[[Value]]'];
    }
    set then(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].then, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-promise.prototype-@@tostringtag
    // 25.6.5.5 Promise.prototype [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%PromisePrototype%', proto, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch
// 25.6.5.1 Promise.prototype.catch ( onRejected )
class $PromiseProto_catch extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%PromiseProto_catch%', proto);
    }
    performSteps(ctx, thisArgument, [onRejected], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (onRejected === void 0) {
            onRejected = intrinsics.undefined;
        }
        // 1. Let promise be the this value.
        const promise = thisArgument;
        // 2. Return ? Invoke(promise, "then", « undefined, onRejected »).
        return $Invoke(ctx, promise, intrinsics.then, new $List(intrinsics.undefined, onRejected)); // TODO: fix $Empty typings
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.prototype.finally
// 25.6.5.3 Promise.prototype.finally ( onFinally )
class $PromiseProto_finally extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%PromiseProto_finally%', proto);
    }
    performSteps(ctx, thisArgument, [onFinally], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (onFinally === void 0) {
            onFinally = intrinsics.undefined;
        }
        // 1. Let promise be the this value.
        const promise = thisArgument;
        // 2. If Type(promise) is not Object, throw a TypeError exception.
        if (!promise.isObject) {
            return new $TypeError(realm, `Expected 'this' to be an object, but got: ${promise}`);
        }
        // 3. Let C be ? SpeciesConstructor(promise, %Promise%).
        const C = $SpeciesConstructor(ctx, promise, intrinsics['%Promise%']);
        if (C.isAbrupt) {
            return C;
        }
        let thenFinally;
        let catchFinally;
        // 4. Assert: IsConstructor(C) is true.
        // 5. If IsCallable(onFinally) is false, then
        if (!onFinally.isFunction) {
            // 5. a. Let thenFinally be onFinally.
            thenFinally = onFinally;
            // 5. b. Let catchFinally be onFinally.
            catchFinally = onFinally;
        }
        // 6. Else,
        else {
            // 6. a. Let stepsThenFinally be the algorithm steps defined in Then Finally Functions.
            // 6. b. Let thenFinally be CreateBuiltinFunction(stepsThenFinally, « [[Constructor]], [[OnFinally]] »).
            // 6. c. Set thenFinally.[[Constructor]] to C.
            // 6. d. Set thenFinally.[[OnFinally]] to onFinally.
            thenFinally = new $ThenFinally(realm, C, onFinally);
            // 6. e. Let stepsCatchFinally be the algorithm steps defined in Catch Finally Functions.
            // 6. f. Let catchFinally be CreateBuiltinFunction(stepsCatchFinally, « [[Constructor]], [[OnFinally]] »).
            // 6. g. Set catchFinally.[[Constructor]] to C.
            // 6. h. Set catchFinally.[[OnFinally]] to onFinally.
            catchFinally = new $CatchFinally(realm, C, onFinally);
        }
        // 7. Return ? Invoke(promise, "then", « thenFinally, catchFinally »).
        return $Invoke(ctx, promise, intrinsics.then, new $List(thenFinally, catchFinally)); // TODO: fix typings $Empty shenanigans
    }
}
// http://www.ecma-international.org/ecma-262/#sec-thenfinallyfunctions
// 25.6.5.3.1 Then Finally Functions
class $ThenFinally extends $BuiltinFunction {
    constructor(realm, constructor, onFinally) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'Then Finally', intrinsics['%FunctionPrototype%']);
        this['[[Constructor]]'] = constructor;
        this['[[OnFinally]]'] = onFinally;
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Let onFinally be F.[[OnFinally]].
        const onFinally = F['[[OnFinally]]'];
        // 3. Assert: IsCallable(onFinally) is true.
        // 4. Let result be ? Call(onFinally, undefined).
        const result = $Call(ctx, onFinally, intrinsics.undefined, intrinsics.undefined);
        if (result.isAbrupt) {
            return result;
        }
        // 5. Let C be F.[[Constructor]].
        const C = F['[[Constructor]]'];
        // 6. Assert: IsConstructor(C) is true.
        // 7. Let promise be ? PromiseResolve(C, result).
        const promise = $PromiseResolve(ctx, C, result);
        if (promise.isAbrupt) {
            return promise;
        }
        // 8. Let valueThunk be equivalent to a function that returns value.
        const valueThunk = new $ValueThunk(realm, value);
        // 9. Return ? Invoke(promise, "then", « valueThunk »).
        return $Invoke(ctx, promise, intrinsics.then, new $List(valueThunk)); // TODO: fix typings $Empty shenanigans
    }
}
class $ValueThunk extends $BuiltinFunction {
    constructor(realm, value) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'ValueThunk', intrinsics['%FunctionPrototype%']);
        this.value = value;
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        return this.value;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-catchfinallyfunctions
// 25.6.5.3.2 Catch Finally Functions
class $CatchFinally extends $BuiltinFunction {
    constructor(realm, constructor, onFinally) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'Catch Finally', intrinsics['%FunctionPrototype%']);
        this['[[Constructor]]'] = constructor;
        this['[[OnFinally]]'] = onFinally;
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Let onFinally be F.[[OnFinally]].
        const onFinally = F['[[OnFinally]]'];
        // 3. Assert: IsCallable(onFinally) is true.
        // 4. Let result be ? Call(onFinally, undefined).
        const result = $Call(ctx, onFinally, intrinsics.undefined, intrinsics.undefined);
        if (result.isAbrupt) {
            return result;
        }
        // 5. Let C be F.[[Constructor]].
        const C = F['[[Constructor]]'];
        // 6. Assert: IsConstructor(C) is true.
        // 7. Let promise be ? PromiseResolve(C, result).
        const promise = $PromiseResolve(ctx, C, result);
        if (promise.isAbrupt) {
            return promise;
        }
        // 8. Let thrower be equivalent to a function that throws reason.
        const thrower = new $Thrower(realm, value);
        // 9. Return ? Invoke(promise, "then", « thrower »).
        return $Invoke(ctx, promise, intrinsics.then, new $List(thrower)); // TODO: fix typings $Empty shenanigans
    }
}
class $Thrower extends $BuiltinFunction {
    constructor(realm, reason) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'Thrower', intrinsics['%FunctionPrototype%']);
        this.reason = reason;
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // TODO: double check if this is the correct way to throw
        return this.reason.ToCompletion(5 /* throw */, ctx.Realm['[[Intrinsics]]'].empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-promise.prototype.then
// 25.6.5.4 Promise.prototype.then ( onFulfilled , onRejected )
class $PromiseProto_then extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%PromiseProto_then%', proto);
    }
    performSteps(ctx, thisArgument, [onFulfilled, onRejected], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (onFulfilled === void 0) {
            onFulfilled = intrinsics.undefined;
        }
        if (onRejected === void 0) {
            onRejected = intrinsics.undefined;
        }
        // 1. Let promise be the this value.
        const promise = thisArgument;
        // 2. If IsPromise(promise) is false, throw a TypeError exception.
        if (!promise.isObject) {
            return new $TypeError(realm, `Expected 'this' to be an object, but got: ${promise}`);
        }
        // 3. Let C be ? SpeciesConstructor(promise, %Promise%).
        const C = $SpeciesConstructor(ctx, promise, intrinsics['%Promise%']);
        if (C.isAbrupt) {
            return C;
        }
        // 4. Let resultCapability be ? NewPromiseCapability(C).
        const resultCapability = $NewPromiseCapability(ctx, C);
        if (resultCapability.isAbrupt) {
            return resultCapability;
        }
        // 5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).
        return $PerformPromiseThen(ctx, 
        // TODO: verify if this cast is safe
        promise, onFulfilled, onRejected, resultCapability);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-performpromisethen
// 25.6.5.4.1 PerformPromiseThen ( promise , onFulfilled , onRejected [ , resultCapability ] )
function $PerformPromiseThen(ctx, promise, onFulfilled, onRejected, resultCapability) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: IsPromise(promise) is true.
    // 2. If resultCapability is present, then
    if (resultCapability !== void 0) ;
    // 3. Else,
    else {
        // 3. a. Set resultCapability to undefined.
        resultCapability = intrinsics.undefined;
    }
    // 4. If IsCallable(onFulfilled) is false, then
    if (!onFulfilled.isFunction) {
        // 4. a. Set onFulfilled to undefined.
        onFulfilled = intrinsics.undefined;
    }
    // 5. If IsCallable(onRejected) is false, then
    if (!onRejected.isFunction) {
        // 5. a. Set onRejected to undefined.
        onRejected = intrinsics.undefined;
    }
    // 6. Let fulfillReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: "Fulfill", [[Handler]]: onFulfilled }.
    const fulfillReaction = new $PromiseReaction(resultCapability, 1 /* Fulfill */, onFulfilled);
    // 7. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: "Reject", [[Handler]]: onRejected }.
    const rejectReaction = new $PromiseReaction(resultCapability, 2 /* Reject */, onRejected);
    // 8. If promise.[[PromiseState]] is "pending", then
    if (promise['[[PromiseState]]'] === 1 /* pending */) {
        // 8. a. Append fulfillReaction as the last element of the List that is promise.[[PromiseFulfillReactions]].
        promise['[[PromiseFulfillReactions]]'].push(fulfillReaction);
        // 8. b. Append rejectReaction as the last element of the List that is promise.[[PromiseRejectReactions]].
        promise['[[PromiseRejectReactions]]'].push(rejectReaction);
    }
    // 9. Else if promise.[[PromiseState]] is "fulfilled", then
    else if (promise['[[PromiseState]]'] === 2 /* fulfilled */) {
        // 9. a. Let value be promise.[[PromiseResult]].
        const value = promise['[[PromiseResult]]'];
        // 9. b. Perform EnqueueJob("PromiseJobs", PromiseReactionJob, « fulfillReaction, value »).
        realm.PromiseJobs.EnqueueJob(ctx, new PromiseReactionJob(realm, ctx.ScriptOrModule, fulfillReaction, value));
    }
    // 10. Else,
    else {
        // 10. a. Assert: The value of promise.[[PromiseState]] is "rejected".
        // 10. b. Let reason be promise.[[PromiseResult]].
        const reason = promise['[[PromiseResult]]'];
        // 10. c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, "handle").
        if (!promise['[[PromiseIsHandled]]']) {
            $HostPromiseRejectionTracker(ctx, promise);
        }
        // 10. d. Perform EnqueueJob("PromiseJobs", PromiseReactionJob, « rejectReaction, reason »).
        realm.PromiseJobs.EnqueueJob(ctx, new PromiseReactionJob(realm, ctx.ScriptOrModule, rejectReaction, reason));
    }
    // 11. Set promise.[[PromiseIsHandled]] to true.
    promise['[[PromiseIsHandled]]'] = true;
    // 12. If resultCapability is undefined, then
    if (resultCapability === void 0 || resultCapability.isUndefined) {
        // 12. a. Return undefined.
        return intrinsics.undefined;
    }
    // 13. Else,
    else {
        // 13. a. Return resultCapability.[[Promise]].
        return resultCapability['[[Promise]]'];
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-promise-instances
// #region 25.6.6 Properties of Promise Instances
var PromiseState;
(function (PromiseState) {
    PromiseState[PromiseState["pending"] = 1] = "pending";
    PromiseState[PromiseState["fulfilled"] = 2] = "fulfilled";
    PromiseState[PromiseState["rejected"] = 3] = "rejected";
})(PromiseState || (PromiseState = {}));
// http://www.ecma-international.org/ecma-262/#sec-properties-of-promise-instances
// 25.6.6 Properties of Promise Instances
class $PromiseInstance extends $Object {
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'PromiseInstance', proto, 1 /* normal */, intrinsics.empty);
        // 4. Set promise.[[PromiseState]] to "pending".
        this['[[PromiseState]]'] = 1 /* pending */;
        this['[[PromiseResult]]'] = void 0;
        // 5. Set promise.[[PromiseFulfillReactions]] to a new empty List.
        this['[[PromiseFulfillReactions]]'] = new $List();
        // 6. Set promise.[[PromiseRejectReactions]] to a new empty List.
        this['[[PromiseRejectReactions]]'] = new $List();
        // 7. Set promise.[[PromiseIsHandled]] to false.
        this['[[PromiseIsHandled]]'] = false;
    }
    static Create(ctx, NewTarget) {
        const proto = $GetPrototypeFromConstructor(ctx, NewTarget, '%PromisePrototype%');
        if (proto.isAbrupt) {
            return proto;
        }
        return new $PromiseInstance(ctx.Realm, proto);
    }
}
// #endregion

// http://www.ecma-international.org/ecma-262/#sec-getiterator
function $GetIterator(ctx, obj, hint, method) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. If hint is not present, set hint to sync.
    if (hint === void 0) {
        hint = 'sync';
    }
    // 2. Assert: hint is either sync or async.
    // 3. If method is not present, then
    if (method === void 0) {
        // 3. a. If hint is async, then
        if (hint === 'async') {
            // 3. a. i. Set method to ? GetMethod(obj, @@asyncIterator).
            const $method = $GetMethod(ctx, obj, intrinsics['@@asyncIterator']);
            if ($method.isAbrupt) {
                return $method;
            }
            method = $method;
            // 3. a. ii. If method is undefined, then
            if (method.isUndefined) {
                // 3. a. ii. 1. Let syncMethod be ? GetMethod(obj, @@iterator).
                const syncMethod = $GetMethod(ctx, obj, intrinsics['@@iterator']);
                if (syncMethod.isAbrupt) {
                    return syncMethod;
                }
                // 3. a. ii. 2. Let syncIteratorRecord be ? GetIterator(obj, sync, syncMethod).
                const syncIteratorRecord = $GetIterator(ctx, obj, 'sync', syncMethod);
                if (syncIteratorRecord.isAbrupt) {
                    return syncIteratorRecord;
                }
                // 3. a. ii. 3. Return ? CreateAsyncFromSyncIterator(syncIteratorRecord).
                return $CreateAsyncFromSyncIterator(ctx, syncIteratorRecord);
            }
        }
        else {
            // 3. b. Otherwise, set method to ? GetMethod(obj, @@iterator).
            const $method = $GetMethod(ctx, obj, intrinsics['@@iterator']);
            if ($method.isAbrupt) {
                return $method;
            }
            method = $method;
        }
    }
    // 4. Let iterator be ? Call(method, obj).
    const iterator = $Call(ctx, method, obj, intrinsics.undefined);
    if (iterator.isAbrupt) {
        return iterator;
    }
    // 5. If Type(iterator) is not Object, throw a TypeError exception.
    if (!iterator.isObject) {
        return new $TypeError(realm, `The iterator is ${iterator}, but expected an object`);
    }
    // 6. Let nextMethod be ? GetV(iterator, "next").
    const nextMethod = iterator['[[Get]]'](ctx, intrinsics.next, iterator);
    if (nextMethod.isAbrupt) {
        return nextMethod;
    }
    // 7. Let iteratorRecord be Record { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }.
    const iteratorRecord = new $IteratorRecord(
    /* [[Iterator]] */ iterator, 
    /* [[NextMethod]] */ nextMethod, 
    /* [[Done]] */ intrinsics.false);
    // 8. Return iteratorRecord.
    return iteratorRecord;
}
// http://www.ecma-international.org/ecma-262/#sec-iteratornext
function $IteratorNext(ctx, iteratorRecord, value) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    let result;
    // 1. If value is not present, then
    if (value === void 0) {
        // 1. a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »).
        const $result = $Call(ctx, iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], intrinsics.undefined);
        if ($result.isAbrupt) {
            return $result;
        }
        result = $result;
    }
    // 2. Else,
    else {
        // 2. a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « value »).
        const $result = $Call(ctx, iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], new $List(value));
        if ($result.isAbrupt) {
            return $result;
        }
        result = $result;
    }
    // 3. If Type(result) is not Object, throw a TypeError exception.
    if (!result.isObject) {
        return new $TypeError(ctx.Realm, `The iterator next result is ${result}, but expected an object`);
    }
    // 4. Return result.
    return result;
}
// http://www.ecma-international.org/ecma-262/#sec-iteratorcomplete
function $IteratorComplete(ctx, iterResult) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(iterResult) is Object.
    // 2. Return ToBoolean(? Get(iterResult, "done")).
    return iterResult['[[Get]]'](ctx, intrinsics.$done, iterResult).ToBoolean(ctx);
}
// http://www.ecma-international.org/ecma-262/#sec-iteratorvalue
function $IteratorValue(ctx, iterResult) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(iterResult) is Object.
    // 2. Return ? Get(iterResult, "value").
    return iterResult['[[Get]]'](ctx, intrinsics.$value, iterResult);
}
// http://www.ecma-international.org/ecma-262/#sec-iteratorstep
function $IteratorStep(ctx, iteratorRecord) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let result be ? IteratorNext(iteratorRecord).
    const result = $IteratorNext(ctx, iteratorRecord);
    if (result.isAbrupt) {
        return result;
    }
    // 2. Let done be ? IteratorComplete(result).
    const done = $IteratorComplete(ctx, result);
    if (done.isAbrupt) {
        return done;
    }
    // 3. If done is true, return false.
    if (done.isTruthy) {
        return intrinsics.false;
    }
    // 4. Return result.
    return result;
}
// http://www.ecma-international.org/ecma-262/#sec-iteratorclose
function $IteratorClose(ctx, iteratorRecord, completion) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(iteratorRecord.[[Iterator]]) is Object.
    // 2. Assert: completion is a Completion Record.
    // 3. Let iterator be iteratorRecord.[[Iterator]].
    const iterator = iteratorRecord['[[Iterator]]'];
    // 4. Let return be ? GetMethod(iterator, "return").
    const $return = iterator.GetMethod(ctx, intrinsics.$return);
    if ($return.isAbrupt) {
        return $return;
    }
    // 5. If return is undefined, return Completion(completion).
    if ($return.isUndefined) {
        return completion;
    }
    // 6. Let innerResult be Call(return, iterator, « »).
    const innerResult = $Call(ctx, $return, iterator, intrinsics.undefined);
    // 7. If completion.[[Type]] is throw, return Completion(completion).
    if (completion['[[Type]]'] === 5 /* throw */) {
        return completion;
    }
    // 8. If innerResult.[[Type]] is throw, return Completion(innerResult).
    if (innerResult['[[Type]]'] === 5 /* throw */) {
        return innerResult;
    }
    // 9. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.
    if (!innerResult.isObject) {
        return new $TypeError(realm, `The iterator close innerResult is ${innerResult}, but expected an object`);
    }
    // 10. Return Completion(completion).
    return completion;
}
// http://www.ecma-international.org/ecma-262/#sec-createiterresultobject
function $CreateIterResultObject(ctx, value, done) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: Type(done) is Boolean.
    // 2. Let obj be ObjectCreate(%ObjectPrototype%).
    const obj = $Object.ObjectCreate(ctx, 'IterResultObject', intrinsics['%ObjectPrototype%']);
    // 3. Perform CreateDataProperty(obj, "value", value).
    $CreateDataProperty(ctx, obj, intrinsics.$value, value);
    // 4. Perform CreateDataProperty(obj, "done", done).
    $CreateDataProperty(ctx, obj, intrinsics.$done, done);
    // 5. Return obj.
    return obj;
}
// http://www.ecma-international.org/ecma-262/#sec-createlistiteratorRecord
function $CreateListIteratorRecord(ctx, list) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let iterator be ObjectCreate(%IteratorPrototype%, « [[IteratedList]], [[ListIteratorNextIndex]] »).
    // 4. Let steps be the algorithm steps defined in ListIterator next (7.4.9.1).
    // 5. Let next be CreateBuiltinFunction(steps, « »).
    // 6. Return Record { [[Iterator]]: iterator, [[NextMethod]]: next, [[Done]]: false }.
    return new $IteratorRecord(
    /* [[Iterator]] */ new $ListIterator(realm, list), 
    /* [[NextMethod]] */ new $ListIterator_next(realm), 
    /* [[Done]] */ intrinsics.false);
}
// http://www.ecma-international.org/ecma-262/#sec-listiterator-next
class $ListIterator_next extends $BuiltinFunction {
    constructor(realm) {
        super(realm, 'ListIterator_next', realm['[[Intrinsics]]']['%FunctionPrototype%']);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let O be the this value.
        const O = thisArgument;
        // 2. Assert: Type(O) is Object.
        // 3. Assert: O has an [[IteratedList]] internal slot.
        // 4. Let list be O.[[IteratedList]].
        const list = O['[[IteratedList]]'];
        // 5. Let index be O.[[ListIteratorNextIndex]].
        const index = O['[[ListIteratorNextIndex]]'];
        // 6. Let len be the number of elements of list.
        const len = list.length;
        // 7. If index ≥ len, then
        if (index['[[Value]]'] >= len) {
            // 7. a. Return CreateIterResultObject(undefined, true).
            return $CreateIterResultObject(ctx, intrinsics.undefined, intrinsics.true);
        }
        // 8. Set O.[[ListIteratorNextIndex]] to index + 1.
        O['[[ListIteratorNextIndex]]'] = new $Number(realm, index['[[Value]]'] + 1);
        // 9. Return CreateIterResultObject(list[index], false).
        return $CreateIterResultObject(ctx, list[index['[[Value]]']], intrinsics.false);
    }
}
class $ListIterator extends $Object {
    constructor(realm, list) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'ListIterator', intrinsics['%IteratorPrototype%'], 1 /* normal */, intrinsics.empty);
        this['[[IteratedList]]'] = list;
        this['[[ListIteratorNextIndex]]'] = new $Number(realm, 0);
    }
    get isAbrupt() { return false; }
}
class $IteratorRecord {
    constructor(iterator, next, done) {
        this['[[Iterator]]'] = iterator;
        this['[[NextMethod]]'] = next;
        this['[[Done]]'] = done;
    }
    get isAbrupt() { return false; }
}
class $AsyncFromSyncIterator extends $Object {
    constructor(realm, syncIteratorRecord) {
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let asyncIterator be ! ObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).
        super(realm, 'AsyncFromSyncIterator', intrinsics['%AsyncFromSyncIteratorPrototype%'], 1 /* normal */, intrinsics.empty);
        // 2. Set asyncIterator.[[SyncIteratorRecord]] to syncIteratorRecord.
        this['[[SyncIteratorRecord]]'] = syncIteratorRecord;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-%iteratorprototype%-@@iterator
// 25.1.2.1 %IteratorPrototype% [ @@iterator ] ( )
class $Symbol_Iterator extends $BuiltinFunction {
    constructor(realm) {
        super(realm, '[Symbol.iterator]', realm['[[Intrinsics]]']['%FunctionPrototype%']);
        this.SetFunctionName(realm.stack.top, new $String(realm, '[Symbol.iterator]'));
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Return the this value.
        return thisArgument;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-asynciteratorprototype-asynciterator
// 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
class $Symbol_AsyncIterator extends $BuiltinFunction {
    constructor(realm) {
        super(realm, '[Symbol.asyncIterator]', realm['[[Intrinsics]]']['%FunctionPrototype%']);
        this.SetFunctionName(realm.stack.top, new $String(realm, '[Symbol.asyncIterator]'));
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Return the this value.
        return thisArgument;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-%iteratorprototype%-object
// 25.1.2 The %IteratorPrototype% Object
class $IteratorPrototype extends $Object {
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%IteratorPrototype%', proto, 1 /* normal */, intrinsics.empty);
        $DefinePropertyOrThrow(realm.stack.top, this, intrinsics['@@iterator'], new $PropertyDescriptor(realm, intrinsics['@@iterator'], {
            '[[Value]]': new $Symbol_Iterator(realm),
        }));
    }
}
// http://www.ecma-international.org/ecma-262/#sec-asynciteratorprototype
// 25.1.3 The %AsyncIteratorPrototype% Object
class $AsyncIteratorPrototype extends $Object {
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%AsyncIteratorPrototype%', proto, 1 /* normal */, intrinsics.empty);
        $DefinePropertyOrThrow(realm.stack.top, this, intrinsics['@@asyncIterator'], new $PropertyDescriptor(realm, intrinsics['@@asyncIterator'], {
            '[[Value]]': new $Symbol_AsyncIterator(realm),
        }));
    }
}
// http://www.ecma-international.org/ecma-262/#sec-async-from-sync-iterator-objects
// #region 25.1.4 Async-from-Sync Iterator Objects
// http://www.ecma-international.org/ecma-262/#sec-createasyncfromsynciterator
// 25.1.4.1 CreateAsyncFromSyncIterator ( syncIteratorRecord )
function $CreateAsyncFromSyncIterator(ctx, syncIteratorRecord) {
    const realm = ctx.Realm;
    // 1. Let asyncIterator be ! ObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).
    // 2. Set asyncIterator.[[SyncIteratorRecord]] to syncIteratorRecord.
    const asyncIterator = new $AsyncFromSyncIterator(realm, syncIteratorRecord);
    // 3. Return ? GetIterator(asyncIterator, async).
    return $GetIterator(ctx, asyncIterator, 'async');
}
// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%-object
// 25.1.4.2 The %AsyncFromSyncIteratorPrototype% Object
class $AsyncFromSyncIteratorPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.next
    // 25.1.4.2.1 %AsyncFromSyncIteratorPrototype%.next ( value )
    get next() {
        return this.getProperty(this.realm['[[Intrinsics]]'].next)['[[Value]]'];
    }
    set next(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].next, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.return
    // 25.1.4.2.2 %AsyncFromSyncIteratorPrototype%.return ( value )
    get return() {
        return this.getProperty(this.realm['[[Intrinsics]]'].return)['[[Value]]'];
    }
    set return(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].return, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.throw
    // 25.1.4.2.3 %AsyncFromSyncIteratorPrototype%.throw ( value )
    get throw() {
        return this.getProperty(this.realm['[[Intrinsics]]'].throw)['[[Value]]'];
    }
    set throw(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].throw, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%-@@tostringtag
    // 25.1.4.2.4 %AsyncFromSyncIteratorPrototype% [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%AsyncFromSyncIteratorPrototype%', proto, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.next
// 25.1.4.2.1 %AsyncFromSyncIteratorPrototype%.next ( value )
class $AsyncFromSyncIteratorPrototype_next extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%AsyncFromSyncIteratorPrototype%.next', proto);
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let O be the this value.
        const O = thisArgument;
        // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
        const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']);
        // 3. If Type(O) is not Object, or if O does not have a [[SyncIteratorRecord]] internal slot, then
        if (!(O instanceof $AsyncFromSyncIterator)) {
            // 3. a. Let invalidIteratorError be a newly created TypeError object.
            const invalidIteratorError = new $TypeError(realm, `Expected AsyncFromSyncIterator, but got: ${O}`);
            // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « invalidIteratorError »).
            $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(invalidIteratorError));
            // 3. c. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 4. Let syncIteratorRecord be O.[[SyncIteratorRecord]].
        const syncIteratorRecord = O['[[SyncIteratorRecord]]'];
        // 5. Let result be IteratorNext(syncIteratorRecord, value).
        const result = $IteratorNext(ctx, syncIteratorRecord, value);
        // 6. IfAbruptRejectPromise(result, promiseCapability).
        const $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, result, promiseCapability);
        if ($IfAbruptRejectPromiseResult.isAbrupt) {
            return $IfAbruptRejectPromiseResult;
        }
        // 7. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability).
        return $AsyncFromSyncIteratorContinuation(ctx, result, promiseCapability);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.return
// 25.1.4.2.2 %AsyncFromSyncIteratorPrototype%.return ( value )
class $AsyncFromSyncIteratorPrototype_return extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%AsyncFromSyncIteratorPrototype%.return', proto);
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let O be the this value.
        const O = thisArgument;
        // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
        const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']);
        // 3. If Type(O) is not Object, or if O does not have a [[SyncIteratorRecord]] internal slot, then
        if (!(O instanceof $AsyncFromSyncIterator)) {
            // 3. a. Let invalidIteratorError be a newly created TypeError object.
            const invalidIteratorError = new $TypeError(realm, `Expected AsyncFromSyncIterator, but got: ${O}`);
            // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « invalidIteratorError »).
            $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(invalidIteratorError));
            // 3. c. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 4. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]].
        const syncIterator = O['[[SyncIteratorRecord]]']['[[Iterator]]'];
        // 5. Let return be GetMethod(syncIterator, "return").
        const $return = $GetMethod(ctx, syncIterator, intrinsics.return);
        // 6. IfAbruptRejectPromise(return, promiseCapability).
        let $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, $return, promiseCapability);
        if ($IfAbruptRejectPromiseResult.isAbrupt) {
            return $IfAbruptRejectPromiseResult;
        }
        // 7. If return is undefined, then
        if ($return.isUndefined) {
            // 7. a. Let iterResult be ! CreateIterResultObject(value, true).
            const iterResult = $CreateIterResultObject(ctx, value, intrinsics.true);
            // 7. b. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iterResult »).
            $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(iterResult));
            // 7. c. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 8. Let result be Call(return, syncIterator, « value »).
        const result = $Call(ctx, $return, syncIterator, new $List(value));
        // 9. IfAbruptRejectPromise(result, promiseCapability).
        $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, result, promiseCapability);
        if ($IfAbruptRejectPromiseResult.isAbrupt) {
            return $IfAbruptRejectPromiseResult;
        }
        // 10. If Type(result) is not Object, then
        if (!result.isObject) {
            // 10. a. Perform ! Call(promiseCapability.[[Reject]], undefined, « a newly created TypeError object »).
            const err = new $TypeError(realm, `Expected syncIterator return result to be an object, but got: ${result}`);
            $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(err));
            // 10. b. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 11. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability).
        return $AsyncFromSyncIteratorContinuation(ctx, result, promiseCapability);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.throw
// 25.1.4.2.3 %AsyncFromSyncIteratorPrototype%.throw ( value )
class $AsyncFromSyncIteratorPrototype_throw extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%AsyncFromSyncIteratorPrototype%.throw', proto);
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let O be the this value.
        const O = thisArgument;
        // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
        const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']);
        // 3. If Type(O) is not Object, or if O does not have a [[SyncIteratorRecord]] internal slot, then
        if (!(O instanceof $AsyncFromSyncIterator)) {
            // 3. a. Let invalidIteratorError be a newly created TypeError object.
            const invalidIteratorError = new $TypeError(realm, `Expected AsyncFromSyncIterator, but got: ${O}`);
            // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « invalidIteratorError »).
            $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(invalidIteratorError));
            // 3. c. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 4. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]].
        const syncIterator = O['[[SyncIteratorRecord]]']['[[Iterator]]'];
        // 5. Let throw be GetMethod(syncIterator, "throw").
        const $throw = $GetMethod(ctx, syncIterator, intrinsics.throw);
        // 6. IfAbruptRejectPromise(throw, promiseCapability).
        let $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, $throw, promiseCapability);
        if ($IfAbruptRejectPromiseResult.isAbrupt) {
            return $IfAbruptRejectPromiseResult;
        }
        // 7. If throw is undefined, then
        if ($throw.isUndefined) {
            // 7. a. Perform ! Call(promiseCapability.[[Reject]], undefined, « value »).
            $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(value));
            // 7. b. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 8. Let result be Call(throw, syncIterator, « value »).
        const result = $Call(ctx, $throw, syncIterator, new $List(value));
        // 9. IfAbruptRejectPromise(result, promiseCapability).
        $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, result, promiseCapability);
        if ($IfAbruptRejectPromiseResult.isAbrupt) {
            return $IfAbruptRejectPromiseResult;
        }
        // 10. If Type(result) is not Object, then
        if (!result.isObject) {
            // 10. a. Perform ! Call(promiseCapability.[[Reject]], undefined, « a newly created TypeError object »).
            const err = new $TypeError(realm, `Expected syncIterator return result to be an object, but got: ${result}`);
            $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(err));
            // 10. b. Return promiseCapability.[[Promise]].
            return promiseCapability['[[Promise]]'];
        }
        // 11. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability).
        return $AsyncFromSyncIteratorContinuation(ctx, result, promiseCapability);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-async-from-sync-iterator-value-unwrap-functions
// 25.1.4.2.5 Async-from-Sync Iterator Value Unwrap Functions
class $AsyncFromSyncIterator_Value_Unwrap extends $BuiltinFunction {
    constructor(realm, done) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'Async-from-Sync Iterator Value Unwrap', intrinsics['%FunctionPrototype%']);
        this['[[Done]]'] = done;
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Return ! CreateIterResultObject(value, F.[[Done]]).
        return $CreateIterResultObject(ctx, value, F['[[Done]]']);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-async-from-sync-iterator-instances
// 25.1.4.3 Properties of Async-from-Sync Iterator Instances
// http://www.ecma-international.org/ecma-262/#sec-asyncfromsynciteratorcontinuation
// 25.1.4.4 AsyncFromSyncIteratorContinuation ( result , promiseCapability )
function $AsyncFromSyncIteratorContinuation(ctx, result, promiseCapability) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let done be IteratorComplete(result).
    const done = $IteratorComplete(ctx, result);
    // 2. IfAbruptRejectPromise(done, promiseCapability).
    let $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, done, promiseCapability);
    if ($IfAbruptRejectPromiseResult.isAbrupt) {
        return $IfAbruptRejectPromiseResult;
    }
    // 3. Let value be IteratorValue(result).
    const value = $IteratorValue(ctx, result);
    // 4. IfAbruptRejectPromise(value, promiseCapability).
    $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, value, promiseCapability);
    if ($IfAbruptRejectPromiseResult.isAbrupt) {
        return $IfAbruptRejectPromiseResult;
    }
    // 5. Let valueWrapper be ? PromiseResolve(%Promise%, « value »).
    const valueWrapper = $PromiseResolve(ctx, intrinsics['%Promise%'], new $List(value)); // TODO: fix types
    if (valueWrapper.isAbrupt) {
        return valueWrapper;
    }
    // 6. Let steps be the algorithm steps defined in Async-from-Sync Iterator Value Unwrap Functions.
    // 7. Let onFulfilled be CreateBuiltinFunction(steps, « [[Done]] »).
    // 8. Set onFulfilled.[[Done]] to done.
    const onFulfilled = new $AsyncFromSyncIterator_Value_Unwrap(realm, done);
    // 9. Perform ! PerformPromiseThen(valueWrapper, onFulfilled, undefined, promiseCapability).
    $PerformPromiseThen(ctx, valueWrapper, onFulfilled, intrinsics.undefined, promiseCapability);
    // 10. Return promiseCapability.[[Promise]].
    return promiseCapability['[[Promise]]'];
}
// #endregion

// http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects
class $StringExoticObject extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-stringcreate
    // 9.4.3.4 StringCreate ( value , prototype )
    constructor(realm, value, proto) {
        super(realm, 'StringExoticObject', proto, 1 /* normal */, realm['[[Intrinsics]]'].empty);
        // 1. Assert: Type(value) is String.
        // 2. Let S be a newly created String exotic object.
        // 3. Set S.[[StringData]] to value.
        this['[[StringData]]'] = value;
        // 4. Set S's essential internal methods to the default ordinary object definitions specified in 9.1.
        // 5. Set S.[[GetOwnProperty]] as specified in 9.4.3.1.
        // 6. Set S.[[DefineOwnProperty]] as specified in 9.4.3.2.
        // 7. Set S.[[OwnPropertyKeys]] as specified in 9.4.3.3.
        // 8. Set S.[[Prototype]] to prototype.
        // 9. Set S.[[Extensible]] to true.
        // 10. Let length be the number of code unit elements in value.
        const length = value['[[Value]]'].length;
        // 11. Perform ! DefinePropertyOrThrow(S, "length", PropertyDescriptor { [[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).
        $DefinePropertyOrThrow(realm.stack.top, this, realm['[[Intrinsics]]'].length, new $PropertyDescriptor(realm, realm['[[Intrinsics]]'].length, {
            '[[Value]]': new $Number(realm, length),
            '[[Writable]]': realm['[[Intrinsics]]'].false,
            '[[Enumerable]]': realm['[[Intrinsics]]'].false,
            '[[Configurable]]': realm['[[Intrinsics]]'].false,
        }));
        // 12. Return S.
    }
    // http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects-getownproperty-p
    // 9.4.3.1 [[GetOwnProperty]] ( P )
    '[[GetOwnProperty]]'(ctx, P) {
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let desc be OrdinaryGetOwnProperty(S, P).
        const desc = super['[[GetOwnProperty]]'](ctx, P);
        // 3. If desc is not undefined, return desc.
        if (!desc.isUndefined) {
            return desc;
        }
        // 4. Return ! StringGetOwnProperty(S, P).
        return $StringGetOwnProperty(ctx, this, P);
    }
    // http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects-defineownproperty-p-desc
    // 9.4.3.2 [[DefineOwnProperty]] ( P , Desc )
    '[[DefineOwnProperty]]'(ctx, P, Desc) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let stringDesc be ! StringGetOwnProperty(S, P).
        const stringDesc = $StringGetOwnProperty(ctx, this, P);
        // 3. If stringDesc is not undefined, then
        if (!stringDesc.isUndefined) {
            // 3. a. Let extensible be S.[[Extensible]].
            const extensible = this['[[Extensible]]'];
            // 3. b. Return ! IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc).
            return $ValidateAndApplyPropertyDescriptor(ctx, 
            /* O */ intrinsics.undefined, 
            /* P */ intrinsics.undefined, 
            /* extensible */ extensible, 
            /* Desc */ Desc, 
            /* current */ stringDesc);
        }
        // 4. Return ! OrdinaryDefineOwnProperty(S, P, Desc).
        return super['[[DefineOwnProperty]]'](ctx, P, Desc);
    }
    // http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects-ownpropertykeys
    // 9.4.3.3 [[OwnPropertyKeys]] ( )
    '[[OwnPropertyKeys]]'(ctx) {
        const realm = ctx.Realm;
        // 1. Let keys be a new empty List.
        const keys = new $List();
        // 2. Let str be O.[[StringData]].
        const str = this['[[StringData]]'];
        // 3. Assert: Type(str) is String.
        // 4. Let len be the length of str.
        const len = str['[[Value]]'].length;
        let i = 0;
        let keysLen = 0;
        // 5. For each integer i starting with 0 such that i < len, in ascending order, do
        for (; i < len; ++i) {
            // 5. a. Add ! ToString(i) as the last element of keys.
            keys[keysLen++] = new $String(realm, i.toString());
        }
        // 6. For each own property key P of O such that P is an array index and ToInteger(P) ≥ len, in ascending numeric index order, do
        // 6. a. Add P as the last element of keys.
        // 7. For each own property key P of O such that Type(P) is String and P is not an array index, in ascending chronological order of property creation, do
        // 7. a. Add P as the last element of keys.
        // 8. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, do
        // 8. a. Add P as the last element of keys.
        // 9. Return keys.
        return keys;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-stringgetownproperty
function $StringGetOwnProperty(ctx, S, P) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: S is an Object that has a [[StringData]] internal slot.
    // 2. Assert: IsPropertyKey(P) is true.
    // 3. If Type(P) is not String, return undefined.
    if (!P.isString) {
        return intrinsics.undefined;
    }
    // 4. Let index be ! CanonicalNumericIndexString(P).
    const index = P.CanonicalNumericIndexString(ctx);
    // 5. If index is undefined, return undefined.
    if (index.isUndefined) {
        return intrinsics.undefined;
    }
    // 6. If IsInteger(index) is false, return undefined.
    if (!index.IsInteger) {
        return intrinsics.undefined;
    }
    // 7. If index = -0, return undefined.
    if (index.is(intrinsics['-0'])) {
        return intrinsics.undefined;
    }
    // 8. Let str be S.[[StringData]].
    const str = S['[[StringData]]'];
    // 9. Assert: Type(str) is String.
    // 10. Let len be the length of str.
    const len = str['[[Value]]'].length;
    // 11. If index < 0 or len ≤ index, return undefined.
    if (index['[[Value]]'] < 0 || len <= index['[[Value]]']) {
        return intrinsics.undefined;
    }
    // 12. Let resultStr be the String value of length 1, containing one code unit from str, specifically the code unit at index index.
    const resultStr = new $String(realm, str['[[Value]]'][index['[[Value]]']]);
    // 13. Return a PropertyDescriptor { [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
    return new $PropertyDescriptor(realm, P, {
        '[[Value]]': resultStr,
        '[[Writable]]': intrinsics.false,
        '[[Enumerable]]': intrinsics.true,
        '[[Configurable]]': intrinsics.false,
    });
}

// http://www.ecma-international.org/ecma-262/#sec-string-constructor
class $StringConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%String%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-string-constructor-string-value
    // 21.1.1.1 String ( value )
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        let s;
        // 1. If no arguments were passed to this function invocation, let s be "".
        if (argumentsList.length === 0) {
            s = new $String(realm, '');
        }
        // 2. Else,
        else {
            const [value] = argumentsList;
            // 2. a. If NewTarget is undefined and Type(value) is Symbol, return SymbolDescriptiveString(value).
            if (NewTarget.isUndefined && value.isSymbol) ;
            // 2. b. Let s be ? ToString(value).
            const $s = value.ToString(ctx);
            if ($s.isAbrupt) {
                return $s;
            }
            s = $s;
        }
        // 3. If NewTarget is undefined, return s.
        if (NewTarget.isUndefined) {
            return s;
        }
        // 4. Return ! StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, "%StringPrototype%")).
        const proto = $GetPrototypeFromConstructor(ctx, NewTarget, '%StringPrototype%');
        if (proto.isAbrupt) {
            return proto;
        }
        return new $StringExoticObject(realm, s, proto);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-string-prototype-object
class $StringPrototype extends $Object {
    constructor(realm, objectPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%StringPrototype%', objectPrototype, 1 /* normal */, intrinsics.empty);
        this['[[StringData]]'] = new $String(realm, '');
    }
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
}
class $StringSet {
    constructor() {
        this.arr = [];
        this.map = new Map();
    }
    has(item) {
        return this.map.has(item['[[Value]]']);
    }
    add(item) {
        const arr = this.arr;
        const map = this.map;
        const value = item['[[Value]]'];
        let idx = map.get(value);
        if (idx === void 0) {
            arr[idx = arr.length] = item;
            map.set(value, idx);
        }
        else {
            arr[idx] = item;
        }
    }
    [Symbol.iterator]() {
        return this.arr[Symbol.iterator]();
    }
}

// http://www.ecma-international.org/ecma-262/#sec-object-constructor
// #region 19.1.1 The Object Constructor
class $ObjectConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype
    // 19.1.2.19 Object.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.assign
    // 19.1.2.1 Object.assign ( target , ... sources )
    get $assign() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$assign)['[[Value]]'];
    }
    set $assign(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$assign, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.create
    // 19.1.2.2 Object.create ( O , Properties )
    get $create() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$create)['[[Value]]'];
    }
    set $create(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$create, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.defineproperties
    // 19.1.2.3 Object.defineProperties ( O , Properties )
    get $defineProperties() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$defineProperties)['[[Value]]'];
    }
    set $defineProperties(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$defineProperties, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.defineproperty
    // 19.1.2.4 Object.defineProperty ( O , P , Attributes )
    get $defineProperty() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$defineProperty)['[[Value]]'];
    }
    set $defineProperty(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$defineProperty, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.entries
    // 19.1.2.5 Object.entries ( O )
    get $entries() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$entries)['[[Value]]'];
    }
    set $entries(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$entries, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.freeze
    // 19.1.2.6 Object.freeze ( O )
    get $freeze() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$freeze)['[[Value]]'];
    }
    set $freeze(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$freeze, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.fromentries
    // 19.1.2.7 Object.fromEntries ( iterable )
    get $fromEntries() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$fromEntries)['[[Value]]'];
    }
    set $fromEntries(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$fromEntries, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptor
    // 19.1.2.8 Object.getOwnPropertyDescriptor ( O , P )
    get $getOwnPropertyDescriptor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor)['[[Value]]'];
    }
    set $getOwnPropertyDescriptor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptors
    // 19.1.2.9 Object.getOwnPropertyDescriptors ( O )
    get $getOwnPropertyDescriptors() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptors)['[[Value]]'];
    }
    set $getOwnPropertyDescriptors(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptors, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertynames
    // 19.1.2.10 Object.getOwnPropertyNames ( O )
    get $getOwnPropertyNames() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyNames)['[[Value]]'];
    }
    set $getOwnPropertyNames(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyNames, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertysymbols
    // 19.1.2.11 Object.getOwnPropertySymbols ( O )
    get $getOwnPropertySymbols() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertySymbols)['[[Value]]'];
    }
    set $getOwnPropertySymbols(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertySymbols, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.getprototypeof
    // 19.1.2.12 Object.getPrototypeOf ( O )
    get $getPrototypeOf() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf)['[[Value]]'];
    }
    set $getPrototypeOf(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.is
    // 19.1.2.13 Object.is ( value1 , value2 )
    get $is() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$is)['[[Value]]'];
    }
    set $is(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$is, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.isextensible
    // 19.1.2.14 Object.isExtensible ( O )
    get $isExtensible() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$isExtensible)['[[Value]]'];
    }
    set $isExtensible(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$isExtensible, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.isfrozen
    // 19.1.2.15 Object.isFrozen ( O )
    get $isFrozen() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$isFrozen)['[[Value]]'];
    }
    set $isFrozen(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$isFrozen, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.issealed
    // 19.1.2.16 Object.isSealed ( O )
    get $isSealed() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$isSealed)['[[Value]]'];
    }
    set $isSealed(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$isSealed, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.keys
    // 19.1.2.17 Object.keys ( O )
    get $keys() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$keys)['[[Value]]'];
    }
    set $keys(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$keys, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.preventextensions
    // 19.1.2.18 Object.preventExtensions ( O )
    get $preventExtensions() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$preventExtensions)['[[Value]]'];
    }
    set $preventExtensions(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$preventExtensions, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.seal
    // 19.1.2.20 Object.seal ( O )
    get $seal() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$seal)['[[Value]]'];
    }
    set $seal(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$seal, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.setprototypeof
    // 19.1.2.21 Object.setPrototypeOf ( O , proto )
    get $setPrototypeOf() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf)['[[Value]]'];
    }
    set $setPrototypeOf(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.values
    // 19.1.2.22 Object.values ( O )
    get $values() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$values)['[[Value]]'];
    }
    set $values(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$values, value);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Object%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object-value
    // 19.1.1.1 Object ( [ value ] )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is neither undefined nor the active function, then
        if (!NewTarget.isUndefined && NewTarget !== this) {
            // 1. a. Return ? OrdinaryCreateFromConstructor(NewTarget, "%ObjectPrototype%").
            return $OrdinaryCreateFromConstructor(ctx, NewTarget, '%ObjectPrototype%');
        }
        // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).
        if (value === void 0 || value.isNil) {
            return $Object.ObjectCreate(ctx, 'Object', intrinsics['%ObjectPrototype%']);
        }
        // 3. Return ! ToObject(value).
        return value.ToObject(ctx);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.assign
// 19.1.2.1 Object.assign ( target , ... sources )
class $Object_assign extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.assign', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let to be ? ToObject(target).
        // 2. If only one argument was passed, return to.
        // 3. Let sources be the List of argument values starting with the second argument.
        // 4. For each element nextSource of sources, in ascending index order, do
        // 4. a. If nextSource is neither undefined nor null, then
        // 4. a. i. Let from be ! ToObject(nextSource).
        // 4. a. ii. Let keys be ? from.[[OwnPropertyKeys]]().
        // 4. a. iii. For each element nextKey of keys in List order, do
        // 4. a. iii. 1. Let desc be ? from.[[GetOwnProperty]](nextKey).
        // 4. a. iii. 2. If desc is not undefined and desc.[[Enumerable]] is true, then
        // 4. a. iii. 2. a. Let propValue be ? Get(from, nextKey).
        // 4. a. iii. 2. b. Perform ? Set(to, nextKey, propValue, true).
        // 5. Return to.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.create
// 19.1.2.2 Object.create ( O , Properties )
class $Object_create extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.create', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is neither Object nor Null, throw a TypeError exception.
        // 2. Let obj be ObjectCreate(O).
        // 3. If Properties is not undefined, then
        // 3. a. Return ? ObjectDefineProperties(obj, Properties).
        // 4. Return obj.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.defineproperties
// 19.1.2.3 Object.defineProperties ( O , Properties )
class $Object_defineProperties extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.defineProperties', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Return ? ObjectDefineProperties(O, Properties).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.defineproperty
// 19.1.2.4 Object.defineProperty ( O , P , Attributes )
class $Object_defineProperty extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.defineProperty', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, throw a TypeError exception.
        // 2. Let key be ? ToPropertyKey(P).
        // 3. Let desc be ? ToPropertyDescriptor(Attributes).
        // 4. Perform ? DefinePropertyOrThrow(O, key, desc).
        // 5. Return O.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.entries
// 19.1.2.5 Object.entries ( O )
class $Object_entries extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.entries', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let obj be ? ToObject(O).
        // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, "key+value").
        // 3. Return CreateArrayFromList(nameList).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.freeze
// 19.1.2.6 Object.freeze ( O )
class $Object_freeze extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.freeze', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, return O.
        // 2. Let status be ? SetIntegrityLevel(O, "frozen").
        // 3. If status is false, throw a TypeError exception.
        // 4. Return O.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.fromentries
// 19.1.2.7 Object.fromEntries ( iterable )
class $Object_fromEntries extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.fromEntries', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Perform ? RequireObjectCoercible(iterable).
        // 2. Let obj be ObjectCreate(%ObjectPrototype%).
        // 3. Assert: obj is an extensible ordinary object with no own properties.
        // 4. Let stepsDefine be the algorithm steps defined in CreateDataPropertyOnObject Functions.
        // 5. Let adder be CreateBuiltinFunction(stepsDefine, « »).
        // 6. Return ? AddEntriesFromIterable(obj, iterable, adder).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptor
// 19.1.2.8 Object.getOwnPropertyDescriptor ( O , P )
class $Object_getOwnPropertyDescriptor extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.getOwnPropertyDescriptor', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let obj be ? ToObject(O).
        // 2. Let key be ? ToPropertyKey(P).
        // 3. Let desc be ? obj.[[GetOwnProperty]](key).
        // 4. Return FromPropertyDescriptor(desc).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptors
// 19.1.2.9 Object.getOwnPropertyDescriptors ( O )
class $Object_getOwnPropertyDescriptors extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.getOwnPropertyDescriptors', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let obj be ? ToObject(O).
        // 2. Let ownKeys be ? obj.[[OwnPropertyKeys]]().
        // 3. Let descriptors be ! ObjectCreate(%ObjectPrototype%).
        // 4. For each element key of ownKeys in List order, do
        // 4. a. Let desc be ? obj.[[GetOwnProperty]](key).
        // 4. b. Let descriptor be ! FromPropertyDescriptor(desc).
        // 4. c. If descriptor is not undefined, perform ! CreateDataProperty(descriptors, key, descriptor).
        // 5. Return descriptors.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertynames
// 19.1.2.10 Object.getOwnPropertyNames ( O )
class $Object_getOwnPropertyNames extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.getOwnPropertyNames', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Return ? GetOwnPropertyKeys(O, String).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertysymbols
// 19.1.2.11 Object.getOwnPropertySymbols ( O )
class $Object_getOwnPropertySymbols extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.getOwnPropertySymbols', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Return ? GetOwnPropertyKeys(O, Symbol).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.getprototypeof
// 19.1.2.12 Object.getPrototypeOf ( O )
class $Object_getPrototypeOf extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.getPrototypeOf', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let obj be ? ToObject(O).
        // 2. Return ? obj.[[GetPrototypeOf]]().
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.is
// 19.1.2.13 Object.is ( value1 , value2 )
class $Object_is extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.is', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Return SameValue(value1, value2).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.isextensible
// 19.1.2.14 Object.isExtensible ( O )
class $Object_isExtensible extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.isExtensible', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, return false.
        // 2. Return ? IsExtensible(O).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.isfrozen
// 19.1.2.15 Object.isFrozen ( O )
class $Object_isFrozen extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.isFrozen', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, return true.
        // 2. Return ? TestIntegrityLevel(O, "frozen").
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.issealed
// 19.1.2.16 Object.isSealed ( O )
class $Object_isSealed extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.isSealed', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, return true.
        // 2. Return ? TestIntegrityLevel(O, "sealed").
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.keys
// 19.1.2.17 Object.keys ( O )
class $Object_keys extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.keys', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let obj be ? ToObject(O).
        // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, "key").
        // 3. Return CreateArrayFromList(nameList).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.preventextensions
// 19.1.2.18 Object.preventExtensions ( O )
class $Object_preventExtensions extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.preventExtensions', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, return O.
        // 2. Let status be ? O.[[PreventExtensions]]().
        // 3. If status is false, throw a TypeError exception.
        // 4. Return O.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.seal
// 19.1.2.20 Object.seal ( O )
class $Object_seal extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.seal', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. If Type(O) is not Object, return O.
        // 2. Let status be ? SetIntegrityLevel(O, "sealed").
        // 3. If status is false, throw a TypeError exception.
        // 4. Return O.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.setprototypeof
// 19.1.2.21 Object.setPrototypeOf ( O , proto )
class $Object_setPrototypeOf extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.setPrototypeOf', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Set O to ? RequireObjectCoercible(O).
        // 2. If Type(proto) is neither Object nor Null, throw a TypeError exception.
        // 3. If Type(O) is not Object, return O.
        // 4. Let status be ? O.[[SetPrototypeOf]](proto).
        // 5. If status is false, throw a TypeError exception.
        // 6. Return O.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.values
// 19.1.2.22 Object.values ( O )
class $Object_values extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.values', proto);
    }
    performSteps(ctx, thisArgument, [O], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (O === void 0) {
            O = intrinsics.undefined;
        }
        // 1. Let obj be ? ToObject(O).
        // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, "value").
        // 3. Return CreateArrayFromList(nameList).
        throw new Error('Method not implemented.');
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-object-prototype-object
// #region 19.1.3 Properties of the Object Prototype Object
class $ObjectPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.constructor
    // 19.1.3.1 Object.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.hasownproperty
    // 19.1.3.2 Object.prototype.hasOwnProperty ( V )
    get $hasOwnProperty() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$hasOwnProperty)['[[Value]]'];
    }
    set $hasOwnProperty(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$hasOwnProperty, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.isprototypeof
    // 19.1.3.3 Object.prototype.isPrototypeOf ( V )
    get $isPrototypeOf() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$isPrototypeOf)['[[Value]]'];
    }
    set $isPrototypeOf(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$isPrototypeOf, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.propertyisenumerable
    // 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )
    get $propertyIsEnumerable() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$propertyIsEnumerable)['[[Value]]'];
    }
    set $propertyIsEnumerable(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$propertyIsEnumerable, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.tolocalestring
    // 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
    get $toLocaleString() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$toLocaleString)['[[Value]]'];
    }
    set $toLocaleString(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$toLocaleString, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.tostring
    // 19.1.3.6 Object.prototype.toString ( )
    get $toString() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$toString)['[[Value]]'];
    }
    set $toString(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$toString, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-object.prototype.valueof
    // 19.1.3.7 Object.prototype.valueOf ( )
    get $valueOf() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$valueOf)['[[Value]]'];
    }
    set $valueOf(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$valueOf, value);
    }
    constructor(realm) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%ObjectPrototype%', intrinsics.null, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.prototype.hasownproperty
// 19.1.3.2 Object.prototype.hasOwnProperty ( V )
class $ObjectPrototype_hasOwnProperty extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.prototype.hasOwnProperty', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Let P be ? ToPropertyKey(V).
        // 2. Let O be ? ToObject(this value).
        // 3. Return ? HasOwnProperty(O, P).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.prototype.isprototypeof
// 19.1.3.3 Object.prototype.isPrototypeOf ( V )
class $ObjectPrototype_isPrototypeOf extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.prototype.isPrototypeOf', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. If Type(V) is not Object, return false.
        // 2. Let O be ? ToObject(this value).
        // 3. Repeat,
        // 3. a. Set V to ? V.[[GetPrototypeOf]]().
        // 3. b. If V is null, return false.
        // 3. c. If SameValue(O, V) is true, return true.
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.prototype.propertyisenumerable
// 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )
class $ObjectPrototype_propertyIsEnumerable extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.prototype.propertyIsEnumerable', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Let P be ? ToPropertyKey(V).
        // 2. Let O be ? ToObject(this value).
        // 3. Let desc be ? O.[[GetOwnProperty]](P).
        // 4. If desc is undefined, return false.
        // 5. Return desc.[[Enumerable]].
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.prototype.tolocalestring
// 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )
class $ObjectPrototype_toLocaleString extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.prototype.toLocaleString', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Let O be the this value.
        // 2. Return ? Invoke(O, "toString").
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.prototype.tostring
// 19.1.3.6 Object.prototype.toString ( )
class $ObjProto_toString extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Object.prototype.toString', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If the this value is undefined, return "[object Undefined]".
        if (thisArgument.isUndefined) {
            return new $String(realm, '[object Undefined]');
        }
        // 2. If the this value is null, return "[object Null]".
        if (thisArgument.isNull) {
            return new $String(realm, '[object Null]');
        }
        // 3. Let O be ! ToObject(this value).
        const O = thisArgument.ToObject(ctx);
        const tag = O['[[Get]]'](ctx, intrinsics['@@toStringTag'], O);
        if (tag.isAbrupt) {
            return tag;
        }
        if (tag.isString) {
            return new $String(realm, `[object ${tag['[[Value]]']}]`);
        }
        // 4. Let isArray be ? IsArray(O).
        // 5. If isArray is true, let builtinTag be "Array".
        if (O.isArray) {
            // TODO: implement IsArray semantics for proxy with null handler (which throws type error)
            return new $String(realm, `[object Array]`);
        }
        // 6. Else if O is a String exotic object, let builtinTag be "String".
        if (O instanceof $StringExoticObject) {
            return new $String(realm, `[object String]`);
        }
        // 7. Else if O has a [[ParameterMap]] internal slot, let builtinTag be "Arguments".
        if ('[[ParameterMap]]' in O) {
            return new $String(realm, `[object Arguments]`);
        }
        // 8. Else if O has a [[Call]] internal method, let builtinTag be "Function".
        if ('[[Call]]' in O) {
            return new $String(realm, `[object Function]`);
        }
        // 9. Else if O has an [[ErrorData]] internal slot, let builtinTag be "Error".
        if ('[[ErrorData]]' in O) {
            return new $String(realm, `[object Error]`);
        }
        // 10. Else if O has a [[BooleanData]] internal slot, let builtinTag be "Boolean".
        if ('[[BooleanData]]' in O) {
            return new $String(realm, `[object Boolean]`);
        }
        // 11. Else if O has a [[NumberData]] internal slot, let builtinTag be "Number".
        if ('[[NumberData]]' in O) {
            return new $String(realm, `[object Number]`);
        }
        // 12. Else if O has a [[DateValue]] internal slot, let builtinTag be "Date".
        if ('[[DateValue]]' in O) {
            return new $String(realm, `[object Date]`);
        }
        // 13. Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be "RegExp".
        if ('[[RegExpMatcher]]' in O) {
            return new $String(realm, `[object RegExp]`);
        }
        // 14. Else, let builtinTag be "Object".
        return new $String(realm, `[object Object]`);
        // 15. Let tag be ? Get(O, @@toStringTag).
        // 16. If Type(tag) is not String, set tag to builtinTag.
        // 17. Return the string-concatenation of "[object ", tag, and "]".
    }
}
// http://www.ecma-international.org/ecma-262/#sec-object.prototype.valueof
// 19.1.3.7 Object.prototype.valueOf ( )
class $ObjProto_valueOf extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%ObjProto_valueOf%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Return ? ToObject(this value).
        throw new Error('Method not implemented.');
    }
}
// #endregion

class $ComputedPropertyName {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ComputedPropertyName`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        this.PropName = new $Empty(realm, void 0, void 0, this);
    }
    get $kind() { return typescript.SyntaxKind.ComputedPropertyName; }
    // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation
    // 12.2.6.7 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        // ComputedPropertyName : [ AssignmentExpression ]
        // 1. Let exprValue be the result of evaluating AssignmentExpression.
        const exprValue = this.$expression.Evaluate(ctx);
        // 2. Let propName be ? GetValue(exprValue).
        const propName = exprValue.GetValue(ctx);
        if (propName.isAbrupt) {
            return propName.enrichWith(ctx, this);
        }
        // 3. Return ? ToPropertyKey(propName).
        return propName.ToPropertyKey(ctx).enrichWith(ctx, this);
    }
    // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation
    EvaluatePropName(ctx) {
        ctx.checkTimeout();
        return this.Evaluate(ctx);
    }
}
class $ObjectBindingPattern {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ObjectBindingPattern`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.combinedModifierFlags = parent.combinedModifierFlags;
        ctx |= 64 /* InBindingPattern */;
        const $elements = this.$elements = $bindingElementList(node.elements, this, ctx);
        this.BoundNames = $elements.flatMap(getBoundNames);
        this.ContainsExpression = $elements.some(getContainsExpression);
        this.HasInitializer = $elements.some(getHasInitializer);
        this.IsSimpleParameterList = $elements.every(getIsSimpleParameterList);
    }
    get $kind() { return typescript.SyntaxKind.ObjectBindingPattern; }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization
    // 13.3.3.5 Runtime Semantics: BindingInitialization
    InitializeBinding(ctx, value, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeBinding(#${ctx.id})`);
        const realm = ctx.Realm;
        // BindingPattern : ObjectBindingPattern
        // 1. Perform ? RequireObjectCoercible(value).
        if (value.isNil) {
            return new $TypeError(realm, `Cannot destructure ${value['[[Value]]']} into object`).enrichWith(ctx, this);
        }
        const elements = this.$elements;
        for (let i = 0, ii = elements.length; i < ii; ++i) {
            const el = elements[i];
            const result = el.InitializePropertyBinding(ctx, value, environment);
            if (result.isAbrupt) {
                return result.enrichWith(ctx, this);
            }
        }
        return new $Empty(realm);
    }
}
function $$arrayBindingElement(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.BindingElement:
            return new $BindingElement(node, parent, ctx, idx);
        case typescript.SyntaxKind.OmittedExpression:
            return new $OmittedExpression(node, parent, ctx, idx);
    }
}
function $$arrayBindingElementList(nodes, parent, ctx) {
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = $$arrayBindingElement(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
function $bindingElementList(nodes, parent, ctx) {
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $BindingElement(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
class $ArrayBindingPattern {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ArrayBindingPattern`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.combinedModifierFlags = parent.combinedModifierFlags;
        ctx |= 64 /* InBindingPattern */;
        const $elements = this.$elements = $$arrayBindingElementList(node.elements, this, ctx);
        this.BoundNames = $elements.flatMap(getBoundNames);
        this.ContainsExpression = $elements.some(getContainsExpression);
        this.HasInitializer = $elements.some(getHasInitializer);
        this.IsSimpleParameterList = $elements.every(getIsSimpleParameterList);
    }
    get $kind() { return typescript.SyntaxKind.ArrayBindingPattern; }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization
    // 13.3.3.5 Runtime Semantics: BindingInitialization
    InitializeBinding(ctx, value, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeBinding(#${ctx.id})`);
        // BindingPattern : ArrayBindingPattern
        // 1. Let iteratorRecord be ? GetIterator(value).
        const iteratorRecord = $GetIterator(ctx, value);
        if (iteratorRecord.isAbrupt) {
            return iteratorRecord.enrichWith(ctx, this);
        }
        // 2. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.
        const result = this.InitializeIteratorBinding(ctx, iteratorRecord, environment);
        if (result.isAbrupt) {
            return result.enrichWith(ctx, this);
        } // TODO: we sure about this? Spec doesn't say it
        // 3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).
        if (iteratorRecord['[[Done]]'].isFalsey) {
            return $IteratorClose(ctx, iteratorRecord, result).enrichWith(ctx, this);
        }
        // 4. Return result.
        return result;
    }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
    // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
    InitializeIteratorBinding(ctx, iteratorRecord, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);
        const realm = ctx.Realm;
        const elements = this.$elements;
        for (let i = 0, ii = elements.length; i < ii; ++i) {
            const el = elements[i];
            switch (el.$kind) {
                case typescript.SyntaxKind.OmittedExpression: {
                    if (i + 1 === ii) {
                        // If the last element is an elision, skip it as per the runtime semantics:
                        // ArrayBindingPattern : [ BindingElementList , ]
                        // 1. Return the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.
                        // ArrayBindingPattern : [ Elision ]
                        // 1. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
                        break;
                    }
                    const result = el.EvaluateDestructuringAssignmentIterator(ctx, iteratorRecord);
                    if (result.isAbrupt) {
                        return result.enrichWith(ctx, this);
                    }
                    break;
                }
                case typescript.SyntaxKind.BindingElement: {
                    // ArrayBindingPattern : [ Elision opt BindingRestElement ]
                    // 1. If Elision is present, then
                    // 1. a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
                    // 2. Return the result of performing IteratorBindingInitialization for BindingRestElement with iteratorRecord and environment as arguments.
                    // ArrayBindingPattern : [ BindingElementList ]
                    // 1. Return the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.
                    // ArrayBindingPattern : [ BindingElementList , Elision ]
                    // 1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.
                    // 2. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
                    // ArrayBindingPattern : [ BindingElementList , Elision opt BindingRestElement ]
                    // 1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.
                    // 2. If Elision is present, then
                    // 2. a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.
                    // 3. Return the result of performing IteratorBindingInitialization for BindingRestElement with iteratorRecord and environment as arguments.
                    const result = el.InitializeIteratorBinding(ctx, iteratorRecord, environment);
                    if (result.isAbrupt) {
                        return result.enrichWith(ctx, this);
                    }
                    if (i + 1 === ii) {
                        return result;
                    }
                }
            }
        }
        // ArrayBindingPattern : [ ]
        // 1. Return NormalCompletion(empty).
        return new $Empty(realm);
    }
}
class $BindingElement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.BindingElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.combinedModifierFlags = this.modifierFlags | parent.combinedModifierFlags;
        ctx = clearBit(ctx, 8 /* IsBindingName */);
        if (node.propertyName === void 0) {
            this.$propertyName = void 0;
            const $name = this.$name = $$bindingName(node.name, this, ctx | 8 /* IsBindingName */, -1);
            this.BoundNames = $name.BoundNames;
            if (node.initializer === void 0) {
                this.$initializer = void 0;
                this.ContainsExpression = $name.ContainsExpression;
                this.HasInitializer = false;
                this.IsSimpleParameterList = $name.$kind === typescript.SyntaxKind.Identifier;
            }
            else {
                this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
                this.ContainsExpression = true;
                this.HasInitializer = true;
                this.IsSimpleParameterList = false;
            }
        }
        else {
            const $propertyName = this.$propertyName = $$propertyName(node.propertyName, this, ctx, -1);
            const $name = this.$name = $$bindingName(node.name, this, ctx | 8 /* IsBindingName */, -1);
            this.BoundNames = $name.BoundNames;
            if (node.initializer === void 0) {
                this.$initializer = void 0;
                this.ContainsExpression = $propertyName.$kind === typescript.SyntaxKind.ComputedPropertyName || $name.ContainsExpression;
                this.HasInitializer = false;
                this.IsSimpleParameterList = $name.$kind === typescript.SyntaxKind.Identifier;
            }
            else {
                this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
                this.ContainsExpression = true;
                this.HasInitializer = true;
                this.IsSimpleParameterList = false;
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.BindingElement; }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization
    // 13.3.3.6 Runtime Semantics: PropertyBindingInitialization
    InitializePropertyBinding(ctx, value, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializePropertyBinding(#${ctx.id})`);
        const PropertyName = this.$propertyName;
        // BindingProperty : SingleNameBinding
        if (PropertyName === void 0) {
            // 1. Let name be the string that is the only element of BoundNames of SingleNameBinding.
            // 2. Perform ? KeyedBindingInitialization for SingleNameBinding using value, environment, and name as the arguments.
            // 3. Return a new List containing name.
            // Cast is safe because when propertyName is undefined, destructuring is syntactically not possible
            return this.$name.InitializePropertyBinding(ctx, value, environment).enrichWith(ctx, this);
        }
        // BindingProperty : PropertyName : BindingElement
        // 1. Let P be the result of evaluating PropertyName.
        const P = PropertyName.Evaluate(ctx);
        // 2. ReturnIfAbrupt(P).
        if (P.isAbrupt) {
            return P.enrichWith(ctx, this);
        }
        // 3. Perform ? KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.
        const result = this.InitializeKeyedBinding(ctx, value, environment, P); // TODO: this cast is very wrong. Need to revisit later
        if (result.isAbrupt) {
            return result.enrichWith(ctx, this);
        }
        // 4. Return a new List containing P.
        return new $List(P); // TODO: this cast is very wrong. Need to revisit later
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-keyedbindinginitialization
    // 13.3.3.9 Runtime Semantics: KeyedBindingInitialization
    InitializeKeyedBinding(ctx, value, environment, propertyName, initializer) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeKeyedBinding(#${ctx.id})`);
        ctx.Realm;
        const BindingElement = this.$name;
        // SingleNameBinding : BindingIdentifier Initializer opt
        // 1. Let bindingId be StringValue of BindingIdentifier.
        // 2. Let lhs be ? ResolveBinding(bindingId, environment).
        // 3. Let v be ? GetV(value, propertyName).
        // 4. If Initializer is present and v is undefined, then
        // 4. a. If IsAnonymousFunctionDefinition(Initializer) is true, then
        // 4. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.
        // 4. b. Else,
        // 4. b. i. Let defaultValue be the result of evaluating Initializer.
        // 4. b. ii. Set v to ? GetValue(defaultValue).
        // 5. If environment is undefined, return ? PutValue(lhs, v).
        // 6. Return InitializeReferencedBinding(lhs, v).
        if (BindingElement.$kind === typescript.SyntaxKind.Identifier) {
            return BindingElement.InitializeKeyedBinding(ctx, value, environment, propertyName, initializer).enrichWith(ctx, this);
        }
        // BindingElement : BindingPattern Initializer opt
        // 1. Let v be ? GetV(value, propertyName).
        const obj = value.ToObject(ctx);
        if (obj.isAbrupt) {
            return obj.enrichWith(ctx, this);
        }
        let v = obj['[[Get]]'](ctx, propertyName, obj);
        if (v.isAbrupt) {
            return v.enrichWith(ctx, this);
        }
        // 2. If Initializer is present and v is undefined, then
        if (initializer !== void 0 && v.isUndefined) {
            // 2. a. Let defaultValue be the result of evaluating Initializer.
            const defaultValue = initializer.Evaluate(ctx);
            // 2. b. Set v to ? GetValue(defaultValue).
            v = defaultValue.GetValue(ctx);
            if (v.isAbrupt) {
                return v.enrichWith(ctx, this);
            }
        }
        // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.
        return BindingElement.InitializeBinding(ctx, v, environment).enrichWith(ctx, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
    // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
    InitializeIteratorBinding(ctx, iteratorRecord, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const BindingElement = this.$name;
        // BindingElement : SingleNameBinding
        // 1. Return the result of performing IteratorBindingInitialization for SingleNameBinding with iteratorRecord and environment as the arguments.
        // SingleNameBinding : BindingIdentifier Initializer opt
        // 1. Let bindingId be StringValue of BindingIdentifier.
        // 2. Let lhs be ? ResolveBinding(bindingId, environment).
        // 3. If iteratorRecord.[[Done]] is false, then
        // 3. a. Let next be IteratorStep(iteratorRecord).
        // 3. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
        // 3. c. ReturnIfAbrupt(next).
        // 3. d. If next is false, set iteratorRecord.[[Done]] to true.
        // 3. e. Else,
        // 3. e. i. Let v be IteratorValue(next).
        // 3. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
        // 3. e. iii. ReturnIfAbrupt(v).
        // 4. If iteratorRecord.[[Done]] is true, let v be undefined.
        // 5. If Initializer is present and v is undefined, then
        // 5. a. If IsAnonymousFunctionDefinition(Initializer) is true, then
        // 5. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.
        // 5. b. Else,
        // 5. b. i. Let defaultValue be the result of evaluating Initializer.
        // 5. b. ii. Set v to ? GetValue(defaultValue).
        // 6. If environment is undefined, return ? PutValue(lhs, v).
        // 7. Return InitializeReferencedBinding(lhs, v).
        if (BindingElement.$kind === typescript.SyntaxKind.Identifier) {
            return BindingElement.InitializeIteratorBinding(ctx, iteratorRecord, environment, this.$initializer).enrichWith(ctx, this);
        }
        // NOTE: this section is duplicated in ParameterDeclaration
        // BindingElement : BindingPattern Initializer opt
        let v = intrinsics.undefined; // TODO: sure about this?
        // 1. If iteratorRecord.[[Done]] is false, then
        if (iteratorRecord['[[Done]]'].isFalsey) {
            // 1. a. Let next be IteratorStep(iteratorRecord).
            const next = $IteratorStep(ctx, iteratorRecord);
            // 1. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (next.isAbrupt) {
                iteratorRecord['[[Done]]'] = intrinsics.true;
                // 1. c. ReturnIfAbrupt(next).
                if (next.isAbrupt) {
                    return next.enrichWith(ctx, this);
                }
            }
            // 1. d. If next is false, set iteratorRecord.[[Done]] to true.
            if (next.isFalsey) {
                iteratorRecord['[[Done]]'] = intrinsics.true;
            }
            // 1. e. Else,
            else {
                // 1. e. i. Let v be IteratorValue(next).
                v = $IteratorValue(ctx, next);
                // 1. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
                if (v.isAbrupt) {
                    iteratorRecord['[[Done]]'] = intrinsics.true;
                    // 1. e. iii. ReturnIfAbrupt(v).
                    if (v.isAbrupt) {
                        return v.enrichWith(ctx, this);
                    }
                }
            }
        }
        // 2. If iteratorRecord.[[Done]] is true, let v be undefined.
        if (iteratorRecord['[[Done]]'].isTruthy) {
            v = intrinsics.undefined;
        }
        const initializer = this.$initializer;
        // 3. If Initializer is present and v is undefined, then
        if (initializer !== void 0 && v.isUndefined) {
            // 3. a. Let defaultValue be the result of evaluating Initializer.
            const defaultValue = initializer.Evaluate(ctx);
            // 3. b. Set v to ? GetValue(defaultValue).
            v = defaultValue.GetValue(ctx);
            if (v.isAbrupt) {
                return v.enrichWith(ctx, this);
            }
        }
        // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.
        return BindingElement.InitializeBinding(ctx, v, environment).enrichWith(ctx, this);
    }
}
class $SpreadElement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.SpreadElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.SpreadElement; }
    // http://www.ecma-international.org/ecma-262/#sec-argument-lists-runtime-semantics-argumentlistevaluation
    // 12.3.6.1 Runtime Semantics: ArgumentListEvaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        // ArgumentList :
        //     ... AssignmentExpression
        // 1. Let list be a new empty List.
        const list = new $List();
        // 2. Let spreadRef be the result of evaluating AssignmentExpression.
        const spreadRef = this.$expression.Evaluate(ctx);
        // 3. Let spreadObj be ? GetValue(spreadRef).
        const spreadObj = spreadRef.GetValue(ctx);
        if (spreadObj.isAbrupt) {
            return spreadObj.enrichWith(ctx, this);
        }
        // 4. Let iteratorRecord be ? GetIterator(spreadObj).
        const iteratorRecord = $GetIterator(ctx, spreadObj);
        if (iteratorRecord.isAbrupt) {
            return iteratorRecord.enrichWith(ctx, this);
        }
        // 5. Repeat,
        while (true) {
            // 5. a. Let next be ? IteratorStep(iteratorRecord).
            const next = $IteratorStep(ctx, iteratorRecord);
            if (next.isAbrupt) {
                return next.enrichWith(ctx, this);
            }
            // 5. b. If next is false, return list.
            if (next.isFalsey) {
                return list;
            }
            // 5. c. Let nextArg be ? IteratorValue(next).
            const nextArg = $IteratorValue(ctx, next);
            if (nextArg.isAbrupt) {
                return nextArg.enrichWith(ctx, this);
            }
            // 5. d. Append nextArg as the last element of list.
            list.push(nextArg);
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-arrayaccumulation
    // 12.2.5.2 Runtime Semantics: ArrayAccumulation
    AccumulateArray(ctx, array, nextIndex) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        // SpreadElement : ... AssignmentExpression
        // 1. Let spreadRef be the result of evaluating AssignmentExpression.
        const spreadRef = this.$expression.Evaluate(ctx);
        // 2. Let spreadObj be ? GetValue(spreadRef).
        const spreadObj = spreadRef.GetValue(ctx);
        if (spreadObj.isAbrupt) {
            return spreadObj.enrichWith(ctx, this);
        }
        // 3. Let iteratorRecord be ? GetIterator(spreadObj).
        const iteratorRecord = $GetIterator(ctx, spreadObj);
        if (iteratorRecord.isAbrupt) {
            return iteratorRecord.enrichWith(ctx, this);
        }
        // 4. Repeat,
        while (true) {
            // 4. a. Let next be ? IteratorStep(iteratorRecord).
            const next = $IteratorStep(ctx, iteratorRecord);
            if (next.isAbrupt) {
                return next.enrichWith(ctx, this);
            }
            // 4. b. If next is false, return nextIndex.
            if (next.isFalsey) {
                return nextIndex;
            }
            // 4. c. Let nextValue be ? IteratorValue(next).
            const nextValue = $IteratorValue(ctx, next);
            if (nextValue.isAbrupt) {
                return nextValue.enrichWith(ctx, this);
            }
            // 4. d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).
            $CreateDataProperty(ctx, array, nextIndex.ToUint32(ctx).ToString(ctx), nextValue);
            // 4. e. Assert: status is true.
            // 4. f. Increase nextIndex by 1.
            nextIndex = new $Number(realm, nextIndex['[[Value]]'] + 1);
        }
    }
}
class $OmittedExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.OmittedExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames
        // 13.3.3.1 Static Semantics: BoundNames
        this.BoundNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression
        // 13.3.3.2 Static Semantics: ContainsExpression
        this.ContainsExpression = false;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer
        // 13.3.3.3 Static Semantics: HasInitializer
        this.HasInitializer = false;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist
        // 13.3.3.4 Static Semantics: IsSimpleParameterList
        this.IsSimpleParameterList = false;
    }
    get $kind() { return typescript.SyntaxKind.OmittedExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-iteratordestructuringassignmentevaluation
    // 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation
    EvaluateDestructuringAssignmentIterator(ctx, iteratorRecord) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.EvaluateDestructuringAssignmentIterator(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // Elision : ,
        // 1. If iteratorRecord.[[Done]] is false, then
        if (iteratorRecord['[[Done]]'].isFalsey) {
            // 1. a. Let next be IteratorStep(iteratorRecord).
            const next = $IteratorStep(ctx, iteratorRecord);
            // 1. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (next.isAbrupt) {
                iteratorRecord['[[Done]]'] = intrinsics.true;
                // 1. c. ReturnIfAbrupt(next).
                return next;
            }
            // 1. d. If next is false, set iteratorRecord.[[Done]] to true.
            if (next.isFalsey) {
                iteratorRecord['[[Done]]'] = intrinsics.true;
            }
        }
        // 2. Return NormalCompletion(empty).
        return new $Empty(realm);
    }
    Evaluate(ctx) {
        ctx.checkTimeout();
        return null; // TODO: implement this;
    }
}
// #endregion

// http://www.ecma-international.org/ecma-262/#sec-reference-specification-type
class $Reference {
    constructor(realm, baseValue, referencedName, strict, thisValue) {
        this.realm = realm;
        this.baseValue = baseValue;
        this.referencedName = referencedName;
        this.strict = strict;
        this.thisValue = thisValue;
    }
    // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.
    // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.
    // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.
    get isAbrupt() { return false; }
    enrichWith(ctx, node) {
        return this;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getbase
    // 6.2.4.1 GetBase ( V )
    GetBase() {
        // 1. Assert: Type(V) is Reference.
        // 2. Return the base value component of V.
        return this.baseValue;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getreferencedname
    // 6.2.4.2 GetReferencedName ( V )
    GetReferencedName() {
        // 1. Assert: Type(V) is Reference.
        // 2. Return the referenced name component of V.
        return this.referencedName;
    }
    // http://www.ecma-international.org/ecma-262/#sec-isstrictreference
    // 6.2.4.3 IsStrictReference ( V )
    IsStrictReference() {
        // 1. Assert: Type(V) is Reference.
        // 2. Return the strict reference flag of V.
        return this.strict;
    }
    // http://www.ecma-international.org/ecma-262/#sec-hasprimitivebase
    // 6.2.4.4 HasPrimitiveBase ( V )
    HasPrimitiveBase() {
        // 1. Assert: Type(V) is Reference.
        // 2. If Type(V's base value component) is Boolean, String, Symbol, or Number, return true; otherwise return false.
        if (this.baseValue.isPrimitive && !this.baseValue.isUndefined) {
            return this.realm['[[Intrinsics]]'].true;
        }
        return this.realm['[[Intrinsics]]'].false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-ispropertyreference
    // 6.2.4.5 IsPropertyReference ( V )
    IsPropertyReference() {
        // 1. Assert: Type(V) is Reference.
        // 2. If either the base value component of V is an Object or HasPrimitiveBase(V) is true, return true; otherwise return false.
        if (this.baseValue.isObject || this.HasPrimitiveBase().isTruthy) {
            return this.realm['[[Intrinsics]]'].true;
        }
        return this.realm['[[Intrinsics]]'].false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-isunresolvablereference
    // 6.2.4.6 IsUnresolvableReference ( V )
    IsUnresolvableReference() {
        // 1. Assert: Type(V) is Reference.
        // 2. If the base value component of V is undefined, return true; otherwise return false.
        if (this.baseValue.isUndefined) {
            return this.realm['[[Intrinsics]]'].true;
        }
        return this.realm['[[Intrinsics]]'].false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-issuperreference
    // 6.2.4.7 IsSuperReference ( V )
    IsSuperReference() {
        // 1. Assert: Type(V) is Reference.
        // 2. If V has a thisValue component, return true; otherwise return false.
        if (!this.thisValue.isUndefined) {
            return this.realm['[[Intrinsics]]'].true;
        }
        return this.realm['[[Intrinsics]]'].false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getvalue
    // 6.2.4.8 GetValue ( V )
    GetValue(ctx) {
        // 1. ReturnIfAbrupt(V).
        // 2. If Type(V) is not Reference, return V.
        // 3. Let base be GetBase(V).
        let base = this.GetBase();
        // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.
        if (this.IsUnresolvableReference().isTruthy) {
            return new $ReferenceError(ctx.Realm, `${this.referencedName['[[Value]]']} is not defined.`);
        }
        // 5. If IsPropertyReference(V) is true, then
        if (this.IsPropertyReference().isTruthy) {
            // 5. a. If HasPrimitiveBase(V) is true, then
            if (this.HasPrimitiveBase().isTruthy) {
                // 5. a. i. Assert: In this case, base will never be undefined or null.
                // 5. a. ii. Set base to ! ToObject(base).
                base = base.ToObject(ctx);
            }
            // 5. b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).
            return base['[[Get]]'](ctx, this.GetReferencedName(), this.GetThisValue());
        }
        // 6. Else base must be an Environment Record,
        else {
            // 6. a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).
            return base.GetBindingValue(ctx, this.GetReferencedName(), this.IsStrictReference());
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-putvalue
    // 6.2.4.9 PutValue ( V , W )
    PutValue(ctx, W) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. ReturnIfAbrupt(V).
        // 2. ReturnIfAbrupt(W).
        // 3. If Type(V) is not Reference, throw a ReferenceError exception.
        // 4. Let base be GetBase(V).
        let base = this.GetBase();
        // 5. If IsUnresolvableReference(V) is true, then
        if (this.IsUnresolvableReference().isTruthy) {
            // 5. a. If IsStrictReference(V) is true, then
            if (this.IsStrictReference().isTruthy) {
                // 5. a. i. Throw a ReferenceError exception.
                return new $ReferenceError(realm, `${this.referencedName['[[Value]]']} is not defined.`);
            }
            // 5. b. Let globalObj be GetGlobalObject().
            const globalObj = realm['[[GlobalObject]]'];
            // 5. c. Return ? Set(globalObj, GetReferencedName(V), W, false).
            return $Set(ctx, globalObj, this.GetReferencedName(), W, intrinsics.false);
        }
        // 6. Else if IsPropertyReference(V) is true, then
        else if (this.IsPropertyReference().isTruthy) {
            // 6. a. If HasPrimitiveBase(V) is true, then
            if (this.HasPrimitiveBase().isTruthy) {
                // 6. a. i. Assert: In this case, base will never be undefined or null.
                // 6. a. ii. Set base to ! ToObject(base).
                base = base.ToObject(ctx);
            }
            // 6. b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).
            const succeeded = base['[[Set]]'](ctx, this.GetReferencedName(), W, this.GetThisValue());
            if (succeeded.isAbrupt) {
                return succeeded;
            }
            // 6. c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.
            if (succeeded.isFalsey && this.IsStrictReference().isTruthy) {
                return new $TypeError(realm, `${this.referencedName['[[Value]]']} is not writable.`);
            }
            // 6. d. Return.
            return intrinsics.undefined;
        }
        // 7. Else base must be an Environment Record,
        else {
            // 7. a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).
            return base.SetMutableBinding(ctx, this.GetReferencedName(), W, this.IsStrictReference());
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-getthisvalue
    // 6.2.4.10 GetThisValue ( V )
    GetThisValue() {
        // 1. Assert: IsPropertyReference(V) is true.
        // 2. If IsSuperReference(V) is true, then
        if (this.IsSuperReference().isTruthy) {
            // 2. a. Return the value of the thisValue component of the reference V.
            return this.thisValue;
        }
        // 3. Return GetBase(V).
        return this.GetBase();
    }
    // http://www.ecma-international.org/ecma-262/#sec-initializereferencedbinding
    // 6.2.4.11 InitializeReferencedBinding ( V , W )
    InitializeReferencedBinding(ctx, W) {
        // 1. ReturnIfAbrupt(V).
        // 2. ReturnIfAbrupt(W).
        // 3. Assert: Type(V) is Reference.
        // 4. Assert: IsUnresolvableReference(V) is false.
        // 5. Let base be GetBase(V).
        const base = this.GetBase();
        // 6. Assert: base is an Environment Record.
        // 7. Return base.InitializeBinding(GetReferencedName(V), W).
        return base.InitializeBinding(ctx, this.GetReferencedName(), W);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects
class $NamespaceExoticObject extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-modulenamespacecreate
    // 9.4.6.11 ModuleNamespaceCreate ( module , exports )
    constructor(realm, mod, exports) {
        super(realm, 'NamespaceExoticObject', realm['[[Intrinsics]]'].null, 1 /* normal */, realm['[[Intrinsics]]'].empty);
        // 1. Assert: module is a Module Record.
        // 2. Assert: module.[[Namespace]] is undefined.
        // 3. Assert: exports is a List of String values.
        // 4. Let M be a newly created object.
        // 5. Set M's essential internal methods to the definitions specified in 9.4.6.
        // 6. Set M.[[Module]] to module.
        this['[[Module]]'] = mod;
        // 7. Let sortedExports be a new List containing the same values as the list exports where the values are ordered as if an Array of the same values had been sorted using Array.prototype.sort using undefined as comparefn.
        // 8. Set M.[[Exports]] to sortedExports.
        this['[[Exports]]'] = exports.$copy();
        // 9. Create own properties of M corresponding to the definitions in 26.3.
        // 10. Set module.[[Namespace]] to M.
        mod['[[Namespace]]'] = this;
        // 11. Return M.
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-setprototypeof-v
    // 9.4.6.1 [[SetPrototypeOf]] ( V )
    '[[SetPrototypeOf]]'(ctx, V) {
        // 1. Return ? SetImmutablePrototype(O, V).
        return $SetImmutablePrototype(ctx, this, V);
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-isextensible
    // 9.4.6.2 [[IsExtensible]] ( )
    '[[IsExtensible]]'(ctx) {
        // 1. Return false.
        return this.realm['[[Intrinsics]]'].false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-preventextensions
    // 9.4.6.3 [[PreventExtensions]] ( )
    '[[PreventExtensions]]'(ctx) {
        // 1. Return true.
        return this.realm['[[Intrinsics]]'].true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-getownproperty-p
    // 9.4.6.4 [[GetOwnProperty]] ( P )
    '[[GetOwnProperty]]'(ctx, P) {
        // 1. If Type(P) is Symbol, return OrdinaryGetOwnProperty(O, P).
        if (P.isSymbol) {
            return super['[[GetOwnProperty]]'](ctx, P);
        }
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const O = this;
        // 2. Let exports be O.[[Exports]].
        const exports = O['[[Exports]]'];
        // 3. If P is not an element of exports, return undefined.
        if (exports.every(x => !x.is(P))) {
            return intrinsics.undefined;
        }
        // 4. Let value be ? O.[[Get]](P, O).
        const value = O['[[Get]]'](ctx, P, O);
        if (value.isAbrupt) {
            return value;
        }
        // 5. Return PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }.
        const desc = new $PropertyDescriptor(realm, P);
        desc['[[Value]]'] = value;
        desc['[[Writable]]'] = intrinsics.true;
        desc['[[Enumerable]]'] = intrinsics.true;
        desc['[[Configurable]]'] = intrinsics.false;
        return desc;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-defineownproperty-p-desc
    // 9.4.6.5 [[DefineOwnProperty]] ( P , Desc )
    '[[DefineOwnProperty]]'(ctx, P, Desc) {
        // 1. If Type(P) is Symbol, return OrdinaryDefineOwnProperty(O, P, Desc).
        if (P.isSymbol) {
            return super['[[DefineOwnProperty]]'](ctx, P, Desc);
        }
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const O = this;
        // 2. Let current be ? O.[[GetOwnProperty]](P).
        const current = O['[[GetOwnProperty]]'](ctx, P);
        if (current.isAbrupt) {
            return current;
        }
        // 3. If current is undefined, return false.
        if (current.isUndefined) {
            return intrinsics.false;
        }
        // 4. If IsAccessorDescriptor(Desc) is true, return false.
        if (Desc.isAccessorDescriptor) {
            return intrinsics.false;
        }
        // 5. If Desc.[[Writable]] is present and has value false, return false.
        if (Desc['[[Writable]]'].hasValue && Desc['[[Writable]]'].isFalsey) {
            return intrinsics.false;
        }
        // 6. If Desc.[[Enumerable]] is present and has value false, return false.
        if (Desc['[[Enumerable]]'].hasValue && Desc['[[Enumerable]]'].isFalsey) {
            return intrinsics.false;
        }
        // 7. If Desc.[[Configurable]] is present and has value true, return false.
        if (Desc['[[Configurable]]'].hasValue === Desc['[[Configurable]]'].isTruthy) {
            return intrinsics.false;
        }
        // 8. If Desc.[[Value]] is present, return SameValue(Desc.[[Value]], current.[[Value]]).
        if (!Desc['[[Value]]'].isEmpty) {
            if (Desc['[[Value]]'].is(current['[[Value]]'])) {
                return intrinsics.true;
            }
            return intrinsics.false;
        }
        // 9. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-hasproperty-p
    // 9.4.6.6 [[HasProperty]] ( P )
    '[[HasProperty]]'(ctx, P) {
        // 1. If Type(P) is Symbol, return OrdinaryHasProperty(O, P).
        if (P.isSymbol) {
            return super['[[HasProperty]]'](ctx, P);
        }
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const O = this;
        // 2. Let exports be O.[[Exports]].
        const exports = O['[[Exports]]'];
        // 3. If P is an element of exports, return true.
        if (exports.some(x => x.is(P))) {
            return intrinsics.true;
        }
        // 4. Return false.
        return intrinsics.false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-get-p-receiver
    // 9.4.6.7 [[Get]] ( P , Receiver )
    '[[Get]]'(ctx, P, Receiver) {
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. If Type(P) is Symbol, then
        // 2. a. Return ? OrdinaryGet(O, P, Receiver).
        if (P.isSymbol) {
            return super['[[Get]]'](ctx, P, Receiver);
        }
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const O = this;
        // 3. Let exports be O.[[Exports]].
        const exports = O['[[Exports]]'];
        // 4. If P is not an element of exports, return undefined.
        if (exports.every(x => !x.is(P))) {
            return intrinsics.undefined;
        }
        // 5. Let m be O.[[Module]].
        const m = O['[[Module]]'];
        // 6. Let binding be ! m.ResolveExport(P, « »).
        const binding = m.ResolveExport(ctx, P, new ResolveSet());
        // 7. Assert: binding is a ResolvedBinding Record.
        // 8. Let targetModule be binding.[[Module]].
        const targetModule = binding.Module;
        // 9. Assert: targetModule is not undefined.
        // 10. Let targetEnv be targetModule.[[Environment]].
        const targetEnv = targetModule['[[Environment]]'];
        // 11. If targetEnv is undefined, throw a ReferenceError exception.
        if (targetEnv.isUndefined) {
            return new $ReferenceError(realm, `${P['[[Value]]']} cannot be resolved from namespace.`);
        }
        // 12. Let targetEnvRec be targetEnv's EnvironmentRecord.
        // 13. Return ? targetEnvRec.GetBindingValue(binding.[[BindingName]], true).
        return targetEnv.GetBindingValue(ctx, binding.BindingName, intrinsics.true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-set-p-v-receiver
    // 9.4.6.8 [[Set]] ( P , V , Receiver )
    '[[Set]]'(ctx, P, V, Receiver) {
        // 1. Return false.
        return ctx.Realm['[[Intrinsics]]'].false;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-delete-p
    // 9.4.6.9 [[Delete]] ( P )
    '[[Delete]]'(ctx, P) {
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. If Type(P) is Symbol, then
        // 2. a. Return ? OrdinaryDelete(O, P).
        if (P.isSymbol) {
            return super['[[Delete]]'](ctx, P);
        }
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const O = this;
        // 3. Let exports be O.[[Exports]].
        const exports = O['[[Exports]]'];
        // 4. If P is an element of exports, return false.
        if (exports.some(x => x.is(P))) {
            return intrinsics.false;
        }
        // 5. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-ownpropertykeys
    // 9.4.6.10 [[OwnPropertyKeys]] ( )
    '[[OwnPropertyKeys]]'(ctx) {
        // 1. Let exports be a copy of O.[[Exports]].
        const $exports = this['[[Exports]]'].$copy();
        // 2. Let symbolKeys be ! OrdinaryOwnPropertyKeys(O).
        const symbolKeys = super['[[OwnPropertyKeys]]'](ctx);
        // 3. Append all the entries of symbolKeys to the end of exports.
        $exports.push(...symbolKeys);
        // 4. Return exports.
        return $exports;
    }
}

function $expressionWithTypeArgumentsList(nodes, parent, ctx) {
    if (nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $ExpressionWithTypeArguments(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
class $HeritageClause {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.HeritageClause`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$types = $expressionWithTypeArgumentsList(node.types, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.HeritageClause; }
}
class $ExpressionWithTypeArguments {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ExpressionWithTypeArguments`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.ExpressionWithTypeArguments; }
}
// #endregion
class $ClassExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ClassExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-constructormethod
        // 14.6.3 Static Semantics: ConstructorMethod
        this.ConstructorMethod = void 0;
        // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isconstantdeclaration
        // 14.6.7 Static Semantics: IsConstantDeclaration
        this.IsConstantDeclaration = false;
        // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isfunctiondefinition
        // 14.6.8 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = true;
        const intrinsics = realm['[[Intrinsics]]'];
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        const $heritageClauses = this.$heritageClauses = $heritageClauseList(node.heritageClauses, this, ctx);
        const $members = this.$members = $$classElementList(node.members, this, ctx);
        this.ClassHeritage = $heritageClauses.find(h => h.node.token === typescript.SyntaxKind.ExtendsKeyword);
        if ($name === void 0) {
            this.BoundNames = [intrinsics['*default*']];
        }
        else {
            if (hasAllBits(modifierFlags, typescript.ModifierFlags.ExportDefault)) {
                this.BoundNames = [...$name.BoundNames, intrinsics['*default*']];
            }
            else {
                this.BoundNames = $name.BoundNames;
            }
        }
        const NonConstructorMethodDefinitions = this.NonConstructorMethodDefinitions = [];
        const PrototypePropertyNameList = this.PrototypePropertyNameList = [];
        let $member;
        for (let i = 0, ii = $members.length; i < ii; ++i) {
            $member = $members[i];
            switch ($member.$kind) {
                case typescript.SyntaxKind.PropertyDeclaration:
                    break;
                case typescript.SyntaxKind.Constructor:
                    this.ConstructorMethod = $member;
                    break;
                case typescript.SyntaxKind.MethodDeclaration:
                case typescript.SyntaxKind.GetAccessor:
                case typescript.SyntaxKind.SetAccessor:
                    NonConstructorMethodDefinitions.push($member);
                    if (!$member.PropName.isEmpty && !$member.IsStatic) {
                        PrototypePropertyNameList.push($member.PropName);
                    }
                    break;
                case typescript.SyntaxKind.SemicolonClassElement:
            }
        }
        this.HasName = $name !== void 0;
    }
    get $kind() { return typescript.SyntaxKind.ClassExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-class-definitions-runtime-semantics-namedevaluation
    // 14.6.15 Runtime Semantics: NamedEvaluation
    EvaluateNamed(ctx, name) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // ClassExpression : class ClassTail
        // 1. Return the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and name.
        return $ClassDeclaration.prototype.EvaluateClassDefinition.call(this, ctx, intrinsics.undefined, name);
    }
    // http://www.ecma-international.org/ecma-262/#sec-class-definitions-runtime-semantics-evaluation
    // 14.6.16 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ClassExpression : class BindingIdentifier opt ClassTail
        // 1. If BindingIdentifieropt is not present, let className be undefined.
        // 2. Else, let className be StringValue of BindingIdentifier.
        const className = this.$name === void 0 ? intrinsics.undefined : this.$name.StringValue;
        // 3. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments className and className.
        const value = $ClassDeclaration.prototype.EvaluateClassDefinition.call(this, ctx, className, className);
        // 4. ReturnIfAbrupt(value).
        if (value.isAbrupt) {
            return value.enrichWith(ctx, this);
        }
        // 5. Set value.[[SourceText]] to the source text matched by ClassExpression.
        value['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 6. Return value.
        return value;
    }
}
class $ClassDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ClassDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isconstantdeclaration
        // 14.6.7 Static Semantics: IsConstantDeclaration
        this.IsConstantDeclaration = false;
        // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isfunctiondefinition
        // 14.6.8 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = true;
        this.VarDeclaredNames = kernel.emptyArray; // TODO: this is actually not explicitly specced. Need to double check
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-lexicallyscopeddeclarations
        // 15.2.3.8 Static Semantics: LexicallyScopedDeclarations
        this.LexicallyDeclaredNames = kernel.emptyArray; // TODO: this is actually not explicitly specced. Need to double check
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const intrinsics = realm['[[Intrinsics]]'];
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (hasBit(modifierFlags, typescript.ModifierFlags.Export)) {
            ctx |= 4096 /* InExport */;
        }
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        let $name;
        if (node.name === void 0) {
            $name = this.$name = new $Undefined(realm, void 0, void 0, this);
        }
        else {
            $name = this.$name = new $Identifier(node.name, this, ctx, -1);
        }
        const $heritageClauses = this.$heritageClauses = $heritageClauseList(node.heritageClauses, this, ctx);
        const $members = this.$members = $$classElementList(node.members, this, ctx);
        this.ClassHeritage = $heritageClauses.find(h => h.node.token === typescript.SyntaxKind.ExtendsKeyword);
        const NonConstructorMethodDefinitions = this.NonConstructorMethodDefinitions = [];
        const PrototypePropertyNameList = this.PrototypePropertyNameList = [];
        let $member;
        for (let i = 0, ii = $members.length; i < ii; ++i) {
            $member = $members[i];
            switch ($member.$kind) {
                case typescript.SyntaxKind.PropertyDeclaration:
                    break;
                case typescript.SyntaxKind.Constructor:
                    this.ConstructorMethod = $member;
                    break;
                case typescript.SyntaxKind.MethodDeclaration:
                case typescript.SyntaxKind.GetAccessor:
                case typescript.SyntaxKind.SetAccessor:
                    NonConstructorMethodDefinitions.push($member);
                    if (!$member.PropName.isEmpty && !$member.IsStatic) {
                        PrototypePropertyNameList.push($member.PropName);
                    }
                    break;
                case typescript.SyntaxKind.SemicolonClassElement:
            }
        }
        const HasName = this.HasName = !$name.isUndefined;
        if (hasBit(ctx, 4096 /* InExport */)) {
            if (hasBit(this.modifierFlags, typescript.ModifierFlags.Default)) {
                if (HasName) {
                    const [localName] = $name.BoundNames;
                    const BoundNames = this.BoundNames = [localName, intrinsics['*default*']];
                    this.ExportedBindings = BoundNames;
                    this.ExportedNames = [intrinsics['default']];
                    this.ExportEntries = [
                        new ExportEntryRecord(
                        /* source */ this, 
                        /* ExportName */ intrinsics['default'], 
                        /* ModuleRequest */ intrinsics.null, 
                        /* ImportName */ intrinsics.null, 
                        /* LocalName */ localName),
                    ];
                }
                else {
                    const BoundNames = this.BoundNames = [intrinsics['*default*']];
                    this.ExportedBindings = BoundNames;
                    this.ExportedNames = [intrinsics['default']];
                    this.ExportEntries = [
                        new ExportEntryRecord(
                        /* source */ this, 
                        /* ExportName */ intrinsics['default'], 
                        /* ModuleRequest */ intrinsics.null, 
                        /* ImportName */ intrinsics.null, 
                        /* LocalName */ intrinsics['*default*']),
                    ];
                }
                this.LexicallyScopedDeclarations = [this];
            }
            else {
                // Must have a name, so we assume it does
                const BoundNames = this.BoundNames = $name.BoundNames;
                const [localName] = BoundNames;
                this.ExportedBindings = BoundNames;
                this.ExportedNames = BoundNames;
                this.ExportEntries = [
                    new ExportEntryRecord(
                    /* source */ this, 
                    /* ExportName */ localName, 
                    /* ModuleRequest */ intrinsics.null, 
                    /* ImportName */ intrinsics.null, 
                    /* LocalName */ localName),
                ];
                this.LexicallyScopedDeclarations = [this];
            }
        }
        else {
            // Must have a name, so we assume it does
            this.BoundNames = $name.BoundNames;
            this.ExportedBindings = kernel.emptyArray;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = kernel.emptyArray;
            this.LexicallyScopedDeclarations = kernel.emptyArray;
        }
        this.ModuleRequests = kernel.emptyArray;
    }
    get $kind() { return typescript.SyntaxKind.ClassDeclaration; }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-classdefinitionevaluation
    // 14.6.13 Runtime Semantics: ClassDefinitionEvaluation
    EvaluateClassDefinition(ctx, classBinding, className) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // ClassTail : ClassHeritage opt { ClassBody opt }
        // 1. Let lex be the LexicalEnvironment of the running execution context.
        const lex = ctx.LexicalEnvironment;
        // 2. Let classScope be NewDeclarativeEnvironment(lex).
        const classScope = new $DeclarativeEnvRec(this.logger, realm, lex);
        // 3. Let classScopeEnvRec be classScope's EnvironmentRecord.
        // 4. If classBinding is not undefined, then
        if (!classBinding.isUndefined) {
            // 4. a. Perform classScopeEnvRec.CreateImmutableBinding(classBinding, true).
            classScope.CreateImmutableBinding(ctx, classBinding, intrinsics.true);
        }
        let protoParent;
        let constructorParent;
        // 5. If ClassHeritageopt is not present, then
        if (this.ClassHeritage === void 0) {
            // 5. a. Let protoParent be the intrinsic object %ObjectPrototype%.
            protoParent = intrinsics['%ObjectPrototype%'];
            // 5. b. Let constructorParent be the intrinsic object %FunctionPrototype%.
            constructorParent = intrinsics['%FunctionPrototype%'];
        }
        // 6. Else,
        else {
            // 6. a. Set the running execution context's LexicalEnvironment to classScope.
            ctx.LexicalEnvironment = classScope;
            // 6. b. Let superclassRef be the result of evaluating ClassHeritage.
            const superClassRef = this.ClassHeritage.$types[0].$expression.Evaluate(ctx);
            // 6. c. Set the running execution context's LexicalEnvironment to lex.
            ctx.LexicalEnvironment = lex;
            // 6. d. Let superclass be ? GetValue(superclassRef).
            const superClass = superClassRef.GetValue(ctx);
            if (superClass.isAbrupt) {
                return superClass.enrichWith(ctx, this);
            }
            // 6. e. If superclass is null, then
            if (superClass.isNull) {
                // 6. e. i. Let protoParent be null.
                protoParent = intrinsics.null;
                // 6. e. ii. Let constructorParent be the intrinsic object %FunctionPrototype%.
                constructorParent = intrinsics['%FunctionPrototype%'];
            }
            // 6. f. Else if IsConstructor(superclass) is false, throw a TypeError exception.
            else if (!superClass.isFunction) {
                return new $TypeError(realm, `Superclass is ${superClass}, but expected a function`);
            }
            // 6. g. Else,
            else {
                // 6. g. i. Let protoParent be ? Get(superclass, "prototype").
                const $protoParent = superClass['[[Get]]'](ctx, intrinsics.$prototype, superClass);
                if ($protoParent.isAbrupt) {
                    return $protoParent.enrichWith(ctx, this);
                }
                // 6. g. ii. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.
                if (!$protoParent.isObject && !$protoParent.isNull) {
                    return new $TypeError(realm, `Superclass prototype is ${superClass}, but expected null or an object`);
                }
                protoParent = $protoParent;
                // 6. g. iii. Let constructorParent be superclass.
                constructorParent = superClass;
            }
        }
        // 7. Let proto be ObjectCreate(protoParent).
        const proto = new $Object(realm, 'proto', protoParent, 1 /* normal */, intrinsics.empty);
        let constructor;
        // 8. If ClassBodyopt is not present, let constructor be empty.
        if (this.ConstructorMethod === void 0) {
            constructor = intrinsics.empty;
        }
        // 9. Else, let constructor be ConstructorMethod of ClassBody.
        else {
            constructor = this.ConstructorMethod;
        }
        // 10. If constructor is empty, then
        if (constructor instanceof $Empty) {
            // 10. a. If ClassHeritageopt is present, then
            if (this.ClassHeritage !== void 0) {
                // 10. a. i. Set constructor to the result of parsing the source text constructor(... args){ super (...args);} using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].
                constructor = this.ConstructorMethod = new $ConstructorDeclaration(typescript.createConstructor(void 0, void 0, [
                    typescript.createParameter(void 0, void 0, typescript.createToken(typescript.SyntaxKind.DotDotDotToken), typescript.createIdentifier('args')),
                ], typescript.createBlock([
                    typescript.createExpressionStatement(typescript.createCall(typescript.createSuper(), void 0, [
                        typescript.createSpread(typescript.createIdentifier('args')),
                    ])),
                ])), this, this.ctx, -1);
            }
            // 10. b. Else,
            else {
                // 10. b. i. Set constructor to the result of parsing the source text constructor(){ } using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].
                constructor = this.ConstructorMethod = new $ConstructorDeclaration(typescript.createConstructor(void 0, void 0, [], typescript.createBlock([])), this, this.ctx, -1);
            }
        }
        // 11. Set the running execution context's LexicalEnvironment to classScope.
        ctx.LexicalEnvironment = classScope;
        // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.
        const constructorInfo = constructor.DefineMethod(ctx, proto, constructorParent);
        // 13. Assert: constructorInfo is not an abrupt completion.
        // 14. Let F be constructorInfo.[[Closure]].
        const F = constructorInfo['[[Closure]]'];
        // 15. If ClassHeritageopt is present, set F.[[ConstructorKind]] to "derived".
        if (this.ClassHeritage !== void 0) {
            F['[[ConstructorKind]]'] = 'derived';
        }
        // 16. Perform MakeConstructor(F, false, proto).
        F.MakeConstructor(ctx, intrinsics.false, proto);
        // 17. Perform MakeClassConstructor(F).
        F['[[FunctionKind]]'] = 2 /* classConstructor */;
        // 18. If className is not undefined, then
        if (!className.isUndefined) {
            // 18. a. Perform SetFunctionName(F, className).
            F.SetFunctionName(ctx, className);
        }
        // 19. Perform CreateMethodProperty(proto, "constructor", F).
        proto['[[DefineOwnProperty]]'](ctx, intrinsics.$constructor, new $PropertyDescriptor(realm, intrinsics.$constructor, {
            '[[Value]]': F,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.true,
        }));
        // 20. If ClassBodyopt is not present, let methods be a new empty List.
        // 21. Else, let methods be NonConstructorMethodDefinitions of ClassBody.
        const methods = this.NonConstructorMethodDefinitions;
        let status;
        // 22. For each ClassElement m in order from methods, do
        for (const m of methods) {
            // 22. a. If IsStatic of m is false, then
            if (!m.IsStatic) {
                // 22. a. i. Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.
                status = m.EvaluatePropertyDefinition(ctx, proto, intrinsics.false);
            }
            // 22. b. Else,
            else {
                // 22. b. i. Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.
                status = m.EvaluatePropertyDefinition(ctx, F, intrinsics.false);
            }
            // 22. c. If status is an abrupt completion, then
            if (status.isAbrupt) {
                // 22. c. i. Set the running execution context's LexicalEnvironment to lex.
                ctx.LexicalEnvironment = lex;
                // 22. c. ii. Return Completion(status).
                return status;
            }
        }
        // 23. Set the running execution context's LexicalEnvironment to lex.
        ctx.LexicalEnvironment = lex;
        // 24. If classBinding is not undefined, then
        if (!classBinding.isUndefined) {
            // 24. a. Perform classScopeEnvRec.InitializeBinding(classBinding, F).
            classScope.InitializeBinding(ctx, classBinding, F);
        }
        // 25. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-bindingclassdeclarationevaluation
    // 14.6.14 Runtime Semantics: BindingClassDeclarationEvaluation
    EvaluateBindingClassDeclaration(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const name = this.$name;
        if (name.isUndefined) {
            // ClassDeclaration : class ClassTail
            // 1. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and "default".
            const value = this.EvaluateClassDefinition(ctx, intrinsics.undefined, intrinsics.default);
            // 2. ReturnIfAbrupt(value).
            if (value.isAbrupt) {
                return value.enrichWith(ctx, this);
            }
            // 3. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
            value['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
            // 4. Return value.
            return value;
        }
        // ClassDeclaration : class BindingIdentifier ClassTail
        // 1. Let className be StringValue of BindingIdentifier.
        const className = name.StringValue;
        // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments className and className.
        const value = this.EvaluateClassDefinition(ctx, className, className);
        // 3. ReturnIfAbrupt(value).
        if (value.isAbrupt) {
            return value.enrichWith(ctx, this);
        }
        // 4. Set value.[[SourceText]] to the source text matched by ClassDeclaration.
        value['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 5. Let env be the running execution context's LexicalEnvironment.
        // 6. Perform ? InitializeBoundName(className, value, env).
        const $InitializeBoundNameResult = ctx.LexicalEnvironment.InitializeBinding(ctx, className, value);
        if ($InitializeBoundNameResult.isAbrupt) {
            return $InitializeBoundNameResult.enrichWith(ctx, this);
        }
        // 7. Return value.
        return value;
    }
    // http://www.ecma-international.org/ecma-262/#sec-class-definitions-runtime-semantics-evaluation
    // 14.6.16 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // ClassDeclaration : class BindingIdentifier ClassTail
        // 1. Perform ? BindingClassDeclarationEvaluation of this ClassDeclaration.
        const $EvaluateBindingClassDeclarationResult = this.EvaluateBindingClassDeclaration(ctx);
        if ($EvaluateBindingClassDeclarationResult.isAbrupt) {
            return $EvaluateBindingClassDeclarationResult.enrichWith(ctx, this);
        }
        // 2. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        ctx.checkTimeout();
        return this.ConstructorMethod.EvaluateBody(ctx, functionObject, argumentsList);
    }
}
class $PropertyDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.PropertyDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        this.$name = $$propertyName(node.name, this, ctx | 512 /* IsMemberName */, -1);
        this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
        this.IsStatic = hasBit(modifierFlags, typescript.ModifierFlags.Static);
    }
    get $kind() { return typescript.SyntaxKind.PropertyDeclaration; }
}
class $SemicolonClassElement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.SemicolonClassElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-isstatic
        // 14.6.9 Static Semantics: IsStatic
        this.IsStatic = false;
        // http://www.ecma-international.org/ecma-262/#sec-method-definitions-static-semantics-propname
        // 14.3.5 Static Semantics: PropName
        this.PropName = empty;
    }
    get $kind() { return typescript.SyntaxKind.SemicolonClassElement; }
}

class $InterfaceDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.InterfaceDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.VarDeclaredNames = kernel.emptyArray;
        this.VarScopedDeclarations = kernel.emptyArray;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.IsType = true;
        const intrinsics = realm['[[Intrinsics]]'];
        ctx |= 128 /* InTypeElement */;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (hasBit(modifierFlags, typescript.ModifierFlags.Export)) {
            ctx |= 4096 /* InExport */;
        }
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        this.$heritageClauses = $heritageClauseList(node.heritageClauses, this, ctx);
        const BoundNames = this.BoundNames = $name.BoundNames;
        this.TypeDeclarations = [this];
        if (hasBit(ctx, 4096 /* InExport */)) {
            const [localName] = BoundNames;
            this.ExportedBindings = BoundNames;
            this.ExportedNames = BoundNames;
            this.ExportEntries = [
                new ExportEntryRecord(
                /* source */ this, 
                /* ExportName */ localName, 
                /* ModuleRequest */ intrinsics.null, 
                /* ImportName */ intrinsics.null, 
                /* LocalName */ localName),
            ];
        }
        else {
            this.ExportedBindings = kernel.emptyArray;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = kernel.emptyArray;
        }
    }
    get $kind() { return typescript.SyntaxKind.InterfaceDeclaration; }
}
class $TypeAliasDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TypeAliasDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.VarDeclaredNames = kernel.emptyArray;
        this.VarScopedDeclarations = kernel.emptyArray;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.IsType = true;
        const intrinsics = realm['[[Intrinsics]]'];
        ctx |= 128 /* InTypeElement */;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (hasBit(modifierFlags, typescript.ModifierFlags.Export)) {
            ctx |= 4096 /* InExport */;
        }
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        const BoundNames = this.BoundNames = $name.BoundNames;
        this.TypeDeclarations = [this];
        if (hasBit(ctx, 4096 /* InExport */)) {
            const [localName] = BoundNames;
            this.ExportedBindings = BoundNames;
            this.ExportedNames = BoundNames;
            this.ExportEntries = [
                new ExportEntryRecord(
                /* source */ this, 
                /* ExportName */ localName, 
                /* ModuleRequest */ intrinsics.null, 
                /* ImportName */ intrinsics.null, 
                /* LocalName */ localName),
            ];
        }
        else {
            this.ExportedBindings = kernel.emptyArray;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = kernel.emptyArray;
        }
    }
    get $kind() { return typescript.SyntaxKind.TypeAliasDeclaration; }
}
function $enumMemberList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $EnumMember(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
class $EnumDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.EnumDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.VarDeclaredNames = kernel.emptyArray;
        this.VarScopedDeclarations = kernel.emptyArray;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.IsType = true;
        const intrinsics = realm['[[Intrinsics]]'];
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (hasBit(modifierFlags, typescript.ModifierFlags.Export)) {
            ctx |= 4096 /* InExport */;
        }
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        this.$members = $enumMemberList(node.members, this, ctx);
        const BoundNames = this.BoundNames = $name.BoundNames;
        this.TypeDeclarations = [this];
        if (hasBit(ctx, 4096 /* InExport */)) {
            const [localName] = BoundNames;
            this.ExportedBindings = BoundNames;
            this.ExportedNames = BoundNames;
            this.ExportEntries = [
                new ExportEntryRecord(
                /* source */ this, 
                /* ExportName */ localName, 
                /* ModuleRequest */ intrinsics.null, 
                /* ImportName */ intrinsics.null, 
                /* LocalName */ localName),
            ];
        }
        else {
            this.ExportedBindings = kernel.emptyArray;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = kernel.emptyArray;
        }
    }
    get $kind() { return typescript.SyntaxKind.EnumDeclaration; }
}
class $EnumMember {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.EnumMember`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$name = $$propertyName(node.name, this, ctx | 512 /* IsMemberName */, -1);
        this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.EnumMember; }
}

// #region Pseudo-literals
class $TemplateHead {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.TemplateHead`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.TemplateHead; }
    // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation
    // 12.2.9.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.undefined; // TODO: implement this
    }
}
class $TemplateMiddle {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.TemplateMiddle`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.TemplateMiddle; }
    // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation
    // 12.2.9.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.undefined; // TODO: implement this
    }
}
class $TemplateTail {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.TemplateTail`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.TemplateTail; }
    // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation
    // 12.2.9.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // TemplateSpans : TemplateTail
        // 1. Let tail be the TV of TemplateTail as defined in 11.8.6.
        // 2. Return the String value consisting of the code units of tail.
        return intrinsics.undefined; // TODO: implement this
    }
}
class $TemplateSpan {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TemplateSpan`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        if (node.literal.kind === typescript.SyntaxKind.TemplateMiddle) {
            this.$literal = new $TemplateMiddle(node.literal, this, ctx);
        }
        else {
            this.$literal = new $TemplateTail(node.literal, this, ctx);
        }
    }
    get $kind() { return typescript.SyntaxKind.TemplateSpan; }
    // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation
    // 12.2.9.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // TemplateSpans : TemplateMiddleList TemplateTail
        // 1. Let head be the result of evaluating TemplateMiddleList.
        // 2. ReturnIfAbrupt(head).
        // 3. Let tail be the TV of TemplateTail as defined in 11.8.6.
        // 4. Return the string-concatenation of head and tail.
        // TemplateMiddleList : TemplateMiddle Expression
        // 1. Let head be the TV of TemplateMiddle as defined in 11.8.6.
        // 2. Let subRef be the result of evaluating Expression.
        // 3. Let sub be ? GetValue(subRef).
        // 4. Let middle be ? ToString(sub).
        // 5. Return the sequence of code units consisting of the code units of head followed by the elements of middle.
        // TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
        // 1. Let rest be the result of evaluating TemplateMiddleList.
        // 2. ReturnIfAbrupt(rest).
        // 3. Let middle be the TV of TemplateMiddle as defined in 11.8.6.
        // 4. Let subRef be the result of evaluating Expression.
        // 5. Let sub be ? GetValue(subRef).
        // 6. Let last be ? ToString(sub).
        // 7. Return the sequence of code units consisting of the elements of rest followed by the code units of middle followed by the elements of last.
        return intrinsics.undefined; // TODO: implement this
    }
}
// #endregion
class $NumericLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.NumericLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        const num = Number(node.text);
        this.PropName = new $String(realm, num.toString(), void 0, void 0, this);
        this.Value = new $Number(realm, num, void 0, void 0, this);
    }
    get $kind() { return typescript.SyntaxKind.NumericLiteral; }
    // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation
    // 12.2.4.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        // 1. Return the number whose value is MV of NumericLiteral as defined in 11.8.3.
        return this.Value;
    }
    // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation
    EvaluatePropName(ctx) {
        ctx.checkTimeout();
        return this.PropName;
    }
}
class $BigIntLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.BigIntLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
    }
    get $kind() { return typescript.SyntaxKind.BigIntLiteral; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics['0']; // TODO: implement this
    }
}
class $StringLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.StringLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        const StringValue = this.StringValue = new $String(realm, node.text, void 0, void 0, this);
        this.PropName = StringValue;
        this.Value = StringValue;
    }
    get $kind() { return typescript.SyntaxKind.StringLiteral; }
    // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation
    // 12.2.4.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        // Literal : StringLiteral
        // 1. Return the StringValue of StringLiteral as defined in 11.8.4.1.
        return this.Value;
    }
    // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation
    EvaluatePropName(ctx) {
        ctx.checkTimeout();
        return this.PropName;
    }
}
class $RegularExpressionLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.RegularExpressionLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        this.StringValue = node.text;
    }
    get $kind() { return typescript.SyntaxKind.RegularExpressionLiteral; }
    // http://www.ecma-international.org/ecma-262/#sec-regular-expression-literals-runtime-semantics-evaluation
    // 12.2.8.2 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // PrimaryExpression : RegularExpressionLiteral
        // 1. Let pattern be the String value consisting of the UTF16Encoding of each code point of BodyText of RegularExpressionLiteral.
        // 2. Let flags be the String value consisting of the UTF16Encoding of each code point of FlagText of RegularExpressionLiteral.
        // 3. Return RegExpCreate(pattern, flags).
        return intrinsics['%ObjectPrototype%']; // TODO: implement this
    }
}
class $NoSubstitutionTemplateLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.NoSubstitutionTemplateLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
    }
    get $kind() { return typescript.SyntaxKind.NoSubstitutionTemplateLiteral; }
    // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation
    // 12.2.9.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // TemplateLiteral : NoSubstitutionTemplate
        // 1. Return the String value whose code units are the elements of the TV of NoSubstitutionTemplate as defined in 11.8.6.
        return intrinsics['']; // TODO: implement this
    }
}
class $NullLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.NullLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        this.Value = new $Null(realm, void 0, void 0, this);
    }
    get $kind() { return typescript.SyntaxKind.NullKeyword; }
    // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation
    // 12.2.4.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        // Literal : NullLiteral
        // 1. Return null.
        return this.Value;
    }
}
class $BooleanLiteral {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.BooleanLiteral`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        this.$kind = node.kind;
        this.Value = new $Boolean(realm, node.kind === typescript.SyntaxKind.TrueKeyword, void 0, void 0, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation
    // 12.2.4.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        // Literal : BooleanLiteral
        // 1. If BooleanLiteral is the token false, return false.
        // 2. If BooleanLiteral is the token true, return true.
        return this.Value;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-scripts
class $ESScript {
    constructor(logger, $file, node, realm) {
        this.logger = logger;
        this.$file = $file;
        this.node = node;
        this.realm = realm;
        this.disposed = false;
        this.mos = this;
        this.parent = this;
        this.ctx = 0 /* None */;
        this.depth = 0;
        const intrinsics = realm['[[Intrinsics]]'];
        this.ExecutionResult = intrinsics.empty;
        this['[[Environment]]'] = intrinsics.undefined;
        this.path = `ESScript<(...)${$file.rootlessPath}>`;
        this.logger = logger.root;
        let ctx = 0 /* None */;
        this.DirectivePrologue = GetDirectivePrologue(node.statements);
        if (this.DirectivePrologue.ContainsUseStrict) {
            ctx |= 65536 /* InStrictMode */;
        }
        const LexicallyDeclaredNames = this.LexicallyDeclaredNames = [];
        const LexicallyScopedDeclarations = this.LexicallyScopedDeclarations = [];
        const VarDeclaredNames = this.VarDeclaredNames = [];
        const VarScopedDeclarations = this.VarScopedDeclarations = [];
        const $statements = this.$statements = [];
        const statements = node.statements;
        let stmt;
        let $stmt;
        let s = 0;
        for (let i = 0, ii = statements.length; i < ii; ++i) {
            stmt = statements[i];
            switch (stmt.kind) {
                case typescript.SyntaxKind.VariableStatement:
                    $stmt = $statements[s] = new $VariableStatement(stmt, this, ctx, s);
                    ++s;
                    if ($stmt.isLexical) {
                        LexicallyDeclaredNames.push(...$stmt.BoundNames);
                        LexicallyScopedDeclarations.push($stmt);
                    }
                    else {
                        VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                        VarScopedDeclarations.push($stmt);
                    }
                    break;
                case typescript.SyntaxKind.FunctionDeclaration:
                    $stmt = $statements[s] = new $FunctionDeclaration(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.BoundNames);
                    VarScopedDeclarations.push($stmt);
                    break;
                case typescript.SyntaxKind.ClassDeclaration:
                    $stmt = $statements[s] = new $ClassDeclaration(stmt, this, ctx, s);
                    ++s;
                    LexicallyDeclaredNames.push(...$stmt.BoundNames);
                    LexicallyScopedDeclarations.push($stmt);
                    break;
                case typescript.SyntaxKind.Block:
                    $stmt = $statements[s] = new $Block(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.EmptyStatement:
                    $stmt = $statements[s] = new $EmptyStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ExpressionStatement:
                    $stmt = $statements[s] = new $ExpressionStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.IfStatement:
                    $stmt = $statements[s] = new $IfStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.DoStatement:
                    $stmt = $statements[s] = new $DoStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.WhileStatement:
                    $stmt = $statements[s] = new $WhileStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ForStatement:
                    $stmt = $statements[s] = new $ForStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ForInStatement:
                    $stmt = $statements[s] = new $ForInStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ForOfStatement:
                    $stmt = $statements[s] = new $ForOfStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ContinueStatement:
                    $stmt = $statements[s] = new $ContinueStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.BreakStatement:
                    $stmt = $statements[s] = new $BreakStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ReturnStatement:
                    $stmt = $statements[s] = new $ReturnStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.WithStatement:
                    $stmt = $statements[s] = new $WithStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.SwitchStatement:
                    $stmt = $statements[s] = new $SwitchStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.LabeledStatement:
                    $stmt = $statements[s] = new $LabeledStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.TopLevelVarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.TopLevelVarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ThrowStatement:
                    $stmt = $statements[s] = new $ThrowStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.TryStatement:
                    $stmt = $statements[s] = new $TryStatement(stmt, this, ctx, s);
                    ++s;
                    VarDeclaredNames.push(...$stmt.VarDeclaredNames);
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.DebuggerStatement:
                    $stmt = $statements[s] = new $DebuggerStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                default:
                    throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
            }
        }
    }
    get isNull() { return false; }
    get isScript() { return true; }
    get isModule() { return false; }
    // http://www.ecma-international.org/ecma-262/#sec-globaldeclarationinstantiation
    // 15.1.11 Runtime Semantics: GlobalDeclarationInstantiation ( script , env )
    InstantiateGlobalDeclaration(ctx, env) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const script = this;
        // 1. Let envRec be env's EnvironmentRecord.
        const envRec = env;
        // 2. Assert: envRec is a global Environment Record.
        // 3. Let lexNames be the LexicallyDeclaredNames of script.
        const lexNames = script.LexicallyDeclaredNames;
        // 4. Let varNames be the VarDeclaredNames of script.
        const varNames = script.VarDeclaredNames;
        // 5. For each name in lexNames, do
        for (const name of lexNames) {
            // 5. a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.
            if (envRec.HasVarDeclaration(ctx, name).isTruthy) {
                return new $SyntaxError(realm, `${name} is already var-declared in global scope`).enrichWith(ctx, this);
            }
            // 5. b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
            if (envRec.HasLexicalDeclaration(ctx, name).isTruthy) {
                return new $SyntaxError(realm, `${name} is already lexically-declared in global scope`).enrichWith(ctx, this);
            }
            // 5. c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).
            const hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(ctx, name);
            if (hasRestrictedGlobal.isAbrupt) {
                return hasRestrictedGlobal.enrichWith(ctx, this);
            }
            // 5. d. If hasRestrictedGlobal is true, throw a SyntaxError exception.
            if (hasRestrictedGlobal.isTruthy) {
                return new $SyntaxError(realm, `${name} is a restricted global property`).enrichWith(ctx, this);
            }
        }
        // 6. For each name in varNames, do
        for (const name of varNames) {
            // 6. a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.
            if (envRec.HasLexicalDeclaration(ctx, name).isTruthy) {
                return new $SyntaxError(realm, `${name} is already lexically-declared in global scope`).enrichWith(ctx, this);
            }
        }
        // 7. Let varDeclarations be the VarScopedDeclarations of script.
        const varDeclarations = script.VarScopedDeclarations;
        // 8. Let functionsToInitialize be a new empty List.
        const functionsToInitialize = [];
        // 9. Let declaredFunctionNames be a new empty List.
        const declaredFunctionNames = new $StringSet();
        // 10. For each d in varDeclarations, in reverse list order, do
        for (let i = varDeclarations.length - 1; i >= 0; --i) {
            const d = varDeclarations[i];
            // 10. a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
            if (d instanceof $FunctionDeclaration) {
                // 10. a. i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
                // 10. a. ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
                // 10. a. iii. Let fn be the sole element of the BoundNames of d.
                const [fn] = d.BoundNames;
                // 10. a. iv. If fn is not an element of declaredFunctionNames, then
                if (!declaredFunctionNames.has(fn)) {
                    // 10. a. iv. 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).
                    const fnDefinable = envRec.CanDeclareGlobalFunction(ctx, fn);
                    if (fnDefinable.isAbrupt) {
                        return fnDefinable.enrichWith(ctx, this);
                    }
                    // 10. a. iv. 2. If fnDefinable is false, throw a TypeError exception.
                    if (fnDefinable.isFalsey) {
                        return new $TypeError(realm, `function declaration ${fn} cannot be defined in global scope.`).enrichWith(ctx, this);
                    }
                    // 10. a. iv. 3. Append fn to declaredFunctionNames.
                    declaredFunctionNames.add(fn);
                    // 10. a. iv. 4. Insert d as the first element of functionsToInitialize.
                    functionsToInitialize.unshift(d);
                }
            }
        }
        // 11. Let declaredVarNames be a new empty List.
        const declaredVarNames = new $StringSet();
        // 12. For each d in varDeclarations, do
        for (const d of varDeclarations) {
            // 12. a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then
            if (!(d instanceof $FunctionDeclaration)) {
                // 12. a. i. For each String vn in the BoundNames of d, do
                for (const vn of d.BoundNames) {
                    // 12. a. i. 1. If vn is not an element of declaredFunctionNames, then
                    if (!declaredFunctionNames.has(vn)) {
                        // 12. a. i. 1. a. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).
                        const vnDefinable = envRec.CanDeclareGlobalVar(ctx, vn);
                        if (vnDefinable.isAbrupt) {
                            return vnDefinable.enrichWith(ctx, this);
                        }
                        // 12. a. i. 1. b. If vnDefinable is false, throw a TypeError exception.
                        if (vnDefinable.isFalsey) {
                            return new $TypeError(realm, `var declaration ${vn} cannot be defined in global scope.`).enrichWith(ctx, this);
                        }
                        // 12. a. i. 1. c. If vn is not an element of declaredVarNames, then
                        if (!declaredVarNames.has(vn)) {
                            // 12. a. i. 1. c. i. Append vn to declaredVarNames.
                            declaredVarNames.add(vn);
                        }
                    }
                }
            }
        }
        // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
        // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.
        // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.
        const lexDeclarations = script.LexicallyScopedDeclarations;
        // 16. For each element d in lexDeclarations, do
        for (const d of lexDeclarations) {
            // 16. a. NOTE: Lexically declared names are only instantiated here but not initialized.
            // 16. b. For each element dn of the BoundNames of d, do
            for (const dn of d.BoundNames) {
                // 16. b. i. If IsConstantDeclaration of d is true, then
                if (d.IsConstantDeclaration) {
                    // 16. b. i. 1. Perform ? envRec.CreateImmutableBinding(dn, true).
                    const $CreateImmutableBindingResult = envRec.CreateImmutableBinding(ctx, dn, intrinsics.true);
                    if ($CreateImmutableBindingResult.isAbrupt) {
                        return $CreateImmutableBindingResult.enrichWith(ctx, this);
                    }
                }
                // 16. b. ii. Else,
                else {
                    // 16. b. ii. 1. Perform ? envRec.CreateMutableBinding(dn, false).
                    const $CreateImmutableBindingResult = envRec.CreateImmutableBinding(ctx, dn, intrinsics.false);
                    if ($CreateImmutableBindingResult.isAbrupt) {
                        return $CreateImmutableBindingResult.enrichWith(ctx, this);
                    }
                }
            }
        }
        // 17. For each Parse Node f in functionsToInitialize, do
        for (const f of functionsToInitialize) {
            // 17. a. Let fn be the sole element of the BoundNames of f.
            const [fn] = f.BoundNames;
            // 17. b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.
            const fo = f.InstantiateFunctionObject(ctx, env);
            if (fo.isAbrupt) {
                return fo.enrichWith(ctx, this);
            }
            // 17. c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).
            const $CreateGlobalFunctionBindingResult = envRec.CreateGlobalFunctionBinding(ctx, fn, fo, intrinsics.false);
            if ($CreateGlobalFunctionBindingResult.isAbrupt) {
                return $CreateGlobalFunctionBindingResult.enrichWith(ctx, this);
            }
        }
        // 18. For each String vn in declaredVarNames, in list order, do
        for (const vn of declaredVarNames) {
            // 18. a. Perform ? envRec.CreateGlobalVarBinding(vn, false).
            const $CreateGlobalVarBindingResult = envRec.CreateGlobalVarBinding(ctx, vn, intrinsics.false);
            if ($CreateGlobalVarBindingResult.isAbrupt) {
                return $CreateGlobalVarBindingResult.enrichWith(ctx, this);
            }
        }
        // 19. Return NormalCompletion(empty).
        return new $Empty(realm);
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-scriptevaluation
    // 15.1.10 ScriptEvaluation ( scriptRecord )
    EvaluateScript(ctx) {
        const scriptRecord = this;
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        const stack = realm.stack;
        // 1. Let globalEnv be scriptRecord.[[Realm]].[[GlobalEnv]].
        const globalEnv = scriptRecord.realm['[[GlobalEnv]]'];
        // 2. Let scriptCxt be a new ECMAScript code execution context.
        const scriptCxt = new ExecutionContext(realm);
        // 3. Set the Function of scriptCxt to null.
        // 4. Set the Realm of scriptCxt to scriptRecord.[[Realm]].
        // 5. Set the ScriptOrModule of scriptCxt to scriptRecord.
        scriptCxt.ScriptOrModule = scriptRecord;
        // 6. Set the VariableEnvironment of scriptCxt to globalEnv.
        scriptCxt.VariableEnvironment = globalEnv;
        // 7. Set the LexicalEnvironment of scriptCxt to globalEnv.
        scriptCxt.LexicalEnvironment = globalEnv;
        // 8. Suspend the currently running execution context.
        ctx.suspend();
        // 9. Push scriptCxt on to the execution context stack; scriptCxt is now the running execution context.
        stack.push(scriptCxt);
        // 10. Let scriptBody be scriptRecord.[[ECMAScriptCode]].
        const scriptBody = scriptRecord;
        // 11. Let result be GlobalDeclarationInstantiation(scriptBody, globalEnv).
        let result = scriptBody.InstantiateGlobalDeclaration(scriptCxt, globalEnv);
        // 12. If result.[[Type]] is normal, then
        if (result['[[Type]]'] === 1 /* normal */) {
            // 12. a. Set result to the result of evaluating scriptBody.
            const $statements = scriptBody.$statements;
            let $statement;
            let sl = (void 0);
            for (let i = 0, ii = $statements.length; i < ii; ++i) {
                $statement = $statements[i];
                switch ($statement.$kind) {
                    case typescript.SyntaxKind.VariableStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.FunctionDeclaration:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ClassDeclaration:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.Block:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.EmptyStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ExpressionStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.IfStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.DoStatement:
                        sl = $statement.EvaluateLabelled(scriptCxt, new $StringSet());
                        break;
                    case typescript.SyntaxKind.WhileStatement:
                        sl = $statement.EvaluateLabelled(scriptCxt, new $StringSet());
                        break;
                    case typescript.SyntaxKind.ForStatement:
                        sl = $statement.EvaluateLabelled(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ForInStatement:
                        sl = $statement.EvaluateLabelled(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ForOfStatement:
                        sl = $statement.EvaluateLabelled(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ContinueStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.BreakStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ReturnStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.WithStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.SwitchStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.LabeledStatement:
                        sl = $statement.EvaluateLabelled(scriptCxt);
                        break;
                    case typescript.SyntaxKind.ThrowStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.TryStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    case typescript.SyntaxKind.DebuggerStatement:
                        sl = $statement.Evaluate(scriptCxt);
                        break;
                    default:
                        throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[$statement.$kind]}.`);
                }
                if (sl.isAbrupt) {
                    sl.enrichWith(ctx, this);
                    break;
                }
            }
            result = sl;
        }
        // 13. If result.[[Type]] is normal and result.[[Value]] is empty, then
        if (result['[[Type]]'] === 1 /* normal */ && result.isEmpty) {
            // 13. a. Set result to NormalCompletion(undefined).
            result = new $Undefined(realm);
        }
        // 14. Suspend scriptCxt and remove it from the execution context stack.
        scriptCxt.suspend();
        stack.pop();
        // 15. Assert: The execution context stack is not empty.
        // 16. Resume the context that is now on the top of the execution context stack as the running execution context.
        ctx.resume();
        // 17. Return Completion(result).
        return result;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-abstract-module-records
// http://www.ecma-international.org/ecma-262/#sec-cyclic-module-records
// http://www.ecma-international.org/ecma-262/#sec-source-text-module-records
class $ESModule {
    constructor(logger, $file, node, realm, pkg, moduleResolver, compilerOptions) {
        this.logger = logger;
        this.$file = $file;
        this.node = node;
        this.realm = realm;
        this.pkg = pkg;
        this.moduleResolver = moduleResolver;
        this.compilerOptions = compilerOptions;
        this.disposed = false;
        this.mos = this;
        this.parent = this;
        this.ctx = 0 /* None */;
        this.depth = 0;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const intrinsics = realm['[[Intrinsics]]'];
        this.ExecutionResult = intrinsics.empty;
        this['[[Environment]]'] = intrinsics.undefined;
        this['[[Namespace]]'] = intrinsics.undefined;
        this.path = `ESModule<(...)${$file.rootlessPath}>`;
        this.logger = logger.root;
        let ctx = 0 /* None */;
        this.DirectivePrologue = GetDirectivePrologue(node.statements);
        if (this.DirectivePrologue.ContainsUseStrict) {
            ctx |= 65536 /* InStrictMode */;
        }
        const ExportedBindings = this.ExportedBindings = [];
        const ExportedNames = this.ExportedNames = [];
        const ExportEntries = this.ExportEntries = [];
        const ImportEntries = this.ImportEntries = [];
        const ImportedLocalNames = this.ImportedLocalNames = [];
        const ModuleRequests = this.ModuleRequests = [];
        const LexicallyScopedDeclarations = this.LexicallyScopedDeclarations = [];
        const VarScopedDeclarations = this.VarScopedDeclarations = [];
        const $statements = this.$statements = [];
        const statements = node.statements;
        let stmt;
        let $stmt;
        let s = 0;
        for (let i = 0, ii = statements.length; i < ii; ++i) {
            stmt = statements[i];
            switch (stmt.kind) {
                case typescript.SyntaxKind.ModuleDeclaration:
                    $stmt = $statements[s] = new $ModuleDeclaration(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.NamespaceExportDeclaration:
                    $stmt = $statements[s] = new $NamespaceExportDeclaration(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ImportEqualsDeclaration:
                    $stmt = $statements[s] = new $ImportEqualsDeclaration(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ImportDeclaration:
                    $stmt = $statements[s] = new $ImportDeclaration(stmt, this, ctx, s);
                    ++s;
                    ImportEntries.push(...$stmt.ImportEntries);
                    ImportedLocalNames.push(...$stmt.ImportEntries.map(getLocalName));
                    ModuleRequests.push(...$stmt.ModuleRequests);
                    break;
                case typescript.SyntaxKind.ExportAssignment:
                    $stmt = $statements[s] = new $ExportAssignment(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ExportDeclaration:
                    $stmt = $statements[s] = new $ExportDeclaration(stmt, this, ctx, s);
                    ++s;
                    ExportedBindings.push(...$stmt.ExportedBindings);
                    ExportedNames.push(...$stmt.ExportedNames);
                    ExportEntries.push(...$stmt.ExportEntries);
                    ModuleRequests.push(...$stmt.ModuleRequests);
                    LexicallyScopedDeclarations.push(...$stmt.LexicallyScopedDeclarations);
                    break;
                case typescript.SyntaxKind.VariableStatement:
                    $stmt = $statements[s] = new $VariableStatement(stmt, this, ctx, s);
                    ++s;
                    if ($stmt.isLexical) {
                        LexicallyScopedDeclarations.push($stmt);
                    }
                    else {
                        VarScopedDeclarations.push($stmt);
                    }
                    if (hasBit($stmt.modifierFlags, typescript.ModifierFlags.Export)) {
                        ExportedBindings.push(...$stmt.ExportedBindings);
                        ExportedNames.push(...$stmt.ExportedNames);
                        ExportEntries.push(...$stmt.ExportEntries);
                    }
                    break;
                case typescript.SyntaxKind.FunctionDeclaration:
                    // Skip overload signature
                    if (stmt.body === void 0) {
                        continue;
                    }
                    $stmt = $statements[s] = new $FunctionDeclaration(stmt, this, ctx, s);
                    ++s;
                    if (hasBit($stmt.modifierFlags, typescript.ModifierFlags.Export)) {
                        ExportedBindings.push(...$stmt.ExportedBindings);
                        ExportedNames.push(...$stmt.ExportedNames);
                        ExportEntries.push(...$stmt.ExportEntries);
                    }
                    LexicallyScopedDeclarations.push($stmt);
                    break;
                case typescript.SyntaxKind.ClassDeclaration:
                    $stmt = $statements[s] = new $ClassDeclaration(stmt, this, ctx, s);
                    ++s;
                    if (hasBit($stmt.modifierFlags, typescript.ModifierFlags.Export)) {
                        ExportedBindings.push(...$stmt.ExportedBindings);
                        ExportedNames.push(...$stmt.ExportedNames);
                        ExportEntries.push(...$stmt.ExportEntries);
                    }
                    LexicallyScopedDeclarations.push($stmt);
                    break;
                case typescript.SyntaxKind.InterfaceDeclaration:
                    $stmt = $statements[s] = new $InterfaceDeclaration(stmt, this, ctx, s);
                    ++s;
                    if (hasBit($stmt.modifierFlags, typescript.ModifierFlags.Export)) {
                        ExportedBindings.push(...$stmt.ExportedBindings);
                        ExportedNames.push(...$stmt.ExportedNames);
                        ExportEntries.push(...$stmt.ExportEntries);
                    }
                    break;
                case typescript.SyntaxKind.TypeAliasDeclaration:
                    $stmt = $statements[s] = new $TypeAliasDeclaration(stmt, this, ctx, s);
                    ++s;
                    if (hasBit($stmt.modifierFlags, typescript.ModifierFlags.Export)) {
                        ExportedBindings.push(...$stmt.ExportedBindings);
                        ExportedNames.push(...$stmt.ExportedNames);
                        ExportEntries.push(...$stmt.ExportEntries);
                    }
                    break;
                case typescript.SyntaxKind.EnumDeclaration:
                    $stmt = $statements[s] = new $EnumDeclaration(stmt, this, ctx, s);
                    ++s;
                    if (hasBit($stmt.modifierFlags, typescript.ModifierFlags.Export)) {
                        ExportedBindings.push(...$stmt.ExportedBindings);
                        ExportedNames.push(...$stmt.ExportedNames);
                        ExportEntries.push(...$stmt.ExportEntries);
                    }
                    break;
                case typescript.SyntaxKind.Block:
                    $stmt = $statements[s] = new $Block(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.EmptyStatement:
                    $stmt = $statements[s] = new $EmptyStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ExpressionStatement:
                    $stmt = $statements[s] = new $ExpressionStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.IfStatement:
                    $stmt = $statements[s] = new $IfStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.DoStatement:
                    $stmt = $statements[s] = new $DoStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.WhileStatement:
                    $stmt = $statements[s] = new $WhileStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ForStatement:
                    $stmt = $statements[s] = new $ForStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ForInStatement:
                    $stmt = $statements[s] = new $ForInStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ForOfStatement:
                    $stmt = $statements[s] = new $ForOfStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ContinueStatement:
                    $stmt = $statements[s] = new $ContinueStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.BreakStatement:
                    $stmt = $statements[s] = new $BreakStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.ReturnStatement:
                    $stmt = $statements[s] = new $ReturnStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.WithStatement:
                    $stmt = $statements[s] = new $WithStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.SwitchStatement:
                    $stmt = $statements[s] = new $SwitchStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.LabeledStatement:
                    $stmt = $statements[s] = new $LabeledStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.ThrowStatement:
                    $stmt = $statements[s] = new $ThrowStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                case typescript.SyntaxKind.TryStatement:
                    $stmt = $statements[s] = new $TryStatement(stmt, this, ctx, s);
                    ++s;
                    VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.DebuggerStatement:
                    $stmt = $statements[s] = new $DebuggerStatement(stmt, this, ctx, s);
                    ++s;
                    break;
                default:
                    throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
            }
        }
        // http://www.ecma-international.org/ecma-262/#sec-parsemodule
        // 15.2.1.17.1 ParseModule ( sourceText , realm , hostDefined )
        // 1. Assert: sourceText is an ECMAScript source text (see clause 10).
        // 2. Parse sourceText using Module as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let body be the resulting parse tree. Otherwise, let body be a List of one or more SyntaxError or ReferenceError objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.
        // 3. If body is a List of errors, return body.
        // 4. Let requestedModules be the ModuleRequests of body.
        const requestedModules = ModuleRequests;
        // 5. Let importEntries be ImportEntries of body.
        const importEntries = ImportEntries;
        // 6. Let importedBoundNames be ImportedLocalNames(importEntries).
        const importedBoundNames = ImportedLocalNames;
        // 7. Let indirectExportEntries be a new empty List.
        const indirectExportEntries = [];
        // 8. Let localExportEntries be a new empty List.
        const localExportEntries = [];
        // 9. Let starExportEntries be a new empty List.
        const starExportEntries = [];
        // 10. Let exportEntries be ExportEntries of body.
        const exportEntries = ExportEntries;
        let ee;
        // 11. For each ExportEntry Record ee in exportEntries, do
        for (let i = 0, ii = exportEntries.length; i < ii; ++i) {
            ee = exportEntries[i];
            // 11. a. If ee.[[ModuleRequest]] is null, then
            if (ee.ModuleRequest.isNull) {
                // 11. a. i. If ee.[[LocalName]] is not an element of importedBoundNames, then
                if (!importedBoundNames.some(x => x.is(ee.LocalName))) {
                    // 11. a. i. 1. Append ee to localExportEntries.
                    localExportEntries.push(ee);
                }
                // 11. a. ii. Else,
                else {
                    // 11. a. ii. 1. Let ie be the element of importEntries whose [[LocalName]] is the same as ee.[[LocalName]].
                    const ie = importEntries.find(x => x.LocalName.is(ee.LocalName));
                    // 11. a. ii. 2. If ie.[[ImportName]] is "*", then
                    if (ie.ImportName['[[Value]]'] === '*') {
                        // 11. a. ii. 2. a. Assert: This is a re-export of an imported module namespace object.
                        // 11. a. ii. 2. b. Append ee to localExportEntries.
                        localExportEntries.push(ee);
                    }
                    // 11. a. ii. 3. Else this is a re-export of a single name,
                    else {
                        // 11. a. ii. 3. a. Append the ExportEntry Record { [[ModuleRequest]]: ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]], [[LocalName]]: null, [[ExportName]]: ee.[[ExportName]] } to indirectExportEntries.
                        indirectExportEntries.push(new ExportEntryRecord(
                        /* source */ this, 
                        /* ExportName */ ee.ExportName, 
                        /* ModuleRequest */ ie.ModuleRequest, 
                        /* ImportName */ ie.ImportName, 
                        /* LocalName */ intrinsics.null));
                    }
                }
            }
            // 11. b. Else if ee.[[ImportName]] is "*", then
            else if (ee.ImportName['[[Value]]'] === '*') {
                // 11. b. i. Append ee to starExportEntries.
                starExportEntries.push(ee);
            }
            // 11. c. Else,
            else {
                // 11. c. i. Append ee to indirectExportEntries.
                indirectExportEntries.push(ee);
            }
        }
        // 12. Return Source Text Module Record { [[Realm]]: Realm, [[Environment]]: undefined, [[Namespace]]: undefined, [[Status]]: "uninstantiated", [[EvaluationError]]: undefined, [[HostDefined]]: hostDefined, [[ECMAScriptCode]]: body, [[RequestedModules]]: requestedModules, [[ImportEntries]]: importEntries, [[LocalExportEntries]]: localExportEntries, [[IndirectExportEntries]]: indirectExportEntries, [[StarExportEntries]]: starExportEntries, [[DFSIndex]]: undefined, [[DFSAncestorIndex]]: undefined }.
        this.Status = 'uninstantiated';
        this.DFSIndex = void 0;
        this.DFSAncestorIndex = void 0;
        this.RequestedModules = requestedModules;
        this.IndirectExportEntries = indirectExportEntries;
        this.LocalExportEntries = localExportEntries;
        this.StarExportEntries = starExportEntries;
        this.logger.trace(`RequestedModules: `, requestedModules);
        this.logger.trace(`ImportEntries: `, importEntries);
        this.logger.trace(`IndirectExportEntries: `, indirectExportEntries);
        this.logger.trace(`LocalExportEntries: `, localExportEntries);
        this.logger.trace(`StarExportEntries: `, starExportEntries);
    }
    get isAbrupt() { return false; }
    get $kind() { return typescript.SyntaxKind.SourceFile; }
    get isNull() { return false; }
    get isScript() { return false; }
    get isModule() { return true; }
    // http://www.ecma-international.org/ecma-262/#sec-moduledeclarationinstantiation
    // 15.2.1.16.1 Instantiate ( ) Concrete Method
    Instantiate(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const start = Date.now();
        this.logger.debug(`${this.path}.[Instantiate] starting`);
        // TODO: this is temporary. Should be done by RunJobs
        if (realm.stack.top.ScriptOrModule.isNull) {
            realm.stack.top.ScriptOrModule = this;
        }
        // 1. Let module be this Cyclic Module Record.
        // 2. Assert: module.[[Status]] is not "instantiating" or "evaluating".
        // 3. Let stack be a new empty List.
        const stack = [];
        // 4. Let result be InnerModuleInstantiation(module, stack, 0).
        const result = this._InnerModuleInstantiation(ctx, stack, new $Number(realm, 0));
        // 5. If result is an abrupt completion, then
        if (result.isAbrupt) {
            // 5. a. For each module m in stack, do
            for (const m of stack) {
                // 5. a. i. Assert: m.[[Status]] is "instantiating".
                // 5. a. ii. Set m.[[Status]] to "uninstantiated".
                m.Status = 'uninstantiated';
                // 5. a. iii. Set m.[[Environment]] to undefined.
                m['[[Environment]]'] = intrinsics.undefined;
                // 5. a. iv. Set m.[[DFSIndex]] to undefined.
                m.DFSIndex = void 0;
                // 5. a. v. Set m.[[DFSAncestorIndex]] to undefined.
                m.DFSAncestorIndex = void 0;
            }
            // 5. b. Assert: module.[[Status]] is "uninstantiated".
            // 5. c. Return result.
            return result;
        }
        // 6. Assert: module.[[Status]] is "instantiated" or "evaluated".
        // 7. Assert: stack is empty.
        // 8. Return undefined.
        const end = Date.now();
        this.logger.debug(`${this.path}.[Instantiate] done in ${Math.round(end - start)}ms`);
        return new $Undefined(realm);
    }
    // http://www.ecma-international.org/ecma-262/#sec-innermoduleinstantiation
    // 15.2.1.16.1.1 InnerModuleInstantiation ( module , stack , idx )
    /** @internal */
    _InnerModuleInstantiation(ctx, stack, idx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}._InnerModuleInstantiation(#${ctx.id})`);
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. If module is not a Cyclic Module Record, then
        // 1. a. Perform ? module.Evaluate(ctx).
        // 1. b. Return idx.
        // We only deal with cyclic module records for now
        // 2. If module.[[Status]] is "instantiating", "instantiated", or "evaluated", then
        if (this.Status === 'instantiating' || this.Status === 'instantiated' || this.Status === 'evaluated') {
            // 2. Return idx.
            return idx;
        }
        // 3. Assert: module.[[Status]] is "uninstantiated".
        // 4. Set module.[[Status]] to "instantiating".
        this.Status = 'instantiating';
        // 5. Set module.[[DFSIndex]] to idx.
        this.DFSIndex = idx['[[Value]]'];
        // 6. Set module.[[DFSAncestorIndex]] to idx.
        this.DFSAncestorIndex = idx['[[Value]]'];
        // 7. Increase idx by 1.
        idx = new $Number(realm, idx['[[Value]]'] + 1);
        // 8. Append module to stack.
        stack.push(this);
        // 9. For each String required that is an element of module.[[RequestedModules]], do
        for (const required of this.RequestedModules) {
            // 9. a. Let requiredModule be ? HostResolveImportedModule(module, required).
            const requiredModule = this.moduleResolver.ResolveImportedModule(ctx, this, required);
            if (requiredModule.isAbrupt) {
                return requiredModule.enrichWith(ctx, this);
            }
            // 9. b. Set idx to ? InnerModuleInstantiation(requiredModule, stack, idx).
            const $idx = requiredModule._InnerModuleInstantiation(ctx, stack, idx);
            if ($idx.isAbrupt) {
                return $idx.enrichWith(ctx, this);
            }
            idx = $idx;
            // 9. c. Assert: requiredModule.[[Status]] is either "instantiating", "instantiated", or "evaluated".
            // 9. d. Assert: requiredModule.[[Status]] is "instantiating" if and only if requiredModule is in stack.
            // 9. e. If requiredModule.[[Status]] is "instantiating", then
            if (requiredModule instanceof $ESModule && requiredModule.Status === 'instantiating') {
                // 9. e. i. Assert: requiredModule is a Cyclic Module Record.
                this.logger.warn(`[_InnerModuleInstantiation] ${requiredModule.$file.name} is a cyclic module record`);
                // 9. e. ii. Set module.[[DFSAncestorIndex]] to min(module.[[DFSAncestorIndex]], requiredModule.[[DFSAncestorIndex]]).
                this.DFSAncestorIndex = Math.min(this.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
            }
        }
        // 10. Perform ? module.InitializeEnvironment().
        const $InitializeEnvironmentResult = this.InitializeEnvironment(ctx);
        if ($InitializeEnvironmentResult.isAbrupt) {
            return $InitializeEnvironmentResult.enrichWith(ctx, this);
        }
        // 11. Assert: module occurs exactly once in stack.
        // 12. Assert: module.[[DFSAncestorIndex]] is less than or equal to module.[[DFSIndex]].
        // 13. If module.[[DFSAncestorIndex]] equals module.[[DFSIndex]], then
        if (this.DFSAncestorIndex === this.DFSIndex) {
            // 13. a. Let done be false.
            let done = false;
            // 13. b. Repeat, while done is false,
            while (!done) {
                // 13. b. i. Let requiredModule be the last element in stack.
                // 13. b. ii. Remove the last element of stack.
                const requiredModule = stack.pop();
                // 13. b. iii. Set requiredModule.[[Status]] to "instantiated".
                requiredModule.Status = 'instantiated';
                // 13. b. iv. If requiredModule and module are the same Module Record, set done to true.
                if (requiredModule === this) {
                    done = true;
                }
            }
        }
        // 14. Return idx.
        return idx;
    }
    // http://www.ecma-international.org/ecma-262/#sec-source-text-module-record-initialize-environment
    // 15.2.1.17.4 InitializeEnvironment ( ) Concrete Method
    InitializeEnvironment(ctx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeEnvironment(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let module be this Source Text Module Record.
        // 2. For each ExportEntry Record e in module.[[IndirectExportEntries]], do
        for (const e of this.IndirectExportEntries) {
            // 2. a. Let resolution be ? module.ResolveExport(e.[[ExportName]], « »).
            const resolution = this.ResolveExport(ctx, e.ExportName, new ResolveSet());
            if (resolution.isAbrupt) {
                return resolution.enrichWith(ctx, this);
            }
            // 2. b. If resolution is null or "ambiguous", throw a SyntaxError exception.
            if (resolution.isNull || resolution.isAmbiguous) {
                return new $SyntaxError(realm, `ResolveExport(${e.ExportName}) returned ${resolution}`);
            }
            // 2. c. Assert: resolution is a ResolvedBinding Record.
        }
        // 3. Assert: All named exports from module are resolvable.
        // 4. Let realm be module.[[Realm]].
        // 5. Assert: Realm is not undefined.
        // 6. Let env be NewModuleEnvironment(realm.[[GlobalEnv]]).
        const envRec = new $ModuleEnvRec(this.logger, realm, realm['[[GlobalEnv]]']);
        // 7. Set module.[[Environment]] to env.
        this['[[Environment]]'] = envRec;
        // 8. Let envRec be env's EnvironmentRecord.
        // 9. For each ImportEntry Record in in module.[[ImportEntries]], do
        for (const ie of this.ImportEntries) {
            // 9. a. Let importedModule be ! HostResolveImportedModule(module, in.[[ModuleRequest]]).
            const importedModule = this.moduleResolver.ResolveImportedModule(ctx, this, ie.ModuleRequest);
            // 9. b. NOTE: The above call cannot fail because imported module requests are a subset of module.[[RequestedModules]], and these have been resolved earlier in this algorithm.
            // 9. c. If in.[[ImportName]] is "*", then
            if (ie.ImportName['[[Value]]'] === '*') {
                // 9. c. i. Let namespace be ? GetModuleNamespace(importedModule).
                const namespace = (function (mod) {
                    // http://www.ecma-international.org/ecma-262/#sec-getmodulenamespace
                    // 15.2.1.19 Runtime Semantics: GetModuleNamespace ( module )
                    // 1. Assert: module is an instance of a concrete subclass of Module Record.
                    // 2. Assert: module.[[Status]] is not "uninstantiated".
                    // 3. Let namespace be module.[[Namespace]].
                    let namespace = mod['[[Namespace]]'];
                    // 4. If namespace is undefined, then
                    if (namespace.isUndefined) {
                        // 4. a. Let exportedNames be ? module.GetExportedNames(« »).
                        const exportedNames = mod.GetExportedNames(ctx, new Set());
                        if (exportedNames.isAbrupt) {
                            return exportedNames.enrichWith(ctx, mod);
                        }
                        // 4. b. Let unambiguousNames be a new empty List.
                        const unambiguousNames = new $List();
                        // 4. c. For each name that is an element of exportedNames, do
                        for (const name of exportedNames) {
                            // 4. c. i. Let resolution be ? module.ResolveExport(name, « »).
                            const resolution = mod.ResolveExport(ctx, name, new ResolveSet());
                            if (resolution.isAbrupt) {
                                return resolution.enrichWith(ctx, mod);
                            }
                            // 4. c. ii. If resolution is a ResolvedBinding Record, append name to unambiguousNames.
                            if (resolution instanceof ResolvedBindingRecord) {
                                unambiguousNames.push(name);
                            }
                        }
                        // 4. d. Set namespace to ModuleNamespaceCreate(module, unambiguousNames).
                        namespace = new $NamespaceExoticObject(realm, mod, unambiguousNames);
                    }
                    // 5. Return namespace.
                    return namespace;
                })(importedModule);
                // 9. c. ii. Perform ! envRec.CreateImmutableBinding(in.[[LocalName]], true).
                envRec.CreateImmutableBinding(ctx, ie.LocalName, intrinsics.true);
                // 9. c. iii. Call envRec.InitializeBinding(in.[[LocalName]], namespace).
                if (namespace.isAbrupt) {
                    return namespace.enrichWith(ctx, this);
                } // TODO: sure about this? Spec doesn't say it
                envRec.InitializeBinding(ctx, ie.LocalName, namespace);
            }
            // 9. d. Else,
            else {
                // 9. d. i. Let resolution be ? importedModule.ResolveExport(in.[[ImportName]], « »).
                const resolution = importedModule.ResolveExport(ctx, ie.ImportName, new ResolveSet());
                if (resolution.isAbrupt) {
                    return resolution.enrichWith(ctx, this);
                }
                // 9. d. ii. If resolution is null or "ambiguous", throw a SyntaxError exception.
                if (resolution.isNull || resolution.isAmbiguous) {
                    return new $SyntaxError(realm, `ResolveExport(${ie.ImportName}) returned ${resolution}`);
                }
                // 9. d. iii. Call envRec.CreateImportBinding(in.[[LocalName]], resolution.[[Module]], resolution.[[BindingName]]).
                envRec.CreateImportBinding(ctx, ie.LocalName, resolution.Module, resolution.BindingName);
            }
        }
        // 10. Let code be module.[[ECMAScriptCode]].
        // 11. Let varDeclarations be the VarScopedDeclarations of code.
        const varDeclarations = this.VarScopedDeclarations;
        // 12. Let declaredVarNames be a new empty List.
        const declaredVarNames = new $List();
        // 13. For each element d in varDeclarations, do
        for (const d of varDeclarations) {
            // 13. a. For each element dn of the BoundNames of d, do
            for (const dn of d.BoundNames) {
                // 13. a. i. If dn is not an element of declaredVarNames, then
                if (!declaredVarNames.$contains(dn)) {
                    // 13. a. i. 1. Perform ! envRec.CreateMutableBinding(dn, false).
                    envRec.CreateMutableBinding(ctx, dn, intrinsics.false);
                    // 13. a. i. 2. Call envRec.InitializeBinding(dn, undefined).
                    envRec.InitializeBinding(ctx, dn, intrinsics.undefined);
                    // 13. a. i. 3. Append dn to declaredVarNames.
                    declaredVarNames.push(dn);
                }
            }
        }
        // 14. Let lexDeclarations be the LexicallyScopedDeclarations of code.
        const lexDeclarations = this.LexicallyScopedDeclarations;
        // 15. For each element d in lexDeclarations, do
        for (const d of lexDeclarations) {
            // 15. a. For each element dn of the BoundNames of d, do
            for (const dn of d.BoundNames) {
                // 15. a. i. If IsConstantDeclaration of d is true, then
                if (d.IsConstantDeclaration) {
                    // 15. a. i. 1. Perform ! envRec.CreateImmutableBinding(dn, true).
                    envRec.CreateImmutableBinding(ctx, dn, intrinsics.true);
                }
                // 15. a. ii. Else,
                else {
                    // 15. a. ii. 1. Perform ! envRec.CreateMutableBinding(dn, false).
                    envRec.CreateMutableBinding(ctx, dn, intrinsics.false);
                    // 15. a. iii. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then
                    if (d.$kind === typescript.SyntaxKind.FunctionDeclaration) {
                        // 15. a. iii. 1. Let fo be the result of performing InstantiateFunctionObject for d with argument env.
                        const fo = d.InstantiateFunctionObject(ctx, envRec);
                        if (fo.isAbrupt) {
                            return fo.enrichWith(ctx, this);
                        }
                        // 15. a. iii. 2. Call envRec.InitializeBinding(dn, fo).
                        envRec.InitializeBinding(ctx, dn, fo);
                    }
                }
            }
        }
        // 16. Return NormalCompletion(empty).
        return new $Empty(realm);
    }
    // http://www.ecma-international.org/ecma-262/#sec-getexportednames
    // 15.2.1.17.2 GetExportedNames ( exportStarSet ) Concrete Method
    GetExportedNames(ctx, exportStarSet) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Let module be this Source Text Module Record.
        const mod = this;
        // 2. If exportStarSet contains module, then
        if (exportStarSet.has(mod)) {
            // 2. a. Assert: We've reached the starting point of an import * circularity.
            // 2. b. Return a new empty List.
            return new $List();
        }
        // 3. Append module to exportStarSet.
        exportStarSet.add(mod);
        // 4. Let exportedNames be a new empty List.
        const exportedNames = new $List();
        // 5. For each ExportEntry Record e in module.[[LocalExportEntries]], do
        for (const e of mod.LocalExportEntries) {
            // 5. a. Assert: module provides the direct binding for this export.
            // 5. b. Append e.[[ExportName]] to exportedNames.
            exportedNames.push(e.ExportName);
        }
        // 6. For each ExportEntry Record e in module.[[IndirectExportEntries]], do
        for (const e of mod.IndirectExportEntries) {
            // 6. a. Assert: module imports a specific binding for this export.
            // 6. b. Append e.[[ExportName]] to exportedNames.
            exportedNames.push(e.ExportName);
        }
        // 7. For each ExportEntry Record e in module.[[StarExportEntries]], do
        for (const e of mod.StarExportEntries) {
            // 7. a. Let requestedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).
            const requestedModule = this.moduleResolver.ResolveImportedModule(ctx, mod, e.ModuleRequest);
            if (requestedModule.isAbrupt) {
                return requestedModule.enrichWith(ctx, this);
            }
            // 7. b. Let starNames be ? requestedModule.GetExportedNames(exportStarSet).
            const starNames = requestedModule.GetExportedNames(ctx, exportStarSet);
            if (starNames.isAbrupt) {
                return starNames.enrichWith(ctx, this);
            }
            // 7. c. For each element n of starNames, do
            for (const n of starNames) {
                // 7. c. i. If SameValue(n, "default") is false, then
                if (n['[[Value]]'] !== 'default') {
                    // 7. c. i. 1. If n is not an element of exportedNames, then
                    if (!exportedNames.$contains(n)) {
                        // 7. c. i. 1. a. Append n to exportedNames.
                        exportedNames.push(n);
                    }
                }
            }
        }
        // 8. Return exportedNames.
        return exportedNames;
    }
    // http://www.ecma-international.org/ecma-262/#sec-resolveexport
    // 15.2.1.17.3 ResolveExport ( exportName , resolveSet ) Concrete Method
    ResolveExport(ctx, exportName, resolveSet) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Let module be this Source Text Module Record.
        // 2. For each Record { [[Module]], [[ExportName]] } r in resolveSet, do
        // 2. a. If module and r.[[Module]] are the same Module Record and SameValue(exportName, r.[[ExportName]]) is true, then
        if (resolveSet.has(this, exportName)) {
            // 2. a. i. Assert: This is a circular import request.
            // 2. a. ii. Return null.
            this.logger.warn(`[ResolveExport] Circular import: ${exportName}`);
            return new $Null(realm);
        }
        // 3. Append the Record { [[Module]]: module, [[ExportName]]: exportName } to resolveSet.
        resolveSet.add(this, exportName);
        // 4. For each ExportEntry Record e in module.[[LocalExportEntries]], do
        for (const e of this.LocalExportEntries) {
            // 4. a. If SameValue(exportName, e.[[ExportName]]) is true, then
            if (exportName.is(e.ExportName)) {
                // 4. a. i. Assert: module provides the direct binding for this export.
                this.logger.debug(`${this.path}.[ResolveExport] found direct binding for ${exportName['[[Value]]']}`);
                // 4. a. ii. Return ResolvedBinding Record { [[Module]]: module, [[BindingName]]: e.[[LocalName]] }.
                return new ResolvedBindingRecord(this, e.LocalName);
            }
        }
        // 5. For each ExportEntry Record e in module.[[IndirectExportEntries]], do
        for (const e of this.IndirectExportEntries) {
            // 5. a. If SameValue(exportName, e.[[ExportName]]) is true, then
            if (exportName.is(e.ExportName)) {
                // 5. a. i. Assert: module imports a specific binding for this export.
                this.logger.debug(`${this.path}.[ResolveExport] found specific imported binding for ${exportName['[[Value]]']}`);
                // 5. a. ii. Let importedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).
                const importedModule = this.moduleResolver.ResolveImportedModule(ctx, this, e.ModuleRequest);
                if (importedModule.isAbrupt) {
                    return importedModule.enrichWith(ctx, this);
                }
                // 5. a. iii. Return importedModule.ResolveExport(e.[[ImportName]], resolveSet).
                return importedModule.ResolveExport(ctx, e.ImportName, resolveSet);
            }
        }
        // 6. If SameValue(exportName, "default") is true, then
        if (exportName['[[Value]]'] === 'default') {
            // 6. a. Assert: A default export was not explicitly defined by this module.
            // 6. b. Return null.
            this.logger.warn(`[ResolveExport] No default export defined`);
            return new $Null(realm);
            // 6. c. NOTE: A default export cannot be provided by an export *.
        }
        // 7. Let starResolution be null.
        let starResolution = new $Null(realm);
        // 8. For each ExportEntry Record e in module.[[StarExportEntries]], do
        for (const e of this.StarExportEntries) {
            // 8. a. Let importedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).
            const importedModule = this.moduleResolver.ResolveImportedModule(ctx, this, e.ModuleRequest);
            if (importedModule.isAbrupt) {
                return importedModule.enrichWith(ctx, this);
            }
            // 8. b. Let resolution be ? importedModule.ResolveExport(exportName, resolveSet).
            const resolution = importedModule.ResolveExport(ctx, exportName, resolveSet);
            if (resolution.isAbrupt) {
                return resolution.enrichWith(ctx, this);
            }
            // 8. c. If resolution is "ambiguous", return "ambiguous".
            if (resolution.isAmbiguous) {
                this.logger.warn(`[ResolveExport] ambiguous resolution for ${exportName['[[Value]]']}`);
                return resolution;
            }
            // 8. d. If resolution is not null, then
            if (!resolution.isNull) {
                // 8. d. i. Assert: resolution is a ResolvedBinding Record.
                // 8. d. ii. If starResolution is null, set starResolution to resolution.
                if (starResolution.isNull) {
                    starResolution = resolution;
                }
                // 8. d. iii. Else,
                else {
                    // 8. d. iii. 1. Assert: There is more than one * import that includes the requested name.
                    // 8. d. iii. 2. If resolution.[[Module]] and starResolution.[[Module]] are not the same Module Record or SameValue(resolution.[[BindingName]], starResolution.[[BindingName]]) is false, return "ambiguous".
                    if (!(resolution.Module === starResolution.Module && resolution.BindingName.is(starResolution.BindingName))) {
                        this.logger.warn(`[ResolveExport] ambiguous resolution for ${exportName['[[Value]]']}`);
                        return new $String(realm, 'ambiguous');
                    }
                }
            }
        }
        if (starResolution.isNull) {
            this.logger.warn(`[ResolveExport] starResolution is null for ${exportName['[[Value]]']}`);
        }
        // 9. Return starResolution.
        return starResolution;
    }
    // http://www.ecma-international.org/ecma-262/#sec-moduleevaluation
    // 15.2.1.16.2 Evaluate ( ) Concrete Method
    EvaluateModule(ctx) {
        this.logger.debug(`${this.path}.EvaluateModule()`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let module be this Cyclic Module Record.
        // 2. Assert: module.[[Status]] is "instantiated" or "evaluated".
        // 3. Let stack be a new empty List.
        const stack = [];
        // 4. Let result be InnerModuleEvaluation(module, stack, 0).
        const result = this.EvaluateModuleInner(ctx, stack, 0);
        // 5. If result is an abrupt completion, then
        if (result.isAbrupt) {
            // 5. a. For each module m in stack, do
            for (const m of stack) {
                // 5. a. i. Assert: m.[[Status]] is "evaluating".
                // 5. a. ii. Set m.[[Status]] to "evaluated".
                m.Status = 'evaluated';
                // 5. a. iii. Set m.[[EvaluationError]] to result.
                // TODO
            }
            // 5. b. Assert: module.[[Status]] is "evaluated" and module.[[EvaluationError]] is result.
            // 5. c. Return result.
            return result;
        }
        // 6. Assert: module.[[Status]] is "evaluated" and module.[[EvaluationError]] is undefined.
        // 7. Assert: stack is empty.
        // 8. Return undefined.
        return new $Undefined(realm, 1 /* normal */, intrinsics.empty, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-innermoduleevaluation
    // 15.2.1.16.2.1 InnerModuleEvaluation ( module , stack , idx )
    EvaluateModuleInner(ctx, stack, idx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.EvaluateModuleInner(#${ctx.id})`);
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. If module is not a Cyclic Module Record, then
        // 1. a. Perform ? module.Evaluate(ctx).
        // 1. b. Return idx.
        // 2. If module.[[Status]] is "evaluated", then
        if (this.Status === 'evaluated') {
            // 2. a. If module.[[EvaluationError]] is undefined, return idx.
            return new $Number(realm, idx); // TODO
            // 2. b. Otherwise return module.[[EvaluationError]].
        }
        // 3. If module.[[Status]] is "evaluating", return idx.
        if (this.Status === 'evaluating') {
            return new $Number(realm, idx);
        }
        // 4. Assert: module.[[Status]] is "instantiated".
        // 5. Set module.[[Status]] to "evaluating".
        this.Status = 'evaluating';
        // 6. Set module.[[DFSIndex]] to idx.
        this.DFSIndex = idx;
        // 7. Set module.[[DFSAncestorIndex]] to idx.
        this.DFSAncestorIndex = idx;
        // 8. Increase idx by 1.
        ++idx;
        // 9. Append module to stack.
        stack.push(this);
        // 10. For each String required that is an element of module.[[RequestedModules]], do
        for (const required of this.RequestedModules) {
            // 10. a. Let requiredModule be ! HostResolveImportedModule(module, required).
            const requiredModule = this.moduleResolver.ResolveImportedModule(ctx, this, required); // TODO
            // 10. b. NOTE: Instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.
            // 10. c. Set idx to ? InnerModuleEvaluation(requiredModule, stack, idx).
            const $EvaluateModuleInnerResult = requiredModule.EvaluateModuleInner(ctx, stack, idx);
            if ($EvaluateModuleInnerResult.isAbrupt) {
                return $EvaluateModuleInnerResult.enrichWith(ctx, this);
            }
            idx = $EvaluateModuleInnerResult['[[Value]]'];
            // 10. d. Assert: requiredModule.[[Status]] is either "evaluating" or "evaluated".
            // 10. e. Assert: requiredModule.[[Status]] is "evaluating" if and only if requiredModule is in stack.
            // 10. f. If requiredModule.[[Status]] is "evaluating", then
            if (requiredModule.Status === 'evaluating') {
                // 10. f. i. Assert: requiredModule is a Cyclic Module Record.
                // 10. f. ii. Set module.[[DFSAncestorIndex]] to min(module.[[DFSAncestorIndex]], requiredModule.[[DFSAncestorIndex]]).
                this.DFSAncestorIndex = Math.min(this.DFSAncestorIndex, requiredModule.DFSAncestorIndex);
            }
        }
        // 11. Perform ? module.ExecuteModule().
        const $ExecuteModuleResult = this.ExecutionResult = this.ExecuteModule(ctx);
        if ($ExecuteModuleResult.isAbrupt) {
            return $ExecuteModuleResult.enrichWith(ctx, this);
        }
        // 12. Assert: module occurs exactly once in stack.
        // 13. Assert: module.[[DFSAncestorIndex]] is less than or equal to module.[[DFSIndex]].
        // 14. If module.[[DFSAncestorIndex]] equals module.[[DFSIndex]], then
        if (this.DFSAncestorIndex === this.DFSIndex) {
            // 14. a. Let done be false.
            let done = false;
            // 14. b. Repeat, while done is false,
            while (!done) {
                // 14. b. i. Let requiredModule be the last element in stack.
                // 14. b. ii. Remove the last element of stack.
                const requiredModule = stack.pop();
                // 14. b. iii. Set requiredModule.[[Status]] to "evaluated".
                requiredModule.Status = 'evaluated';
                // 14. b. iv. If requiredModule and module are the same Module Record, set done to true.
                if (requiredModule === this) {
                    done = true;
                }
            }
        }
        // 15. Return idx.
        return new $Number(realm, idx);
    }
    // http://www.ecma-international.org/ecma-262/#sec-source-text-module-record-execute-module
    // 15.2.1.17.5 ExecuteModule ( ) Concrete Method
    ExecuteModule(ctx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.ExecuteModule(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let module be this Source Text Module Record.
        // 2. Let moduleCxt be a new ECMAScript code execution context.
        const moduleCxt = new ExecutionContext(this.realm);
        // 3. Set the Function of moduleCxt to null.
        moduleCxt.Function = intrinsics.null;
        // 4. Assert: module.[[Realm]] is not undefined.
        // 5. Set the Realm of moduleCxt to module.[[Realm]].
        // 6. Set the ScriptOrModule of moduleCxt to module.
        moduleCxt.ScriptOrModule = this;
        // 7. Assert: module has been linked and declarations in its module environment have been instantiated.
        // 8. Set the VariableEnvironment of moduleCxt to module.[[Environment]].
        moduleCxt.VariableEnvironment = this['[[Environment]]'];
        // 9. Set the LexicalEnvironment of moduleCxt to module.[[Environment]].
        moduleCxt.LexicalEnvironment = this['[[Environment]]'];
        // 10. Suspend the currently running execution context.
        const stack = realm.stack;
        ctx.suspend();
        // 11. Push moduleCxt on to the execution context stack; moduleCxt is now the running execution context.
        stack.push(moduleCxt);
        // 12. Let result be the result of evaluating module.[[ECMAScriptCode]].
        const result = this.Evaluate(moduleCxt);
        // 13. Suspend moduleCxt and remove it from the execution context stack.
        moduleCxt.suspend();
        stack.pop();
        // 14. Resume the context that is now on the top of the execution context stack as the running execution context.
        ctx.resume();
        // 15. Return Completion(result).
        return result;
    }
    // http://www.ecma-international.org/ecma-262/#sec-module-semantics-runtime-semantics-evaluation
    // 15.2.1.21 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        const $statements = this.$statements;
        // Module : [empty]
        // 1. Return NormalCompletion(undefined).
        // ModuleBody : ModuleItemList
        // 1. Let result be the result of evaluating ModuleItemList.
        // 2. If result.[[Type]] is normal and result.[[Value]] is empty, then
        // 2. a. Return NormalCompletion(undefined).
        // 3. Return Completion(result).
        // ModuleItemList : ModuleItemList ModuleItem
        // 1. Let sl be the result of evaluating ModuleItemList.
        // 2. ReturnIfAbrufpt(sl).
        // 3. Let s be the result of evaluating ModuleItem.
        // 4. Return Completion(UpdateEmpty(s, sl)).
        // ModuleItem : ImportDeclaration
        // 1. Return NormalCompletion(empty).
        let $statement;
        let sl = (void 0);
        for (let i = 0, ii = $statements.length; i < ii; ++i) {
            $statement = $statements[i];
            switch ($statement.$kind) {
                case typescript.SyntaxKind.ModuleDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.NamespaceExportDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ImportEqualsDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ImportDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ExportAssignment:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ExportDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.VariableStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.FunctionDeclaration:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ClassDeclaration:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.InterfaceDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.TypeAliasDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.EnumDeclaration:
                    // sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.Block:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.EmptyStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ExpressionStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.IfStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.DoStatement:
                    sl = $statement.EvaluateLabelled(ctx, new $StringSet());
                    break;
                case typescript.SyntaxKind.WhileStatement:
                    sl = $statement.EvaluateLabelled(ctx, new $StringSet());
                    break;
                case typescript.SyntaxKind.ForStatement:
                    sl = $statement.EvaluateLabelled(ctx);
                    break;
                case typescript.SyntaxKind.ForInStatement:
                    sl = $statement.EvaluateLabelled(ctx);
                    break;
                case typescript.SyntaxKind.ForOfStatement:
                    sl = $statement.EvaluateLabelled(ctx);
                    break;
                case typescript.SyntaxKind.ContinueStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.BreakStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.ReturnStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.WithStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.SwitchStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.LabeledStatement:
                    sl = $statement.EvaluateLabelled(ctx);
                    break;
                case typescript.SyntaxKind.ThrowStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.TryStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                case typescript.SyntaxKind.DebuggerStatement:
                    sl = $statement.Evaluate(ctx);
                    break;
                default:
                    throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[$statement.$kind]}.`);
            }
            if (sl.isAbrupt) {
                return sl.enrichWith(ctx, this);
            }
        }
        return sl;
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        this['[[Environment]]'] = void 0;
        this['[[Namespace]]'] = void 0;
        this.mos = void 0;
        this.parent = void 0;
        this.$statements = void 0;
        this.DirectivePrologue = void 0;
        this.ExecutionResult = void 0;
        this.ExportedBindings = void 0;
        this.ExportedNames = void 0;
        this.ExportEntries = void 0;
        this.ImportEntries = void 0;
        this.ImportedLocalNames = void 0;
        this.ModuleRequests = void 0;
        this.LexicallyScopedDeclarations = void 0;
        this.VarScopedDeclarations = void 0;
        this.TypeDeclarations = void 0;
        this.RequestedModules = void 0;
        this.LocalExportEntries = void 0;
        this.IndirectExportEntries = void 0;
        this.StarExportEntries = void 0;
        this.logger = void 0;
        this.$file = void 0;
        this.node = void 0;
        this.realm = void 0;
        this.pkg = void 0;
        this.moduleResolver = void 0;
        this.compilerOptions = void 0;
    }
}
class $DocumentFragment {
    constructor(logger, $file, node, realm, pkg) {
        this.logger = logger;
        this.$file = $file;
        this.node = node;
        this.realm = realm;
        this.pkg = pkg;
        this.documentFragment = this;
        this.parent = this;
        this.ctx = 0 /* None */;
        this.depth = 0;
        const intrinsics = realm['[[Intrinsics]]'];
        this['[[Environment]]'] = intrinsics.undefined;
        this['[[Namespace]]'] = intrinsics.undefined;
        this.logger = logger.root;
        this.path = `DocumentFragment<(...)${$file.rootlessPath}>`;
    }
    get isNull() { return false; }
    get isAbrupt() { return false; }
    ResolveExport(ctx, exportName, resolveSet) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.[ResolveExport] returning content as '${exportName['[[Value]]']}'`);
        return new ResolvedBindingRecord(this, exportName);
    }
    GetExportedNames(ctx, exportStarSet) {
        ctx.checkTimeout();
        return new $List();
    }
    Instantiate(ctx) {
        ctx.checkTimeout();
        return ctx.Realm['[[Intrinsics]]'].undefined;
    }
    /** @internal */
    _InnerModuleInstantiation(ctx, stack, idx) {
        ctx.checkTimeout();
        return idx;
    }
    dispose() {
        throw new Error('Method not implemented.');
    }
}
class $ModuleDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ModuleDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (node.name.kind === typescript.SyntaxKind.Identifier) {
            this.$name = new $Identifier(node.name, this, ctx, -1);
        }
        else {
            this.$name = new $StringLiteral(node.name, this, ctx, -1);
        }
        if (node.body === void 0) {
            this.$body = void 0;
        }
        else {
            switch (node.body.kind) {
                case typescript.SyntaxKind.Identifier:
                    this.$body = new $Identifier(node.body, this, ctx, -1);
                    break;
                case typescript.SyntaxKind.ModuleBlock:
                    this.$body = new $ModuleBlock(node.body, this, ctx);
                    break;
                case typescript.SyntaxKind.ModuleDeclaration:
                    this.$body = new $ModuleDeclaration(node.body, this, ctx, -1);
                    break;
                default:
                    throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.ModuleDeclaration; }
}
// http://www.ecma-international.org/ecma-262/#importentry-record
/**
 * | Import Statement Form          | MR        | IN          | LN        |
 * |:-------------------------------|:----------|:------------|:----------|
 * | `import v from "mod";`         | `"mod"`   | `"default"` | `"v"`     |
 * | `import * as ns from "mod";`   | `"mod"`   | `"*"`       | `"ns"`    |
 * | `import {x} from "mod";`       | `"mod"`   | `"x"`       | `"x"`     |
 * | `import {x as v} from "mod";`  | `"mod"`   | `"x"`       | `"v"`     |
 * | `import "mod";`                | N/A       | N/A         | N/A       |
 */
class ImportEntryRecord {
    constructor(source, ModuleRequest, ImportName, LocalName) {
        this.source = source;
        this.ModuleRequest = ModuleRequest;
        this.ImportName = ImportName;
        this.LocalName = LocalName;
    }
}
/**
 * One of:
 * - import x = require("mod");
 * - import x = M.x;
 */
class $ImportEqualsDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ImportEqualsDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$name = $identifier(node.name, this, ctx, -1);
        switch (node.moduleReference.kind) {
            case typescript.SyntaxKind.Identifier:
                this.$moduleReference = new $Identifier(node.moduleReference, this, ctx, -1);
                break;
            case typescript.SyntaxKind.QualifiedName:
                this.$moduleReference = new $QualifiedName(node.moduleReference, this, ctx);
                break;
            case typescript.SyntaxKind.ExternalModuleReference:
                this.$moduleReference = new $ExternalModuleReference(node.moduleReference, this, ctx);
                break;
            default:
                throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
        }
    }
    get $kind() { return typescript.SyntaxKind.ImportEqualsDeclaration; }
}
// In case of:
// import "mod"  => importClause = undefined, moduleSpecifier = "mod"
// In rest of the cases, module specifier is string literal corresponding to module
// ImportClause information is shown at its declaration below.
class $ImportDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ImportDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        const $moduleSpecifier = this.$moduleSpecifier = new $StringLiteral(node.moduleSpecifier, this, ctx, -1);
        const moduleSpecifier = this.moduleSpecifier = $moduleSpecifier.StringValue;
        if (node.importClause === void 0) {
            this.$importClause = new $Undefined(realm, void 0, void 0, this);
            this.BoundNames = kernel.emptyArray;
            this.ImportEntries = kernel.emptyArray;
        }
        else {
            const $importClause = this.$importClause = new $ImportClause(node.importClause, this, ctx);
            this.BoundNames = $importClause.BoundNames;
            this.ImportEntries = $importClause.ImportEntriesForModule;
        }
        this.ModuleRequests = [moduleSpecifier];
    }
    get $kind() { return typescript.SyntaxKind.ImportDeclaration; }
}
// In case of:
// import d from "mod" => name = d, namedBinding = undefined
// import * as ns from "mod" => name = undefined, namedBinding: NamespaceImport = { name: ns }
// import d, * as ns from "mod" => name = d, namedBinding: NamespaceImport = { name: ns }
// import { a, b as x } from "mod" => name = undefined, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}
// import d, { a, b as x } from "mod" => name = d, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}
class $ImportClause {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.ImportClause`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const intrinsics = realm['[[Intrinsics]]'];
        const moduleSpecifier = this.moduleSpecifier = parent.moduleSpecifier;
        const BoundNames = this.BoundNames = [];
        const ImportEntriesForModule = this.ImportEntriesForModule = [];
        if (node.name === void 0) {
            this.$name = new $Undefined(realm, void 0, void 0, this);
        }
        else {
            const $name = this.$name = new $Identifier(node.name, this, ctx, -1);
            const [localName] = $name.BoundNames;
            BoundNames.push(localName);
            ImportEntriesForModule.push(new ImportEntryRecord(
            /* source */ this, 
            /* ModuleRequest */ moduleSpecifier, 
            /* ImportName */ intrinsics.default, 
            /* LocalName */ localName));
        }
        if (node.namedBindings === void 0) {
            this.$namedBindings = void 0;
        }
        else {
            if (node.namedBindings.kind === typescript.SyntaxKind.NamespaceImport) {
                const $namedBindings = this.$namedBindings = new $NamespaceImport(node.namedBindings, this, ctx);
                BoundNames.push(...$namedBindings.BoundNames);
                ImportEntriesForModule.push(...$namedBindings.ImportEntriesForModule);
            }
            else {
                const $namedBindings = this.$namedBindings = new $NamedImports(node.namedBindings, this, ctx);
                BoundNames.push(...$namedBindings.BoundNames);
                ImportEntriesForModule.push(...$namedBindings.ImportEntriesForModule);
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.ImportClause; }
}
class $NamedImports {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.NamedImports`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.moduleSpecifier = parent.moduleSpecifier;
        const $elements = this.$elements = node.elements.map(x => new $ImportSpecifier(x, this, ctx));
        this.BoundNames = $elements.flatMap(getBoundNames);
        this.ImportEntriesForModule = $elements.flatMap(getImportEntriesForModule);
    }
    get $kind() { return typescript.SyntaxKind.NamedImports; }
}
class $ImportSpecifier {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.ImportSpecifier`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        let $propertyName;
        if (node.propertyName === void 0) {
            $propertyName = this.$propertyName = new $Undefined(realm, void 0, void 0, this);
        }
        else {
            $propertyName = this.$propertyName = new $Identifier(node.propertyName, this, ctx, -1);
        }
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        const BoundNames = this.BoundNames = this.$name.BoundNames;
        const moduleSpecifier = parent.moduleSpecifier;
        if ($propertyName.isUndefined) {
            const [localName] = BoundNames;
            this.ImportEntriesForModule = [
                new ImportEntryRecord(
                /* source */ this, 
                /* ModuleRequest */ moduleSpecifier, 
                /* ImportName */ localName, 
                /* LocalName */ localName),
            ];
        }
        else {
            const importName = $propertyName.StringValue;
            const localName = $name.StringValue;
            this.ImportEntriesForModule = [
                new ImportEntryRecord(
                /* source */ this, 
                /* ModuleRequest */ moduleSpecifier, 
                /* ImportName */ importName, 
                /* LocalName */ localName),
            ];
        }
    }
    get $kind() { return typescript.SyntaxKind.ImportSpecifier; }
}
class $NamespaceImport {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.NamespaceImport`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const intrinsics = realm['[[Intrinsics]]'];
        const $name = this.$name = new $Identifier(node.name, this, ctx, -1);
        this.BoundNames = $name.BoundNames;
        const moduleSpecifier = parent.moduleSpecifier;
        const localName = $name.StringValue;
        this.ImportEntriesForModule = [
            new ImportEntryRecord(
            /* source */ this, 
            /* ModuleRequest */ moduleSpecifier, 
            /* ImportName */ intrinsics['*'], 
            /* LocalName */ localName),
        ];
    }
    get $kind() { return typescript.SyntaxKind.NamespaceImport; }
}
/**
 * | Export Statement Form           | EN           | MR            | IN         | LN            |
 * |:--------------------------------|:-------------|:--------------|:-----------|:--------------|
 * | `export var v;`                 | `"v"`        | `null`        | `null`     | `"v"`         |
 * | `export default function f(){}` | `"default"`  | `null`        | `null`     | `"f"`         |
 * | `export default function(){}`   | `"default"`  | `null`        | `null`     | `"*default*"` |
 * | `export default 42;`            | `"default"`  | `null`        | `null`     | `"*default*"` |
 * | `export {x};`                   | `"x"`        | `null`        | `null`     | `"x"`         |
 * | `export {v as x};`              | `"x"`        | `null`        | `null`     | `"v"`         |
 * | `export {x} from "mod";`        | `"x"`        | `"mod"`       | `"x"`      | `null`        |
 * | `export {v as x} from "mod";`   | `"x"`        | `"mod"`       | `"v"`      | `null`        |
 * | `export * from "mod";`          | `null`       | `"mod"`       | `"*"`      | `null`        |
 */
class ExportEntryRecord {
    constructor(source, ExportName, ModuleRequest, ImportName, LocalName) {
        this.source = source;
        this.ExportName = ExportName;
        this.ModuleRequest = ModuleRequest;
        this.ImportName = ImportName;
        this.LocalName = LocalName;
    }
}
class $ExportAssignment {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ExportAssignment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const intrinsics = realm['[[Intrinsics]]'];
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        this.BoundNames = [intrinsics['*default*']];
    }
    get $kind() { return typescript.SyntaxKind.ExportAssignment; }
}
class $ExportDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ExportDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-boundnames
        // 15.2.3.2 Static Semantics: BoundNames
        this.BoundNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportedbindings
        // 15.2.3.3 Static Semantics: ExportedBindings
        this.ExportedBindings = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-isconstantdeclaration
        // 15.2.3.7 Static Semantics: IsConstantDeclaration
        this.IsConstantDeclaration = false;
        // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-lexicallyscopeddeclarations
        // 15.2.3.8 Static Semantics: LexicallyScopedDeclarations
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const intrinsics = realm['[[Intrinsics]]'];
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        let moduleSpecifier;
        if (node.moduleSpecifier === void 0) {
            this.$moduleSpecifier = void 0;
            moduleSpecifier = this.moduleSpecifier = intrinsics.null;
            this.ModuleRequests = kernel.emptyArray;
        }
        else {
            const $moduleSpecifier = this.$moduleSpecifier = new $StringLiteral(node.moduleSpecifier, this, ctx, -1);
            moduleSpecifier = this.moduleSpecifier = $moduleSpecifier.StringValue;
            this.ModuleRequests = [moduleSpecifier];
        }
        if (node.exportClause === void 0) {
            this.$exportClause = void 0;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = [
                new ExportEntryRecord(
                /* source */ this, 
                /* ExportName */ intrinsics.null, 
                /* ModuleRequest */ moduleSpecifier, 
                /* ImportName */ intrinsics['*'], 
                /* LocalName */ intrinsics.null),
            ];
        }
        else {
            // @ts-ignore - TODO(fkleuver): update AOT to use new TS 3.8 ast
            const $exportClause = this.$exportClause = new $NamedExports(node.exportClause, this, ctx);
            this.ExportedNames = $exportClause.ExportedNames;
            this.ExportEntries = $exportClause.ExportEntriesForModule;
        }
    }
    get $kind() { return typescript.SyntaxKind.ExportDeclaration; }
}
class $NamedExports {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.NamedExports`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.moduleSpecifier = parent.moduleSpecifier;
        const $elements = this.$elements = node.elements.map(x => new $ExportSpecifier(x, this, ctx));
        this.ExportedNames = $elements.flatMap(getExportedNames);
        this.ExportEntriesForModule = $elements.flatMap(getExportEntriesForModule);
        this.ReferencedBindings = $elements.flatMap(getReferencedBindings);
    }
    get $kind() { return typescript.SyntaxKind.NamedExports; }
}
class $ExportSpecifier {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.ExportSpecifier`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const intrinsics = realm['[[Intrinsics]]'];
        let $propertyName;
        if (node.propertyName === void 0) {
            $propertyName = this.$propertyName = new $Undefined(realm, void 0, void 0, this);
        }
        else {
            $propertyName = this.$propertyName = new $Identifier(node.propertyName, this, ctx, -1);
        }
        const $name = this.$name = new $Identifier(node.name, this, ctx, -1);
        const moduleSpecifier = parent.moduleSpecifier;
        if ($propertyName.isUndefined) {
            const sourceName = $name.StringValue;
            this.ReferencedBindings = [sourceName];
            this.ExportedNames = [sourceName];
            if (moduleSpecifier.isNull) {
                this.ExportEntriesForModule = [
                    new ExportEntryRecord(
                    /* source */ this, 
                    /* ExportName */ sourceName, 
                    /* ModuleRequest */ moduleSpecifier, 
                    /* ImportName */ intrinsics.null, 
                    /* LocalName */ sourceName),
                ];
            }
            else {
                this.ExportEntriesForModule = [
                    new ExportEntryRecord(
                    /* source */ this, 
                    /* ExportName */ sourceName, 
                    /* ModuleRequest */ moduleSpecifier, 
                    /* ImportName */ sourceName, 
                    /* LocalName */ intrinsics.null),
                ];
            }
        }
        else {
            const exportName = $name.StringValue;
            const sourceName = $propertyName.StringValue;
            this.ReferencedBindings = [sourceName];
            this.ExportedNames = [exportName];
            if (moduleSpecifier.isNull) {
                this.ExportEntriesForModule = [
                    new ExportEntryRecord(
                    /* source */ this, 
                    /* ExportName */ exportName, 
                    /* ModuleRequest */ moduleSpecifier, 
                    /* ImportName */ intrinsics.null, 
                    /* LocalName */ sourceName),
                ];
            }
            else {
                this.ExportEntriesForModule = [
                    new ExportEntryRecord(
                    /* source */ this, 
                    /* ExportName */ exportName, 
                    /* ModuleRequest */ moduleSpecifier, 
                    /* ImportName */ sourceName, 
                    /* LocalName */ intrinsics.null),
                ];
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.ExportSpecifier; }
}
class $NamespaceExportDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.NamespaceExportDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$name = $identifier(node.name, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.NamespaceExportDeclaration; }
}
class $ModuleBlock {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.ModuleBlock`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // TODO: ModuleBlock shares a lot in common with SourceFile, so we implement this last to try to maximize code reuse / reduce refactoring overhead and/or see if the two can be consolidated.
        this.$statements = kernel.emptyArray;
    }
    get $kind() { return typescript.SyntaxKind.ModuleBlock; }
}
class $ExternalModuleReference {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.ExternalModuleReference`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = new $StringLiteral(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.ExternalModuleReference; }
}
class $QualifiedName {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.QualifiedName`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        if (node.left.kind === typescript.SyntaxKind.Identifier) {
            this.$left = new $Identifier(node.left, this, ctx, -1);
        }
        else {
            this.$left = new $QualifiedName(node.left, this, ctx);
        }
        this.$right = new $Identifier(node.right, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.QualifiedName; }
}

class $VariableStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.VariableStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const intrinsics = realm['[[Intrinsics]]'];
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        ctx |= 4 /* InVariableStatement */;
        if (hasBit(this.modifierFlags, typescript.ModifierFlags.Export)) {
            ctx |= 4096 /* InExport */;
        }
        const $declarationList = this.$declarationList = new $VariableDeclarationList(node.declarationList, this, ctx);
        const isLexical = this.isLexical = $declarationList.isLexical;
        this.IsConstantDeclaration = $declarationList.IsConstantDeclaration;
        const BoundNames = this.BoundNames = $declarationList.BoundNames;
        this.VarDeclaredNames = $declarationList.VarDeclaredNames;
        this.VarScopedDeclarations = $declarationList.VarScopedDeclarations;
        if (hasBit(ctx, 4096 /* InExport */)) {
            this.ExportedBindings = BoundNames;
            this.ExportedNames = BoundNames;
            this.ExportEntries = BoundNames.map(name => new ExportEntryRecord(
            /* source */ this, 
            /* ExportName */ name, 
            /* ModuleRequest */ intrinsics.null, 
            /* ImportName */ intrinsics.null, 
            /* LocalName */ name));
            if (isLexical) {
                this.LexicallyScopedDeclarations = [this];
            }
            else {
                this.LexicallyScopedDeclarations = kernel.emptyArray;
            }
        }
        else {
            this.ExportedBindings = kernel.emptyArray;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = kernel.emptyArray;
            this.LexicallyScopedDeclarations = kernel.emptyArray;
        }
        this.ModuleRequests = kernel.emptyArray;
    }
    get $kind() { return typescript.SyntaxKind.VariableStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-runtime-semantics-evaluation
    // 13.3.1.4 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-variable-statement-runtime-semantics-evaluation
    // 13.3.2.4 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-runtime-semantics-evaluation
        // 13.3.1.4 Runtime Semantics: Evaluation
        // LexicalDeclaration : LetOrConst BindingList ;
        // 1. Let next be the result of evaluating BindingList.
        // 2. ReturnIfAbrupt(next).
        // 3. Return NormalCompletion(empty).
        // BindingList : BindingList , LexicalBinding
        // 1. Let next be the result of evaluating BindingList.
        // 2. ReturnIfAbrupt(next).
        // 3. Return the result of evaluating LexicalBinding.
        // LexicalBinding : BindingIdentifier
        // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).
        // 2. Return InitializeReferencedBinding(lhs, undefined).
        // LexicalBinding : BindingIdentifier Initializer
        // 1. Let bindingId be StringValue of BindingIdentifier.
        // 2. Let lhs be ResolveBinding(bindingId).
        // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
        // 3. a. Let value be the result of performing NamedEvaluation for Initializer with argument bindingId.
        // 4. Else,
        // 4. a. Let rhs be the result of evaluating Initializer.
        // 4. b. Let value be ? GetValue(rhs).
        // 5. Return InitializeReferencedBinding(lhs, value).
        // LexicalBinding : BindingPattern Initializer
        // 1. Let rhs be the result of evaluating Initializer.
        // 2. Let value be ? GetValue(rhs).
        // 3. Let env be the running execution context's LexicalEnvironment.
        // 4. Return the result of performing BindingInitialization for BindingPattern using value and env as the arguments.
        // http://www.ecma-international.org/ecma-262/#sec-variable-statement-runtime-semantics-evaluation
        // 13.3.2.4 Runtime Semantics: Evaluation
        // VariableStatement : var VariableDeclarationList ;
        // 1. Let next be the result of evaluating VariableDeclarationList.
        // 2. ReturnIfAbrupt(next).
        // 3. Return NormalCompletion(empty).
        // VariableDeclarationList : VariableDeclarationList , VariableDeclaration
        // 1. Let next be the result of evaluating VariableDeclarationList.
        // 2. ReturnIfAbrupt(next).
        // 3. Return the result of evaluating VariableDeclaration.
        // VariableDeclaration : BindingIdentifier
        // 1. Return NormalCompletion(empty).
        // VariableDeclaration : BindingIdentifier Initializer
        // 1. Let bindingId be StringValue of BindingIdentifier.
        // 2. Let lhs be ? ResolveBinding(bindingId).
        // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then
        // 3. a. Let value be the result of performing NamedEvaluation for Initializer with argument bindingId.
        // 4. Else,
        // 4. a. Let rhs be the result of evaluating Initializer.
        // 4. b. Let value be ? GetValue(rhs).
        // 5. Return ? PutValue(lhs, value).
        // VariableDeclaration : BindingPattern Initializer
        // 1. Let rhs be the result of evaluating Initializer.
        // 2. Let rval be ? GetValue(rhs).
        // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.
        return intrinsics.empty; // TODO: implement this
    }
}
class $VariableDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.VariableDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (hasBit(ctx, 4 /* InVariableStatement */)) {
            this.combinedModifierFlags = modifierFlags | parent.combinedModifierFlags;
        }
        else {
            this.combinedModifierFlags = modifierFlags;
        }
        const $name = this.$name = $$bindingName(node.name, this, ctx, -1);
        // Clear this flag because it's used inside $Identifier to declare locals/exports
        // and we don't want to do that on the identifiers in types/initializers.
        ctx = clearBit(ctx, 4 /* InVariableStatement */);
        this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
        this.BoundNames = $name.BoundNames;
        if (hasBit(ctx, 32768 /* IsVar */)) { // TODO: what about parameter and for declarations?
            this.VarDeclaredNames = this.BoundNames;
            this.VarScopedDeclarations = [this];
            this.IsConstantDeclaration = false;
        }
        else {
            this.VarDeclaredNames = kernel.emptyArray;
            this.VarScopedDeclarations = kernel.emptyArray;
            this.IsConstantDeclaration = hasBit(ctx, 8192 /* IsConst */);
        }
    }
    get $kind() { return typescript.SyntaxKind.VariableDeclaration; }
    InitializeBinding(ctx, value) {
        var _a, _b;
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const bindingName = this.$name;
        const kind = bindingName.$kind;
        const boundNames = bindingName.BoundNames;
        const envRec = ctx.LexicalEnvironment;
        if (((_a = boundNames === null || boundNames === void 0 ? void 0 : boundNames.length) !== null && _a !== void 0 ? _a : 0) > 0) {
            switch (kind) {
                // http://www.ecma-international.org/ecma-262/#sec-identifiers-runtime-semantics-bindinginitialization
                // 12.1.5 Runtime Semantics: BindingInitialization
                // http://www.ecma-international.org/ecma-262/#sec-initializeboundname
                // 12.1.5.1 Runtime Semantics: InitializeBoundName ( name , value , environment )
                case typescript.SyntaxKind.Identifier: {
                    const name = (_b = boundNames[0]) === null || _b === void 0 ? void 0 : _b.GetValue(ctx);
                    // 1. Assert: Type(name) is String.
                    // 2. If environment is not undefined, then
                    if (envRec !== void 0) {
                        // 2. a. Let env be the EnvironmentRecord component of environment.
                        // 2. b. Perform env.InitializeBinding(name, value).
                        envRec.InitializeBinding(ctx, name, value);
                        // 2. c. Return NormalCompletion(undefined).
                        return realm['[[Intrinsics]]'].undefined;
                    }
                    else {
                        // 3. Else,
                        // 3. a. Let lhs be ResolveBinding(name).
                        const lhs = realm.ResolveBinding(name);
                        if (lhs.isAbrupt) {
                            return lhs.enrichWith(ctx, this);
                        } // TODO: is this correct? spec doesn't say it
                        // 3. b. Return ? PutValue(lhs, value).
                        return lhs.PutValue(ctx, value).enrichWith(ctx, this);
                    }
                }
                case typescript.SyntaxKind.ObjectBindingPattern:
                    bindingName.InitializeBinding(ctx, value, envRec);
                    break;
                case typescript.SyntaxKind.ArrayBindingPattern:
                    // TODO
                    break;
            }
        }
        return ctx.Realm['[[Intrinsics]]'].empty;
    }
}
function $variableDeclarationList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $VariableDeclaration(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
class $VariableDeclarationList {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.VariableDeclarationList`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.isLexical = (node.flags & (typescript.NodeFlags.Const | typescript.NodeFlags.Let)) > 0;
        this.IsConstantDeclaration = (node.flags & typescript.NodeFlags.Const) > 0;
        if (hasBit(ctx, 4 /* InVariableStatement */)) {
            this.combinedModifierFlags = parent.modifierFlags;
        }
        else {
            this.combinedModifierFlags = typescript.ModifierFlags.None;
        }
        if (hasBit(node.flags, typescript.NodeFlags.Const)) {
            ctx |= 8192 /* IsConst */;
        }
        else if (hasBit(node.flags, typescript.NodeFlags.Let)) {
            ctx |= 16384 /* IsLet */;
        }
        else {
            ctx |= 32768 /* IsVar */;
        }
        const $declarations = this.$declarations = $variableDeclarationList(node.declarations, this, ctx);
        this.BoundNames = $declarations.flatMap(getBoundNames);
        this.VarDeclaredNames = $declarations.flatMap(getVarDeclaredNames);
        this.VarScopedDeclarations = $declarations.flatMap(getVarScopedDeclarations);
    }
    get $kind() { return typescript.SyntaxKind.VariableDeclarationList; }
}
// #region Statements
class $Block {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.Block`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const $statements = this.$statements = $$tsStatementList(node.statements, this, ctx);
        const LexicallyDeclaredNames = this.LexicallyDeclaredNames = [];
        const LexicallyScopedDeclarations = this.LexicallyScopedDeclarations = [];
        const TopLevelLexicallyDeclaredNames = this.TopLevelLexicallyDeclaredNames = [];
        const TopLevelLexicallyScopedDeclarations = this.TopLevelLexicallyScopedDeclarations = [];
        const TopLevelVarDeclaredNames = this.TopLevelVarDeclaredNames = [];
        const TopLevelVarScopedDeclarations = this.TopLevelVarScopedDeclarations = [];
        const VarDeclaredNames = this.VarDeclaredNames = [];
        const VarScopedDeclarations = this.VarScopedDeclarations = [];
        const len = $statements.length;
        let $statement;
        for (let i = 0; i < len; ++i) {
            $statement = $statements[i];
            switch ($statement.$kind) {
                case typescript.SyntaxKind.FunctionDeclaration:
                    LexicallyDeclaredNames.push(...$statement.BoundNames);
                    LexicallyScopedDeclarations.push($statement);
                    TopLevelVarDeclaredNames.push(...$statement.BoundNames);
                    TopLevelVarScopedDeclarations.push($statement);
                    break;
                case typescript.SyntaxKind.ClassDeclaration:
                    LexicallyDeclaredNames.push(...$statement.BoundNames);
                    LexicallyScopedDeclarations.push($statement);
                    TopLevelLexicallyDeclaredNames.push(...$statement.BoundNames);
                    TopLevelLexicallyScopedDeclarations.push($statement);
                    break;
                case typescript.SyntaxKind.VariableStatement:
                    if ($statement.isLexical) {
                        LexicallyDeclaredNames.push(...$statement.BoundNames);
                        LexicallyScopedDeclarations.push($statement);
                        TopLevelLexicallyDeclaredNames.push(...$statement.BoundNames);
                        TopLevelLexicallyScopedDeclarations.push($statement);
                    }
                    else {
                        TopLevelVarDeclaredNames.push(...$statement.VarDeclaredNames);
                        TopLevelVarScopedDeclarations.push(...$statement.VarScopedDeclarations);
                        VarDeclaredNames.push(...$statement.VarDeclaredNames);
                        VarScopedDeclarations.push(...$statement.VarScopedDeclarations);
                    }
                    break;
                case typescript.SyntaxKind.LabeledStatement:
                    LexicallyDeclaredNames.push(...$statement.LexicallyDeclaredNames);
                    LexicallyScopedDeclarations.push(...$statement.LexicallyScopedDeclarations);
                    TopLevelVarDeclaredNames.push(...$statement.TopLevelVarDeclaredNames);
                    TopLevelVarScopedDeclarations.push(...$statement.TopLevelVarScopedDeclarations);
                    VarDeclaredNames.push(...$statement.VarDeclaredNames);
                    VarScopedDeclarations.push(...$statement.VarScopedDeclarations);
                    break;
                case typescript.SyntaxKind.Block:
                case typescript.SyntaxKind.IfStatement:
                case typescript.SyntaxKind.DoStatement:
                case typescript.SyntaxKind.WhileStatement:
                case typescript.SyntaxKind.ForStatement:
                case typescript.SyntaxKind.ForInStatement:
                case typescript.SyntaxKind.ForOfStatement:
                case typescript.SyntaxKind.WithStatement:
                case typescript.SyntaxKind.SwitchStatement:
                case typescript.SyntaxKind.TryStatement:
                    TopLevelVarDeclaredNames.push(...$statement.VarDeclaredNames);
                    TopLevelVarScopedDeclarations.push(...$statement.VarScopedDeclarations);
                    VarDeclaredNames.push(...$statement.VarDeclaredNames);
                    VarScopedDeclarations.push(...$statement.VarScopedDeclarations);
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.Block; }
    // http://www.ecma-international.org/ecma-262/#sec-block-runtime-semantics-evaluation
    // 13.2.13 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        const $statements = this.$statements;
        // Block : { }
        // 1. Return NormalCompletion(empty).
        if ($statements.length === 0) {
            return intrinsics.empty;
        }
        // Block : { StatementList }
        // 1. Let oldEnv be the running execution context's LexicalEnvironment.
        const oldEnv = ctx.LexicalEnvironment;
        // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
        const blockEnv = ctx.LexicalEnvironment = new $DeclarativeEnvRec(this.logger, realm, oldEnv);
        // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).
        const $BlockDeclarationInstantiationResult = BlockDeclarationInstantiation(ctx, this.LexicallyScopedDeclarations, blockEnv);
        if ($BlockDeclarationInstantiationResult.isAbrupt) {
            return $BlockDeclarationInstantiationResult;
        }
        // 4. Set the running execution context's LexicalEnvironment to blockEnv.
        realm.stack.push(ctx);
        // 5. Let blockValue be the result of evaluating StatementList.
        const blockValue = evaluateStatementList(ctx, $statements);
        // 6. Set the running execution context's LexicalEnvironment to oldEnv.
        realm.stack.pop();
        ctx.LexicalEnvironment = oldEnv;
        // 7. Return blockValue.
        return blockValue;
    }
}
class $EmptyStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.EmptyStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
    }
    get $kind() { return typescript.SyntaxKind.EmptyStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-empty-statement-runtime-semantics-evaluation
    // 13.4.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // EmptyStatement : ;
        // 1. Return NormalCompletion(empty).
        return intrinsics.empty;
    }
}
class $ExpressionStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ExpressionStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.ExpressionStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-expression-statement-runtime-semantics-evaluation
    // 13.5.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ExpressionStatement : Expression ;
        // 1. Let exprRef be the result of evaluating Expression.
        // 2. Return ? GetValue(exprRef).
        return this.$expression.Evaluate(ctx).GetValue(ctx).enrichWith(ctx, this);
    }
}
class $IfStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.IfStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        const $thenStatement = this.$thenStatement = $$esLabelledItem(node.thenStatement, this, ctx, -1);
        if (node.elseStatement === void 0) {
            this.$elseStatement = void 0;
            this.VarDeclaredNames = $thenStatement.VarDeclaredNames;
            this.VarScopedDeclarations = $thenStatement.VarScopedDeclarations;
        }
        else {
            const $elseStatement = this.$elseStatement = $$esLabelledItem(node.elseStatement, this, ctx, -1);
            this.VarDeclaredNames = [
                ...$thenStatement.VarDeclaredNames,
                ...$elseStatement.VarDeclaredNames,
            ];
            this.VarScopedDeclarations = [
                ...$thenStatement.VarScopedDeclarations,
                ...$elseStatement.VarScopedDeclarations,
            ];
        }
    }
    get $kind() { return typescript.SyntaxKind.IfStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-if-statement-runtime-semantics-evaluation
    // 13.6.7 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        const { $expression, $thenStatement, $elseStatement } = this;
        const exprRef = $expression.Evaluate(ctx);
        const exprValue = exprRef.GetValue(ctx).ToBoolean(ctx);
        if ($elseStatement !== undefined) {
            // IfStatement : if ( Expression ) Statement else Statement
            // 1. Let exprRef be the result of evaluating Expression.
            // 2. Let exprValue be ToBoolean(? GetValue(exprRef)).
            let stmtCompletion;
            // 3. If exprValue is true, then
            if (exprValue.is(intrinsics.true)) {
                // 3. a. Let stmtCompletion be the result of evaluating the first Statement.
                stmtCompletion = evaluateStatement(ctx, $thenStatement);
            }
            else {
                // 4. Else,
                // 4. a. Let stmtCompletion be the result of evaluating the second Statement.
                stmtCompletion = evaluateStatement(ctx, $elseStatement);
            }
            // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)).
            stmtCompletion.UpdateEmpty(intrinsics.undefined);
            return stmtCompletion;
        }
        else {
            // IfStatement : if ( Expression ) Statement
            // 1. Let exprRef be the result of evaluating Expression.
            // 2. Let exprValue be ToBoolean(? GetValue(exprRef)).
            let stmtCompletion;
            // 3. If exprValue is false, then
            if (exprValue.is(intrinsics.false)) {
                // 3. a. Return NormalCompletion(undefined).
                return new $Undefined(realm);
            }
            else {
                // 4. Else,
                // 4. a. Let stmtCompletion be the result of evaluating Statement.
                stmtCompletion = evaluateStatement(ctx, $thenStatement);
                // 4. b. Return Completion(UpdateEmpty(stmtCompletion, undefined)).
                stmtCompletion.UpdateEmpty(intrinsics.undefined);
                return stmtCompletion;
            }
        }
    }
}
class $DoStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.DoStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        this.VarDeclaredNames = $statement.VarDeclaredNames;
        this.VarScopedDeclarations = $statement.VarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.DoStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-do-while-statement-runtime-semantics-labelledevaluation
    // 13.7.2.6 Runtime Semantics: LabelledEvaluation
    EvaluateLabelled(ctx, labelSet) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);
        // IterationStatement : do Statement while ( Expression ) ;
        const expr = this.$expression;
        const stmt = this.$statement;
        // 1. Let V be undefined.
        let V = intrinsics.undefined;
        // 2. Repeat,
        while (true) {
            // 2. a. Let stmtResult be the result of evaluating Statement.
            const stmtResult = evaluateStatement(ctx, stmt);
            // 2. b. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).
            if ($LoopContinues(ctx, stmtResult, labelSet).isFalsey) {
                return stmtResult.UpdateEmpty(V);
            }
            // 2. c. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].
            if (!stmtResult.isEmpty) {
                V = stmtResult;
            }
            // 2. d. Let exprRef be the result of evaluating Expression.
            const exprRef = expr.Evaluate(ctx);
            // 2. e. Let exprValue be ? GetValue(exprRef).
            const exprValue = exprRef.GetValue(ctx);
            if (exprValue.isAbrupt) {
                return exprValue.enrichWith(ctx, this);
            }
            // 2. f. If ToBoolean(exprValue) is false, return NormalCompletion(V).
            const bool = exprValue.ToBoolean(ctx);
            if (bool.isAbrupt) {
                return bool.enrichWith(ctx, this);
            }
            if (bool.isFalsey) {
                return V.ToCompletion(1 /* normal */, intrinsics.empty);
            }
        }
    }
}
class $WhileStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.WhileStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        this.VarDeclaredNames = $statement.VarDeclaredNames;
        this.VarScopedDeclarations = $statement.VarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.WhileStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-while-statement-runtime-semantics-labelledevaluation
    // 13.7.3.6 Runtime Semantics: LabelledEvaluation
    EvaluateLabelled(ctx, labelSet) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);
        // IterationStatement : while ( Expression ) Statement
        const expr = this.$expression;
        const stmt = this.$statement;
        // 1. Let V be undefined.
        let V = intrinsics.undefined;
        // 2. Repeat,
        while (true) {
            // 2. a. Let exprRef be the result of evaluating Expression.
            const exprRef = expr.Evaluate(ctx);
            // 2. b. Let exprValue be ? GetValue(exprRef).
            const exprValue = exprRef.GetValue(ctx);
            if (exprValue.isAbrupt) {
                return exprValue.enrichWith(ctx, this);
            }
            // 2. c. If ToBoolean(exprValue) is false, return NormalCompletion(V).
            const bool = exprValue.ToBoolean(ctx);
            if (bool.isAbrupt) {
                return bool.enrichWith(ctx, this);
            }
            if (bool.isFalsey) {
                return V.ToCompletion(1 /* normal */, intrinsics.empty);
            }
            // 2. d. Let stmtResult be the result of evaluating Statement.
            const stmtResult = evaluateStatement(ctx, stmt);
            // 2. e. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).
            if ($LoopContinues(ctx, stmtResult, labelSet).isFalsey) {
                return stmtResult.UpdateEmpty(V);
            }
            // 2. f. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].
            if (!stmtResult.isEmpty) {
                V = stmtResult;
            }
        }
    }
}
class $ForStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ForStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.$condition = $assignmentExpression(node.condition, this, ctx, -1);
        this.$incrementor = $assignmentExpression(node.incrementor, this, ctx, -1);
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        if (node.initializer === void 0) {
            this.$initializer = void 0;
            this.VarDeclaredNames = $statement.VarDeclaredNames;
            this.VarScopedDeclarations = $statement.VarScopedDeclarations;
        }
        else {
            if (node.initializer.kind === typescript.SyntaxKind.VariableDeclarationList) {
                const $initializer = this.$initializer = new $VariableDeclarationList(node.initializer, this, ctx);
                if ($initializer.isLexical) {
                    this.VarDeclaredNames = $statement.VarDeclaredNames;
                    this.VarScopedDeclarations = $statement.VarScopedDeclarations;
                }
                else {
                    this.VarDeclaredNames = [
                        ...$initializer.VarDeclaredNames,
                        ...$statement.VarDeclaredNames,
                    ];
                    this.VarScopedDeclarations = [
                        ...$initializer.VarScopedDeclarations,
                        ...$statement.VarScopedDeclarations,
                    ];
                }
            }
            else {
                this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
                this.VarDeclaredNames = $statement.VarDeclaredNames;
                this.VarScopedDeclarations = $statement.VarScopedDeclarations;
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.ForStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-for-statement-runtime-semantics-labelledevaluation
    // 13.7.4.7 Runtime Semantics: LabelledEvaluation
    EvaluateLabelled(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);
        // IterationStatement : for ( Expression opt ; Expression opt ; Expression opt ) Statement
        // 1. If the first Expression is present, then
        // 1. a. Let exprRef be the result of evaluating the first Expression.
        // 1. b. Perform ? GetValue(exprRef).
        // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).
        // IterationStatement : for ( var VariableDeclarationList ; Expression opt ; Expression opt ) Statement
        // 1. Let varDcl be the result of evaluating VariableDeclarationList.
        // 2. ReturnIfAbrupt(varDcl).
        // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).
        // IterationStatement : for ( LexicalDeclaration Expression opt ; Expression opt ) Statement
        // 1. Let oldEnv be the running execution context's LexicalEnvironment.
        // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).
        // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.
        // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.
        // 5. Let boundNames be the BoundNames of LexicalDeclaration.
        // 6. For each element dn of boundNames, do
        // 6. a. If isConst is true, then
        // 6. a. i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).
        // 6. b. Else,
        // 6. b. i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).
        // 7. Set the running execution context's LexicalEnvironment to loopEnv.
        // 8. Let forDcl be the result of evaluating LexicalDeclaration.
        // 9. If forDcl is an abrupt completion, then
        // 9. a. Set the running execution context's LexicalEnvironment to oldEnv.
        // 9. b. Return Completion(forDcl).
        // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».
        // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).
        // 12. Set the running execution context's LexicalEnvironment to oldEnv.
        // 13. Return Completion(bodyResult).
        return intrinsics.empty; // TODO: implement this
    }
}
class $ForInStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ForInStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        if (node.initializer.kind === typescript.SyntaxKind.VariableDeclarationList) {
            const $initializer = this.$initializer = new $VariableDeclarationList(node.initializer, this, ctx);
            if ($initializer.isLexical) {
                this.BoundNames = $initializer.BoundNames;
                this.VarDeclaredNames = $statement.VarDeclaredNames;
                this.VarScopedDeclarations = $statement.VarScopedDeclarations;
            }
            else {
                this.BoundNames = kernel.emptyArray;
                this.VarDeclaredNames = [
                    ...$initializer.VarDeclaredNames,
                    ...$statement.VarDeclaredNames,
                ];
                this.VarScopedDeclarations = [
                    ...$initializer.VarScopedDeclarations,
                    ...$statement.VarScopedDeclarations,
                ];
            }
        }
        else {
            this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
            this.BoundNames = kernel.emptyArray;
            this.VarDeclaredNames = $statement.VarDeclaredNames;
            this.VarScopedDeclarations = $statement.VarScopedDeclarations;
        }
    }
    get $kind() { return typescript.SyntaxKind.ForInStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation
    // 13.7.5.11 Runtime Semantics: LabelledEvaluation
    EvaluateLabelled(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);
        // IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).
        // IterationStatement : for ( var ForBinding in Expression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).
        // IterationStatement : for ( ForDeclaration in Expression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).
        // IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).
        // IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).
        // IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).
        // IterationStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet, async).
        // IterationStatement : for await ( var ForBinding of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet, async).
        // IterationStatement : for await ( ForDeclaration of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, async-iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet, async).
        return intrinsics.empty; // TODO: implement this
    }
    // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-evaluation
    // 13.7.5.14 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ForBinding : BindingIdentifier
        // 1. Let bindingId be StringValue of BindingIdentifier.
        // 2. Return ? ResolveBinding(bindingId).
        return intrinsics.empty; // TODO: implement this
    }
}
class $ForOfStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ForOfStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        if (node.initializer.kind === typescript.SyntaxKind.VariableDeclarationList) {
            const $initializer = this.$initializer = new $VariableDeclarationList(node.initializer, this, ctx);
            if ($initializer.isLexical) {
                this.BoundNames = $initializer.BoundNames;
                this.VarDeclaredNames = $statement.VarDeclaredNames;
                this.VarScopedDeclarations = $statement.VarScopedDeclarations;
            }
            else {
                this.BoundNames = kernel.emptyArray;
                this.VarDeclaredNames = [
                    ...$initializer.VarDeclaredNames,
                    ...$statement.VarDeclaredNames,
                ];
                this.VarScopedDeclarations = [
                    ...$initializer.VarScopedDeclarations,
                    ...$statement.VarScopedDeclarations,
                ];
            }
        }
        else {
            this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
            this.BoundNames = kernel.emptyArray;
            this.VarDeclaredNames = $statement.VarDeclaredNames;
            this.VarScopedDeclarations = $statement.VarScopedDeclarations;
        }
    }
    get $kind() { return typescript.SyntaxKind.ForOfStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation
    // 13.7.5.11 Runtime Semantics: LabelledEvaluation
    EvaluateLabelled(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);
        // IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).
        // IterationStatement : for ( var ForBinding in Expression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).
        // IterationStatement : for ( ForDeclaration in Expression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).
        // IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).
        // IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).
        // IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).
        // IterationStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet, async).
        // IterationStatement : for await ( var ForBinding of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet, async).
        // IterationStatement : for await ( ForDeclaration of AssignmentExpression ) Statement
        // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, async-iterate).
        // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet, async).
        return intrinsics.empty; // TODO: implement this
    }
    // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-evaluation
    // 13.7.5.14 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $ContinueStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ContinueStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        this.$label = $identifier(node.label, this, ctx | 2048 /* IsLabelReference */, -1);
    }
    get $kind() { return typescript.SyntaxKind.ContinueStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-continue-statement-runtime-semantics-evaluation
    // 13.8.3 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ContinueStatement : continue ;
        // 1. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }.
        if (this.$label === void 0) {
            return new $Empty(realm, 3 /* continue */, intrinsics.empty, this);
        }
        // ContinueStatement : continue LabelIdentifier ;
        // 1. Let label be the StringValue of LabelIdentifier.
        // 2. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: label }.
        return new $Empty(realm, 3 /* continue */, this.$label.StringValue, this);
    }
}
class $BreakStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.BreakStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        this.$label = $identifier(node.label, this, ctx | 2048 /* IsLabelReference */, -1);
    }
    get $kind() { return typescript.SyntaxKind.BreakStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-break-statement-runtime-semantics-evaluation
    // 13.9.3 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // BreakStatement : break ;
        // 1. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.
        if (this.$label === void 0) {
            return new $Empty(realm, 2 /* break */, intrinsics.empty, this);
        }
        // BreakStatement : break LabelIdentifier ;
        // 1. Let label be the StringValue of LabelIdentifier.
        // 2. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: label }.
        return new $Empty(realm, 2 /* break */, this.$label.StringValue, this);
    }
}
class $ReturnStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ReturnStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        if (node.expression === void 0) {
            this.$expression = void 0;
        }
        else {
            this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        }
    }
    get $kind() { return typescript.SyntaxKind.ReturnStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-return-statement
    // 13.10 The return Statement
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ReturnStatement : return ;
        // 1. Return Completion { [[Type]]: return, [[Value]]: undefined, [[Target]]: empty }.
        if (this.$expression === void 0) {
            return new $Undefined(realm, 4 /* return */);
        }
        // ReturnStatement : return Expression ;
        // 1. Let exprRef be the result of evaluating Expression.
        const exprRef = this.$expression.Evaluate(ctx);
        // 2. Let exprValue be ? GetValue(exprRef).
        const exprValue = exprRef.GetValue(ctx);
        if (exprValue.isAbrupt) {
            return exprValue.enrichWith(ctx, this);
        }
        // 3. If ! GetGeneratorKind() is async, set exprValue to ? Await(exprValue). // TODO
        // 4. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.
        return exprValue.ToCompletion(4 /* return */, intrinsics.empty);
    }
}
class $WithStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.WithStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        this.VarDeclaredNames = $statement.VarDeclaredNames;
        this.VarScopedDeclarations = $statement.VarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.WithStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-with-statement-runtime-semantics-evaluation
    // 13.11.7 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // WithStatement : with ( Expression ) Statement
        // 1. Let val be the result of evaluating Expression.
        // 2. Let obj be ? ToObject(? GetValue(val)).
        // 3. Let oldEnv be the running execution context's LexicalEnvironment.
        // 4. Let newEnv be NewObjectEnvironment(obj, oldEnv).
        // 5. Set the withEnvironment flag of newEnv's EnvironmentRecord to true.
        // 6. Set the running execution context's LexicalEnvironment to newEnv.
        // 7. Let C be the result of evaluating Statement.
        // 8. Set the running execution context's LexicalEnvironment to oldEnv.
        // 9. Return Completion(UpdateEmpty(C, undefined)).
        return intrinsics.empty; // TODO: implement this
    }
}
class $SwitchStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.SwitchStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        const $caseBlock = this.$caseBlock = new $CaseBlock(node.caseBlock, this, ctx);
        this.LexicallyDeclaredNames = $caseBlock.LexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $caseBlock.LexicallyScopedDeclarations;
        this.VarDeclaredNames = $caseBlock.VarDeclaredNames;
        this.VarScopedDeclarations = $caseBlock.VarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.SwitchStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-switch-statement-runtime-semantics-evaluation
    // 13.12.11 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        const realm = ctx.Realm;
        // SwitchStatement : switch ( Expression ) CaseBlock
        // 1. Let exprRef be the result of evaluating Expression.
        // 2. Let switchValue be ? GetValue(exprRef).
        const switchValue = this.$expression.Evaluate(ctx).GetValue(ctx);
        if (switchValue.isAbrupt) {
            return switchValue.enrichWith(ctx, this);
        }
        // 3. Let oldEnv be the running execution context's LexicalEnvironment.
        const oldEnv = ctx.LexicalEnvironment;
        // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).
        const blockEnv = ctx.LexicalEnvironment = new $DeclarativeEnvRec(this.logger, realm, oldEnv);
        // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).
        const $BlockDeclarationInstantiationResult = BlockDeclarationInstantiation(ctx, this.LexicallyScopedDeclarations, blockEnv);
        if ($BlockDeclarationInstantiationResult.isAbrupt) {
            return $BlockDeclarationInstantiationResult;
        }
        // 6. Set the running execution context's LexicalEnvironment to blockEnv.
        realm.stack.push(ctx);
        // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.
        const R = this.EvaluateCaseBlock(ctx, switchValue);
        // 8. Set the running execution context's LexicalEnvironment to oldEnv.
        realm.stack.pop();
        ctx.LexicalEnvironment = oldEnv;
        // 9. Return R.
        return R;
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-caseblockevaluation
    // 13.12.9 Runtime Semantics: CaseBlockEvaluation
    EvaluateCaseBlock(ctx, switchValue) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const { $caseBlock: { $clauses: clauses } } = this;
        const { undefined: $undefined, empty } = realm['[[Intrinsics]]'];
        // CaseBlock : { }
        // 1. Return NormalCompletion(undefined).
        if (clauses.length === 0) {
            return new $Undefined(realm);
        }
        let V = $undefined;
        const defaultClauseIndex = clauses.findIndex((clause) => clause.$kind === typescript.SyntaxKind.DefaultClause);
        class CaseClausesEvaluationResult {
            constructor(result, found, isAbrupt) {
                this.result = result;
                this.found = found;
                this.isAbrupt = isAbrupt;
            }
        }
        const evaluateCaseClauses = (inclusiveStartIndex, exclusiveEndIndex, found = false) => {
            // 1. Let V be undefined.
            // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.
            // 3. Let found be false.
            // 4. For each CaseClause C in A, do
            for (let i = inclusiveStartIndex; i < exclusiveEndIndex; i++) {
                const C = clauses[i];
                // 4. a. If found is false, then
                if (!found) {
                    // 4. a. i. Set found to ? CaseClauseIsSelected(C, input).
                    found = this.IsCaseClauseSelected(ctx, C, switchValue);
                }
                // 4. b. If found is true, then
                if (found) {
                    // 4. b. i. Let R be the result of evaluating C.
                    const R = evaluateStatementList(ctx, C.$statements);
                    // 4. b. ii. If R.[[Value]] is not empty, set V to R.[[Value]].
                    if (R.hasValue) {
                        V = R;
                    }
                    // 4. b. iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
                    if (R.isAbrupt) {
                        return new CaseClausesEvaluationResult(R.enrichWith(ctx, this).UpdateEmpty(V), found, true);
                    }
                }
            }
            // 5. Return NormalCompletion(V).
            return new CaseClausesEvaluationResult(V.ToCompletion(1 /* normal */, intrinsics.empty), found, false);
        };
        // CaseBlock : { CaseClauses }
        if (defaultClauseIndex === -1) {
            return evaluateCaseClauses(0, clauses.length).result;
        }
        // CaseBlock : { CaseClauses opt DefaultClause CaseClauses opt }
        // 1. Let V be undefined.
        // 2. If the first CaseClauses is present, then
        // 2. a. Let A be the List of CaseClause items in the first CaseClauses, in source text order.
        // 3. Else,
        // 3. a. Let A be « ».
        // 4. Let found be false.
        // 5. For each CaseClause C in A, do
        // 5. a. If found is false, then
        // 5. a. i. Set found to ? CaseClauseIsSelected(C, input).
        // 5. b. If found is true, then
        // 5. b. i. Let R be the result of evaluating C.
        // 5. b. ii. If R.[[Value]] is not empty, set V to R.[[Value]].
        // 5. b. iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        let { result, found, isAbrupt } = evaluateCaseClauses(0, defaultClauseIndex);
        if (isAbrupt) {
            return result;
        }
        // 6. Let foundInB be false.
        // 7. If the second CaseClauses is present, then
        // 7. a. Let B be the List of CaseClause items in the second CaseClauses, in source text order.
        // 8. Else,
        // 8. a. Let B be « ».
        // 9. If found is false, then
        if (!found) {
            // 9. a. For each CaseClause C in B, do
            // 9. a. i. If foundInB is false, then
            // 9. a. i. 1. Set foundInB to ? CaseClauseIsSelected(C, input).
            // 9. a. ii. If foundInB is true, then
            // 9. a. ii. 1. Let R be the result of evaluating CaseClause C.
            // 9. a. ii. 2. If R.[[Value]] is not empty, set V to R.[[Value]].
            // 9. a. ii. 3. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
            // 10. If foundInB is true, return NormalCompletion(V).
            ({ result, isAbrupt, found } = evaluateCaseClauses(defaultClauseIndex + 1, clauses.length));
            if (isAbrupt || found) {
                return result;
            }
        }
        // 11. Let R be the result of evaluating DefaultClause.
        // 12. If R.[[Value]] is not empty, set V to R.[[Value]].
        // 13. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        ({ result, isAbrupt } = evaluateCaseClauses(defaultClauseIndex, defaultClauseIndex + 1, true));
        if (isAbrupt) {
            return result;
        }
        // 14. For each CaseClause C in B (NOTE: this is another complete iteration of the second CaseClauses), do
        // 14. a. Let R be the result of evaluating CaseClause C.
        // 14. b. If R.[[Value]] is not empty, set V to R.[[Value]].
        // 14. c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).
        // 15. Return NormalCompletion(V).
        return evaluateCaseClauses(defaultClauseIndex + 1, clauses.length, true).result;
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-caseclauseisselected
    // 13.12.10 Runtime Semantics: CaseClauseIsSelected ( C , input )
    IsCaseClauseSelected(ctx, clause, switchValue) {
        ctx.checkTimeout();
        // 1. Assert: C is an instance of the production CaseClause:caseExpression:StatementListopt .
        // 2. Let exprRef be the result of evaluating the Expression of C.
        // 3. Let clauseSelector be ? GetValue(exprRef).
        // 4. Return the result of performing Strict Equality Comparison input === clauseSelector.
        return clause.$expression.Evaluate(ctx).GetValue(ctx)['[[Value]]'] === switchValue['[[Value]]'];
    }
}
class $LabeledStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.LabeledStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-toplevellexicallydeclarednames
        // 13.13.8 Static Semantics: TopLevelLexicallyDeclaredNames
        this.TopLevelLexicallyDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations
        // 13.13.9 Static Semantics: TopLevelLexicallyScopedDeclarations
        this.TopLevelLexicallyScopedDeclarations = kernel.emptyArray;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        this.$label = $identifier(node.label, this, ctx | 1024 /* IsLabel */, -1);
        const $statement = this.$statement = $$esLabelledItem(node.statement, this, ctx, -1);
        if ($statement.$kind === typescript.SyntaxKind.FunctionDeclaration) {
            this.LexicallyDeclaredNames = $statement.BoundNames;
            this.LexicallyScopedDeclarations = [$statement];
            this.TopLevelVarDeclaredNames = $statement.BoundNames;
            this.TopLevelVarScopedDeclarations = [$statement];
            this.VarDeclaredNames = kernel.emptyArray;
            this.VarScopedDeclarations = kernel.emptyArray;
        }
        else {
            this.LexicallyDeclaredNames = kernel.emptyArray;
            this.LexicallyScopedDeclarations = kernel.emptyArray;
            if ($statement.$kind === typescript.SyntaxKind.LabeledStatement) {
                this.TopLevelVarDeclaredNames = $statement.TopLevelVarDeclaredNames;
                this.TopLevelVarScopedDeclarations = $statement.TopLevelVarScopedDeclarations;
            }
            else {
                this.TopLevelVarDeclaredNames = $statement.VarDeclaredNames;
                this.TopLevelVarScopedDeclarations = $statement.VarScopedDeclarations;
            }
            this.VarDeclaredNames = $statement.VarDeclaredNames;
            this.VarScopedDeclarations = $statement.VarScopedDeclarations;
        }
    }
    get $kind() { return typescript.SyntaxKind.LabeledStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-runtime-semantics-labelledevaluation
    // 13.13.14 Runtime Semantics: LabelledEvaluation
    EvaluateLabelled(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);
        // LabelledStatement : LabelIdentifier : LabelledItem
        // 1. Let label be the StringValue of LabelIdentifier.
        // 2. Append label as an element of labelSet.
        // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.
        // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then
        // 4. a. Set stmtResult to NormalCompletion(stmtResult.[[Value]]).
        // 5. Return Completion(stmtResult).
        // LabelledItem : Statement
        // 1. If Statement is either a LabelledStatement or a BreakableStatement, then
        // 1. a. Return LabelledEvaluation of Statement with argument labelSet.
        // 2. Else,
        // 2. a. Return the result of evaluating Statement.
        // LabelledItem : FunctionDeclaration
        // 1. Return the result of evaluating FunctionDeclaration.
        return intrinsics.undefined; // TODO: implement this
    }
    // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-runtime-semantics-evaluation
    // 13.13.15 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // LabelledStatement : LabelIdentifier : LabelledItem
        // 1. Let newLabelSet be a new empty List.
        // 2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.
        return intrinsics.undefined; // TODO: implement this
    }
}
class $ThrowStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ThrowStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.ThrowStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-throw-statement-runtime-semantics-evaluation
    // 13.14.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ThrowStatement : throw Expression ;
        // 1. Let exprRef be the result of evaluating Expression.
        const exprRef = this.$expression.Evaluate(ctx);
        // 2. Let exprValue be ? GetValue(exprRef).
        const exprValue = exprRef.GetValue(ctx);
        if (exprValue.isAbrupt) {
            return exprValue.enrichWith(ctx, this);
        }
        // 3. Return ThrowCompletion(exprValue).
        return exprValue.ToCompletion(5 /* throw */, intrinsics.empty);
    }
}
class $TryStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TryStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        const $tryBlock = this.$tryBlock = new $Block(node.tryBlock, this, ctx, -1);
        if (node.catchClause === void 0) {
            // finallyBlock must be defined
            this.$catchClause = void 0;
            const $finallyBlock = this.$finallyBlock = new $Block(node.finallyBlock, this, ctx, -1);
            this.VarDeclaredNames = [
                ...$tryBlock.VarDeclaredNames,
                ...$finallyBlock.VarDeclaredNames,
            ];
            this.VarScopedDeclarations = [
                ...$tryBlock.VarScopedDeclarations,
                ...$finallyBlock.VarScopedDeclarations,
            ];
        }
        else if (node.finallyBlock === void 0) {
            // catchClause must be defined
            const $catchClause = this.$catchClause = new $CatchClause(node.catchClause, this, ctx);
            this.$finallyBlock = void 0;
            this.VarDeclaredNames = [
                ...$tryBlock.VarDeclaredNames,
                ...$catchClause.VarDeclaredNames,
            ];
            this.VarScopedDeclarations = [
                ...$tryBlock.VarScopedDeclarations,
                ...$catchClause.VarScopedDeclarations,
            ];
        }
        else {
            const $catchClause = this.$catchClause = new $CatchClause(node.catchClause, this, ctx);
            const $finallyBlock = this.$finallyBlock = new $Block(node.finallyBlock, this, ctx, -1);
            this.VarDeclaredNames = [
                ...$tryBlock.VarDeclaredNames,
                ...$catchClause.VarDeclaredNames,
                ...$finallyBlock.VarDeclaredNames,
            ];
            this.VarScopedDeclarations = [
                ...$tryBlock.VarScopedDeclarations,
                ...$catchClause.VarScopedDeclarations,
                ...$finallyBlock.VarScopedDeclarations,
            ];
        }
    }
    get $kind() { return typescript.SyntaxKind.TryStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-try-statement-runtime-semantics-evaluation
    // 13.15.8 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        const realm = ctx.Realm;
        // TryStatement : try Block Catch
        // 1. Let B be the result of evaluating Block.
        // 2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].
        // 3. Else, let C be B.
        // 4. Return Completion(UpdateEmpty(C, undefined)).
        // TryStatement : try Block Finally
        // 1. Let B be the result of evaluating Block.
        // 2. Let F be the result of evaluating Finally.
        // 3. If F.[[Type]] is normal, set F to B.
        // 4. Return Completion(UpdateEmpty(F, undefined)).
        // TryStatement : try Block Catch Finally
        // 1. Let B be the result of evaluating Block.
        // 2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].
        // 3. Else, let C be B.
        // 4. Let F be the result of evaluating Finally.
        // 5. If F.[[Type]] is normal, set F to C.
        // 6. Return Completion(UpdateEmpty(F, undefined)).
        let result = this.$tryBlock.Evaluate(ctx);
        if (this.$catchClause !== void 0) {
            result = result['[[Type]]'] === 5 /* throw */ ? this.EvaluateCatchClause(ctx, result.GetValue(ctx)) : result; // TODO: fix types
        }
        const $finallyBlock = this.$finallyBlock;
        if ($finallyBlock !== void 0) {
            const F = $finallyBlock.Evaluate(ctx);
            result = F['[[Type]]'] !== 1 /* normal */ ? F : result;
        }
        result.UpdateEmpty(realm['[[Intrinsics]]'].undefined);
        return result;
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-catchclauseevaluation
    // 13.15.7 Runtime Semantics: CatchClauseEvaluation
    EvaluateCatchClause(ctx, thrownValue) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const catchClause = this.$catchClause;
        const varDeclarations = catchClause === null || catchClause === void 0 ? void 0 : catchClause.$variableDeclaration;
        const hasCatchParamteres = varDeclarations !== void 0;
        // Catch : catch Block
        // 1. Return the result of evaluating Block.
        // Catch : catch ( CatchParameter ) Block
        // 1. Let oldEnv be the running execution context's LexicalEnvironment.
        const oldEnv = ctx.LexicalEnvironment;
        if (hasCatchParamteres) {
            // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).
            // 3. Let catchEnvRec be catchEnv's EnvironmentRecord.
            ctx.LexicalEnvironment = new $DeclarativeEnvRec(this.logger, realm, oldEnv);
            // 4. For each element argName of the BoundNames of CatchParameter, do
            // 4. a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).
            catchClause === null || catchClause === void 0 ? void 0 : catchClause.CreateBinding(ctx, realm);
            // 5. Set the running execution context's LexicalEnvironment to catchEnv.
            realm.stack.push(ctx);
            // 6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.
            const status = varDeclarations === null || varDeclarations === void 0 ? void 0 : varDeclarations.InitializeBinding(ctx, thrownValue);
            // 7. If status is an abrupt completion, then
            if (status === null || status === void 0 ? void 0 : status.isAbrupt) {
                // 7. a. Set the running execution context's LexicalEnvironment to oldEnv.
                realm.stack.pop();
                ctx.LexicalEnvironment = oldEnv;
                // 7. b. Return Completion(status).
                return status;
            }
        }
        // 8. Let B be the result of evaluating Block.
        const B = catchClause === null || catchClause === void 0 ? void 0 : catchClause.$block.Evaluate(ctx);
        // 9. Set the running execution context's LexicalEnvironment to oldEnv.
        if (hasCatchParamteres) {
            realm.stack.pop();
            ctx.LexicalEnvironment = oldEnv;
        }
        // 10. Return Completion(B).
        return B; // TODO fix typings
    }
}
class $DebuggerStatement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.DebuggerStatement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.LexicallyDeclaredNames = kernel.emptyArray;
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames
        // 13.1.5 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations
        // 13.1.6 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
    }
    get $kind() { return typescript.SyntaxKind.DebuggerStatement; }
    // http://www.ecma-international.org/ecma-262/#sec-debugger-statement-runtime-semantics-evaluation
    // 13.16.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // DebuggerStatement : debugger ;
        // 1. If an implementation-defined debugging facility is available and enabled, then
        // 1. a. Perform an implementation-defined debugging action.
        // 1. b. Let result be an implementation-defined Completion value.
        // 2. Else,
        // 2. a. Let result be NormalCompletion(empty).
        // 3. Return result.
        return intrinsics.empty; // TODO: implement this
    }
}
function $$clauseList(nodes, parent, ctx) {
    const len = nodes.length;
    let node;
    const $nodes = [];
    for (let i = 0; i < len; ++i) {
        node = nodes[i];
        switch (node.kind) {
            case typescript.SyntaxKind.CaseClause:
                $nodes[i] = new $CaseClause(node, parent, ctx, i);
                break;
            case typescript.SyntaxKind.DefaultClause:
                $nodes[i] = new $DefaultClause(node, parent, ctx, i);
                break;
        }
    }
    return $nodes;
}
class $CaseBlock {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.CaseBlock`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const $clauses = this.$clauses = $$clauseList(node.clauses, this, ctx);
        this.LexicallyDeclaredNames = $clauses.flatMap(getLexicallyDeclaredNames);
        this.LexicallyScopedDeclarations = $clauses.flatMap(getLexicallyScopedDeclarations);
        this.VarDeclaredNames = $clauses.flatMap(getVarDeclaredNames);
        this.VarScopedDeclarations = $clauses.flatMap(getVarScopedDeclarations);
    }
    get $kind() { return typescript.SyntaxKind.CaseBlock; }
}
class $CaseClause {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.CaseClause`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        const $statements = this.$statements = $$tsStatementList(node.statements, this, ctx);
        this.LexicallyDeclaredNames = $statements.flatMap(getLexicallyDeclaredNames);
        this.LexicallyScopedDeclarations = $statements.flatMap(getLexicallyScopedDeclarations);
        this.VarDeclaredNames = $statements.flatMap(getVarDeclaredNames);
        this.VarScopedDeclarations = $statements.flatMap(getVarScopedDeclarations);
    }
    get $kind() { return typescript.SyntaxKind.CaseClause; }
}
class $DefaultClause {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.DefaultClause`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const $statements = this.$statements = $$tsStatementList(node.statements, this, ctx);
        this.LexicallyDeclaredNames = $statements.flatMap(getLexicallyDeclaredNames);
        this.LexicallyScopedDeclarations = $statements.flatMap(getLexicallyScopedDeclarations);
        this.VarDeclaredNames = $statements.flatMap(getVarDeclaredNames);
        this.VarScopedDeclarations = $statements.flatMap(getVarScopedDeclarations);
    }
    get $kind() { return typescript.SyntaxKind.DefaultClause; }
}
class $CatchClause {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.CatchClause`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        ctx |= 32 /* InCatchClause */;
        if (node.variableDeclaration === void 0) {
            this.$variableDeclaration = void 0;
        }
        else {
            this.$variableDeclaration = new $VariableDeclaration(node.variableDeclaration, this, ctx, -1);
        }
        const $block = this.$block = new $Block(node.block, this, ctx, -1);
        this.VarDeclaredNames = $block.VarDeclaredNames;
        this.VarScopedDeclarations = $block.VarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.CatchClause; }
    CreateBinding(ctx, realm) {
        var _a, _b;
        ctx.checkTimeout();
        for (const argName of (_b = (_a = this.$variableDeclaration) === null || _a === void 0 ? void 0 : _a.BoundNames) !== null && _b !== void 0 ? _b : []) {
            ctx.LexicalEnvironment.CreateMutableBinding(ctx, argName, realm['[[Intrinsics]]'].false);
        }
    }
}
// #endregion

class $MethodDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.MethodDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        const $name = this.$name = $$propertyName(node.name, this, ctx | 512 /* IsMemberName */, -1);
        this.$parameters = new $FormalParameterList(node.parameters, this, ctx);
        const $body = this.$body = new $Block(node.body, this, ctx, -1);
        this.PropName = $name.PropName;
        this.IsStatic = hasBit(modifierFlags, typescript.ModifierFlags.Static);
        this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;
        this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;
        this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;
        if (!hasBit(modifierFlags, typescript.ModifierFlags.Async)) {
            if (node.asteriskToken === void 0) {
                this.functionKind = 0 /* normal */;
            }
            else {
                this.functionKind = 4 /* generator */;
            }
        }
        else if (node.asteriskToken === void 0) {
            this.functionKind = 8 /* async */;
        }
        else {
            this.functionKind = 12 /* asyncGenerator */;
        }
    }
    get $kind() { return typescript.SyntaxKind.MethodDeclaration; }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-definemethod
    // 14.3.7 Runtime Semantics: DefineMethod
    DefineMethod(ctx, object) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // NOTE: this logic and signature is adapted to the fact that this is never a constructor method (that's what $ConstructorDeclaration is for)
        // MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
        // 1. Let propKey be the result of evaluating PropertyName.
        const propKey = this.$name.EvaluatePropName(ctx);
        // 2. ReturnIfAbrupt(propKey).
        if (propKey.isAbrupt) {
            return propKey.enrichWith(ctx, this);
        }
        // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = intrinsics.true; // TODO: use static semantics
        // 4. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 5. If functionPrototype is present as a parameter, then
        // 5. a. Let kind be Normal.
        // 5. b. Let prototype be functionPrototype.
        // 6. Else,
        // 6. a. Let kind be Method.
        // 6. b. Let prototype be the intrinsic object %FunctionPrototype%.
        const functionPrototype = intrinsics['%FunctionPrototype%'];
        // 7. Let closure be FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype).
        const closure = $Function.FunctionCreate(ctx, 'method', this, scope, strict, functionPrototype);
        // 8. Perform MakeMethod(closure, object).
        closure['[[HomeObject]]'] = object;
        // 9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 10. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.
        return new MethodDefinitionRecord(propKey, closure);
    }
    // http://www.ecma-international.org/ecma-262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation
    // 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation
    EvaluatePropertyDefinition(ctx, object, enumerable) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
        // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.
        const methodDef = this.DefineMethod(ctx, object);
        // 2. ReturnIfAbrupt(methodDef).
        if (methodDef.isAbrupt) {
            return methodDef.enrichWith(ctx, this);
        }
        // 3. Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).
        methodDef['[[Closure]]'].SetFunctionName(ctx, methodDef['[[Key]]']);
        // 4. Let desc be the PropertyDescriptor { [[Value]]: methodDef.[[Closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }.
        const desc = new $PropertyDescriptor(realm, methodDef['[[Key]]'], {
            '[[Value]]': methodDef['[[Closure]]'],
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': enumerable,
            '[[Configurable]]': intrinsics.true,
        });
        // 5. Return ? DefinePropertyOrThrow(object, methodDef.[[Key]], desc).
        return $DefinePropertyOrThrow(ctx, object, methodDef['[[Key]]'], desc).enrichWith(ctx, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        ctx.checkTimeout();
        return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);
    }
}
class $GetAccessorDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.GetAccessorDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.functionKind = 0 /* normal */;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        const $name = this.$name = $$propertyName(node.name, this, ctx | 512 /* IsMemberName */, -1);
        this.$parameters = new $FormalParameterList(node.parameters, this, ctx);
        const $body = this.$body = new $Block(node.body, this, ctx, -1);
        this.PropName = $name.PropName;
        this.IsStatic = hasBit(modifierFlags, typescript.ModifierFlags.Static);
        this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;
        this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;
        this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.GetAccessor; }
    // http://www.ecma-international.org/ecma-262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation
    // 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation
    EvaluatePropertyDefinition(ctx, object, enumerable) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // MethodDefinition : get PropertyName ( ) { FunctionBody }
        // 1. Let propKey be the result of evaluating PropertyName.
        const propKey = this.$name.EvaluatePropName(ctx);
        // 2. ReturnIfAbrupt(propKey).
        if (propKey.isAbrupt) {
            return propKey.enrichWith(ctx, this);
        }
        // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = intrinsics.true; // TODO: use static semantics
        // 4. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 5. Let formalParameterList be an instance of the production FormalParameters:[empty] .
        // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).
        const closure = $Function.FunctionCreate(ctx, 'method', this, scope, strict);
        // 7. Perform MakeMethod(closure, object).
        closure['[[HomeObject]]'] = object;
        // 8. Perform SetFunctionName(closure, propKey, "get").
        closure.SetFunctionName(ctx, propKey, intrinsics.$get);
        // 9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 10. Let desc be the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
        const desc = new $PropertyDescriptor(realm, propKey, {
            '[[Get]]': closure,
            '[[Enumerable]]': enumerable,
            '[[Configurable]]': intrinsics.true,
        });
        // 11. Return ? DefinePropertyOrThrow(object, propKey, desc).
        return $DefinePropertyOrThrow(ctx, object, propKey, desc).enrichWith(ctx, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        ctx.checkTimeout();
        return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);
    }
}
class $SetAccessorDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.SetAccessorDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.functionKind = 0 /* normal */;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        const $name = this.$name = $$propertyName(node.name, this, ctx | 512 /* IsMemberName */, -1);
        this.$parameters = new $FormalParameterList(node.parameters, this, ctx);
        const $body = this.$body = new $Block(node.body, this, ctx, -1);
        this.PropName = $name.PropName;
        this.IsStatic = hasBit(modifierFlags, typescript.ModifierFlags.Static);
        this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;
        this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;
        this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.SetAccessor; }
    // http://www.ecma-international.org/ecma-262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation
    // 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation
    EvaluatePropertyDefinition(ctx, object, enumerable) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody }
        // 1. Let propKey be the result of evaluating PropertyName.
        const propKey = this.$name.EvaluatePropName(ctx);
        // 2. ReturnIfAbrupt(propKey).
        if (propKey.isAbrupt) {
            return propKey.enrichWith(ctx, this);
        }
        // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = intrinsics.true; // TODO: use static semantics
        // 4. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).
        const closure = $Function.FunctionCreate(ctx, 'method', this, scope, strict);
        // 6. Perform MakeMethod(closure, object).
        closure['[[HomeObject]]'] = object;
        // 7. Perform SetFunctionName(closure, propKey, "set").
        closure.SetFunctionName(ctx, propKey, intrinsics.$set);
        // 8. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 9. Let desc be the PropertyDescriptor { [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.
        const desc = new $PropertyDescriptor(realm, propKey, {
            '[[Set]]': closure,
            '[[Enumerable]]': enumerable,
            '[[Configurable]]': intrinsics.true,
        });
        // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).
        return $DefinePropertyOrThrow(ctx, object, propKey, desc).enrichWith(ctx, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        ctx.checkTimeout();
        return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);
    }
}

class $Decorator {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.Decorator`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.Decorator; }
}
// #region LHS
class $ThisExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ThisExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
    }
    get $kind() { return typescript.SyntaxKind.ThisKeyword; }
    // http://www.ecma-international.org/ecma-262/#sec-this-keyword-runtime-semantics-evaluation
    // 12.2.2.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // PrimaryExpression : this
        // 1. Return ? ResolveThisBinding().
        return realm.ResolveThisBinding().enrichWith(ctx, this);
    }
}
class $SuperExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.SuperExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.SuperKeyword; }
    // http://www.ecma-international.org/ecma-262/#sec-super-keyword-runtime-semantics-evaluation
    // 12.3.5.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // SuperProperty : super [ Expression ]
        // 1. Let env be GetThisEnvironment().
        // 2. Let actualThis be ? env.GetThisBinding().
        // 3. Let propertyNameReference be the result of evaluating Expression.
        // 4. Let propertyNameValue be ? GetValue(propertyNameReference).
        // 5. Let propertyKey be ? ToPropertyKey(propertyNameValue).
        // 6. If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be false.
        // 7. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).
        // SuperProperty : super . IdentifierName
        // 1. Let env be GetThisEnvironment().
        // 2. Let actualThis be ? env.GetThisBinding().
        // 3. Let propertyKey be StringValue of IdentifierName.
        // 4. If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be false.
        // 5. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).
        // SuperCall : super Arguments
        // 1. Let newTarget be GetNewTarget().
        // 2. Assert: Type(newTarget) is Object.
        // 3. Let func be ? GetSuperConstructor().
        // 4. Let argList be ArgumentListEvaluation of Arguments.
        // 5. ReturnIfAbrupt(argList).
        // 6. Let result be ? Construct(func, argList, newTarget).
        // 7. Let thisER be GetThisEnvironment().
        // 8. Return ? thisER.BindThisValue(result).
        return intrinsics.undefined; // TODO: implement this
    }
}
function $argumentOrArrayLiteralElement(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.SpreadElement:
            return new $SpreadElement(node, parent, ctx, idx);
        case typescript.SyntaxKind.OmittedExpression:
            return new $OmittedExpression(node, parent, ctx, idx);
        default:
            return $assignmentExpression(node, parent, ctx, idx);
    }
}
function $argumentOrArrayLiteralElementList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = $argumentOrArrayLiteralElement(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
class $ArrayLiteralExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ArrayLiteralExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        this.$elements = $argumentOrArrayLiteralElementList(node.elements, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.ArrayLiteralExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-arrayaccumulation
    // 12.2.5.2 Runtime Semantics: ArrayAccumulation
    AccumulateArray(ctx, array, nextIndex) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const elements = this.$elements;
        let el;
        let padding = 0;
        let postIndex = intrinsics['0'];
        for (let i = 0, ii = elements.length; i < ii; ++i) {
            el = elements[i];
            switch (el.$kind) {
                case typescript.SyntaxKind.OmittedExpression: {
                    ++padding;
                    break;
                }
                case typescript.SyntaxKind.SpreadElement: {
                    // ElementList : Elision opt SpreadElement
                    // 1. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
                    // 2. Return the result of performing ArrayAccumulation for SpreadElement with arguments array and nextIndex + padding.
                    // ElementList : ElementList , Elision opt SpreadElement
                    // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
                    // 2. ReturnIfAbrupt(postIndex).
                    // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
                    // 4. Return the result of performing ArrayAccumulation for SpreadElement with arguments array and postIndex + padding.
                    const $postIndex = el.AccumulateArray(ctx, array, new $Number(realm, postIndex['[[Value]]'] + padding));
                    if ($postIndex.isAbrupt) {
                        return $postIndex.enrichWith(ctx, this);
                    }
                    postIndex = $postIndex;
                    padding = 0;
                    break;
                }
                default: {
                    // ElementList : Elision opt AssignmentExpression
                    // 1. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
                    // 2. Let initResult be the result of evaluating AssignmentExpression.
                    // 3. Let initValue be ? GetValue(initResult).
                    // 4. Let created be CreateDataProperty(array, ToString(ToUint32(nextIndex + padding)), initValue).
                    // 5. Assert: created is true.
                    // 6. Return nextIndex + padding + 1.
                    // ElementList : ElementList , Elision opt AssignmentExpression
                    // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.
                    // 2. ReturnIfAbrupt(postIndex).
                    // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
                    // 4. Let initResult be the result of evaluating AssignmentExpression.
                    const initResult = el.Evaluate(ctx);
                    // 5. Let initValue be ? GetValue(initResult).
                    const initValue = initResult.GetValue(ctx);
                    if (initValue.isAbrupt) {
                        return initValue.enrichWith(ctx, this);
                    }
                    // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex + padding)), initValue).
                    $CreateDataProperty(ctx, array, new $Number(realm, postIndex['[[Value]]'] + padding).ToUint32(ctx).ToString(ctx), initValue);
                    // 7. Assert: created is true.
                    // 8. Return postIndex + padding + 1.
                    postIndex = new $Number(realm, postIndex['[[Value]]'] + padding + 1);
                    padding = 0;
                    break;
                }
            }
        }
        return postIndex;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array-initializer-runtime-semantics-evaluation
    // 12.2.5.3 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // ArrayLiteral : [ Elision opt ]
        // 1. Let array be ! ArrayCreate(0).
        // 2. Let pad be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
        // 3. Perform Set(array, "length", ToUint32(pad), false).
        // 4. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        // 5. Return array.
        // ArrayLiteral : [ ElementList ]
        // 1. Let array be ! ArrayCreate(0).
        const array = new $ArrayExoticObject(realm, intrinsics['0']);
        // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
        const len = this.AccumulateArray(ctx, array, intrinsics['0']);
        // 3. ReturnIfAbrupt(len).
        if (len.isAbrupt) {
            return len.enrichWith(ctx, this);
        }
        // 4. Perform Set(array, "length", ToUint32(len), false).
        $Set(ctx, array, intrinsics.length, len.ToUint32(ctx), intrinsics.false);
        // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        // 6. Return array.
        return array;
        // ArrayLiteral : [ ElementList , Elision opt ]
        // 1. Let array be ! ArrayCreate(0).
        // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.
        // 3. ReturnIfAbrupt(len).
        // 4. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.
        // 5. Perform Set(array, "length", ToUint32(padding + len), false).
        // 6. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.
        // 7. Return array.
    }
}
function $$objectLiteralElementLikeList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    let el;
    for (let i = 0; i < len; ++i) {
        el = nodes[i];
        switch (el.kind) {
            case typescript.SyntaxKind.PropertyAssignment:
                $nodes[i] = new $PropertyAssignment(el, parent, ctx, i);
                break;
            case typescript.SyntaxKind.ShorthandPropertyAssignment:
                $nodes[i] = new $ShorthandPropertyAssignment(el, parent, ctx, i);
                break;
            case typescript.SyntaxKind.SpreadAssignment:
                $nodes[i] = new $SpreadAssignment(el, parent, ctx, i);
                break;
            case typescript.SyntaxKind.MethodDeclaration:
                $nodes[i] = new $MethodDeclaration(el, parent, ctx, i);
                break;
            case typescript.SyntaxKind.GetAccessor:
                $nodes[i] = new $GetAccessorDeclaration(el, parent, ctx, i);
                break;
            case typescript.SyntaxKind.SetAccessor:
                $nodes[i] = new $SetAccessorDeclaration(el, parent, ctx, i);
                break;
        }
    }
    return $nodes;
}
class $ObjectLiteralExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ObjectLiteralExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        this.$properties = $$objectLiteralElementLikeList(node.properties, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.ObjectLiteralExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation
    // 12.2.6.7 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // ObjectLiteral : { }
        // 1. Return ObjectCreate(%ObjectPrototype%).
        // ObjectLiteral : { PropertyDefinitionList } { PropertyDefinitionList , }
        // 1. Let obj be ObjectCreate(%ObjectPrototype%).
        const obj = $Object.ObjectCreate(ctx, 'Object', intrinsics['%ObjectPrototype%']);
        // 2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.
        for (const prop of this.$properties) {
            const $PropertyDefinitionEvaluationResult = prop.EvaluatePropertyDefinition(ctx, obj, intrinsics.true);
            if ($PropertyDefinitionEvaluationResult.isAbrupt) {
                return $PropertyDefinitionEvaluationResult.enrichWith(ctx, this);
            }
        }
        // 3. Return obj.
        return obj;
    }
}
class $PropertyAssignment {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.PropertyAssignment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        const $name = this.$name = $$propertyName(node.name, this, ctx | 512 /* IsMemberName */, -1);
        this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
        this.PropName = $name.PropName;
    }
    get $kind() { return typescript.SyntaxKind.PropertyAssignment; }
    // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation
    // 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
    EvaluatePropertyDefinition(ctx, object, enumerable) {
        ctx.checkTimeout();
        // PropertyDefinition :
        //     PropertyName : AssignmentExpression
        // 1. Let propKey be the result of evaluating PropertyName.
        const propKey = this.$name.EvaluatePropName(ctx);
        // 2. ReturnIfAbrupt(propKey).
        if (propKey.isAbrupt) {
            return propKey.enrichWith(ctx, this);
        }
        let propValue;
        // 3. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then
        if (this.$initializer instanceof $FunctionExpression && !this.$initializer.HasName) {
            // 3. a. Let propValue be the result of performing NamedEvaluation for AssignmentExpression with argument propKey.
            const $propValue = this.$initializer.EvaluateNamed(ctx, propKey);
            if ($propValue.isAbrupt) {
                return $propValue.enrichWith(ctx, this);
            }
            propValue = $propValue;
        }
        // 4. Else,
        else {
            // 4. a. Let exprValueRef be the result of evaluating AssignmentExpression.
            const exprValueRef = this.$initializer.Evaluate(ctx);
            // 4. b. Let propValue be ? GetValue(exprValueRef).
            const $propValue = exprValueRef.GetValue(ctx);
            if ($propValue.isAbrupt) {
                return $propValue.enrichWith(ctx, this);
            }
            propValue = $propValue;
        }
        // 5. Assert: enumerable is true.
        // 6. Assert: object is an ordinary, extensible object with no non-configurable properties.
        // 7. Return ! CreateDataPropertyOrThrow(object, propKey, propValue).
        return $CreateDataProperty(ctx, object, propKey, propValue);
    }
}
class $ShorthandPropertyAssignment {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ShorthandPropertyAssignment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        this.$objectAssignmentInitializer = $assignmentExpression(node.objectAssignmentInitializer, this, ctx, -1);
        this.PropName = $name.PropName;
    }
    get $kind() { return typescript.SyntaxKind.ShorthandPropertyAssignment; }
    // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation
    // 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
    EvaluatePropertyDefinition(ctx, object, enumerable) {
        ctx.checkTimeout();
        // PropertyDefinition :
        //     IdentifierReference
        // 1. Let propName be StringValue of IdentifierReference.
        const propName = this.$name.StringValue;
        // 2. Let exprValue be the result of evaluating IdentifierReference.
        const exprValue = this.$name.Evaluate(ctx);
        // 3. Let propValue be ? GetValue(exprValue).
        const propValue = exprValue.GetValue(ctx);
        if (propValue.isAbrupt) {
            return propValue.enrichWith(ctx, this);
        }
        // 4. Assert: enumerable is true.
        // 5. Assert: object is an ordinary, extensible object with no non-configurable properties.
        // 6. Return ! CreateDataPropertyOrThrow(object, propName, propValue).
        return $CreateDataProperty(ctx, object, propName, propValue);
    }
}
class $SpreadAssignment {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.SpreadAssignment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname
        // 12.2.6.5 Static Semantics: PropName
        this.PropName = empty;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.SpreadAssignment; }
    // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation
    // 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation
    EvaluatePropertyDefinition(ctx, object, enumerable) {
        ctx.checkTimeout();
        // PropertyDefinition :
        //     ... AssignmentExpression
        // 1. Let exprValue be the result of evaluating AssignmentExpression.
        const exprValue = this.$expression.Evaluate(ctx);
        // 2. Let fromValue be ? GetValue(exprValue).
        const fromValue = exprValue.GetValue(ctx);
        if (fromValue.isAbrupt) {
            return fromValue.enrichWith(ctx, this);
        }
        // 3. Let excludedNames be a new empty List.
        const excludedNames = [];
        // 4. Return ? CopyDataProperties(object, fromValue, excludedNames).
        return $CopyDataProperties(ctx, object, fromValue, excludedNames);
    }
}
class $PropertyAccessExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.PropertyAccessExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
        // @ts-ignore - TODO(fkleuver): update AOT to use new TS 3.8 ast
        this.$name = $identifier(node.name, this, ctx | 256 /* IsPropertyAccessName */, -1);
    }
    get $kind() { return typescript.SyntaxKind.PropertyAccessExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-property-accessors-runtime-semantics-evaluation
    // 12.3.2.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // MemberExpression : MemberExpression . IdentifierName
        // 1. Let baseReference be the result of evaluating MemberExpression.
        const baseReference = this.$expression.Evaluate(ctx);
        // 2. Let baseValue be ? GetValue(baseReference).
        const baseValue = baseReference.GetValue(ctx);
        if (baseValue.isAbrupt) {
            return baseValue.enrichWith(ctx, this);
        }
        // 3. baseValue bv be ? RequireObjectCoercible(baseValue).
        if (baseValue.isNil) {
            return new $TypeError(realm, `Cannot access property ${this.$name.StringValue['[[Value]]']} on value: ${baseValue['[[Value]]']}`).enrichWith(ctx, this);
        }
        // 4. Let propertyNameString be StringValue of IdentifierName.
        const propertyNameString = this.$name.StringValue;
        // 5. If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be false.
        const strict = intrinsics.true; // TODO: use static semantics
        // 6. Return a value of type Reference whose base value component is bv, whose referenced name component is propertyNameString, and whose strict reference flag is strict.
        return new $Reference(realm, baseValue, propertyNameString, strict, intrinsics.undefined);
    }
}
class $ElementAccessExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ElementAccessExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
        this.$argumentExpression = $assignmentExpression(node.argumentExpression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.ElementAccessExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-property-accessors-runtime-semantics-evaluation
    // 12.3.2.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // MemberExpression : MemberExpression [ Expression ]
        // 1. Let baseReference be the result of evaluating MemberExpression.
        const baseReference = this.$expression.Evaluate(ctx);
        // 2. Let baseValue be ? GetValue(baseReference).
        const baseValue = baseReference.GetValue(ctx);
        if (baseValue.isAbrupt) {
            return baseValue.enrichWith(ctx, this);
        }
        // 3. Let propertyNameReference be the result of evaluating Expression.
        const propertyNameReference = this.$argumentExpression.Evaluate(ctx);
        // 4. Let propertyNameValue be ? GetValue(propertyNameReference).
        const propertyNameValue = propertyNameReference.GetValue(ctx);
        if (propertyNameValue.isAbrupt) {
            return propertyNameValue.enrichWith(ctx, this);
        }
        // 5. Let bv be ? RequireObjectCoercible(baseValue).
        if (baseValue.isNil) {
            return new $TypeError(realm, `Cannot access computed / indexed property on value: ${baseValue['[[Value]]']}`).enrichWith(ctx, this);
        }
        // 6. Let propertyKey be ? ToPropertyKey(propertyNameValue).
        const propertyKey = propertyNameValue.ToPropertyKey(ctx);
        if (propertyKey.isAbrupt) {
            return propertyKey.enrichWith(ctx, this);
        }
        // 7. If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be false.
        const strict = intrinsics.true; // TODO: use static semantics
        // 8. Return a value of type Reference whose base value component is bv, whose referenced name component is propertyKey, and whose strict reference flag is strict.
        return new $Reference(realm, baseValue, propertyKey, strict, intrinsics.undefined);
    }
}
class $CallExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.CallExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
        this.$arguments = $argumentOrArrayLiteralElementList(node.arguments, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.CallExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-function-calls-runtime-semantics-evaluation
    // 12.3.4.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // CallExpression : CoverCallExpressionAndAsyncArrowHead
        // 1. Let expr be CoveredCallExpression of CoverCallExpressionAndAsyncArrowHead.
        // 2. Let memberExpr be the MemberExpression of expr.
        const memberExpr = this.$expression;
        // 3. Let arguments be the Arguments of expr.
        const $arguments = this.$arguments;
        // 4. Let ref be the result of evaluating memberExpr.
        const ref = memberExpr.Evaluate(ctx);
        // 5. Let func be ? GetValue(ref).
        const func = ref.GetValue(ctx);
        if (func.isAbrupt) {
            return func.enrichWith(ctx, this);
        }
        // 6. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is "eval", then
        if (ref instanceof $Reference && ref.IsPropertyReference().isFalsey && ref.GetReferencedName()['[[Value]]'] === 'eval') {
            // 6. a. If SameValue(func, %eval%) is true, then
            if (func.is(intrinsics['%eval%'])) ;
        }
        // 8. Let tailCall be IsInTailPosition(thisCall).
        // TODO
        // 9. Return ? EvaluateCall(func, ref, arguments, tailCall).
        return $EvaluateCall(ctx, func, ref, $arguments, intrinsics.false).enrichWith(ctx, this);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-evaluatecall
function $EvaluateCall(ctx, func, ref, $arguments, tailPosition) {
    ctx.checkTimeout();
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    let thisValue;
    // 1. If Type(ref) is Reference, then
    if (ref instanceof $Reference) {
        // 1. a. If IsPropertyReference(ref) is true, then
        if (ref.IsPropertyReference().isTruthy) {
            // 1. a. i. Let thisValue be GetThisValue(ref).
            thisValue = ref.GetThisValue();
        }
        // 1. b. Else the base of ref is an Environment Record,
        else {
            // 1. b. i. Let refEnv be GetBase(ref).
            const refEnv = ref.GetBase();
            // 1. b. ii. Let thisValue be refEnv.WithBaseObject().
            thisValue = refEnv.WithBaseObject(ctx);
        }
    }
    // 2. Else Type(ref) is not Reference,
    else {
        // 2. a. Let thisValue be undefined.
        thisValue = intrinsics.undefined;
    }
    // 3. Let argList be ArgumentListEvaluation of arguments.
    const argList = $ArgumentListEvaluation(ctx, $arguments);
    // 4. ReturnIfAbrupt(argList).
    if (argList.isAbrupt) {
        return argList;
    }
    // 5. If Type(func) is not Object, throw a TypeError exception.
    // 6. If IsCallable(func) is false, throw a TypeError exception.
    if (!func.isFunction) {
        return new $TypeError(realm, `${func} is not callable`);
    }
    // 7. If tailPosition is true, perform PrepareForTailCall().
    // TODO
    // 8. Let result be Call(func, thisValue, argList).
    const result = $Call(ctx, func, thisValue, argList);
    // 9. Assert: If tailPosition is true, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.
    // 10. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.
    // 11. Return result.
    return result;
}
// http://www.ecma-international.org/ecma-262/#sec-argument-lists-runtime-semantics-argumentlistevaluation
function $ArgumentListEvaluation(ctx, args) {
    ctx.checkTimeout();
    // Arguments : ( )
    // 1. Return a new empty List.
    // ArgumentList : AssignmentExpression
    // 1. Let ref be the result of evaluating AssignmentExpression.
    // 2. Let arg be ? GetValue(ref).
    // 3. Return a List whose sole item is arg.
    // ArgumentList : ... AssignmentExpression // TODO
    // 1. Let list be a new empty List.
    // 2. Let spreadRef be the result of evaluating AssignmentExpression.
    // 3. Let spreadObj be ? GetValue(spreadRef).
    // 4. Let iteratorRecord be ? GetIterator(spreadObj).
    // 5. Repeat,
    // 5. a. Let next be ? IteratorStep(iteratorRecord).
    // 5. b. If next is false, return list.
    // 5. c. Let nextArg be ? IteratorValue(next).
    // 5. d. Append nextArg as the last element of list.
    // ArgumentList : ArgumentList , AssignmentExpression
    // 1. Let precedingArgs be ArgumentListEvaluation of ArgumentList.
    // 2. ReturnIfAbrupt(precedingArgs).
    // 3. Let ref be the result of evaluating AssignmentExpression.
    // 4. Let arg be ? GetValue(ref).
    // 5. Append arg to the end of precedingArgs.
    // 6. Return precedingArgs.
    const list = new $List();
    for (const arg of args) {
        const ref = arg.Evaluate(ctx);
        if (ref.isAbrupt) {
            return ref;
        }
        const value = ref.GetValue(ctx);
        if (value.isAbrupt) {
            return value;
        }
        if (value.isList) {
            list.push(...value);
        }
        else {
            list.push(value);
        }
    }
    return list;
    // ArgumentList : ArgumentList , ... AssignmentExpression // TODO
    // 1. Let precedingArgs be ArgumentListEvaluation of ArgumentList.
    // 2. ReturnIfAbrupt(precedingArgs).
    // 3. Let spreadRef be the result of evaluating AssignmentExpression.
    // 4. Let iteratorRecord be ? GetIterator(? GetValue(spreadRef)).
    // 5. Repeat,
    // 5. a. Let next be ? IteratorStep(iteratorRecord).
    // 5. b. If next is false, return precedingArgs.
    // 5. c. Let nextArg be ? IteratorValue(next).
    // 5. d. Append nextArg as the last element of precedingArgs.
}
class $NewExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.NewExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
        this.$arguments = $argumentOrArrayLiteralElementList(node.arguments, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.NewExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-new-operator-runtime-semantics-evaluation
    // 12.3.3.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // NewExpression : new NewExpression
        // 1. Return ? EvaluateNew(NewExpression, empty).
        // MemberExpression : new MemberExpression Arguments
        // 1. Return ? EvaluateNew(MemberExpression, Arguments).
        // http://www.ecma-international.org/ecma-262/#sec-evaluatenew
        // 12.3.3.1.1 Runtime Semantics: EvaluateNew ( constructExpr , arguments )
        // 1. Assert: constructExpr is either a NewExpression or a MemberExpression.
        // 2. Assert: arguments is either empty or an Arguments.
        // 3. Let ref be the result of evaluating constructExpr.
        const ref = this.$expression.Evaluate(ctx);
        // 4. Let constructor be ? GetValue(ref).
        const constructor = ref.GetValue(ctx);
        if (constructor.isAbrupt) {
            return constructor.enrichWith(ctx, this);
        }
        const $arguments = this.$arguments;
        let argList;
        // 5. If arguments is empty, let argList be a new empty List.
        if ($arguments.length === 0) {
            argList = new $List();
        }
        // 6. Else,
        else {
            // 6. a. Let argList be ArgumentListEvaluation of arguments.
            const $argList = $ArgumentListEvaluation(ctx, $arguments);
            // 6. b. ReturnIfAbrupt(argList).
            if ($argList.isAbrupt) {
                return $argList.enrichWith(ctx, this);
            }
            argList = $argList;
        }
        // 7. If IsConstructor(constructor) is false, throw a TypeError exception.
        if (!IsConstructor(ctx, constructor)) {
            return new $TypeError(realm, `${constructor} is not a constructor`);
        }
        // 8. Return ? Construct(constructor, argList).
        return $Construct(ctx, constructor, argList, intrinsics.undefined).enrichWith(ctx, this);
    }
}
class $TaggedTemplateExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TaggedTemplateExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$tag = $LHSExpression(node.tag, this, ctx, -1);
        if (node.template.kind === typescript.SyntaxKind.NoSubstitutionTemplateLiteral) {
            this.$template = new $NoSubstitutionTemplateLiteral(node.template, this, ctx, -1);
        }
        else {
            this.$template = new $TemplateExpression(node.template, this, ctx, -1);
        }
    }
    get $kind() { return typescript.SyntaxKind.TaggedTemplateExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-tagged-templates-runtime-semantics-evaluation
    // 12.3.7.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // MemberExpression : MemberExpression TemplateLiteral
        // 1. Let tagRef be the result of evaluating MemberExpression.
        // 2. Let tagFunc be ? GetValue(tagRef).
        // 3. Let thisCall be this MemberExpression.
        // 4. Let tailCall be IsInTailPosition(thisCall).
        // 5. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).
        // CallExpression : CallExpression TemplateLiteral
        // 1. Let tagRef be the result of evaluating CallExpression.
        // 2. Let tagFunc be ? GetValue(tagRef).
        // 3. Let thisCall be this CallExpression.
        // 4. Let tailCall be IsInTailPosition(thisCall).
        // 5. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).
        return intrinsics.undefined; // TODO: implement this
    }
}
function $$templateSpanList(nodes, parent, ctx) {
    if (nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $TemplateSpan(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
class $TemplateExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TemplateExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype
        // 12.2.1.5 Static Semantics: AssignmentTargetType
        this.AssignmentTargetType = 'invalid';
        this.$head = new $TemplateHead(node.head, this, ctx);
        this.$templateSpans = $$templateSpanList(node.templateSpans, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.TemplateExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation
    // 12.2.9.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // SubstitutionTemplate : TemplateHead Expression TemplateSpans
        // 1. Let head be the TV of TemplateHead as defined in 11.8.6.
        // 2. Let subRef be the result of evaluating Expression.
        // 3. Let sub be ? GetValue(subRef).
        // 4. Let middle be ? ToString(sub).
        // 5. Let tail be the result of evaluating TemplateSpans.
        // 6. ReturnIfAbrupt(tail).
        // 7. Return the string-concatenation of head, middle, and tail.
        // TemplateSpans : TemplateTail
        // 1. Let tail be the TV of TemplateTail as defined in 11.8.6.
        // 2. Return the String value consisting of the code units of tail.
        // TemplateSpans : TemplateMiddleList TemplateTail
        // 1. Let head be the result of evaluating TemplateMiddleList.
        // 2. ReturnIfAbrupt(head).
        // 3. Let tail be the TV of TemplateTail as defined in 11.8.6.
        // 4. Return the string-concatenation of head and tail.
        // TemplateMiddleList : TemplateMiddle Expression
        // 1. Let head be the TV of TemplateMiddle as defined in 11.8.6.
        // 2. Let subRef be the result of evaluating Expression.
        // 3. Let sub be ? GetValue(subRef).
        // 4. Let middle be ? ToString(sub).
        // 5. Return the sequence of code units consisting of the code units of head followed by the elements of middle.
        // TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression
        // 1. Let rest be the result of evaluating TemplateMiddleList.
        // 2. ReturnIfAbrupt(rest).
        // 3. Let middle be the TV of TemplateMiddle as defined in 11.8.6.
        // 4. Let subRef be the result of evaluating Expression.
        // 5. Let sub be ? GetValue(subRef).
        // 6. Let last be ? ToString(sub).
        // 7. Return the sequence of code units consisting of the elements of rest followed by the code units of middle followed by the elements of last.
        return intrinsics['']; // TODO: implement this
    }
}
class $ParenthesizedExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ParenthesizedExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        const $expression = this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
        this.CoveredParenthesizedExpression = $expression;
    }
    get $kind() { return typescript.SyntaxKind.ParenthesizedExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-grouping-operator-runtime-semantics-evaluation
    // 12.2.10.5 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList
        // 1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.
        // 2. Return the result of evaluating expr.
        // ParenthesizedExpression : ( Expression )
        // 1. Return the result of evaluating Expression. This may be of type Reference.
        return this.$expression.Evaluate(ctx).enrichWith(ctx, this);
    }
}
class $NonNullExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.NonNullExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $LHSExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.NonNullExpression; }
    // This is a TS expression that wraps an ordinary expression. Just return the evaluate result.
    Evaluate(ctx) {
        ctx.checkTimeout();
        return this.$expression.Evaluate(ctx).enrichWith(ctx, this);
    }
}
class $MetaProperty {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.MetaProperty`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$name = $identifier(node.name, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.MetaProperty; }
    // http://www.ecma-international.org/ecma-262/#sec-meta-properties-runtime-semantics-evaluation
    // 12.3.8.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // NewTarget : new . target
        // 1. Return GetNewTarget().
        return intrinsics.undefined; // TODO: implement this
    }
}
// #endregion
// #region Unary
class $DeleteExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.DeleteExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $unaryExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.DeleteExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-delete-operator-runtime-semantics-evaluation
    // 12.5.3.2 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // 1. Let ref be the result of evaluating UnaryExpression.
        // 2. ReturnIfAbrupt(ref).
        // 3. If Type(ref) is not Reference, return true.
        // 4. If IsUnresolvableReference(ref) is true, then
        // 4. a. Assert: IsStrictReference(ref) is false.
        // 4. b. Return true.
        // 5. If IsPropertyReference(ref) is true, then
        // 5. a. If IsSuperReference(ref) is true, throw a ReferenceError exception.
        // 5. b. Let baseObj be ! ToObject(GetBase(ref)).
        // 5. c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).
        // 5. d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.
        // 5. e. Return deleteStatus.
        // 6. Else ref is a Reference to an Environment Record binding,
        // 6. a. Let bindings be GetBase(ref).
        // 6. b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).
        return intrinsics.true; // TODO: implement this
    }
}
class $TypeOfExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TypeOfExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $unaryExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.TypeOfExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-typeof-operator-runtime-semantics-evaluation
    // 12.5.5.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // UnaryExpression : typeof UnaryExpression
        // 1. Let val be the result of evaluating UnaryExpression.
        let val = this.$expression.Evaluate(ctx);
        // 2. If Type(val) is Reference, then
        // 2. a. If IsUnresolvableReference(val) is true, return "undefined".
        if (val instanceof $Reference && val.IsUnresolvableReference()['[[Value]]']) {
            return new $Undefined(realm);
        }
        // 3. Set val to ? GetValue(val).
        val = val.GetValue(ctx);
        if (val.isAbrupt) {
            return val.enrichWith(ctx, this);
        }
        // 4. Return a String according to Table 35.
        // Table 35: typeof Operator Results
        switch (true) {
            // Type of val   Result
            // Undefined   	"undefined"
            case val instanceof $Undefined:
                return new $String(realm, "undefined");
            // Boolean   	  "boolean"
            case val instanceof $Boolean:
                return new $String(realm, "boolean");
            // Number    	  "number"
            case val instanceof $Number:
                return new $String(realm, "number");
            // String    	  "string"
            case val instanceof $String:
                return new $String(realm, "string");
            // Symbol    	  "symbol"
            // case val instanceof $Symbol:
            //   return new $String(realm, "symbol");
            // Object        (implements [[Call]])	"function"
            case val instanceof $Function:
                return new $String(realm, "function");
            // Object        (ordinary and does not implement [[Call]])	"object"
            // Object        (standard exotic and does not implement [[Call]])	"object"
            // Object        (non-standard exotic and does not implement [[Call]])	Implementation-defined. Must not be "undefined", "boolean", "function", "number", "symbol", or "string".
            case val instanceof $Object:
            // Null    	    "object"
            case val instanceof $Null:
            default:
                return new $String(realm, "object");
        }
    }
}
class $VoidExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.VoidExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $unaryExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.VoidExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-void-operator
    // 12.5.4 The void Operator
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // UnaryExpression : void UnaryExpression
        // 1. Let expr be the result of evaluating UnaryExpression.
        const expr = this.$expression.Evaluate(ctx);
        // 2. Perform ? GetValue(expr).
        const value = expr.GetValue(ctx);
        if (value.isAbrupt) {
            return value.enrichWith(ctx, this);
        }
        // 3. Return undefined.
        return intrinsics.undefined;
    }
}
class $AwaitExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.AwaitExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $unaryExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.AwaitExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-runtime-semantics-evaluation
    // 14.7.14 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // AwaitExpression : await UnaryExpression
        // 1. Let exprRef be the result of evaluating UnaryExpression.
        // 2. Let value be ? GetValue(exprRef).
        // 3. Return ? Await(value).
        return intrinsics.undefined; // TODO: implement this
    }
}
class $PrefixUnaryExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.PrefixUnaryExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$operand = $unaryExpression(node.operand, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.PrefixUnaryExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-prefix-increment-operator-runtime-semantics-evaluation
    // 12.4.6.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-prefix-decrement-operator-runtime-semantics-evaluation
    // 12.4.7.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-unary-plus-operator-runtime-semantics-evaluation
    // 12.5.6.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-unary-minus-operator-runtime-semantics-evaluation
    // 12.5.7.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        switch (this.node.operator) {
            case typescript.SyntaxKind.PlusPlusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-prefix-increment-operator-runtime-semantics-evaluation
                // 12.4.6.1 Runtime Semantics: Evaluation
                // UpdateExpression : ++ UnaryExpression
                // 1. Let expr be the result of evaluating UnaryExpression.
                const expr = this.$operand.Evaluate(ctx);
                if (expr.isAbrupt) {
                    return expr.enrichWith(ctx, this);
                }
                // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
                const $oldValue = expr.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToNumber(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).
                const newValue = new $Number(realm, oldValue['[[Value]]'] + 1);
                // 4. Perform ? PutValue(expr, newValue).
                if (!(expr instanceof $Reference)) {
                    return new $ReferenceError(realm, `Value is not assignable: ${expr}`).enrichWith(ctx, this);
                }
                const $PutValueResult = expr.PutValue(ctx, newValue);
                if ($PutValueResult.isAbrupt) {
                    return $PutValueResult.enrichWith(ctx, this);
                }
                // 5. Return newValue.
                return newValue;
            }
            case typescript.SyntaxKind.MinusMinusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-prefix-decrement-operator-runtime-semantics-evaluation
                // 12.4.7.1 Runtime Semantics: Evaluation
                // UpdateExpression : -- UnaryExpression
                // 1. Let expr be the result of evaluating UnaryExpression.
                const expr = this.$operand.Evaluate(ctx);
                if (expr.isAbrupt) {
                    return expr.enrichWith(ctx, this);
                }
                // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
                const $oldValue = expr.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToNumber(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).
                const newValue = new $Number(realm, oldValue['[[Value]]'] - 1);
                // 4. Perform ? PutValue(expr, newValue).
                if (!(expr instanceof $Reference)) {
                    return new $ReferenceError(realm, `Value is not assignable: ${expr}`).enrichWith(ctx, this);
                }
                const $PutValueResult = expr.PutValue(ctx, newValue);
                if ($PutValueResult.isAbrupt) {
                    return $PutValueResult.enrichWith(ctx, this);
                }
                // 5. Return newValue.
                return newValue;
            }
            case typescript.SyntaxKind.PlusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-unary-plus-operator-runtime-semantics-evaluation
                // 12.5.6.1 Runtime Semantics: Evaluation
                // UnaryExpression : + UnaryExpression
                // 1. Let expr be the result of evaluating UnaryExpression.
                const expr = this.$operand.Evaluate(ctx);
                if (expr.isAbrupt) {
                    return expr.enrichWith(ctx, this);
                }
                // 2. Return ? ToNumber(? GetValue(expr)).
                const $value = expr.GetValue(ctx);
                if ($value.isAbrupt) {
                    return $value.enrichWith(ctx, this);
                }
                const value = $value.ToNumber(ctx);
                if (value.isAbrupt) {
                    return value.enrichWith(ctx, this);
                }
                return value;
            }
            case typescript.SyntaxKind.MinusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-unary-minus-operator-runtime-semantics-evaluation
                // 12.5.7.1 Runtime Semantics: Evaluation
                // UnaryExpression : - UnaryExpression
                // 1. Let expr be the result of evaluating UnaryExpression.
                const expr = this.$operand.Evaluate(ctx);
                if (expr.isAbrupt) {
                    return expr.enrichWith(ctx, this);
                }
                // 2. Let oldValue be ? ToNumber(? GetValue(expr)).
                const $oldValue = expr.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToNumber(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. If oldValue is NaN, return NaN.
                if (oldValue.isNaN) {
                    return oldValue;
                }
                // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.
                return new $Number(realm, -oldValue['[[Value]]']);
            }
            case typescript.SyntaxKind.TildeToken: {
                // http://www.ecma-international.org/ecma-262/#sec-bitwise-not-operator-runtime-semantics-evaluation
                // 12.5.8.1 Runtime Semantics: Evaluation
                // UnaryExpression : ~ UnaryExpression
                // 1. Let expr be the result of evaluating UnaryExpression.
                const expr = this.$operand.Evaluate(ctx);
                if (expr.isAbrupt) {
                    return expr.enrichWith(ctx, this);
                }
                // 2. Let oldValue be ? ToInt32(? GetValue(expr)).
                const $oldValue = expr.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToInt32(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.
                return new $Number(realm, ~oldValue['[[Value]]']);
            }
            case typescript.SyntaxKind.ExclamationToken: {
                // http://www.ecma-international.org/ecma-262/#sec-logical-not-operator-runtime-semantics-evaluation
                // 12.5.9.1 Runtime Semantics: Evaluation
                // UnaryExpression : ! UnaryExpression
                // 1. Let expr be the result of evaluating UnaryExpression.
                const expr = this.$operand.Evaluate(ctx);
                if (expr.isAbrupt) {
                    return expr.enrichWith(ctx, this);
                }
                // 2. Let oldValue be ToBoolean(? GetValue(expr)).
                const $oldValue = expr.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToBoolean(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. If oldValue is true, return false.
                if (oldValue.isTruthy) {
                    return intrinsics.false;
                }
                // 4. Return true.
                return intrinsics.true;
            }
        }
    }
}
class $PostfixUnaryExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.PostfixUnaryExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$operand = $LHSExpression(node.operand, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.PostfixUnaryExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-postfix-increment-operator-runtime-semantics-evaluation
    // 12.4.4.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-postfix-decrement-operator-runtime-semantics-evaluation
    // 12.4.5.1 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        switch (this.node.operator) {
            case typescript.SyntaxKind.PlusPlusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-postfix-increment-operator-runtime-semantics-evaluation
                // 12.4.4.1 Runtime Semantics: Evaluation
                // UpdateExpression : LeftHandSideExpression ++
                // 1. Let lhs be the result of evaluating LeftHandSideExpression.
                const lhs = this.$operand.Evaluate(ctx);
                // 2. Let oldValue be ? ToNumber(? GetValue(lhs)).
                const $oldValue = lhs.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToNumber(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).
                const newValue = new $Number(realm, oldValue['[[Value]]'] + 1);
                // 4. Perform ? PutValue(lhs, newValue).
                if (!(lhs instanceof $Reference)) {
                    return new $ReferenceError(realm, `Value is not assignable: ${lhs}`).enrichWith(ctx, this);
                }
                const $PutValueResult = lhs.PutValue(ctx, newValue);
                if ($PutValueResult.isAbrupt) {
                    return $PutValueResult.enrichWith(ctx, this);
                }
                // 5. Return oldValue.
                return oldValue;
            }
            case typescript.SyntaxKind.MinusMinusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-postfix-decrement-operator-runtime-semantics-evaluation
                // 12.4.5.1 Runtime Semantics: Evaluation
                // UpdateExpression : LeftHandSideExpression --
                // 1. Let lhs be the result of evaluating LeftHandSideExpression.
                const lhs = this.$operand.Evaluate(ctx);
                // 2. Let oldValue be ? ToNumber(? GetValue(lhs)).
                const $oldValue = lhs.GetValue(ctx);
                if ($oldValue.isAbrupt) {
                    return $oldValue.enrichWith(ctx, this);
                }
                const oldValue = $oldValue.ToNumber(ctx);
                if (oldValue.isAbrupt) {
                    return oldValue.enrichWith(ctx, this);
                }
                // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).
                const newValue = new $Number(realm, oldValue['[[Value]]'] - 1);
                // 4. Perform ? PutValue(lhs, newValue).
                if (!(lhs instanceof $Reference)) {
                    return new $ReferenceError(realm, `Value is not assignable: ${lhs}`).enrichWith(ctx, this);
                }
                const $PutValueResult = lhs.PutValue(ctx, newValue);
                if ($PutValueResult.isAbrupt) {
                    return $PutValueResult.enrichWith(ctx, this);
                }
                // 5. Return oldValue.
                return oldValue;
            }
        }
    }
}
class $TypeAssertion {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.TypeAssertion`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.TypeAssertionExpression; }
    // This is a TS expression that wraps an ordinary expression. Just return the evaluate result.
    Evaluate(ctx) {
        ctx.checkTimeout();
        return this.$expression.Evaluate(ctx);
    }
}
// #endregion
// #region Assignment
class $BinaryExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.BinaryExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$left = $assignmentExpression(node.left, this, ctx, -1);
        this.$right = $assignmentExpression(node.right, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.BinaryExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-exp-operator-runtime-semantics-evaluation
    // 12.6.3 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation
    // 12.7.3 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-addition-operator-plus-runtime-semantics-evaluation
    // 12.8.3.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-subtraction-operator-minus-runtime-semantics-evaluation
    // 12.8.4.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-signed-right-shift-operator-runtime-semantics-evaluation
    // 12.9.4.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-unsigned-right-shift-operator-runtime-semantics-evaluation
    // 12.9.5.1 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-relational-operators-runtime-semantics-evaluation
    // 12.10.3 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-equality-operators-runtime-semantics-evaluation
    // 12.11.3 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation
    // 12.12.3 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-binary-logical-operators-runtime-semantics-evaluation
    // 12.13.3 Runtime Semantics: Evaluation
    // http://www.ecma-international.org/ecma-262/#sec-assignment-operators-runtime-semantics-evaluation
    // 12.15.4 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        switch (this.node.operatorToken.kind) {
            case typescript.SyntaxKind.AsteriskAsteriskToken: {
                // http://www.ecma-international.org/ecma-262/#sec-exp-operator-runtime-semantics-evaluation
                // 12.6.3 Runtime Semantics: Evaluation
                // ExponentiationExpression : UpdateExpression ** ExponentiationExpression
                // 1. Let left be the result of evaluating UpdateExpression.
                const left = this.$left.Evaluate(ctx);
                // 2. Let leftValue be ? GetValue(left).
                const leftValue = left.GetValue(ctx);
                if (leftValue.isAbrupt) {
                    return leftValue.enrichWith(ctx, this);
                }
                // 3. Let right be the result of evaluating ExponentiationExpression.
                const right = this.$right.Evaluate(ctx);
                // 4. Let rightValue be ? GetValue(right).
                const rightValue = right.GetValue(ctx);
                if (rightValue.isAbrupt) {
                    return rightValue.enrichWith(ctx, this);
                }
                // 5. Let base be ? ToNumber(leftValue).
                const base = leftValue.ToNumber(ctx);
                if (base.isAbrupt) {
                    return base.enrichWith(ctx, this);
                }
                // 6. Let exponent be ? ToNumber(rightValue).
                const exponent = rightValue.ToNumber(ctx);
                if (exponent.isAbrupt) {
                    return exponent.enrichWith(ctx, this);
                }
                // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.6.4.
                return new $Number(realm, base['[[Value]]'] ** exponent['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.AsteriskToken: {
                // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation
                // 12.7.3 Runtime Semantics: Evaluation
                // MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
                // 1. Let left be the result of evaluating MultiplicativeExpression.
                const left = this.$left.Evaluate(ctx);
                // 2. Let leftValue be ? GetValue(left).
                const leftValue = left.GetValue(ctx);
                if (leftValue.isAbrupt) {
                    return leftValue.enrichWith(ctx, this);
                }
                // 3. Let right be the result of evaluating ExponentiationExpression.
                const right = this.$right.Evaluate(ctx);
                // 4. Let rightValue be ? GetValue(right).
                const rightValue = right.GetValue(ctx);
                if (rightValue.isAbrupt) {
                    return rightValue.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToNumber(leftValue).
                const lnum = leftValue.ToNumber(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToNumber(rightValue).
                const rnum = rightValue.ToNumber(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
                return new $Number(realm, lnum['[[Value]]'] * rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.SlashToken: {
                // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation
                // 12.7.3 Runtime Semantics: Evaluation
                // MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
                // 1. Let left be the result of evaluating MultiplicativeExpression.
                const left = this.$left.Evaluate(ctx);
                // 2. Let leftValue be ? GetValue(left).
                const leftValue = left.GetValue(ctx);
                if (leftValue.isAbrupt) {
                    return leftValue.enrichWith(ctx, this);
                }
                // 3. Let right be the result of evaluating ExponentiationExpression.
                const right = this.$right.Evaluate(ctx);
                // 4. Let rightValue be ? GetValue(right).
                const rightValue = right.GetValue(ctx);
                if (rightValue.isAbrupt) {
                    return rightValue.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToNumber(leftValue).
                const lnum = leftValue.ToNumber(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToNumber(rightValue).
                const rnum = rightValue.ToNumber(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
                return new $Number(realm, lnum['[[Value]]'] / rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.PercentToken: {
                // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation
                // 12.7.3 Runtime Semantics: Evaluation
                // MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
                // 1. Let left be the result of evaluating MultiplicativeExpression.
                const left = this.$left.Evaluate(ctx);
                // 2. Let leftValue be ? GetValue(left).
                const leftValue = left.GetValue(ctx);
                if (leftValue.isAbrupt) {
                    return leftValue.enrichWith(ctx, this);
                }
                // 3. Let right be the result of evaluating ExponentiationExpression.
                const right = this.$right.Evaluate(ctx);
                // 4. Let rightValue be ? GetValue(right).
                const rightValue = right.GetValue(ctx);
                if (rightValue.isAbrupt) {
                    return rightValue.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToNumber(leftValue).
                const lnum = leftValue.ToNumber(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToNumber(rightValue).
                const rnum = rightValue.ToNumber(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
                return new $Number(realm, lnum['[[Value]]'] % rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.PlusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-addition-operator-plus-runtime-semantics-evaluation
                // 12.8.3.1 Runtime Semantics: Evaluation
                // AdditiveExpression : AdditiveExpression + MultiplicativeExpression
                // 1. Let lref be the result of evaluating AdditiveExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating MultiplicativeExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lprim be ? ToPrimitive(lval).
                const lprim = lval.ToPrimitive(ctx);
                if (lprim.isAbrupt) {
                    return lprim.enrichWith(ctx, this);
                }
                // 6. Let rprim be ? ToPrimitive(rval).
                const rprim = rval.ToPrimitive(ctx);
                if (rprim.isAbrupt) {
                    return rprim.enrichWith(ctx, this);
                }
                // 7. If Type(lprim) is String or Type(rprim) is String, then
                if (lprim.isString || rprim.isString) {
                    // 7. a. Let lstr be ? ToString(lprim).
                    const lstr = lprim.ToString(ctx);
                    if (lstr.isAbrupt) {
                        return lstr.enrichWith(ctx, this);
                    }
                    // 7. b. Let rstr be ? ToString(rprim).
                    const rstr = rprim.ToString(ctx);
                    if (rstr.isAbrupt) {
                        return rstr.enrichWith(ctx, this);
                    }
                    // 7. c. Return the string-concatenation of lstr and rstr.
                    return new $String(realm, lstr['[[Value]]'] + rstr['[[Value]]']); // TODO: add temporal state snapshot for tracing
                }
                // 8. Let lnum be ? ToNumber(lprim).
                const lnum = lprim.ToNumber(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 9. Let rnum be ? ToNumber(rprim).
                const rnum = rprim.ToNumber(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 10. Return the result of applying the addition operation to lnum and rnum. See the Note below 12.8.5.
                return new $Number(realm, lnum['[[Value]]'] + rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.MinusToken: {
                // http://www.ecma-international.org/ecma-262/#sec-subtraction-operator-minus-runtime-semantics-evaluation
                // 12.8.4.1 Runtime Semantics: Evaluation
                // AdditiveExpression : AdditiveExpression - MultiplicativeExpression
                // 1. Let lref be the result of evaluating AdditiveExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating MultiplicativeExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToNumber(lval).
                const lnum = lval.ToNumber(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToNumber(rval).
                const rnum = rval.ToNumber(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the subtraction operation to lnum and rnum. See the note below 12.8.5.
                return new $Number(realm, lnum['[[Value]]'] - rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.LessThanLessThanToken: {
                // http://www.ecma-international.org/ecma-262/#sec-left-shift-operator-runtime-semantics-evaluation
                // 12.9.3.1 Runtime Semantics: Evaluation
                // ShiftExpression : ShiftExpression << AdditiveExpression
                // 1. Let lref be the result of evaluating ShiftExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating AdditiveExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToInt32(lval).
                const lnum = lval.ToInt32(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToUint32(rval).
                const rnum = rval.ToUint32(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
                const shiftCount = rnum['[[Value]]'] & 0b11111;
                // 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.
                return new $Number(realm, lnum['[[Value]]'] << shiftCount); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.GreaterThanGreaterThanToken: {
                // http://www.ecma-international.org/ecma-262/#sec-signed-right-shift-operator-runtime-semantics-evaluation
                // 12.9.4.1 Runtime Semantics: Evaluation
                // ShiftExpression : ShiftExpression >> AdditiveExpression
                // 1. Let lref be the result of evaluating ShiftExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating AdditiveExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToInt32(lval).
                const lnum = lval.ToInt32(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToUint32(rval).
                const rnum = rval.ToUint32(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
                const shiftCount = rnum['[[Value]]'] & 0b11111;
                // 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.
                return new $Number(realm, lnum['[[Value]]'] >> shiftCount); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken: {
                // http://www.ecma-international.org/ecma-262/#sec-unsigned-right-shift-operator-runtime-semantics-evaluation
                // 12.9.5.1 Runtime Semantics: Evaluation
                // ShiftExpression : ShiftExpression >>> AdditiveExpression
                // 1. Let lref be the result of evaluating ShiftExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating AdditiveExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToUint32(lval).
                const lnum = lval.ToUint32(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToUint32(rval).
                const rnum = rval.ToUint32(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
                const shiftCount = rnum['[[Value]]'] & 0b11111;
                // 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.
                return new $Number(realm, lnum['[[Value]]'] >>> shiftCount); // TODO: add temporal state snapshot for tracing
            }
            // http://www.ecma-international.org/ecma-262/#sec-relational-operators-runtime-semantics-evaluation
            // 12.10.3 Runtime Semantics: Evaluation
            case typescript.SyntaxKind.LessThanToken: {
                // RelationalExpression : RelationalExpression < ShiftExpression
                // 1. Let lref be the result of evaluating RelationalExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating ShiftExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let r be the result of performing Abstract Relational Comparison lval < rval.
                const r = $AbstractRelationalComparison(ctx, true, lval, rval);
                // 6. ReturnIfAbrupt(r).
                if (r.isAbrupt) {
                    return r.enrichWith(ctx, this);
                }
                // 7. If r is undefined, return false. Otherwise, return r.
                return r.isUndefined ? intrinsics.false : r;
            }
            case typescript.SyntaxKind.GreaterThanToken: {
                // RelationalExpression : RelationalExpression > ShiftExpression
                // 1. Let lref be the result of evaluating RelationalExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating ShiftExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.
                const r = $AbstractRelationalComparison(ctx, false, rval, lval);
                // 6. ReturnIfAbrupt(r).
                if (r.isAbrupt) {
                    return r.enrichWith(ctx, this);
                }
                // 7. If r is undefined, return false. Otherwise, return r.
                return r.isUndefined ? intrinsics.false : r;
            }
            case typescript.SyntaxKind.LessThanEqualsToken: {
                // RelationalExpression : RelationalExpression <= ShiftExpression
                // 1. Let lref be the result of evaluating RelationalExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating ShiftExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.
                const r = $AbstractRelationalComparison(ctx, false, rval, lval);
                // 6. ReturnIfAbrupt(r).
                if (r.isAbrupt) {
                    return r.enrichWith(ctx, this);
                }
                // 7. If r is true or undefined, return false. Otherwise, return true.
                return r.isTruthy || r.isUndefined ? intrinsics.false : intrinsics.true;
            }
            case typescript.SyntaxKind.GreaterThanEqualsToken: {
                // RelationalExpression : RelationalExpression >= ShiftExpression
                // 1. Let lref be the result of evaluating RelationalExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating ShiftExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let r be the result of performing Abstract Relational Comparison lval < rval.
                const r = $AbstractRelationalComparison(ctx, true, lval, rval);
                // 6. ReturnIfAbrupt(r).
                if (r.isAbrupt) {
                    return r.enrichWith(ctx, this);
                }
                // 7. If r is true or undefined, return false. Otherwise, return true.
                return r.isTruthy || r.isUndefined ? intrinsics.false : intrinsics.true;
            }
            case typescript.SyntaxKind.InstanceOfKeyword: {
                // RelationalExpression : RelationalExpression instanceof ShiftExpression
                // 1. Let lref be the result of evaluating RelationalExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating ShiftExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Return ? InstanceofOperator(lval, rval).
                return $InstanceOfOperator(ctx, lval, rval).enrichWith(ctx, this);
            }
            case typescript.SyntaxKind.InKeyword: {
                // RelationalExpression : RelationalExpression in ShiftExpression
                // 1. Let lref be the result of evaluating RelationalExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating ShiftExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. If Type(rval) is not Object, throw a TypeError exception.
                if (!rval.isObject) {
                    return new $TypeError(realm, `Right-hand side of 'in' keyword is not an object: ${rval}`);
                }
                // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).
                return rval['[[HasProperty]]'](ctx, lval.ToPropertyKey(ctx)).enrichWith(ctx, this); // TODO: is this cast safe?
            }
            // http://www.ecma-international.org/ecma-262/#sec-equality-operators-runtime-semantics-evaluation
            // 12.11.3 Runtime Semantics: Evaluation
            case typescript.SyntaxKind.EqualsEqualsToken: {
                // EqualityExpression : EqualityExpression == RelationalExpression
                // 1. Let lref be the result of evaluating EqualityExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating RelationalExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Return the result of performing Abstract Equality Comparison rval == lval.
                return $AbstractEqualityComparison(ctx, rval, lval).enrichWith(ctx, this);
            }
            case typescript.SyntaxKind.ExclamationEqualsToken: {
                // EqualityExpression : EqualityExpression != RelationalExpression
                // 1. Let lref be the result of evaluating EqualityExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating RelationalExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let r be the result of performing Abstract Equality Comparison rval == lval.
                const r = $AbstractEqualityComparison(ctx, rval, lval);
                if (r.isAbrupt) {
                    return r.enrichWith(ctx, this);
                } // TODO: is this correct? spec doesn't say it
                // 6. If r is true, return false. Otherwise, return true.
                return r.isTruthy ? intrinsics.false : intrinsics.true;
            }
            case typescript.SyntaxKind.EqualsEqualsEqualsToken: {
                // EqualityExpression : EqualityExpression === RelationalExpression
                // 1. Let lref be the result of evaluating EqualityExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating RelationalExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Return the result of performing Strict Equality Comparison rval === lval.
                return $StrictEqualityComparison(ctx, rval, lval).enrichWith(ctx, this);
            }
            case typescript.SyntaxKind.ExclamationEqualsEqualsToken: {
                // EqualityExpression : EqualityExpression !== RelationalExpression
                // 1. Let lref be the result of evaluating EqualityExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating RelationalExpression.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let r be the result of performing Strict Equality Comparison rval === lval.
                const r = $StrictEqualityComparison(ctx, rval, lval);
                if (r.isAbrupt) {
                    return r.enrichWith(ctx, this);
                } // TODO: is this correct? spec doesn't say it
                // 6. If r is true, return false. Otherwise, return true.
                return r.isTruthy ? intrinsics.false : intrinsics.true;
            }
            case typescript.SyntaxKind.AmpersandToken: {
                // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation
                // 12.12.3 Runtime Semantics: Evaluation
                // 1. Let lref be the result of evaluating A.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating B.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToInt32(lval).
                const lnum = lval.ToInt32(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToInt32(rval).
                const rnum = rval.ToInt32(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
                return new $Number(realm, lnum['[[Value]]'] & rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.CaretToken: {
                // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation
                // 12.12.3 Runtime Semantics: Evaluation
                // 1. Let lref be the result of evaluating A.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating B.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToInt32(lval).
                const lnum = lval.ToInt32(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToInt32(rval).
                const rnum = rval.ToInt32(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
                return new $Number(realm, lnum['[[Value]]'] ^ rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            case typescript.SyntaxKind.BarToken: {
                // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation
                // 12.12.3 Runtime Semantics: Evaluation
                // 1. Let lref be the result of evaluating A.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating B.
                const rref = this.$right.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let lnum be ? ToInt32(lval).
                const lnum = lval.ToInt32(ctx);
                if (lnum.isAbrupt) {
                    return lnum.enrichWith(ctx, this);
                }
                // 6. Let rnum be ? ToInt32(rval).
                const rnum = rval.ToInt32(ctx);
                if (rnum.isAbrupt) {
                    return rnum.enrichWith(ctx, this);
                }
                // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
                return new $Number(realm, lnum['[[Value]]'] | rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing
            }
            // http://www.ecma-international.org/ecma-262/#sec-binary-logical-operators-runtime-semantics-evaluation
            // 12.13.3 Runtime Semantics: Evaluation
            case typescript.SyntaxKind.AmpersandAmpersandToken: {
                // LogicalANDExpression : LogicalANDExpression && BitwiseORExpression
                // 1. Let lref be the result of evaluating LogicalANDExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let lbool be ToBoolean(lval).
                const lbool = lval.ToBoolean(ctx);
                if (lbool.isAbrupt) {
                    return lbool.enrichWith(ctx, this);
                } // TODO: is this correct? spec doesn't say it
                // 4. If lbool is false, return lval.
                if (lbool.isFalsey) {
                    return lval;
                }
                // 5. Let rref be the result of evaluating BitwiseORExpression.
                const rref = this.$right.Evaluate(ctx);
                // 6. Return ? GetValue(rref).
                return rref.GetValue(ctx);
            }
            case typescript.SyntaxKind.BarBarToken: {
                // LogicalORExpression : LogicalORExpression || LogicalANDExpression
                // 1. Let lref be the result of evaluating LogicalORExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let lbool be ToBoolean(lval).
                const lbool = lval.ToBoolean(ctx);
                if (lbool.isAbrupt) {
                    return lbool.enrichWith(ctx, this);
                } // TODO: is this correct? spec doesn't say it
                // 4. If lbool is true, return lval.
                if (lbool.isTruthy) {
                    return lval;
                }
                // 5. Let rref be the result of evaluating LogicalANDExpression.
                const rref = this.$right.Evaluate(ctx);
                // 6. Return ? GetValue(rref).
                return rref.GetValue(ctx);
            }
            case typescript.SyntaxKind.EqualsToken: {
                // http://www.ecma-international.org/ecma-262/#sec-assignment-operators-runtime-semantics-evaluation
                // 12.15.4 Runtime Semantics: Evaluation
                // AssignmentExpression : LeftHandSideExpression = AssignmentExpression
                const lhs = this.$left;
                const assign = this.$right;
                // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then
                if (!(lhs instanceof $ObjectLiteralExpression || lhs instanceof $ArrayLiteralExpression)) {
                    // 1. a. Let lref be the result of evaluating LeftHandSideExpression.
                    const lref = lhs.Evaluate(ctx);
                    // 1. b. ReturnIfAbrupt(lref).
                    if (lref.isAbrupt) {
                        return lref.enrichWith(ctx, this);
                    }
                    let rval;
                    // 1. c. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then
                    if (assign instanceof $FunctionExpression && !assign.HasName && lref instanceof $Identifier) {
                        // 1. c. i. Let rval be the result of performing NamedEvaluation for AssignmentExpression with argument GetReferencedName(lref).
                        rval = lref.GetReferencedName();
                    }
                    // 1. d. Else,
                    else {
                        // 1. d. i. Let rref be the result of evaluating AssignmentExpression.
                        const rref = assign.Evaluate(ctx);
                        // 1. d. ii. Let rval be ? GetValue(rref).
                        const $rval = rref.GetValue(ctx);
                        if ($rval.isAbrupt) {
                            return $rval.enrichWith(ctx, this);
                        }
                        rval = $rval;
                    }
                    // 1. e. Perform ? PutValue(lref, rval).
                    if (!(lref instanceof $Reference)) {
                        return new $ReferenceError(realm, `Value is not assignable: ${lref}`).enrichWith(ctx, this);
                    }
                    const $PutValueResult = lref.PutValue(ctx, rval);
                    if ($PutValueResult.isAbrupt) {
                        return $PutValueResult.enrichWith(ctx, this);
                    }
                    // 1. f. Return rval.
                    return rval;
                }
                // 2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.
                // 3. Let rref be the result of evaluating AssignmentExpression.
                const rref = assign.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const $rval = rref.GetValue(ctx);
                if ($rval.isAbrupt) {
                    return $rval.enrichWith(ctx, this);
                }
                const rval = $rval;
                // 5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.
                // TODO
                // 6. Return rval.
                return rval;
            }
            case typescript.SyntaxKind.CommaToken: {
                // 1. Let lref be the result of evaluating LeftHandSideExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating AssignmentExpression.
                const rref = this.$left.Evaluate(ctx);
                // 4. Return ? GetValue(rref)
                return rref.GetValue(ctx).enrichWith(ctx, this);
            }
            case typescript.SyntaxKind.QuestionQuestionToken: {
                const lref = this.$left.Evaluate(ctx);
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                if (lval.isNil) {
                    const rref = this.$right.Evaluate(ctx);
                    return rref.GetValue(ctx).enrichWith(ctx, this);
                }
                return lval;
            }
            case typescript.SyntaxKind.AsteriskAsteriskEqualsToken:
            case typescript.SyntaxKind.AsteriskEqualsToken:
            case typescript.SyntaxKind.SlashEqualsToken:
            case typescript.SyntaxKind.PercentEqualsToken:
            case typescript.SyntaxKind.PlusEqualsToken:
            case typescript.SyntaxKind.MinusEqualsToken:
            case typescript.SyntaxKind.LessThanLessThanEqualsToken:
            case typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
            case typescript.SyntaxKind.AmpersandEqualsToken:
            case typescript.SyntaxKind.CaretEqualsToken:
            case typescript.SyntaxKind.BarEqualsToken: {
                // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
                // 1. Let lref be the result of evaluating LeftHandSideExpression.
                const lref = this.$left.Evaluate(ctx);
                // 2. Let lval be ? GetValue(lref).
                const lval = lref.GetValue(ctx);
                if (lval.isAbrupt) {
                    return lval.enrichWith(ctx, this);
                }
                // 3. Let rref be the result of evaluating AssignmentExpression.
                const rref = this.$left.Evaluate(ctx);
                // 4. Let rval be ? GetValue(rref).
                const rval = rref.GetValue(ctx);
                if (rval.isAbrupt) {
                    return rval.enrichWith(ctx, this);
                }
                // 5. Let op be the @ where AssignmentOperator is @=.
                // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.
                let r;
                switch (this.node.operatorToken.kind) {
                    case typescript.SyntaxKind.AsteriskAsteriskEqualsToken: {
                        // 5. Let base be ? ToNumber(leftValue).
                        const base = lval.ToNumber(ctx);
                        if (base.isAbrupt) {
                            return base.enrichWith(ctx, this);
                        }
                        // 6. Let exponent be ? ToNumber(rightValue).
                        const exponent = rval.ToNumber(ctx);
                        if (exponent.isAbrupt) {
                            return exponent.enrichWith(ctx, this);
                        }
                        // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.6.4.
                        r = new $Number(realm, base['[[Value]]'] ** exponent['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.AsteriskEqualsToken: {
                        // 5. Let lnum be ? ToNumber(leftValue).
                        const lnum = lval.ToNumber(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToNumber(rightValue).
                        const rnum = rval.ToNumber(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
                        r = new $Number(realm, lnum['[[Value]]'] * rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.SlashEqualsToken: {
                        // 5. Let lnum be ? ToNumber(leftValue).
                        const lnum = lval.ToNumber(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToNumber(rightValue).
                        const rnum = rval.ToNumber(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
                        r = new $Number(realm, lnum['[[Value]]'] / rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.PercentEqualsToken: {
                        // 5. Let lnum be ? ToNumber(leftValue).
                        const lnum = lval.ToNumber(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToNumber(rightValue).
                        const rnum = rval.ToNumber(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.
                        r = new $Number(realm, lnum['[[Value]]'] % rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.PlusEqualsToken: {
                        // 5. Let lprim be ? ToPrimitive(lval).
                        const lprim = lval.ToPrimitive(ctx);
                        if (lprim.isAbrupt) {
                            return lprim.enrichWith(ctx, this);
                        }
                        // 6. Let rprim be ? ToPrimitive(rval).
                        const rprim = rval.ToPrimitive(ctx);
                        if (rprim.isAbrupt) {
                            return rprim.enrichWith(ctx, this);
                        }
                        // 7. If Type(lprim) is String or Type(rprim) is String, then
                        if (lprim.isString || rprim.isString) {
                            // 7. a. Let lstr be ? ToString(lprim).
                            const lstr = lprim.ToString(ctx);
                            if (lstr.isAbrupt) {
                                return lstr.enrichWith(ctx, this);
                            }
                            // 7. b. Let rstr be ? ToString(rprim).
                            const rstr = rprim.ToString(ctx);
                            if (rstr.isAbrupt) {
                                return rstr.enrichWith(ctx, this);
                            }
                            // 7. c. Return the string-concatenation of lstr and rstr.
                            r = new $String(realm, lstr['[[Value]]'] + rstr['[[Value]]']);
                            break;
                        }
                        // 8. Let lnum be ? ToNumber(lprim).
                        const lnum = lprim.ToNumber(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 9. Let rnum be ? ToNumber(rprim).
                        const rnum = rprim.ToNumber(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 10. Return the result of applying the addition operation to lnum and rnum. See the Note below 12.8.5.
                        r = new $Number(realm, lnum['[[Value]]'] + rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.MinusEqualsToken: {
                        // 5. Let lnum be ? ToNumber(lval).
                        const lnum = lval.ToNumber(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToNumber(rval).
                        const rnum = rval.ToNumber(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the subtraction operation to lnum and rnum. See the note below 12.8.5.
                        r = new $Number(realm, lnum['[[Value]]'] - rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.LessThanLessThanEqualsToken: {
                        // 5. Let lnum be ? ToInt32(lval).
                        const lnum = lval.ToInt32(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToUint32(rval).
                        const rnum = rval.ToUint32(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
                        const shiftCount = rnum['[[Value]]'] & 0b11111;
                        // 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.
                        r = new $Number(realm, lnum['[[Value]]'] << shiftCount);
                        break;
                    }
                    case typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken: {
                        // 5. Let lnum be ? ToInt32(lval).
                        const lnum = lval.ToInt32(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToUint32(rval).
                        const rnum = rval.ToUint32(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
                        const shiftCount = rnum['[[Value]]'] & 0b11111;
                        // 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.
                        r = new $Number(realm, lnum['[[Value]]'] >> shiftCount);
                        break;
                    }
                    case typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken: {
                        // 5. Let lnum be ? ToUint32(lval).
                        const lnum = lval.ToUint32(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToUint32(rval).
                        const rnum = rval.ToUint32(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.
                        const shiftCount = rnum['[[Value]]'] & 0b11111;
                        // 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.
                        r = new $Number(realm, lnum['[[Value]]'] >>> shiftCount);
                        break;
                    }
                    case typescript.SyntaxKind.AmpersandEqualsToken: {
                        // 5. Let lnum be ? ToInt32(lval).
                        const lnum = lval.ToInt32(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToInt32(rval).
                        const rnum = rval.ToInt32(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
                        r = new $Number(realm, lnum['[[Value]]'] & rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.CaretEqualsToken: {
                        // 5. Let lnum be ? ToInt32(lval).
                        const lnum = lval.ToInt32(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToInt32(rval).
                        const rnum = rval.ToInt32(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
                        r = new $Number(realm, lnum['[[Value]]'] ^ rnum['[[Value]]']);
                        break;
                    }
                    case typescript.SyntaxKind.BarEqualsToken: {
                        // 5. Let lnum be ? ToInt32(lval).
                        const lnum = lval.ToInt32(ctx);
                        if (lnum.isAbrupt) {
                            return lnum.enrichWith(ctx, this);
                        }
                        // 6. Let rnum be ? ToInt32(rval).
                        const rnum = rval.ToInt32(ctx);
                        if (rnum.isAbrupt) {
                            return rnum.enrichWith(ctx, this);
                        }
                        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.
                        r = new $Number(realm, lnum['[[Value]]'] | rnum['[[Value]]']);
                        break;
                    }
                }
                // 7. Perform ? PutValue(lref, r).
                if (!(lref instanceof $Reference)) {
                    return new $ReferenceError(realm, `Value is not assignable: ${lref}`).enrichWith(ctx, this);
                }
                const $PutValueResult = lref.PutValue(ctx, r);
                if ($PutValueResult.isAbrupt) {
                    return $PutValueResult.enrichWith(ctx, this);
                }
                // 8. Return r.
                return r;
            }
            default:
                throw new Error(`SyntaxKind ${this.node.operatorToken.kind} not yet implemented`);
        }
    }
}
class $ConditionalExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ConditionalExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        if (node.condition.kind === typescript.SyntaxKind.BinaryExpression) {
            this.$condition = new $BinaryExpression(node.condition, this, ctx, -1);
        }
        else {
            this.$condition = $unaryExpression(node.condition, this, ctx, -1);
        }
        this.$whenTrue = $assignmentExpression(node.whenTrue, this, ctx, -1);
        this.$whenFalse = $assignmentExpression(node.whenFalse, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.ConditionalExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-conditional-operator-runtime-semantics-evaluation
    // 12.14.3 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression
        // 1. Let lref be the result of evaluating LogicalORExpression.
        // 2. Let lval be ToBoolean(? GetValue(lref)).
        // 3. If lval is true, then
        // 3. a. Let trueRef be the result of evaluating the first AssignmentExpression.
        // 3. b. Return ? GetValue(trueRef).
        // 4. Else,
        // 4. a. Let falseRef be the result of evaluating the second AssignmentExpression.
        // 4. b. Return ? GetValue(falseRef).
        return intrinsics.undefined; // TODO: implement this
    }
}
class $YieldExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.YieldExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.YieldExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-evaluation
    // 14.4.14 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // YieldExpression : yield
        // 1. Let generatorKind be ! GetGeneratorKind().
        // 2. If generatorKind is async, then return ? AsyncGeneratorYield(undefined).
        // 3. Otherwise, return ? GeneratorYield(CreateIterResultObject(undefined, false)).
        // YieldExpression : yield AssignmentExpression
        // 1. Let generatorKind be ! GetGeneratorKind().
        // 2. Let exprRef be the result of evaluating AssignmentExpression.
        // 3. Let value be ? GetValue(exprRef).
        // 4. If generatorKind is async, then return ? AsyncGeneratorYield(value).
        // 5. Otherwise, return ? GeneratorYield(CreateIterResultObject(value, false)).
        // YieldExpression : yield * AssignmentExpression
        // 1. Let generatorKind be ! GetGeneratorKind().
        // 2. Let exprRef be the result of evaluating AssignmentExpression.
        // 3. Let value be ? GetValue(exprRef).
        // 4. Let iteratorRecord be ? GetIterator(value, generatorKind).
        // 5. Let iterator be iteratorRecord.[[Iterator]].
        // 6. Let received be NormalCompletion(undefined).
        // 7. Repeat,
        // 7. a. If received.[[Type]] is normal, then
        // 7. a. i. Let innerResult be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « received.[[Value]] »).
        // 7. a. ii. If generatorKind is async, then set innerResult to ? Await(innerResult).
        // 7. a. iii. If Type(innerResult) is not Object, throw a TypeError exception.
        // 7. a. iv. Let done be ? IteratorComplete(innerResult).
        // 7. a. v. If done is true, then
        // 7. a. v. 1. Return ? IteratorValue(innerResult).
        // 7. a. vi. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
        // 7. a. vii. Else, set received to GeneratorYield(innerResult).
        // 7. b. Else if received.[[Type]] is throw, then
        // 7. b. i. Let throw be ? GetMethod(iterator, "throw").
        // 7. b. ii. If throw is not undefined, then
        // 7. b. ii. 1. Let innerResult be ? Call(throw, iterator, « received.[[Value]] »).
        // 7. b. ii. 2. If generatorKind is async, then set innerResult to ? Await(innerResult).
        // 7. b. ii. 3. NOTE: Exceptions from the inner iterator throw method are propagated. Normal completions from an inner throw method are processed similarly to an inner next.
        // 7. b. ii. 4. If Type(innerResult) is not Object, throw a TypeError exception.
        // 7. b. ii. 5. Let done be ? IteratorComplete(innerResult).
        // 7. b. ii. 6. If done is true, then
        // 7. b. ii. 6. a. Return ? IteratorValue(innerResult).
        // 7. b. ii. 7. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).
        // 7. b. ii. 8. Else, set received to GeneratorYield(innerResult).
        // 7. b. iii. Else,
        // 7. b. iii. 1. NOTE: If iterator does not have a throw method, this throw is going to terminate the yield* loop. But first we need to give iterator a chance to clean up.
        // 7. b. iii. 2. Let closeCompletion be Completion { [[Type]]: normal, [[Value]]: empty, [[Target]]: empty }.
        // 7. b. iii. 3. If generatorKind is async, perform ? AsyncIteratorClose(iteratorRecord, closeCompletion).
        // 7. b. iii. 4. Else, perform ? IteratorClose(iteratorRecord, closeCompletion).
        // 7. b. iii. 5. NOTE: The next step throws a TypeError to indicate that there was a yield* protocol violation: iterator does not have a throw method.
        // 7. b. iii. 6. Throw a TypeError exception.
        // 7. c. Else,
        // 7. c. i. Assert: received.[[Type]] is return.
        // 7. c. ii. Let return be ? GetMethod(iterator, "return").
        // 7. c. iii. If return is undefined, then
        // 7. c. iii. 1. If generatorKind is async, then set received.[[Value]] to ? Await(received.[[Value]]).
        // 7. c. iii. 2. Return Completion(received).
        // 7. c. iv. Let innerReturnResult be ? Call(return, iterator, « received.[[Value]] »).
        // 7. c. v. If generatorKind is async, then set innerReturnResult to ? Await(innerReturnResult).
        // 7. c. vi. If Type(innerReturnResult) is not Object, throw a TypeError exception.
        // 7. c. vii. Let done be ? IteratorComplete(innerReturnResult).
        // 7. c. viii. If done is true, then
        // 7. c. viii. 1. Let value be ? IteratorValue(innerReturnResult).
        // 7. c. viii. 2. Return Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
        // 7. c. ix. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerReturnResult)).
        // 7. c. x. Else, set received to GeneratorYield(innerReturnResult).
        return intrinsics.undefined; // TODO: implement this
    }
}
class $AsExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.AsExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.AsExpression; }
    // This is a TS expression that wraps an ordinary expression. Just return the evaluate result.
    Evaluate(ctx) {
        ctx.checkTimeout();
        return this.$expression.Evaluate(ctx);
    }
}
// #endregion
class $Identifier {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.Identifier(${node.text})`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression
        // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression
        this.CoveredParenthesizedExpression = this;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname
        // 12.2.1.2 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition
        // 12.2.1.3 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = false;
        // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref
        // 12.2.1.4 Static Semantics: IsIdentifierRef
        this.IsIdentifierRef = true;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression
        // 13.3.3.2 Static Semantics: ContainsExpression
        this.ContainsExpression = false;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer
        // 13.3.3.3 Static Semantics: HasInitializer
        this.HasInitializer = false;
        // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist
        // 13.3.3.4 Static Semantics: IsSimpleParameterList
        this.IsSimpleParameterList = true;
        const StringValue = this.StringValue = new $String(realm, node.text, void 0, void 0, this);
        this.PropName = StringValue;
        this.BoundNames = [StringValue];
        if (hasBit(ctx, 65536 /* InStrictMode */) && (StringValue['[[Value]]'] === 'eval' || StringValue['[[Value]]'] === 'arguments')) {
            this.AssignmentTargetType = 'strict';
        }
        else {
            this.AssignmentTargetType = 'simple';
        }
    }
    get $kind() { return typescript.SyntaxKind.Identifier; }
    get isUndefined() { return false; }
    get isNull() { return false; }
    // http://www.ecma-international.org/ecma-262/#sec-identifiers-runtime-semantics-evaluation
    // 12.1.6 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // IdentifierReference : Identifier
        // 1. Return ? ResolveBinding(StringValue of Identifier).
        // IdentifierReference : yield
        // 1. Return ? ResolveBinding("yield").
        // IdentifierReference : await
        // 1. Return ? ResolveBinding("await").
        return realm.ResolveBinding(this.StringValue).enrichWith(ctx, this);
    }
    // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation
    EvaluatePropName(ctx) {
        ctx.checkTimeout();
        return this.PropName;
    }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization
    // 13.3.3.6 Runtime Semantics: PropertyBindingInitialization
    InitializePropertyBinding(ctx, value, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializePropertyBinding(#${ctx.id})`);
        // BindingProperty : SingleNameBinding
        // 1. Let name be the string that is the only element of BoundNames of SingleNameBinding.
        const [name] = this.BoundNames;
        // 2. Perform ? KeyedBindingInitialization for SingleNameBinding using value, environment, and name as the arguments.
        const $InitializeKeyedBindingResult = this.InitializeKeyedBinding(ctx, value, environment, name);
        if ($InitializeKeyedBindingResult.isAbrupt) {
            return $InitializeKeyedBindingResult.enrichWith(ctx, this);
        }
        // 3. Return a new List containing name.
        return new $List(...this.BoundNames);
    }
    // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
    // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
    InitializeIteratorBinding(ctx, iteratorRecord, environment, initializer) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // SingleNameBinding : BindingIdentifier Initializer opt
        // 1. Let bindingId be StringValue of BindingIdentifier.
        const bindingId = this.StringValue;
        // 2. Let lhs be ? ResolveBinding(bindingId, environment).
        const lhs = realm.ResolveBinding(bindingId, environment);
        if (lhs.isAbrupt) {
            return lhs.enrichWith(ctx, this);
        }
        let v = intrinsics.undefined; // TODO: sure about this?
        // 3. If iteratorRecord.[[Done]] is false, then
        if (iteratorRecord['[[Done]]'].isFalsey) {
            // 3. a. Let next be IteratorStep(iteratorRecord).
            const next = $IteratorStep(ctx, iteratorRecord);
            // 3. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
            if (next.isAbrupt) {
                iteratorRecord['[[Done]]'] = intrinsics.true;
                // 3. c. ReturnIfAbrupt(next).
                return next;
            }
            // 3. d. If next is false, set iteratorRecord.[[Done]] to true.
            if (next.isFalsey) {
                iteratorRecord['[[Done]]'] = intrinsics.true;
            }
            // 3. e. Else,
            else {
                // 3. e. i. Let v be IteratorValue(next).
                v = $IteratorValue(ctx, next);
                // 3. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
                if (v.isAbrupt) {
                    iteratorRecord['[[Done]]'] = intrinsics.true;
                    // 3. e. iii. ReturnIfAbrupt(v).
                    return v;
                }
            }
        }
        // 4. If iteratorRecord.[[Done]] is true, let v be undefined.
        if (iteratorRecord['[[Done]]'].isTruthy) {
            v = intrinsics.undefined;
        }
        // 5. If Initializer is present and v is undefined, then
        if (initializer !== void 0 && v.isUndefined) {
            // 5. a. If IsAnonymousFunctionDefinition(Initializer) is true, then
            if (initializer instanceof $FunctionExpression && !initializer.HasName) {
                // 5. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.
                v = initializer.EvaluateNamed(ctx, bindingId);
            }
            // 5. b. Else,
            else {
                // 5. b. i. Let defaultValue be the result of evaluating Initializer.
                const defaultValue = initializer.Evaluate(ctx);
                // 5. b. ii. Set v to ? GetValue(defaultValue).
                const $v = defaultValue.GetValue(ctx);
                if ($v.isAbrupt) {
                    return $v.enrichWith(ctx, this);
                }
                v = $v;
            }
        }
        // 6. If environment is undefined, return ? PutValue(lhs, v).
        if (environment === void 0) {
            return lhs.PutValue(ctx, v).enrichWith(ctx, this);
        }
        // 7. Return InitializeReferencedBinding(lhs, v).
        return lhs.InitializeReferencedBinding(ctx, v).enrichWith(ctx, this);
    }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-keyedbindinginitialization
    // 13.3.3.9 Runtime Semantics: KeyedBindingInitialization
    InitializeKeyedBinding(ctx, value, environment, propertyName, initializer) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeKeyedBinding(#${ctx.id})`);
        const realm = ctx.Realm;
        // SingleNameBinding : BindingIdentifier Initializer opt
        // 1. Let bindingId be StringValue of BindingIdentifier.
        const bindingId = this.StringValue;
        // 2. Let lhs be ? ResolveBinding(bindingId, environment).
        const lhs = realm.ResolveBinding(bindingId, environment);
        if (lhs.isAbrupt) {
            return lhs.enrichWith(ctx, this);
        }
        // 3. Let v be ? GetV(value, propertyName).
        const obj = value.ToObject(ctx);
        if (obj.isAbrupt) {
            return obj.enrichWith(ctx, this);
        }
        let v = obj['[[Get]]'](ctx, propertyName, obj);
        if (v.isAbrupt) {
            return v.enrichWith(ctx, this);
        }
        // 4. If Initializer is present and v is undefined, then
        if (initializer !== void 0 && v.isUndefined) {
            // 4. a. If IsAnonymousFunctionDefinition(Initializer) is true, then
            if (initializer instanceof $FunctionExpression && !initializer.HasName) {
                // 4. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.
                v = initializer.EvaluateNamed(ctx, bindingId);
            }
            // 4. b. Else,
            else {
                // 4. b. i. Let defaultValue be the result of evaluating Initializer.
                const defaultValue = initializer.Evaluate(ctx);
                // 4. b. ii. Set v to ? GetValue(defaultValue).
                const $v = defaultValue.GetValue(ctx);
                if ($v.isAbrupt) {
                    return $v.enrichWith(ctx, this);
                }
            }
        }
        // 5. If environment is undefined, return ? PutValue(lhs, v).
        if (environment === void 0) {
            return lhs.PutValue(ctx, v).enrichWith(ctx, this);
        }
        // 6. Return InitializeReferencedBinding(lhs, v).
        return lhs.InitializeReferencedBinding(ctx, v).enrichWith(ctx, this);
    }
}

function $$jsxChildList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        switch (nodes[i].kind) {
            case typescript.SyntaxKind.JsxText:
                $nodes[i] = new $JsxText(nodes[i], parent, ctx, i);
                break;
            case typescript.SyntaxKind.JsxExpression:
                $nodes[i] = new $JsxExpression(nodes[i], parent, ctx, i);
                break;
            case typescript.SyntaxKind.JsxElement:
                $nodes[i] = new $JsxElement(nodes[i], parent, ctx, i);
                break;
            case typescript.SyntaxKind.JsxSelfClosingElement:
                $nodes[i] = new $JsxSelfClosingElement(nodes[i], parent, ctx, i);
                break;
            case typescript.SyntaxKind.JsxFragment:
                $nodes[i] = new $JsxFragment(nodes[i], parent, ctx, i);
                break;
        }
    }
    return $nodes;
}
class $JsxElement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$openingElement = new $JsxOpeningElement(node.openingElement, this, ctx);
        this.$children = $$jsxChildList(node.children, this, ctx);
        this.$closingElement = new $JsxClosingElement(node.closingElement, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.JsxElement; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.undefined; // TODO: implement this
    }
}
function $$jsxTagNameExpression(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.Identifier:
            return new $Identifier(node, parent, ctx, idx);
        case typescript.SyntaxKind.ThisKeyword:
            return new $ThisExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.PropertyAccessExpression:
            return new $PropertyAccessExpression(node, parent, ctx, idx);
        default:
            throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
    }
}
class $JsxSelfClosingElement {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxSelfClosingElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$tagName = $$jsxTagNameExpression(node.tagName, this, ctx, -1);
        this.$attributes = new $JsxAttributes(node.attributes, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.JsxSelfClosingElement; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.undefined; // TODO: implement this
    }
}
class $JsxFragment {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxFragment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$openingFragment = new $JsxOpeningFragment(node.openingFragment, this, ctx);
        this.$children = $$jsxChildList(node.children, this, ctx);
        this.$closingFragment = new $JsxClosingFragment(node.closingFragment, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.JsxFragment; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.undefined; // TODO: implement this
    }
}
class $JsxText {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxText`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.JsxText; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxOpeningElement {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.JsxOpeningElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$tagName = $$jsxTagNameExpression(node.tagName, this, ctx, -1);
        this.$attributes = new $JsxAttributes(node.attributes, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.JsxOpeningElement; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxClosingElement {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.JsxClosingElement`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$tagName = $$jsxTagNameExpression(node.tagName, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.JsxClosingElement; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxOpeningFragment {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.JsxOpeningFragment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.JsxOpeningFragment; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxClosingFragment {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.JsxClosingFragment`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
    }
    get $kind() { return typescript.SyntaxKind.JsxClosingFragment; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxAttribute {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxAttribute`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$name = $identifier(node.name, this, ctx, -1);
        if (node.initializer === void 0) {
            this.$initializer = void 0;
        }
        else {
            if (node.initializer.kind === typescript.SyntaxKind.StringLiteral) {
                this.$initializer = new $StringLiteral(node.initializer, this, ctx, -1);
            }
            else {
                this.$initializer = new $JsxExpression(node.initializer, this, ctx, -1);
            }
        }
    }
    get $kind() { return typescript.SyntaxKind.JsxAttribute; }
}
function $$jsxAttributeLikeList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        switch (nodes[i].kind) {
            case typescript.SyntaxKind.JsxAttribute:
                $nodes[i] = new $JsxAttribute(nodes[i], parent, ctx, i);
                break;
            case typescript.SyntaxKind.JsxSpreadAttribute:
                $nodes[i] = new $JsxSpreadAttribute(nodes[i], parent, ctx, i);
                break;
        }
    }
    return $nodes;
}
class $JsxAttributes {
    constructor(node, parent, ctx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}.JsxAttributes`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$properties = $$jsxAttributeLikeList(node.properties, this, ctx);
    }
    get $kind() { return typescript.SyntaxKind.JsxAttributes; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxSpreadAttribute {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxSpreadAttribute`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.JsxSpreadAttribute; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}
class $JsxExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.JsxExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.$expression = $assignmentExpression(node.expression, this, ctx, -1);
    }
    get $kind() { return typescript.SyntaxKind.JsxExpression; }
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        return intrinsics.empty; // TODO: implement this
    }
}

function $assignmentExpression(node, parent, ctx, idx) {
    if (node === void 0) {
        return void 0;
    }
    switch (node.kind) {
        case typescript.SyntaxKind.AsExpression:
            return new $AsExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.BinaryExpression:
            return new $BinaryExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.ArrowFunction:
            return new $ArrowFunction(node, parent, ctx, idx);
        case typescript.SyntaxKind.ConditionalExpression:
            return new $ConditionalExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.YieldExpression:
            return new $YieldExpression(node, parent, ctx, idx);
        default:
            return $unaryExpression(node, parent, ctx, idx);
    }
}
function $unaryExpression(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.JsxElement:
            return new $JsxElement(node, parent, ctx, idx);
        case typescript.SyntaxKind.JsxFragment:
            return new $JsxFragment(node, parent, ctx, idx);
        case typescript.SyntaxKind.JsxSelfClosingElement:
            return new $JsxSelfClosingElement(node, parent, ctx, idx);
        case typescript.SyntaxKind.PostfixUnaryExpression:
            return new $PostfixUnaryExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.PrefixUnaryExpression:
            return new $PrefixUnaryExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.AwaitExpression:
            return new $AwaitExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.DeleteExpression:
            return new $DeleteExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.TypeAssertionExpression:
            return new $TypeAssertion(node, parent, ctx, idx);
        case typescript.SyntaxKind.TypeOfExpression:
            return new $TypeOfExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.VoidExpression:
            return new $VoidExpression(node, parent, ctx, idx);
        default:
            return $LHSExpression(node, parent, ctx, idx);
    }
}
function $LHSExpression(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.ArrayLiteralExpression:
            return new $ArrayLiteralExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.ClassExpression:
            return new $ClassExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.FunctionExpression:
            return new $FunctionExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.Identifier:
            return new $Identifier(node, parent, ctx, idx);
        case typescript.SyntaxKind.NewExpression:
            return new $NewExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.ObjectLiteralExpression:
            return new $ObjectLiteralExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.ParenthesizedExpression:
            return new $ParenthesizedExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.TemplateExpression:
            return new $TemplateExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.ElementAccessExpression:
            return new $ElementAccessExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.NonNullExpression:
            return new $NonNullExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.PropertyAccessExpression:
            return new $PropertyAccessExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.TaggedTemplateExpression:
            return new $TaggedTemplateExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.CallExpression:
            return new $CallExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.MetaProperty:
            return new $MetaProperty(node, parent, ctx, idx);
        case typescript.SyntaxKind.ThisKeyword:
            return new $ThisExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.SuperKeyword:
            return new $SuperExpression(node, parent, ctx, idx);
        case typescript.SyntaxKind.NumericLiteral:
            return new $NumericLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.BigIntLiteral:
            return new $BigIntLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.StringLiteral:
            return new $StringLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.RegularExpressionLiteral:
            return new $RegularExpressionLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.NoSubstitutionTemplateLiteral:
            return new $NoSubstitutionTemplateLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.NullKeyword:
            return new $NullLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.TrueKeyword:
        case typescript.SyntaxKind.FalseKeyword:
            return new $BooleanLiteral(node, parent, ctx, idx);
        default:
            throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
    }
}
function $identifier(node, parent, ctx, idx) {
    if (node === void 0) {
        return void 0;
    }
    return new $Identifier(node, parent, ctx, idx);
}
function $$propertyName(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.Identifier:
            return new $Identifier(node, parent, ctx, idx);
        case typescript.SyntaxKind.StringLiteral:
            return new $StringLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.NumericLiteral:
            return new $NumericLiteral(node, parent, ctx, idx);
        case typescript.SyntaxKind.ComputedPropertyName:
            return new $ComputedPropertyName(node, parent, ctx, idx);
    }
}
function $$bindingName(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.Identifier:
            return new $Identifier(node, parent, ctx | 8 /* IsBindingName */, idx);
        case typescript.SyntaxKind.ObjectBindingPattern:
            return new $ObjectBindingPattern(node, parent, ctx, idx);
        case typescript.SyntaxKind.ArrayBindingPattern:
            return new $ArrayBindingPattern(node, parent, ctx, idx);
    }
}
function $$esStatement(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.Block:
            return new $Block(node, parent, ctx, idx);
        case typescript.SyntaxKind.EmptyStatement:
            return new $EmptyStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ExpressionStatement:
            return new $ExpressionStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.IfStatement:
            return new $IfStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.DoStatement:
            return new $DoStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.WhileStatement:
            return new $WhileStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ForStatement:
            return new $ForStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ForInStatement:
            return new $ForInStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ForOfStatement:
            return new $ForOfStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ContinueStatement:
            return new $ContinueStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.BreakStatement:
            return new $BreakStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ReturnStatement:
            return new $ReturnStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.WithStatement:
            return new $WithStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.SwitchStatement:
            return new $SwitchStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.LabeledStatement:
            return new $LabeledStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.ThrowStatement:
            return new $ThrowStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.TryStatement:
            return new $TryStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.DebuggerStatement:
            return new $DebuggerStatement(node, parent, ctx, idx);
        default:
            throw new Error(`Unexpected syntax node: ${typescript.SyntaxKind[node.kind]}.`);
    }
}
function $$tsStatementListItem(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.VariableStatement:
            return new $VariableStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.FunctionDeclaration:
            return new $FunctionDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.ClassDeclaration:
            return new $ClassDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.InterfaceDeclaration:
            return new $InterfaceDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.TypeAliasDeclaration:
            return new $TypeAliasDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.EnumDeclaration:
            return new $EnumDeclaration(node, parent, ctx, idx);
        default:
            return $$esStatement(node, parent, ctx, idx);
    }
}
function $$tsStatementList(nodes, parent, ctx) {
    const len = nodes.length;
    let node;
    const $nodes = [];
    let x = 0;
    for (let i = 0; i < len; ++i) {
        node = nodes[i];
        if (node.kind === typescript.SyntaxKind.FunctionDeclaration && node.body === void 0) {
            continue;
        }
        $nodes[x] = $$tsStatementListItem(node, parent, ctx, x);
        ++x;
    }
    return $nodes;
}
function $$esLabelledItem(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.VariableStatement:
            return new $VariableStatement(node, parent, ctx, idx);
        case typescript.SyntaxKind.FunctionDeclaration:
            return new $FunctionDeclaration(node, parent, ctx, idx);
        default:
            return $$esStatement(node, parent, ctx, idx);
    }
}
// #endregion
// #region AST helpers
function GetDirectivePrologue(statements) {
    let directivePrologue = kernel.emptyArray;
    let statement;
    const len = statements.length;
    for (let i = 0; i < len; ++i) {
        statement = statements[i];
        if (statement.kind === typescript.SyntaxKind.ExpressionStatement
            && statement.expression.kind === typescript.SyntaxKind.StringLiteral) {
            if (directivePrologue === kernel.emptyArray) {
                directivePrologue = [statement];
            }
            else {
                directivePrologue.push(statement);
            }
            if (statement.expression.text === 'use strict') {
                directivePrologue.ContainsUseStrict = true;
            }
        }
        else {
            break;
        }
    }
    return directivePrologue;
}
function evaluateStatement(ctx, statement) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    let stmtCompletion = intrinsics.empty;
    switch (statement.$kind) {
        case typescript.SyntaxKind.Block:
        case typescript.SyntaxKind.VariableStatement:
        case typescript.SyntaxKind.EmptyStatement:
        case typescript.SyntaxKind.ExpressionStatement:
        case typescript.SyntaxKind.IfStatement:
        case typescript.SyntaxKind.SwitchStatement:
        case typescript.SyntaxKind.ContinueStatement:
        case typescript.SyntaxKind.BreakStatement:
        case typescript.SyntaxKind.ReturnStatement:
        case typescript.SyntaxKind.WithStatement:
        case typescript.SyntaxKind.LabeledStatement:
        case typescript.SyntaxKind.ThrowStatement:
        case typescript.SyntaxKind.TryStatement:
        case typescript.SyntaxKind.DebuggerStatement:
        case typescript.SyntaxKind.FunctionDeclaration:
            stmtCompletion = statement.Evaluate(ctx);
            break;
        case typescript.SyntaxKind.DoStatement:
        case typescript.SyntaxKind.WhileStatement:
        case typescript.SyntaxKind.ForStatement:
        case typescript.SyntaxKind.ForInStatement:
        case typescript.SyntaxKind.ForOfStatement:
            stmtCompletion = statement.EvaluateLabelled(ctx, new $StringSet());
            break;
        // Note that no default case is needed here as the cases above are exhausetive $$ESStatement (http://www.ecma-international.org/ecma-262/#prod-Statement)
    }
    return stmtCompletion;
}
// http://www.ecma-international.org/ecma-262/#sec-block-runtime-semantics-evaluation
// StatementList : StatementList StatementListItem
function evaluateStatementList(ctx, statements) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let sl be the result of evaluating StatementList.
    // 2. ReturnIfAbrupt(sl).
    // 3. Let s be the result of evaluating StatementListItem.
    // 4. Return Completion(UpdateEmpty(s, sl)).
    let sl = intrinsics.empty;
    for (const statement of statements) {
        const s = evaluateStatement(ctx, statement); // TODO handle the declarations.
        if (s.isAbrupt) {
            return s;
        }
        sl = sl.UpdateEmpty(s);
    }
    return sl;
}
// http://www.ecma-international.org/ecma-262/#sec-blockdeclarationinstantiation
function BlockDeclarationInstantiation(ctx, lexicallyScopedDeclarations, envRec) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let envRec be env's EnvironmentRecord.
    // 2. Assert: envRec is a declarative Environment Record.
    // 3. Let declarations be the LexicallyScopedDeclarations of code.
    // 4. For each element d in declarations, do
    for (const d of lexicallyScopedDeclarations) {
        // 4. a. For each element dn of the BoundNames of d, do
        for (const dn of d.BoundNames) {
            // 4. a. i. If IsConstantDeclaration of d is true, then
            if (d.IsConstantDeclaration) {
                // 4. a. i. 1. Perform ! envRec.CreateImmutableBinding(dn, true).
                envRec.CreateImmutableBinding(ctx, dn, intrinsics.true);
            }
            else {
                // 4. a. ii. Else,
                // 4. a. ii. 1. Perform ! envRec.CreateMutableBinding(dn, false).
                envRec.CreateImmutableBinding(ctx, dn, intrinsics.false);
            }
        }
        const dkind = d.$kind;
        // 4. b. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then
        if (dkind === typescript.SyntaxKind.FunctionDeclaration /* || dkind === SyntaxKind.GeneratorDeclaration || dkind === SyntaxKind.AsyncFunctionDeclaration || dkind === SyntaxKind.AsyncGeneratorDeclaration */) {
            // 4. b. i. Let fn be the sole element of the BoundNames of d.
            const fn = d.BoundNames[0];
            // 4. b. ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.
            const fo = d.InstantiateFunctionObject(ctx, envRec);
            if (fo.isAbrupt) {
                return fo;
            }
            // 4. b. iii. Perform envRec.InitializeBinding(fn, fo).
            envRec.InitializeBinding(ctx, fn, fo);
        }
    }
    return ctx.Realm['[[Intrinsics]]'].empty;
}
// http://www.ecma-international.org/ecma-262/#sec-isconstructor
function IsConstructor(ctx, argument) {
    const intrinsics = ctx.Realm['[[Intrinsics]]'];
    // 1. If Type(argument) is not Object, return false.
    if (!argument.isObject) {
        return intrinsics.false.GetValue(ctx)['[[Value]]'];
    }
    // 2. If argument has a [[Construct]] internal method, return true.
    if (argument instanceof $Function && argument['[[Construct]]'] !== void 0) {
        return intrinsics.true.GetValue(ctx)['[[Value]]'];
    }
    // 3. Return false.
    return intrinsics.false.GetValue(ctx)['[[Value]]'];
}
function $decoratorList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    if (nodes.length === 1) {
        return [new $Decorator(nodes[0], parent, ctx, 0)];
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $Decorator(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
// Simple property accessors used for some map/flatMap/some/every operations,
// to avoid allocating a new arrow function for each of those calls.
function getContainsExpression(obj) { return obj.ContainsExpression; }
function getHasInitializer(obj) { return obj.HasInitializer; }
function getIsSimpleParameterList(obj) { return obj.IsSimpleParameterList; }
function getBoundNames(obj) { return obj.BoundNames; }
function getLexicallyDeclaredNames(obj) { return obj.LexicallyDeclaredNames; }
function getLexicallyScopedDeclarations(obj) { return obj.LexicallyScopedDeclarations; }
function getVarDeclaredNames(obj) { return obj.VarDeclaredNames; }
function getVarScopedDeclarations(obj) { return obj.VarScopedDeclarations; }
function getLocalName(obj) { return obj.LocalName; }
function getImportEntriesForModule(obj) { return obj.ImportEntriesForModule; }
function getExportedNames(obj) { return obj.ExportedNames; }
function getExportEntriesForModule(obj) { return obj.ExportEntriesForModule; }
function getReferencedBindings(obj) { return obj.ReferencedBindings; }
function $heritageClauseList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = Array(len);
    for (let i = 0; i < len; ++i) {
        $nodes[i] = new $HeritageClause(nodes[i], parent, ctx, i);
    }
    return $nodes;
}
function $$classElementList(nodes, parent, ctx) {
    if (nodes === void 0 || nodes.length === 0) {
        return kernel.emptyArray;
    }
    const len = nodes.length;
    const $nodes = [];
    let $node;
    let node;
    for (let i = 0; i < len; ++i) {
        node = nodes[i];
        if (node.body !== void 0) {
            $node = $$classElement(nodes[i], parent, ctx, i);
            if ($node !== void 0) {
                $nodes.push($node);
            }
        }
    }
    return $nodes;
}
function $$classElement(node, parent, ctx, idx) {
    switch (node.kind) {
        case typescript.SyntaxKind.PropertyDeclaration:
            return new $PropertyDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.SemicolonClassElement:
            return new $SemicolonClassElement(node, parent, ctx, idx);
        case typescript.SyntaxKind.MethodDeclaration:
            return new $MethodDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.Constructor:
            return new $ConstructorDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.GetAccessor:
            return new $GetAccessorDeclaration(node, parent, ctx, idx);
        case typescript.SyntaxKind.SetAccessor:
            return new $SetAccessorDeclaration(node, parent, ctx, idx);
        default:
            return void 0;
    }
}
// #endregion
function hasBit(flag, bit) {
    return (flag & bit) > 0;
}
function hasAllBits(flag, bit) {
    return (flag & bit) === bit;
}
function clearBit(flag, bit) {
    return (flag | bit) ^ bit;
}
var Context;
(function (Context) {
    Context[Context["None"] = 0] = "None";
    Context[Context["Dynamic"] = 2] = "Dynamic";
    Context[Context["InVariableStatement"] = 4] = "InVariableStatement";
    Context[Context["IsBindingName"] = 8] = "IsBindingName";
    Context[Context["InParameterDeclaration"] = 16] = "InParameterDeclaration";
    Context[Context["InCatchClause"] = 32] = "InCatchClause";
    Context[Context["InBindingPattern"] = 64] = "InBindingPattern";
    Context[Context["InTypeElement"] = 128] = "InTypeElement";
    Context[Context["IsPropertyAccessName"] = 256] = "IsPropertyAccessName";
    Context[Context["IsMemberName"] = 512] = "IsMemberName";
    Context[Context["IsLabel"] = 1024] = "IsLabel";
    Context[Context["IsLabelReference"] = 2048] = "IsLabelReference";
    Context[Context["InExport"] = 4096] = "InExport";
    Context[Context["IsConst"] = 8192] = "IsConst";
    Context[Context["IsLet"] = 16384] = "IsLet";
    Context[Context["IsBlockScoped"] = 24576] = "IsBlockScoped";
    Context[Context["IsVar"] = 32768] = "IsVar";
    Context[Context["IsFunctionScoped"] = 32768] = "IsFunctionScoped";
    Context[Context["InStrictMode"] = 65536] = "InStrictMode";
})(Context || (Context = {}));
const modifiersToModifierFlags = (function () {
    const lookup = Object.assign(Object.create(null), {
        [typescript.SyntaxKind.ConstKeyword]: typescript.ModifierFlags.Const,
        [typescript.SyntaxKind.DefaultKeyword]: typescript.ModifierFlags.Default,
        [typescript.SyntaxKind.ExportKeyword]: typescript.ModifierFlags.Export,
        [typescript.SyntaxKind.AsyncKeyword]: typescript.ModifierFlags.Async,
        [typescript.SyntaxKind.PrivateKeyword]: typescript.ModifierFlags.Private,
        [typescript.SyntaxKind.ProtectedKeyword]: typescript.ModifierFlags.Protected,
        [typescript.SyntaxKind.PublicKeyword]: typescript.ModifierFlags.Public,
        [typescript.SyntaxKind.StaticKeyword]: typescript.ModifierFlags.Static,
        [typescript.SyntaxKind.AbstractKeyword]: typescript.ModifierFlags.Abstract,
        [typescript.SyntaxKind.DeclareKeyword]: typescript.ModifierFlags.Ambient,
        [typescript.SyntaxKind.ReadonlyKeyword]: typescript.ModifierFlags.Readonly,
    });
    return function (mods) {
        if (mods === void 0) {
            return typescript.ModifierFlags.None;
        }
        const len = mods.length;
        if (len === 1) {
            // todo(fred): bigopon added these cast, as it causes issues to the build
            //             it's from existing working code, though the cast is really weird when the lookup only has a few keys
            return lookup[mods[0].kind];
        }
        else if (len === 2) {
            return lookup[mods[0].kind] + lookup[mods[1].kind];
        }
        else if (len === 3) {
            return lookup[mods[0].kind]
                + lookup[mods[1].kind]
                + lookup[mods[2].kind];
        }
        else {
            // More than 4 modifiers is not possible
            return lookup[mods[0].kind]
                + lookup[mods[1].kind]
                + lookup[mods[2].kind]
                + lookup[mods[3].kind];
        }
    };
})();
var FunctionKind;
(function (FunctionKind) {
    FunctionKind[FunctionKind["normal"] = 0] = "normal";
    FunctionKind[FunctionKind["nonConstructor"] = 1] = "nonConstructor";
    FunctionKind[FunctionKind["classConstructor"] = 2] = "classConstructor";
    FunctionKind[FunctionKind["generator"] = 4] = "generator";
    FunctionKind[FunctionKind["async"] = 8] = "async";
    FunctionKind[FunctionKind["asyncGenerator"] = 12] = "asyncGenerator";
})(FunctionKind || (FunctionKind = {}));
/**
 * Returns the indexed string representation, or an empty string if the number is -1.
 */
function $i(idx) {
    return idx === -1 ? '' : `[${idx}]`;
}

// http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects
class $ArgumentsExoticObject extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-createmappedargumentsobject
    // 9.4.4.7 CreateMappedArgumentsObject ( func , formals , argumentsList , env )
    constructor(realm, func, formals, argumentsList, env) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'ArgumentsExoticObject', intrinsics['%ObjectPrototype%'], 1 /* normal */, intrinsics.empty);
        const ctx = realm.stack.top;
        // 1. Assert: formals does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.
        // 2. Let len be the number of elements in argumentsList.
        const len = argumentsList.length;
        // 3. Let obj be a newly created arguments exotic object with a [[ParameterMap]] internal slot.
        // 4. Set obj.[[GetOwnProperty]] as specified in 9.4.4.1.
        // 5. Set obj.[[DefineOwnProperty]] as specified in 9.4.4.2.
        // 6. Set obj.[[Get]] as specified in 9.4.4.3.
        // 7. Set obj.[[Set]] as specified in 9.4.4.4.
        // 8. Set obj.[[Delete]] as specified in 9.4.4.5.
        // 9. Set the remainder of obj's essential internal methods to the default ordinary object definitions specified in 9.1.
        // 10. Set obj.[[Prototype]] to %ObjectPrototype%.
        // 11. Set obj.[[Extensible]] to true.
        // 12. Let map be ObjectCreate(null).
        const map = new $Object(realm, '[[ParameterMap]]', intrinsics.null, 1 /* normal */, intrinsics.empty);
        // 13. Set obj.[[ParameterMap]] to map.
        this['[[ParameterMap]]'] = map;
        // 14. Let parameterNames be the BoundNames of formals.
        const parameterNames = formals.flatMap(getBoundNames);
        // 15. Let numberOfParameters be the number of elements in parameterNames.
        const numberOfParameters = parameterNames.length;
        // 16. Let index be 0.
        let index = 0;
        // 17. Repeat, while index < len,
        while (index < len) {
            // 17. a. Let val be argumentsList[index].
            const val = argumentsList[index];
            // 17. b. Perform CreateDataProperty(obj, ! ToString(index), val).
            $CreateDataProperty(ctx, this, new $String(realm, index.toString()), val);
            // 17. c. Increase index by 1.
            ++index;
        }
        // 18. Perform DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
        const desc = new $PropertyDescriptor(realm, intrinsics.length);
        desc['[[Value]]'] = new $Number(realm, len);
        // 19. Let mappedNames be a new empty List.
        const mappedNames = [];
        // 20. Let index be numberOfParameters - 1.
        index = numberOfParameters - 1;
        // 21. Repeat, while index ≥ 0,
        while (index >= 0) {
            // 21. a. Let name be parameterNames[index].
            const name = parameterNames[index];
            // 21. b. If name is not an element of mappedNames, then
            if (!mappedNames.some(x => x.is(name))) {
                // 21. b. i. Add name as an element of the list mappedNames.
                mappedNames.push(name);
                // 21. b. ii. If index < len, then
                if (index < len) {
                    // 21. b. ii. 1. Let g be MakeArgGetter(name, env).
                    const g = new $ArgGetter(realm, name, env);
                    // 21. b. ii. 2. Let p be MakeArgSetter(name, env).
                    const p = new $ArgSetter(realm, name, env);
                    // 21. b. ii. 3. Perform map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true }).
                    const desc = new $PropertyDescriptor(realm, new $String(realm, index.toString()), {
                        '[[Set]]': p,
                        '[[Get]]': g,
                        '[[Enumerable]]': intrinsics.false,
                        '[[Configurable]]': intrinsics.true,
                    });
                    map['[[DefineOwnProperty]]'](ctx, desc.name, desc);
                }
            }
            // 21. c. Decrease index by 1.
            --index;
        }
        // 22. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
        const iteratorDesc = new $PropertyDescriptor(realm, intrinsics['@@iterator'], {
            '[[Value]]': intrinsics['%ArrayProto_values%'],
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.true,
        });
        $DefinePropertyOrThrow(ctx, this, iteratorDesc.name, iteratorDesc);
        // 23. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
        const calleeDesc = new $PropertyDescriptor(realm, intrinsics.$callee, {
            '[[Value]]': func,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.true,
        });
        $DefinePropertyOrThrow(ctx, this, calleeDesc.name, calleeDesc);
        // 24. Return obj.
    }
    // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-getownproperty-p
    // 9.4.4.1 [[GetOwnProperty]] ( P )
    '[[GetOwnProperty]]'(ctx, P) {
        // 1. Let args be the arguments object.
        // 2. Let desc be OrdinaryGetOwnProperty(args, P).
        const desc = super['[[GetOwnProperty]]'](ctx, P);
        // 3. If desc is undefined, return desc.
        if (desc.isUndefined) {
            return desc;
        }
        // 4. Let map be args.[[ParameterMap]].
        const map = this['[[ParameterMap]]'];
        // 5. Let isMapped be ! HasOwnProperty(map, P).
        const isMapped = $HasOwnProperty(ctx, map, P).isTruthy;
        // 6. If isMapped is true, then
        if (isMapped) {
            // 6. a. Set desc.[[Value]] to Get(map, P).
            desc['[[Value]]'] = map['[[Get]]'](ctx, P, map);
        }
        // 7. Return desc.
        return desc;
    }
    // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-defineownproperty-p-desc
    // 9.4.4.2 [[DefineOwnProperty]] ( P , Desc )
    '[[DefineOwnProperty]]'(ctx, P, Desc) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let args be the arguments object.
        // 2. Let map be args.[[ParameterMap]].
        const map = this['[[ParameterMap]]'];
        // 3. Let isMapped be HasOwnProperty(map, P).
        const isMapped = $HasOwnProperty(ctx, map, P).isTruthy;
        // 4. Let newArgDesc be Desc.
        let newArgDesc = Desc;
        // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then
        if (isMapped && $IsDataDescriptor(Desc)) {
            // 5. a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then
            if (Desc['[[Value]]'].isEmpty && Desc['[[Writable]]'].hasValue && Desc['[[Writable]]'].isFalsey) {
                // 5. a. i. Set newArgDesc to a copy of Desc.
                newArgDesc = new $PropertyDescriptor(Desc.realm, Desc.name, {
                    // 5. a. ii. Set newArgDesc.[[Value]] to Get(map, P).
                    '[[Value]]': map['[[Get]]'](ctx, P, map),
                    '[[Writable]]': Desc['[[Writable]]'],
                    '[[Enumerable]]': Desc['[[Enumerable]]'],
                    '[[Configurable]]': Desc['[[Configurable]]'],
                });
            }
        }
        // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).
        const allowed = super['[[DefineOwnProperty]]'](ctx, P, newArgDesc);
        if (allowed.isAbrupt) {
            return allowed;
        }
        // 7. If allowed is false, return false.
        if (allowed.isFalsey) {
            return allowed;
        }
        // 8. If isMapped is true, then
        if (isMapped) {
            // 8. a. If IsAccessorDescriptor(Desc) is true, then
            if (Desc.isAccessorDescriptor) {
                // 8. a. i. Call map.[[Delete]](P).
                map['[[Delete]]'](ctx, P);
            }
        }
        // 8. b. Else,
        else {
            // 8. b. i. If Desc.[[Value]] is present, then
            if (Desc['[[Value]]'].hasValue) {
                // 8. b. i. 1. Let setStatus be Set(map, P, Desc.[[Value]], false).
                $Set(ctx, map, P, Desc['[[Value]]'], intrinsics.false);
                // 8. b. i. 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.
                // 8. b. ii. If Desc.[[Writable]] is present and its value is false, then
                if (Desc['[[Writable]]'].hasValue && Desc['[[Writable]]'].isFalsey) {
                    // 8. b. ii. 1. Call map.[[Delete]](P).
                    map['[[Delete]]'](ctx, P);
                }
            }
        }
        // 9. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-get-p-receiver
    // 9.4.4.3 [[Get]] ( P , Receiver )
    '[[Get]]'(ctx, P, Receiver) {
        // 1. Let args be the arguments object.
        // 2. Let map be args.[[ParameterMap]].
        const map = this['[[ParameterMap]]'];
        // 3. Let isMapped be ! HasOwnProperty(map, P).
        const isMapped = $HasOwnProperty(ctx, map, P).isTruthy;
        // 4. If isMapped is false, then
        if (!isMapped) {
            // 4. a. Return ? OrdinaryGet(args, P, Receiver).
            return super['[[Get]]'](ctx, P, Receiver);
        }
        // 5. Else map contains a formal parameter mapping for P,
        else {
            // 5. a. Return Get(map, P).
            return map['[[Get]]'](ctx, P, map);
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-set-p-v-receiver
    // 9.4.4.4 [[Set]] ( P , V , Receiver )
    '[[Set]]'(ctx, P, V, Receiver) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let args be the arguments object.
        // 2. If SameValue(args, Receiver) is false, then
        // 2. a. Let isMapped be false.
        // 3. Else,
        // 3. a. Let map be args.[[ParameterMap]].
        // 3. b. Let isMapped be ! HasOwnProperty(map, P).
        // 4. If isMapped is true, then
        // 4. a. Let setStatus be Set(map, P, V, false).
        // 4. b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.
        // 5. Return ? OrdinarySet(args, P, V, Receiver).
        if (this.is(Receiver)) {
            const map = this['[[ParameterMap]]'];
            const isMapped = $HasOwnProperty(ctx, map, P).isTruthy;
            if (isMapped) {
                $Set(ctx, map, P, V, intrinsics.false);
            }
        }
        return super['[[Set]]'](ctx, P, V, Receiver);
    }
    // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-delete-p
    // 9.4.4.5 [[Delete]] ( P )
    '[[Delete]]'(ctx, P) {
        // 1. Let args be the arguments object.
        // 2. Let map be args.[[ParameterMap]].
        const map = this['[[ParameterMap]]'];
        // 3. Let isMapped be ! HasOwnProperty(map, P).
        const isMapped = $HasOwnProperty(ctx, map, P).isTruthy;
        // 4. Let result be ? OrdinaryDelete(args, P).
        const result = super['[[Delete]]'](ctx, P);
        if (result.isAbrupt) {
            return result;
        }
        // 5. If result is true and isMapped is true, then
        if (result.isTruthy && isMapped) {
            // 5. a. Call map.[[Delete]](P).
            map['[[Delete]]'](ctx, P);
        }
        // 6. Return result.
        return result;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-makearggetter
class $ArgGetter extends $BuiltinFunction {
    constructor(realm, name, env) {
        super(realm, 'ArgGetter', realm['[[Intrinsics]]']['%FunctionPrototype%']);
        // 3. Set getter.[[Name]] to name.
        this['[[Name]]'] = name;
        // 4. Set getter.[[Env]] to env.
        this['[[Env]]'] = env;
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let f be the active function object.
        // 2. Let name be f.[[Name]].
        const name = this['[[Name]]'];
        // 3. Let env be f.[[Env]].
        const env = this['[[Env]]'];
        // 4. Return env.GetBindingValue(name, false).
        return env.GetBindingValue(ctx, name, intrinsics.false);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-makeargsetter
class $ArgSetter extends $BuiltinFunction {
    constructor(realm, name, env) {
        super(realm, 'ArgSetter', realm['[[Intrinsics]]']['%FunctionPrototype%']);
        // 3. Set getter.[[Name]] to name.
        this['[[Name]]'] = name;
        // 4. Set getter.[[Env]] to env.
        this['[[Env]]'] = env;
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let f be the active function object.
        // 2. Let name be f.[[Name]].
        const name = this['[[Name]]'];
        // 3. Let env be f.[[Env]].
        const env = this['[[Env]]'];
        // 4. Return env.SetMutableBinding(name, value, false).
        return env.SetMutableBinding(ctx, name, value, intrinsics.false); // TODO: we probably need to change the signature of performSteps to return $Any but that may open a new can of worms, so leave it for now and revisit when we're further down the road and implemented more natives
    }
}
// http://www.ecma-international.org/ecma-262/#sec-createunmappedargumentsobject
function $CreateUnmappedArgumentsObject(ctx, argumentsList) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let len be the number of elements in argumentsList.
    const len = argumentsList.length;
    // 2. Let obj be ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »).
    const obj = $Object.ObjectCreate(ctx, 'UnmappedArgumentsObject', intrinsics['%ObjectPrototype%'], {
        '[[ParameterMap]]': intrinsics.undefined,
    });
    // 3. Set obj.[[ParameterMap]] to undefined.
    // 4. Perform DefinePropertyOrThrow(obj, "length", PropertyDescriptor { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
    $DefinePropertyOrThrow(ctx, obj, intrinsics.length, new $PropertyDescriptor(realm, intrinsics.length, {
        '[[Value]]': new $Number(realm, len),
        '[[Writable]]': intrinsics.true,
        '[[Enumerable]]': intrinsics.false,
        '[[Configurable]]': intrinsics.true,
    }));
    // 5. Let index be 0.
    let index = 0;
    // 6. Repeat, while index < len,
    while (index < len) {
        // 6. a. Let val be argumentsList[index].
        const val = argumentsList[index];
        // 6. b. Perform CreateDataProperty(obj, ! ToString(index), val).
        $CreateDataProperty(ctx, obj, new $String(realm, index.toString()), val);
        // 6. c. Increase index by 1.
        ++index;
    }
    // 7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).
    $DefinePropertyOrThrow(ctx, obj, intrinsics['@@iterator'], new $PropertyDescriptor(realm, intrinsics['@@iterator'], {
        '[[Value]]': intrinsics['%ArrayProto_values%'],
        '[[Writable]]': intrinsics.true,
        '[[Enumerable]]': intrinsics.false,
        '[[Configurable]]': intrinsics.true,
    }));
    // 8. Perform ! DefinePropertyOrThrow(obj, "callee", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false }).
    $DefinePropertyOrThrow(ctx, obj, intrinsics.$callee, new $PropertyDescriptor(realm, intrinsics.$callee, {
        '[[Get]]': intrinsics['%ThrowTypeError%'],
        '[[Set]]': intrinsics['%ThrowTypeError%'],
        '[[Enumerable]]': intrinsics.false,
        '[[Configurable]]': intrinsics.false,
    }));
    // 9. Return obj.
    return obj;
}

class $FormalParameterList extends Array {
    constructor(nodes, parent, ctx) {
        super();
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-containsexpression
        // 14.1.5 Static Semantics: ContainsExpression
        this.ContainsExpression = false;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-expectedargumentcount
        // 14.1.7 Static Semantics: ExpectedArgumentCount
        this.ExpectedArgumentCount = 0;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-hasinitializer
        // 14.1.8 Static Semantics: HasInitializer
        this.HasInitializer = false;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-issimpleparameterlist
        // 14.1.13 Static Semantics: IsSimpleParameterList
        this.IsSimpleParameterList = true;
        this.hasDuplicates = false;
        if (nodes === void 0) {
            this.BoundNames = kernel.emptyArray;
        }
        else {
            const BoundNames = this.BoundNames = [];
            const seenNames = new Set();
            let boundNamesLen = 0;
            let cur;
            let curBoundNames;
            let curBoundName;
            for (let i = 0, ii = nodes.length; i < ii; ++i) {
                cur = super[i] = new $ParameterDeclaration(nodes[i], parent, ctx, i);
                curBoundNames = cur.BoundNames;
                for (let j = 0, jj = curBoundNames.length; j < jj; ++j) {
                    curBoundName = curBoundNames[j];
                    if (seenNames.has(curBoundName['[[Value]]'])) {
                        this.hasDuplicates = true;
                    }
                    else {
                        seenNames.add(curBoundName['[[Value]]']);
                    }
                    BoundNames[boundNamesLen++] = curBoundName;
                }
                if (cur.ContainsExpression && !this.ContainsExpression) {
                    this.ContainsExpression = true;
                }
                if (cur.HasInitializer && !this.HasInitializer) {
                    this.HasInitializer = true;
                    this.ExpectedArgumentCount = i;
                }
                if (!cur.IsSimpleParameterList && this.IsSimpleParameterList) {
                    this.IsSimpleParameterList = false;
                }
            }
            if (!this.HasInitializer) {
                this.ExpectedArgumentCount = nodes.length;
            }
        }
    }
}
class $FunctionExpression {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.FunctionExpression`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isconstantdeclaration
        // 14.1.11 Static Semantics: IsConstantDeclaration
        this.IsConstantDeclaration = false;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isfunctiondefinition
        // 14.1.12 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = true;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        const DirectivePrologue = this.DirectivePrologue = GetDirectivePrologue(node.body.statements);
        if (DirectivePrologue.ContainsUseStrict) {
            ctx |= 65536 /* InStrictMode */;
        }
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        this.$parameters = new $FormalParameterList(node.parameters, this, ctx);
        const $body = this.$body = new $Block(node.body, this, ctx, -1);
        this.BoundNames = kernel.emptyArray;
        this.ContainsUseStrict = DirectivePrologue.ContainsUseStrict === true;
        this.HasName = $name !== void 0;
        this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;
        this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;
        this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;
        if (!hasBit(modifierFlags, typescript.ModifierFlags.Async)) {
            if (node.asteriskToken === void 0) {
                this.functionKind = 0 /* normal */;
            }
            else {
                this.functionKind = 4 /* generator */;
            }
        }
        else if (node.asteriskToken === void 0) {
            this.functionKind = 8 /* async */;
        }
        else {
            this.functionKind = 12 /* asyncGenerator */;
        }
    }
    get $kind() { return typescript.SyntaxKind.FunctionExpression; }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        return EvaluateBody(this, ctx, functionObject, argumentsList);
    }
    Evaluate(ctx) {
        switch (this.functionKind) {
            case 0 /* normal */:
                return this.$Evaluate(ctx);
            case 4 /* generator */:
                return this.$EvaluateGenerator(ctx);
            case 12 /* asyncGenerator */:
                return this.$EvaluateAsyncGenerator(ctx);
            case 8 /* async */:
                return this.$EvaluateAsync(ctx);
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluation
    // 14.1.22 Runtime Semantics: Evaluation
    $Evaluate(ctx) {
        var _a, _b;
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.$Evaluate(#${ctx.id})`);
        // FunctionExpression :
        //     function ( FormalParameters ) { FunctionBody }
        // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
        // 2. Let scope be the LexicalEnvironment of the running execution context.
        // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).
        // 4. Perform MakeConstructor(closure).
        // 5. Set closure.[[SourceText]] to the source text matched by FunctionExpression.
        // 6. Return closure.
        // FunctionExpression :
        //     function BindingIdentifier ( FormalParameters ) { FunctionBody }
        // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 3. Let funcEnv be NewDeclarativeEnvironment(scope).
        const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);
        // 4. Let envRec be funcEnv's EnvironmentRecord.
        // 5. Let name be StringValue of BindingIdentifier.
        const name = (_b = (_a = this.$name) === null || _a === void 0 ? void 0 : _a.StringValue) !== null && _b !== void 0 ? _b : void 0;
        if (name !== void 0) {
            // 6. Perform envRec.CreateImmutableBinding(name, false).
            funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false);
        }
        // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).
        const closure = $Function.FunctionCreate(ctx, 'normal', this, funcEnv, strict);
        // 8. Perform MakeConstructor(closure).
        closure.MakeConstructor(ctx);
        if (name !== void 0) {
            // 9. Perform SetFunctionName(closure, name).
            closure.SetFunctionName(ctx, name);
        }
        // 10. Set closure.[[SourceText]] to the source text matched by FunctionExpression.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        if (name !== void 0) {
            // 11. Perform envRec.InitializeBinding(name, closure).
            funcEnv.InitializeBinding(ctx, name, closure);
        }
        // 12. Return closure.
        return closure;
    }
    // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-evaluation
    // 14.4.14 Runtime Semantics: Evaluation
    $EvaluateGenerator(ctx) {
        var _a, _b;
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.$EvaluateGenerator(#${ctx.id})`);
        // GeneratorExpression :
        //     function * ( FormalParameters ) { GeneratorBody }
        // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
        // 2. Let scope be the LexicalEnvironment of the running execution context.
        // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).
        // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).
        // 5. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        // 6. Set closure.[[SourceText]] to the source text matched by GeneratorExpression.
        // 7. Return closure.
        // GeneratorExpression :
        //     function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
        // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 3. Let funcEnv be NewDeclarativeEnvironment(scope).
        const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);
        // 4. Let envRec be funcEnv's EnvironmentRecord.
        // 5. Let name be StringValue of BindingIdentifier.
        const name = (_b = (_a = this.$name) === null || _a === void 0 ? void 0 : _a.StringValue) !== null && _b !== void 0 ? _b : void 0;
        if (name !== void 0) {
            // 6. Perform envRec.CreateImmutableBinding(name, false).
            funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false);
        }
        // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).
        const closure = $Function.GeneratorFunctionCreate(ctx, 'normal', this, funcEnv, strict);
        // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).
        const prototype = $Object.ObjectCreate(ctx, 'Generator', intrinsics['%GeneratorPrototype%']);
        // 9. Perform DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(ctx, closure, intrinsics.$prototype, new $PropertyDescriptor(realm, intrinsics.$prototype, {
            '[[Value]]': prototype,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
        if ($DefinePropertyOrThrowResult.isAbrupt) {
            return $DefinePropertyOrThrowResult.enrichWith(ctx, this);
        }
        if (name !== void 0) {
            // 10. Perform SetFunctionName(closure, name).
            closure.SetFunctionName(ctx, name);
            // 11. Perform envRec.InitializeBinding(name, closure).
            funcEnv.InitializeBinding(ctx, name, closure);
        }
        // 12. Set closure.[[SourceText]] to the source text matched by GeneratorExpression.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 13. Return closure.
        return closure;
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-definitions-evaluation
    // 14.5.14 Runtime Semantics: Evaluation
    $EvaluateAsyncGenerator(ctx) {
        var _a, _b;
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.$EvaluateAsyncGenerator(#${ctx.id})`);
        // AsyncGeneratorExpression :
        //     async function * ( FormalParameters ) { AsyncGeneratorBody }
        // 1. If the function code for this AsyncGeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
        // 2. Let scope be the LexicalEnvironment of the running execution context.
        // 3. Let closure be ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict).
        // 4. Let prototype be ! ObjectCreate(%AsyncGeneratorPrototype%).
        // 5. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        // 6. Set closure.[[SourceText]] to the source text matched by AsyncGeneratorExpression.
        // 7. Return closure.
        // AsyncGeneratorExpression :
        //     async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
        // 1. If the function code for this AsyncGeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 3. Let funcEnv be ! NewDeclarativeEnvironment(scope).
        const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);
        // 4. Let envRec be funcEnv's EnvironmentRecord.
        // 5. Let name be StringValue of BindingIdentifier.
        const name = (_b = (_a = this.$name) === null || _a === void 0 ? void 0 : _a.StringValue) !== null && _b !== void 0 ? _b : void 0;
        if (name !== void 0) {
            // 6. Perform ! envRec.CreateImmutableBinding(name).
            funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false); // TODO: we sure about this?
        }
        // 7. Let closure be ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, funcEnv, strict).
        const closure = $Function.AsyncGeneratorFunctionCreate(ctx, 'normal', this, funcEnv, strict);
        // 8. Let prototype be ! ObjectCreate(%AsyncGeneratorPrototype%).
        const prototype = $Object.ObjectCreate(ctx, 'AsyncGenerator', intrinsics['%AsyncGeneratorPrototype%']);
        // 9. Perform ! DefinePropertyOrThrow(closure, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(ctx, closure, intrinsics.$prototype, new $PropertyDescriptor(realm, intrinsics.$prototype, {
            '[[Value]]': prototype,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
        if ($DefinePropertyOrThrowResult.isAbrupt) {
            return $DefinePropertyOrThrowResult.enrichWith(ctx, this);
        }
        if (name !== void 0) {
            // 10. Perform SetFunctionName(closure, name).
            closure.SetFunctionName(ctx, name);
            // 11. Perform envRec.InitializeBinding(name, closure).
            funcEnv.InitializeBinding(ctx, name, closure);
        }
        // 12. Set closure.[[SourceText]] to the source text matched by AsyncGeneratorExpression.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 13. Return closure.
        return closure;
    }
    // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-runtime-semantics-evaluation
    // 14.7.14 Runtime Semantics: Evaluation
    $EvaluateAsync(ctx) {
        var _a, _b;
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.$EvaluateAsync(#${ctx.id})`);
        // AsyncFunctionExpression :
        //     async function ( FormalParameters ) { AsyncFunctionBody }
        // 1. If the function code for AsyncFunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
        // 2. Let scope be the LexicalEnvironment of the running execution context.
        // 3. Let closure be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).
        // 4. Set closure.[[SourceText]] to the source text matched by AsyncFunctionExpression.
        // 5. Return closure.
        // AsyncFunctionExpression :
        //     async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
        // 1. If the function code for AsyncFunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let scope be the LexicalEnvironment of the running execution context.
        const scope = ctx.LexicalEnvironment;
        // 3. Let funcEnv be ! NewDeclarativeEnvironment(scope).
        const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);
        // 4. Let envRec be funcEnv's EnvironmentRecord.
        // 5. Let name be StringValue of BindingIdentifier.
        const name = (_b = (_a = this.$name) === null || _a === void 0 ? void 0 : _a.StringValue) !== null && _b !== void 0 ? _b : void 0;
        if (name !== void 0) {
            // 6. Perform ! envRec.CreateImmutableBinding(name).
            funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false); // TODO: we sure about this?
        }
        // 7. Let closure be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, funcEnv, strict).
        const closure = $Function.AsyncFunctionCreate(ctx, 'normal', this, funcEnv, strict);
        if (name !== void 0) {
            // 8. Perform ! SetFunctionName(closure, name).
            closure.SetFunctionName(ctx, name);
            // 9. Perform ! envRec.InitializeBinding(name, closure).
            funcEnv.InitializeBinding(ctx, name, closure);
        }
        // 10. Set closure.[[SourceText]] to the source text matched by AsyncFunctionExpression.
        closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 11. Return closure.
        return closure;
    }
    EvaluateNamed(ctx, name) {
        ctx.checkTimeout();
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-namedevaluation
        // 14.1.21 Runtime Semantics: NamedEvaluation
        // FunctionExpression :
        //     function ( FormalParameters ) { FunctionBody }
        // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-namedevaluation
        // 14.4.13 Runtime Semantics: NamedEvaluation
        // GeneratorExpression :
        //     function * ( FormalParameters ) { GeneratorBody }
        // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-definitions-namedevaluation
        // 14.5.13 Runtime Semantics: NamedEvaluation
        // AsyncGeneratorExpression :
        //     async function * ( FormalParameters ) { AsyncGeneratorBody }
        // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-runtime-semantics-namedevaluation
        // 14.7.13 Runtime Semantics: NamedEvaluation
        // AsyncFunctionExpression :
        //     async function ( FormalParameters ) { AsyncFunctionBody }
        // FunctionExpression : function ( FormalParameters ) { FunctionBody }
        // 1. Let closure be the result of evaluating this FunctionExpression.
        // 1. Let closure be the result of evaluating this GeneratorExpression.
        // 1. Let closure be the result of evaluating this AsyncGeneratorExpression.
        // 1. Let closure be the result of evaluating this AsyncFunctionExpression.
        const closure = this.Evaluate(ctx);
        if (closure.isAbrupt) {
            return closure.enrichWith(ctx, this);
        }
        // 2. Perform SetFunctionName(closure, name).
        closure.SetFunctionName(ctx, name);
        // 3. Return closure.
        return closure;
    }
}
class $FunctionDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.FunctionDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isconstantdeclaration
        // 14.1.11 Static Semantics: IsConstantDeclaration
        // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-isconstantdeclaration
        // 14.4.7 Static Semantics: IsConstantDeclaration
        // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-isconstantdeclaration
        // 14.5.7 Static Semantics: IsConstantDeclaration
        // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-IsConstantDeclaration
        // 14.7.7 Static Semantics: IsConstantDeclaration
        this.IsConstantDeclaration = false;
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isfunctiondefinition
        // 14.1.12 Static Semantics: IsFunctionDefinition
        // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-isfunctiondefinition
        // 14.4.8 Static Semantics: IsFunctionDefinition
        // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-isfunctiondefinition
        // 14.5.8 Static Semantics: IsFunctionDefinition
        // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-IsFunctionDefinition
        // 14.7.8 Static Semantics: IsFunctionDefinition
        this.IsFunctionDefinition = true;
        // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-modulerequests
        // 15.2.3.9 Static Semantics: ModuleRequests
        this.ModuleRequests = kernel.emptyArray;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const intrinsics = realm['[[Intrinsics]]'];
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (hasBit(modifierFlags, typescript.ModifierFlags.Export)) {
            ctx |= 4096 /* InExport */;
        }
        const DirectivePrologue = this.DirectivePrologue = GetDirectivePrologue(node.body.statements);
        if (this.DirectivePrologue.ContainsUseStrict) {
            ctx |= 65536 /* InStrictMode */;
        }
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        const $name = this.$name = $identifier(node.name, this, ctx, -1);
        this.$parameters = new $FormalParameterList(node.parameters, this, ctx);
        const $body = this.$body = new $Block(node.body, this, ctx, -1);
        this.ContainsUseStrict = DirectivePrologue.ContainsUseStrict === true;
        const HasName = this.HasName = $name !== void 0;
        this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;
        this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;
        this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;
        if ($name === void 0) {
            this.PropName = new $Undefined(realm);
        }
        else {
            this.PropName = $name.PropName;
        }
        if (hasBit(ctx, 4096 /* InExport */)) {
            if (hasBit(this.modifierFlags, typescript.ModifierFlags.Default)) {
                if (HasName) {
                    const [localName] = $name.BoundNames;
                    const BoundNames = this.BoundNames = [localName, intrinsics['*default*']];
                    this.ExportedBindings = BoundNames;
                    this.ExportedNames = [intrinsics['default']];
                    this.ExportEntries = [
                        new ExportEntryRecord(
                        /* source */ this, 
                        /* ExportName */ intrinsics['default'], 
                        /* ModuleRequest */ intrinsics.null, 
                        /* ImportName */ intrinsics.null, 
                        /* LocalName */ localName),
                    ];
                }
                else {
                    const BoundNames = this.BoundNames = [intrinsics['*default*']];
                    this.ExportedBindings = BoundNames;
                    this.ExportedNames = [intrinsics['default']];
                    this.ExportEntries = [
                        new ExportEntryRecord(
                        /* source */ this, 
                        /* ExportName */ intrinsics['default'], 
                        /* ModuleRequest */ intrinsics.null, 
                        /* ImportName */ intrinsics.null, 
                        /* LocalName */ intrinsics['*default*']),
                    ];
                }
            }
            else {
                // Must have a name, so we assume it does
                const BoundNames = this.BoundNames = $name.BoundNames;
                const [localName] = BoundNames;
                this.ExportedBindings = BoundNames;
                this.ExportedNames = BoundNames;
                this.ExportEntries = [
                    new ExportEntryRecord(
                    /* source */ this, 
                    /* ExportName */ localName, 
                    /* ModuleRequest */ intrinsics.null, 
                    /* ImportName */ intrinsics.null, 
                    /* LocalName */ localName),
                ];
            }
        }
        else {
            // Must have a name, so we assume it does
            this.BoundNames = $name.BoundNames;
            this.ExportedBindings = kernel.emptyArray;
            this.ExportedNames = kernel.emptyArray;
            this.ExportEntries = kernel.emptyArray;
        }
        if (!hasBit(modifierFlags, typescript.ModifierFlags.Async)) {
            if (node.asteriskToken === void 0) {
                this.functionKind = 0 /* normal */;
            }
            else {
                this.functionKind = 4 /* generator */;
            }
        }
        else if (node.asteriskToken === void 0) {
            this.functionKind = 8 /* async */;
        }
        else {
            this.functionKind = 12 /* asyncGenerator */;
        }
    }
    get $kind() { return typescript.SyntaxKind.FunctionDeclaration; }
    InstantiateFunctionObject(ctx, Scope) {
        switch (this.functionKind) {
            case 0 /* normal */:
                return this.$InstantiateFunctionObject(ctx, Scope);
            case 4 /* generator */:
                return this.$InstantiateGeneratorFunctionObject(ctx, Scope);
            case 12 /* asyncGenerator */:
                return this.$InstantiateAsyncGeneratorFunctionObject(ctx, Scope);
            case 8 /* async */:
                return this.$InstantiateAsyncFunctionObject(ctx, Scope);
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-instantiatefunctionobject
    // 14.1.20 Runtime Semantics: InstantiateFunctionObject
    $InstantiateFunctionObject(ctx, Scope) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // FunctionDeclaration :
        //     function ( FormalParameters ) { FunctionBody }
        // 1. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, true).
        // 2. Perform MakeConstructor(F).
        // 3. Perform SetFunctionName(F, "default").
        // 4. Set F.[[SourceText]] to the source text matched by FunctionDeclaration.
        // 5. Return F.
        // FunctionDeclaration :
        //     function BindingIdentifier ( FormalParameters ) { FunctionBody }
        // 1. If the function code for FunctionDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let name be StringValue of BindingIdentifier.
        const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;
        // 3. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).
        const F = $Function.FunctionCreate(ctx, 'normal', this, Scope, strict);
        // 4. Perform MakeConstructor(F).
        F.MakeConstructor(ctx);
        // 5. Perform SetFunctionName(F, name).
        F.SetFunctionName(ctx, name);
        // 6. Set F.[[SourceText]] to the source text matched by FunctionDeclaration.
        F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 7. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject
    // 14.4.11 Runtime Semantics: InstantiateFunctionObject
    $InstantiateGeneratorFunctionObject(ctx, Scope) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // GeneratorDeclaration :
        //     function * ( FormalParameters ) { GeneratorBody }
        // 1. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, true).
        // 2. Let prototype be ObjectCreate(%GeneratorPrototype%).
        // 3. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        // 4. Perform SetFunctionName(F, "default").
        // 5. Set F.[[SourceText]] to the source text matched by GeneratorDeclaration.
        // 6. Return F.
        // GeneratorDeclaration :
        //     function * BindingIdentifier ( FormalParameters ) { GeneratorBody }
        // 1. If the function code for GeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let name be StringValue of BindingIdentifier.
        const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;
        // 3. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).
        const F = $Function.GeneratorFunctionCreate(ctx, 'normal', this, Scope, strict);
        // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).
        const prototype = $Object.ObjectCreate(ctx, 'Generator', intrinsics['%GeneratorPrototype%']);
        // 5. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(ctx, F, intrinsics.$prototype, new $PropertyDescriptor(realm, intrinsics.$prototype, {
            '[[Value]]': prototype,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
        if ($DefinePropertyOrThrowResult.isAbrupt) {
            return $DefinePropertyOrThrowResult.enrichWith(ctx, this);
        }
        // 6. Perform SetFunctionName(F, name).
        F.SetFunctionName(ctx, name);
        // 7. Set F.[[SourceText]] to the source text matched by GeneratorDeclaration.
        F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 8. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-definitions-instantiatefunctionobject
    // 14.5.11 Runtime Semantics: InstantiateFunctionObject
    $InstantiateAsyncGeneratorFunctionObject(ctx, Scope) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // AsyncGeneratorDeclaration :
        //     async function * ( FormalParameters ) { AsyncGeneratorBody }
        // 1. If the function code for AsyncGeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
        // 2. Let F be AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict).
        // 3. Let prototype be ObjectCreate(%AsyncGeneratorPrototype%).
        // 4. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        // 5. Perform SetFunctionName(F, "default").
        // 6. Set F.[[SourceText]] to the source text matched by AsyncGeneratorDeclaration.
        // 7. Return F.
        // AsyncGeneratorDeclaration :
        //     async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }
        // 1. If the function code for AsyncGeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let name be StringValue of BindingIdentifier.
        const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;
        // 3. Let F be ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict).
        const F = $Function.GeneratorFunctionCreate(ctx, 'normal', this, Scope, strict);
        // 4. Let prototype be ! ObjectCreate(%AsyncGeneratorPrototype%).
        const prototype = $Object.ObjectCreate(ctx, 'AsyncGenerator', intrinsics['%AsyncGeneratorPrototype%']);
        // 5. Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(ctx, F, intrinsics.$prototype, new $PropertyDescriptor(realm, intrinsics.$prototype, {
            '[[Value]]': prototype,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
        if ($DefinePropertyOrThrowResult.isAbrupt) {
            return $DefinePropertyOrThrowResult.enrichWith(ctx, this);
        }
        // 6. Perform ! SetFunctionName(F, name).
        F.SetFunctionName(ctx, name);
        // 7. Set F.[[SourceText]] to the source text matched by AsyncGeneratorDeclaration.
        F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 8. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-InstantiateFunctionObject
    // 14.7.10 Runtime Semantics: InstantiateFunctionObject
    $InstantiateAsyncFunctionObject(ctx, Scope) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // AsyncFunctionDeclaration :
        //     async function ( FormalParameters ) { AsyncFunctionBody }
        // 1. If the function code for AsyncFunctionDeclaration is strict mode code, let strict be true. Otherwise, let strict be false.
        // 2. Let F be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).
        // 3. Perform ! SetFunctionName(F, "default").
        // 4. Set F.[[SourceText]] to the source text matched by AsyncFunctionDeclaration.
        // 5. Return F.
        // AsyncFunctionDeclaration :
        //     async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }
        // 1. If the function code for AsyncFunctionDeclaration is strict mode code, let strict be true. Otherwise, let strict be false.
        const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);
        // 2. Let name be StringValue of BindingIdentifier.
        const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;
        // 3. Let F be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).
        const F = $Function.GeneratorFunctionCreate(ctx, 'normal', this, Scope, strict);
        // 4. Perform ! SetFunctionName(F, name).
        F.SetFunctionName(ctx, name);
        // 5. Set F.[[SourceText]] to the source text matched by AsyncFunctionDeclaration.
        F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));
        // 6. Return F.
        return F;
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        return EvaluateBody(this, ctx, functionObject, argumentsList);
    }
    Evaluate(ctx) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluation
        // 14.1.22 Runtime Semantics: Evaluation
        // FunctionDeclaration :
        //     function BindingIdentifier ( FormalParameters ) { FunctionBody }
        // 1. Return NormalCompletion(empty).
        // FunctionDeclaration :
        //     function ( FormalParameters ) { FunctionBody }
        // 1. Return NormalCompletion(empty).
        return new $Empty(realm, 1 /* normal */, intrinsics.empty, this);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
// 14.1.18 Runtime Semantics: EvaluateBody
function EvaluateBody(fn, ctx, functionObject, argumentsList) {
    ctx.checkTimeout();
    fn.logger.debug(`${fn.path}.EvaluateBody(#${ctx.id})`);
    const realm = ctx.Realm;
    realm['[[Intrinsics]]'];
    // FunctionBody : FunctionStatementList
    // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
    const fdiResult = $FunctionDeclarationInstantiation(ctx, functionObject, argumentsList);
    if (fdiResult.isAbrupt) {
        return fdiResult.enrichWith(ctx, fn);
    }
    // 2. Return the result of evaluating FunctionStatementList.
    return fn.$body.Evaluate(ctx); // $Block is guaranteed by $ArrowFunction.EvaluateBody
}
// http://www.ecma-international.org/ecma-262/#sec-functiondeclarationinstantiation
function $FunctionDeclarationInstantiation(ctx, func, argumentsList) {
    ctx.checkTimeout();
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Let calleeContext be the running execution context.
    // 2. Let env be the LexicalEnvironment of calleeContext.
    // 3. Let envRec be env's EnvironmentRecord.
    const envRec = ctx.LexicalEnvironment;
    // 4. Let code be func.[[ECMAScriptCode]].
    const code = func['[[ECMAScriptCode]]'];
    // 5. Let strict be func.[[Strict]].
    const strict = func['[[Strict]]'];
    // 6. Let formals be func.[[FormalParameters]].
    const formals = code.$parameters;
    // 7. Let parameterNames be the BoundNames of formals.
    const parameterNames = formals.BoundNames;
    // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.
    const hasDuplicates = formals.hasDuplicates;
    // 9. Let simpleParameterList be IsSimpleParameterList of formals.
    const simpleParameterList = formals.IsSimpleParameterList;
    // 10. Let hasParameterExpressions be ContainsExpression of formals.
    const hasParameterExpressions = formals.ContainsExpression;
    // 11. Let varNames be the VarDeclaredNames of code.
    const varNames = code.VarDeclaredNames;
    // 12. Let varDeclarations be the VarScopedDeclarations of code.
    const varDeclarations = code.VarScopedDeclarations;
    // 13. Let lexicalNames be the LexicallyDeclaredNames of code.
    const lexicalNames = code.LexicallyDeclaredNames;
    // 14. Let functionNames be a new empty List.
    const functionNames = [];
    // 15. Let functionsToInitialize be a new empty List.
    const functionsToInitialize = [];
    let i = varDeclarations.length;
    let d;
    // 16. For each d in varDeclarations, in reverse list order, do
    while (--i >= 0) {
        d = varDeclarations[i];
        // 16. a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then
        if (d instanceof $FunctionDeclaration) {
            // 16. a. i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.
            // 16. a. ii. Let fn be the sole element of the BoundNames of d.
            const [fn] = d.BoundNames;
            // 16. a. iii. If fn is not an element of functionNames, then
            if (!functionNames.some(x => x.is(fn))) {
                // 16. a. iii. 1. Insert fn as the first element of functionNames.
                functionNames.unshift(fn);
                // 16. a. iii. 2. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
                // 16. a. iii. 3. Insert d as the first element of functionsToInitialize.
                functionsToInitialize.unshift(d);
            }
        }
    }
    // 17. Let argumentsObjectNeeded be true.
    let argumentsObjectNeeded = true;
    // 18. If func.[[ThisMode]] is lexical, then
    if (func['[[ThisMode]]'] === 'lexical') {
        // 18. a. NOTE: Arrow functions never have an arguments objects.
        // 18. b. Set argumentsObjectNeeded to false.
        argumentsObjectNeeded = false;
    }
    // 19. Else if "arguments" is an element of parameterNames, then
    else if (parameterNames.some(x => x['[[Value]]'] === 'arguments')) {
        // 19. a. Set argumentsObjectNeeded to false.
        argumentsObjectNeeded = false;
    }
    // 20. Else if hasParameterExpressions is false, then
    else if (!hasParameterExpressions) {
        // 20. a. If "arguments" is an element of functionNames or if "arguments" is an element of lexicalNames, then
        if (functionNames.some(x => x['[[Value]]'] === 'arguments') || lexicalNames.some(x => x['[[Value]]'] === 'arguments')) {
            // 20. a. i. Set argumentsObjectNeeded to false.
            argumentsObjectNeeded = false;
        }
    }
    // 21. For each String paramName in parameterNames, do
    for (const paramName of parameterNames) {
        // 21. a. Let alreadyDeclared be envRec.HasBinding(paramName).
        const alreadyDeclared = envRec.HasBinding(ctx, paramName);
        // 21. b. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.
        // 21. c. If alreadyDeclared is false, then
        if (alreadyDeclared.isFalsey) {
            // 21. c. i. Perform ! envRec.CreateMutableBinding(paramName, false).
            envRec.CreateMutableBinding(ctx, paramName, intrinsics.false);
            // 21. c. ii. If hasDuplicates is true, then
            if (hasDuplicates) {
                // 21. c. ii. 1. Perform ! envRec.InitializeBinding(paramName, undefined).
                envRec.InitializeBinding(ctx, paramName, intrinsics.undefined);
            }
        }
    }
    let ao;
    let parameterBindings;
    // 22. If argumentsObjectNeeded is true, then
    if (argumentsObjectNeeded) {
        // 22. a. If strict is true or if simpleParameterList is false, then
        if (strict.isTruthy || !simpleParameterList) {
            // 22. a. i. Let ao be CreateUnmappedArgumentsObject(argumentsList).
            ao = $CreateUnmappedArgumentsObject(ctx, argumentsList);
        }
        // 22. b. Else,
        else {
            // 22. b. i. NOTE: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.
            // 22. b. ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).
            ao = new $ArgumentsExoticObject(realm, func, formals, argumentsList, envRec);
        }
        // 22. c. If strict is true, then
        if (strict.isTruthy) {
            // 22. c. i. Perform ! envRec.CreateImmutableBinding("arguments", false).
            envRec.CreateImmutableBinding(ctx, intrinsics.$arguments, intrinsics.false);
        }
        // 22. d. Else,
        else {
            // 22. d. i. Perform ! envRec.CreateMutableBinding("arguments", false).
            envRec.CreateMutableBinding(ctx, intrinsics.$arguments, intrinsics.false);
        }
        // 22. e. Call envRec.InitializeBinding("arguments", ao).
        envRec.InitializeBinding(ctx, intrinsics.$arguments, ao);
        // 22. f. Let parameterBindings be a new List of parameterNames with "arguments" appended.
        parameterBindings = parameterNames.concat(intrinsics.$arguments);
    }
    // 23. Else,
    else {
        // 23. a. Let parameterBindings be parameterNames.
        parameterBindings = parameterNames;
    }
    // 24. Let iteratorRecord be CreateListIteratorRecord(argumentsList).
    const iteratorRecord = $CreateListIteratorRecord(ctx, argumentsList);
    // 25. If hasDuplicates is true, then
    if (hasDuplicates) {
        // 25. a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.
        for (const formal of formals) {
            const result = formal.InitializeIteratorBinding(ctx, iteratorRecord, void 0);
            if (result === null || result === void 0 ? void 0 : result.isAbrupt) {
                return result;
            }
        }
    }
    // 26. Else,
    else {
        // 26. a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.
        for (const formal of formals) {
            const result = formal.InitializeIteratorBinding(ctx, iteratorRecord, envRec);
            if (result === null || result === void 0 ? void 0 : result.isAbrupt) {
                return result;
            }
        }
    }
    let varEnvRec;
    // 27. If hasParameterExpressions is false, then
    if (!hasParameterExpressions) {
        // 27. a. NOTE: Only a single lexical environment is needed for the parameters and top-level vars.
        // 27. b. Let instantiatedVarNames be a copy of the List parameterBindings.
        const instantiatedVarNames = parameterBindings.slice();
        // 27. c. For each n in varNames, do
        for (const n of varNames) {
            // 27. c. i. If n is not an element of instantiatedVarNames, then
            if (!instantiatedVarNames.some(x => x.is(n))) {
                // 27. c. i. 1. Append n to instantiatedVarNames.
                instantiatedVarNames.push(n);
                // 27. c. i. 2. Perform ! envRec.CreateMutableBinding(n, false).
                envRec.CreateMutableBinding(ctx, n, intrinsics.false);
                // 27. c. i. 3. Call envRec.InitializeBinding(n, undefined).
                envRec.InitializeBinding(ctx, n, intrinsics.undefined);
            }
        }
        // 27. d. Let varEnv be env.
        // 27. e. Let varEnvRec be envRec.
        varEnvRec = envRec;
    }
    // 28. Else,
    else {
        // 28. a. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.
        // 28. b. Let varEnv be NewDeclarativeEnvironment(env).
        // 28. c. Let varEnvRec be varEnv's EnvironmentRecord.
        varEnvRec = new $DeclarativeEnvRec(code.logger, realm, envRec);
        // 28. d. Set the VariableEnvironment of calleeContext to varEnv.
        ctx.VariableEnvironment = varEnvRec;
        // 28. e. Let instantiatedVarNames be a new empty List.
        const instantiatedVarNames = [];
        // 28. f. For each n in varNames, do
        for (const n of varNames) {
            // 28. f. i. If n is not an element of instantiatedVarNames, then
            if (!instantiatedVarNames.some(x => x.is(n))) {
                // 28. f. i. 1. Append n to instantiatedVarNames.
                instantiatedVarNames.push(n);
                // 28. f. i. 2. Perform ! varEnvRec.CreateMutableBinding(n, false).
                varEnvRec.CreateMutableBinding(ctx, n, intrinsics.false);
                let initialValue;
                // 28. f. i. 3. If n is not an element of parameterBindings or if n is an element of functionNames, let initialValue be undefined.
                if (!parameterBindings.some(x => x.is(n))) {
                    initialValue = intrinsics.undefined;
                }
                // 28. f. i. 4. Else,
                else {
                    // 28. f. i. 4. a. Let initialValue be ! envRec.GetBindingValue(n, false).
                    initialValue = envRec.GetBindingValue(ctx, n, intrinsics.false);
                }
                // 28. f. i. 5. Call varEnvRec.InitializeBinding(n, initialValue).
                varEnvRec.InitializeBinding(ctx, n, initialValue);
                // 28. f. i. 6. NOTE: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.
            }
        }
    }
    // 29. NOTE: Annex B.3.3.1 adds additional steps at this point.
    let lexEnvRec;
    // 30. If strict is false, then
    if (strict.isFalsey) {
        // 30. a. Let lexEnv be NewDeclarativeEnvironment(varEnv).
        lexEnvRec = new $DeclarativeEnvRec(code.logger, realm, varEnvRec);
        // 30. b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.
    }
    // 31. Else, let lexEnv be varEnv.
    else {
        lexEnvRec = varEnvRec;
    }
    // 32. Let lexEnvRec be lexEnv's EnvironmentRecord.
    // 33. Set the LexicalEnvironment of calleeContext to lexEnv.
    ctx.LexicalEnvironment = lexEnvRec;
    // 34. Let lexDeclarations be the LexicallyScopedDeclarations of code.
    const lexDeclarations = code.LexicallyScopedDeclarations;
    // 35. For each element d in lexDeclarations, do
    for (const d of lexDeclarations) {
        // 35. a. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.
        // 35. b. For each element dn of the BoundNames of d, do
        for (const dn of d.BoundNames) {
            // 35. b. i. If IsConstantDeclaration of d is true, then
            if (d.IsConstantDeclaration) {
                // 35. b. i. 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).
                lexEnvRec.CreateImmutableBinding(ctx, dn, intrinsics.true);
            }
            // 35. b. ii. Else,
            else {
                // 35. b. ii. 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).
                lexEnvRec.CreateMutableBinding(ctx, dn, intrinsics.false);
            }
        }
    }
    // 36. For each Parse Node f in functionsToInitialize, do
    for (const f of functionsToInitialize) {
        // 36. a. Let fn be the sole element of the BoundNames of f.
        const [fn] = f.BoundNames;
        // TODO: probably not right
        if (f instanceof $FunctionDeclaration) {
            // 36. b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.
            const fo = f.InstantiateFunctionObject(ctx, lexEnvRec);
            if (fo.isAbrupt) {
                return fo;
            }
            // 36. c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).
            varEnvRec.SetMutableBinding(ctx, fn, fo, intrinsics.false);
        }
    }
    // 37. Return NormalCompletion(empty).
    return new $Empty(realm, 1 /* normal */, intrinsics.empty);
}
class $ArrowFunction {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ArrowFunction`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-boundnames
        // 14.2.2 Static Semantics: BoundNames
        // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-BoundNames
        // 14.8.3 Static Semantics: BoundNames
        this.BoundNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-hasname
        // 14.2.7 Static Semantics: HasName
        // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-HasName
        // 14.8.7 Static Semantics: HasName
        this.HasName = false;
        // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-lexicallydeclarednames
        // 14.2.10 Static Semantics: LexicallyDeclaredNames
        // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames
        // 14.8.9 Static Semantics: LexicallyDeclaredNames
        this.LexicallyDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations
        // 14.2.11 Static Semantics: LexicallyScopedDeclarations
        // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations
        // 14.8.10 Static Semantics: LexicallyScopedDeclarations
        this.LexicallyScopedDeclarations = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-vardeclarednames
        // 14.2.12 Static Semantics: VarDeclaredNames
        // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames
        // 14.8.11 Static Semantics: VarDeclaredNames
        this.VarDeclaredNames = kernel.emptyArray;
        // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-varscopeddeclarations
        // 14.2.13 Static Semantics: VarScopedDeclarations
        // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations
        // 14.8.12 Static Semantics: VarScopedDeclarations
        this.VarScopedDeclarations = kernel.emptyArray;
        this.TypeDeclarations = kernel.emptyArray;
        this.IsType = false;
        const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        if (node.body.kind === typescript.SyntaxKind.Block) {
            const DirectivePrologue = this.DirectivePrologue = GetDirectivePrologue(node.body.statements);
            if (DirectivePrologue.ContainsUseStrict) {
                ctx |= 65536 /* InStrictMode */;
                this.ContainsUseStrict = true;
            }
            else {
                this.ContainsUseStrict = false;
            }
            this.$parameters = this.CoveredFormalsList = new $FormalParameterList(node.parameters, this, ctx);
            this.$body = new $Block(node.body, this, ctx, -1);
        }
        else {
            this.DirectivePrologue = kernel.emptyArray;
            this.ContainsUseStrict = false;
            this.$parameters = this.CoveredFormalsList = new $FormalParameterList(node.parameters, this, ctx);
            this.$body = $assignmentExpression(node.body, this, ctx, -1);
        }
        this.functionKind = hasBit(modifierFlags, typescript.ModifierFlags.Async) ? 8 /* async */ : 0 /* normal */;
    }
    get $kind() { return typescript.SyntaxKind.ArrowFunction; }
    // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-runtime-semantics-evaluation
    // 14.2.17 Runtime Semantics: Evaluation
    Evaluate(ctx) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);
        // ArrowFunction : ArrowParameters => ConciseBody
        // 1. If the function code for this ArrowFunction is strict mode code, let strict be true. Otherwise let strict be false.
        // 2. Let scope be the LexicalEnvironment of the running execution context.
        // 3. Let parameters be CoveredFormalsList of ArrowParameters.
        // 4. Let closure be FunctionCreate(Arrow, parameters, ConciseBody, scope, strict).
        // 5. Set closure.[[SourceText]] to the source text matched by ArrowFunction.
        // 6. Return closure.
        return intrinsics.undefined; // TODO: implement this
    }
    // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-runtime-semantics-evaluatebody
    // 14.2.15 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        ctx.checkTimeout();
        if (this.$body.$kind === typescript.SyntaxKind.Block) {
            return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);
        }
        this.logger.debug(`${this.path}.EvaluateBody(#${ctx.id})`);
        // ConciseBody : AssignmentExpression
        // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).
        // 2. Let exprRef be the result of evaluating AssignmentExpression.
        // 3. Let exprValue be ? GetValue(exprRef).
        // 4. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        return intrinsics.undefined; // TODO: implement this
    }
}
class MethodDefinitionRecord {
    constructor(key, closure) {
        this['[[Key]]'] = key;
        this['[[Closure]]'] = closure;
    }
    get isAbrupt() { return false; }
}
class $ConstructorDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ConstructorDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.functionKind = 0 /* normal */;
        this.modifierFlags = modifiersToModifierFlags(node.modifiers);
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        this.$parameters = new $FormalParameterList(node.parameters, this, ctx);
        const $body = this.$body = new $Block(node.body, this, ctx, -1);
        this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;
        this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;
        this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;
        this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;
    }
    get $kind() { return typescript.SyntaxKind.Constructor; }
    // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-definemethod
    // 14.3.7 Runtime Semantics: DefineMethod
    DefineMethod(ctx, object, functionPrototype) {
        ctx.checkTimeout();
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // NOTE: this logic and signature is adapted to the fact that this is always a constructor method
        // MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }
        // 1. Let propKey be the result of evaluating PropertyName.
        const propKey = intrinsics.$constructor;
        // 2. ReturnIfAbrupt(propKey).
        // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.
        const strict = intrinsics.true; // TODO: use static semantics
        // 4. Let scope be the running execution context's LexicalEnvironment.
        const scope = ctx.LexicalEnvironment;
        // 5. If functionPrototype is present as a parameter, then
        // 5. a. Let kind be Normal.
        // 5. b. Let prototype be functionPrototype.
        // 6. Else,
        // 6. a. Let kind be Method.
        // 6. b. Let prototype be the intrinsic object %FunctionPrototype%.
        // 7. Let closure be FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype).
        const closure = $Function.FunctionCreate(ctx, 'normal', this, scope, strict, functionPrototype);
        // 8. Perform MakeMethod(closure, object).
        closure['[[HomeObject]]'] = object;
        // 9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.
        closure['[[SourceText]]'] = new $String(realm, this.parent.node.getText(this.mos.node));
        // 10. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.
        return new MethodDefinitionRecord(propKey, closure);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody
    // 14.1.18 Runtime Semantics: EvaluateBody
    EvaluateBody(ctx, functionObject, argumentsList) {
        return EvaluateBody(this, ctx, functionObject, argumentsList);
    }
}
class $ParameterDeclaration {
    constructor(node, parent, ctx, idx, mos = parent.mos, realm = parent.realm, depth = parent.depth + 1, logger = parent.logger, path = `${parent.path}${$i(idx)}.ParameterDeclaration`) {
        this.node = node;
        this.parent = parent;
        this.ctx = ctx;
        this.idx = idx;
        this.mos = mos;
        this.realm = realm;
        this.depth = depth;
        this.logger = logger;
        this.path = path;
        this.modifierFlags = this.combinedModifierFlags = modifiersToModifierFlags(node.modifiers);
        ctx |= 16 /* InParameterDeclaration */;
        this.$decorators = $decoratorList(node.decorators, this, ctx);
        const $name = this.$name = $$bindingName(node.name, this, ctx, -1);
        this.BoundNames = $name.BoundNames;
        if (node.initializer === void 0) {
            this.$initializer = void 0;
            this.ContainsExpression = $name.ContainsExpression;
            this.HasInitializer = false;
            this.IsSimpleParameterList = $name.IsSimpleParameterList;
        }
        else {
            this.$initializer = $assignmentExpression(node.initializer, this, ctx, -1);
            this.ContainsExpression = true;
            this.HasInitializer = true;
            this.IsSimpleParameterList = false;
        }
    }
    get $kind() { return typescript.SyntaxKind.Parameter; }
    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-iteratorbindinginitialization
    // 14.1.19 Runtime Semantics: IteratorBindingInitialization
    InitializeIteratorBinding(ctx, iteratorRecord, environment) {
        ctx.checkTimeout();
        this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        const BindingElement = this.$name;
        if (BindingElement.$kind === typescript.SyntaxKind.Identifier) {
            return BindingElement.InitializeIteratorBinding(ctx, iteratorRecord, environment, this.$initializer);
        }
        // FormalParameter : BindingElement
        if (!this.ContainsExpression) {
            // 1. If ContainsExpression of BindingElement is false, return the result of performing IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.
            // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
            // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization
            // NOTE: this section is duplicated in BindingElement
            // BindingElement : BindingPattern Initializer opt
            let v = intrinsics.undefined; // TODO: sure about this?
            // 1. If iteratorRecord.[[Done]] is false, then
            if (iteratorRecord['[[Done]]'].isFalsey) {
                // 1. a. Let next be IteratorStep(iteratorRecord).
                const next = $IteratorStep(ctx, iteratorRecord);
                // 1. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.
                if (next.isAbrupt) {
                    iteratorRecord['[[Done]]'] = intrinsics.true;
                    // 1. c. ReturnIfAbrupt(next).
                    if (next.isAbrupt) {
                        return next;
                    }
                }
                // 1. d. If next is false, set iteratorRecord.[[Done]] to true.
                if (next.isFalsey) {
                    iteratorRecord['[[Done]]'] = intrinsics.true;
                }
                // 1. e. Else,
                else {
                    // 1. e. i. Let v be IteratorValue(next).
                    v = $IteratorValue(ctx, next);
                    // 1. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.
                    if (v.isAbrupt) {
                        iteratorRecord['[[Done]]'] = intrinsics.true;
                        // 1. e. iii. ReturnIfAbrupt(v).
                        if (v.isAbrupt) {
                            return v;
                        }
                    }
                }
            }
            // 2. If iteratorRecord.[[Done]] is true, let v be undefined.
            if (iteratorRecord['[[Done]]'].isTruthy) {
                v = intrinsics.undefined;
            }
            const initializer = this.$initializer;
            // 3. If Initializer is present and v is undefined, then
            if (initializer !== void 0 && v.isUndefined) {
                // 3. a. Let defaultValue be the result of evaluating Initializer.
                const defaultValue = initializer.Evaluate(ctx);
                // 3. b. Set v to ? GetValue(defaultValue).
                const $v = defaultValue.GetValue(ctx);
                if ($v.isAbrupt) {
                    return $v.enrichWith(ctx, this);
                }
            }
            // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.
            return BindingElement.InitializeBinding(ctx, v, environment);
        }
        // TODO: implement the rest of this
        // 2. Let currentContext be the running execution context.
        // 3. Let originalEnv be the VariableEnvironment of currentContext.
        // 4. Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.
        // 5. Assert: environment and originalEnv are the same.
        // 6. Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).
        // 7. Set the VariableEnvironment of currentContext to paramVarEnv.
        // 8. Set the LexicalEnvironment of currentContext to paramVarEnv.
        // 9. Let result be the result of performing IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.
        // 10. Set the VariableEnvironment of currentContext to originalEnv.
        // 11. Set the LexicalEnvironment of currentContext to originalEnv.
        // 12. Return result.
        // FunctionRestParameter : BindingRestElement
        // 1. If ContainsExpression of BindingRestElement is false, return the result of performing IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the arguments.
        // 2. Let currentContext be the running execution context.
        // 3. Let originalEnv be the VariableEnvironment of currentContext.
        // 4. Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.
        // 5. Assert: environment and originalEnv are the same.
        // 6. Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).
        // 7. Set the VariableEnvironment of currentContext to paramVarEnv.
        // 8. Set the LexicalEnvironment of currentContext to paramVarEnv.
        // 9. Let result be the result of performing IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the arguments.
        // 10. Set the VariableEnvironment of currentContext to originalEnv.
        // 11. Set the LexicalEnvironment of currentContext to originalEnv.
        // 12. Return result.
    }
}

// http://www.ecma-international.org/ecma-262/#sec-function-objects
// 19.2 Function Objects
// http://www.ecma-international.org/ecma-262/#sec-function-constructor
// 19.2.1 The Function Constructor
class $FunctionConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-function.length
    // 19.2.2.1 Function.length
    get length() {
        return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'];
    }
    set length(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].length, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype
    // 19.2.2.2 Function.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Function%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function-p1-p2-pn-body
    // 19.2.1.1 Function ( p1 , p2 , … , pn , body )
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let C be the active function object.
        // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
        // 3. Return ? CreateDynamicFunction(C, NewTarget, "normal", args).
        return $CreateDynamicFunction(ctx, this, NewTarget, 0 /* normal */, argumentsList);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-function-prototype-object
// 19.2.3 Properties of the Function Prototype Object
class $FunctionPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.apply
    // 19.2.3.1 Function.prototype.apply ( thisArg , argArray )
    get $apply() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$apply)['[[Value]]'];
    }
    set $apply(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$apply, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.bind
    // 19.2.3.2 Function.prototype.bind ( thisArg , ... args )
    get $bind() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$bind)['[[Value]]'];
    }
    set $bind(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$bind, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.call
    // 19.2.3.3 Function.prototype.call ( thisArg , ... args )
    get $call() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$call)['[[Value]]'];
    }
    set $call(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$call, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.constructor
    // 19.2.3.4 Function.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.tostring
    // 19.2.3.5 Function.prototype.toString ( )
    get $toString() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$toString)['[[Value]]'];
    }
    set $toString(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$toString, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype-@@hasinstance
    // 19.2.3.6 Function.prototype [ @@hasInstance ] ( V )
    get '@@hasInstance'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@hasInstance'])['[[Value]]'];
    }
    set '@@hasInstance'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@hasInstance'], value);
    }
    constructor(realm, objectPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%FunctionPrototype%', objectPrototype, 1 /* normal */, intrinsics.empty);
    }
}
class $FunctionPrototype_apply extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Function.prototype.apply', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.apply
    // 19.2.3.1 Function.prototype.apply ( thisArg , argArray )
    performSteps(ctx, thisArgument, [thisArg, argArray], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (thisArg === void 0) {
            thisArg = intrinsics.undefined;
        }
        // 1. Let func be the this value.
        // 2. If IsCallable(func) is false, throw a TypeError exception.
        // 3. If argArray is undefined or null, then
        // 3. a. Perform PrepareForTailCall().
        // 3. b. Return ? Call(func, thisArg).
        // 4. Let argList be ? CreateListFromArrayLike(argArray).
        // 5. Perform PrepareForTailCall().
        // 6. Return ? Call(func, thisArg, argList).
        throw new Error('Method not implemented.');
    }
}
class $FunctionPrototype_bind extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Function.prototype.bind', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.bind
    // 19.2.3.2 Function.prototype.bind ( thisArg , ... args )
    performSteps(ctx, thisArgument, [thisArg, ...args], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (thisArg === void 0) {
            thisArg = intrinsics.undefined;
        }
        // 1. Let Target be the this value.
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        // 3. Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.
        // 4. Let F be ? BoundFunctionCreate(Target, thisArg, args).
        // 5. Let targetHasLength be ? HasOwnProperty(Target, "length").
        // 6. If targetHasLength is true, then
        // 6. a. Let targetLen be ? Get(Target, "length").
        // 6. b. If Type(targetLen) is not Number, let L be 0.
        // 6. c. Else,
        // 6. c. i. Set targetLen to ! ToInteger(targetLen).
        // 6. c. ii. Let L be the larger of 0 and the result of targetLen minus the number of elements of args.
        // 7. Else, let L be 0.
        // 8. Perform ! SetFunctionLength(F, L).
        // 9. Let targetName be ? Get(Target, "name").
        // 10. If Type(targetName) is not String, set targetName to the empty string.
        // 11. Perform SetFunctionName(F, targetName, "bound").
        // 12. Return F.
        throw new Error('Method not implemented.');
    }
}
class $FunctionPrototype_call extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Function.prototype.call', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.call
    // 19.2.3.3 Function.prototype.call ( thisArg , ... args )
    performSteps(ctx, thisArgument, [thisArg, ...args], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (thisArg === void 0) {
            thisArg = intrinsics.undefined;
        }
        // 1. Let func be the this value.
        const func = thisArgument;
        // 2. If IsCallable(func) is false, throw a TypeError exception.
        if (!func.isFunction) {
            return new $TypeError(realm, `Function.prototype.call called on ${func}, but expected a callable function`);
        }
        // 3. Let argList be a new empty List.
        const argList = new $List();
        // 4. If this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of argList.
        if (args.length > 0) {
            argList.push(...args);
        }
        // 5. Perform PrepareForTailCall().
        ctx.suspend();
        realm.stack.pop();
        // 6. Return ? Call(func, thisArg, argList).
        return $Call(realm.stack.top, func, thisArg, argList);
    }
}
class $FunctionPrototype_toString extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Function.prototype.toString', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.tostring
    // 19.2.3.5 Function.prototype.toString ( )
    performSteps(ctx, thisArgument, [thisArg, ...args], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (thisArg === void 0) {
            thisArg = intrinsics.undefined;
        }
        // 1. Let func be the this value.
        // 2. If func is a Bound Function exotic object or a built-in function object, then return an implementation-dependent String source code representation of func. The representation must have the syntax of a NativeFunction. Additionally, if func is a Well-known Intrinsic Object and is not identified as an anonymous function, the portion of the returned String that would be matched by PropertyName must be the initial value of the name property of func.
        // 3. If Type(func) is Object and func has a [[SourceText]] internal slot and Type(func.[[SourceText]]) is String and ! HostHasSourceTextAvailable(func) is true, then return func.[[SourceText]].
        // 4. If Type(func) is Object and IsCallable(func) is true, then return an implementation-dependent String source code representation of func. The representation must have the syntax of a NativeFunction.
        // 5. Throw a TypeError exception.
        throw new Error('Method not implemented.');
    }
}
class $FunctionPrototype_hasInstance extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Function.prototype.hasInstance', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype-@@hasinstance
    // 19.2.3.6 Function.prototype [ @@hasInstance ] ( V )
    performSteps(ctx, thisArgument, [V], NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. Let F be the this value.
        // 2. Return ? OrdinaryHasInstance(F, V).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-createdynamicfunction
// 19.2.1.1.1 Runtime Semantics: CreateDynamicFunction ( constructor , newTarget , kind , args )
function $CreateDynamicFunction(ctx, constructor, newTarget, kind, args) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    const stack = realm.stack;
    // 1. Assert: The execution context stack has at least two elements.
    // 2. Let callerContext be the second to top element of the execution context stack.
    const callerContext = stack[stack.length - 2];
    // 3. Let callerRealm be callerContext's Realm.
    const callerRealm = callerContext.Realm;
    // 4. Let calleeRealm be the current Realm Record.
    const calleeRealm = realm;
    // 5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).
    const $HostEnsureCanCompileStringsResult = $HostEnsureCanCompileStrings(ctx, callerRealm, calleeRealm);
    if ($HostEnsureCanCompileStringsResult.isAbrupt) {
        return $HostEnsureCanCompileStringsResult;
    }
    // 6. If newTarget is undefined, set newTarget to constructor.
    if (newTarget.isUndefined) {
        newTarget = constructor;
    }
    let prefix;
    let fallbackProto;
    switch (kind) {
        // 7. If kind is "normal", then
        case 0 /* normal */:
            // 7. a. Let goal be the grammar symbol FunctionBody[~Yield, ~Await].
            // 7. b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, ~Await].
            prefix = 'function';
            // 7. c. Let fallbackProto be "%FunctionPrototype%".
            fallbackProto = '%FunctionPrototype%';
            break;
        // 8. Else if kind is "generator", then
        case 4 /* generator */:
            // 8. a. Let goal be the grammar symbol GeneratorBody.
            // 8. b. Let parameterGoal be the grammar symbol FormalParameters[+Yield, ~Await].
            prefix = 'function*';
            // 8. c. Let fallbackProto be "%Generator%".
            fallbackProto = '%Generator%';
            break;
        // 9. Else if kind is "async", then
        case 8 /* async */:
            // 9. a. Let goal be the grammar symbol AsyncFunctionBody.
            // 9. b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, +Await].
            prefix = 'async function';
            // 9. c. Let fallbackProto be "%AsyncFunctionPrototype%".
            fallbackProto = '%AsyncFunctionPrototype%';
            break;
        // 10. Else,
        case 12 /* asyncGenerator */:
            // 10. a. Assert: kind is "async generator".
            // 10. b. Let goal be the grammar symbol AsyncGeneratorBody.
            // 10. c. Let parameterGoal be the grammar symbol FormalParameters[+Yield, +Await].
            prefix = 'async function*';
            // 10. d. Let fallbackProto be "%AsyncGenerator%".
            fallbackProto = '%AsyncGenerator%';
            break;
    }
    // 11. Let argCount be the number of elements in args.
    const argCount = args.length;
    // 12. Let P be the empty String.
    let P = intrinsics[''];
    let $bodyText;
    let bodyText;
    // 13. If argCount = 0, let bodyText be the empty String.
    if (argCount === 0) {
        $bodyText = intrinsics[''];
    }
    // 14. Else if argCount = 1, let bodyText be args[0].
    else if (argCount === 1) {
        $bodyText = args[0];
    }
    // 15. Else argCount > 1,
    else {
        // 15. a. Let firstArg be args[0].
        const firstArg = args[0];
        // 15. b. Set P to ? ToString(firstArg).
        const $P = firstArg.ToString(ctx);
        if ($P.isAbrupt) {
            return $P;
        }
        P = $P;
        // 15. c. Let k be 1.
        let k = 1;
        // 15. d. Repeat, while k < argCount - 1
        while (k < argCount - 1) {
            // 15. d. i. Let nextArg be args[k].
            const nextArg = args[k];
            // 15. d. ii. Let nextArgString be ? ToString(nextArg).
            const nextArgString = nextArg.ToString(ctx);
            if (nextArgString.isAbrupt) {
                return nextArgString;
            }
            // 15. d. iii. Set P to the string-concatenation of the previous value of P, "," (a comma), and nextArgString.
            P = new $String(realm, `${P['[[Value]]']},${nextArgString['[[Value]]']}`);
            // 15. d. iv. Increase k by 1.
            ++k;
        }
        // 15. e. Let bodyText be args[k].
        $bodyText = args[k];
    }
    // 16. Set bodyText to ? ToString(bodyText).
    $bodyText = $bodyText.ToString(ctx);
    if ($bodyText.isAbrupt) {
        return $bodyText;
    }
    // eslint-disable-next-line prefer-const
    bodyText = $bodyText;
    // 41. Let sourceText be the string-concatenation of prefix, " anonymous(", P, 0x000A (LINE FEED), ") {", 0x000A (LINE FEED), bodyText, 0x000A (LINE FEED), and "}".
    // NOTE: we bring this step up here for parsing a proper function with TS (since TS doesn't expose an api for parsing just functions).
    //    The exact same text is then later set as [[SourceText]]
    const sourceText = `${prefix} anonymous(${P['[[Value]]']}\n) {\n${bodyText['[[Value]]']}\n}`;
    // 17. Let parameters be the result of parsing P, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.
    // 18. Let body be the result of parsing bodyText, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.
    const node = typescript.createSourceFile('', sourceText, typescript.ScriptTarget.Latest).statements[0];
    const ScriptOrModule = callerContext.ScriptOrModule;
    const $functionDeclaration = new $FunctionDeclaration(node, ScriptOrModule, 2 /* Dynamic */, -1, ScriptOrModule, calleeRealm, 1, ScriptOrModule.logger, `${ScriptOrModule.path}[Dynamic].FunctionDeclaration`);
    // 19. Let strict be ContainsUseStrict of body.
    const strict = $functionDeclaration.ContainsUseStrict;
    // TODO: revisit whether we need to implement these early errors. See what 262 tests fail, if any, etc.
    // 20. If any static semantics errors are detected for parameters or body, throw a SyntaxError or a ReferenceError exception, depending on the type of the error. If strict is true, the Early Error rules for UniqueFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved in an implementation-dependent manner.
    // 21. If strict is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.
    // 22. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.
    // 23. If body Contains SuperCall is true, throw a SyntaxError exception.
    // 24. If parameters Contains SuperCall is true, throw a SyntaxError exception.
    // 25. If body Contains SuperProperty is true, throw a SyntaxError exception.
    // 26. If parameters Contains SuperProperty is true, throw a SyntaxError exception.
    // 27. If kind is "generator" or "async generator", then
    // 27. a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.
    // 28. If kind is "async" or "async generator", then
    // 28. a. If parameters Contains AwaitExpression is true, throw a SyntaxError exception.
    // 29. If strict is true, then
    // 29. a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.
    // 30. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).
    const proto = $GetPrototypeFromConstructor(ctx, newTarget, fallbackProto);
    if (proto.isAbrupt) {
        return proto;
    }
    // 31. Let F be FunctionAllocate(proto, strict, kind).
    const F = $Function.FunctionAllocate(ctx, proto, new $Boolean(realm, strict), kind);
    // 32. Let realmF be F.[[Realm]].
    const realmF = F['[[Realm]]'];
    // 33. Let scope be realmF.[[GlobalEnv]].
    const scope = realmF['[[GlobalEnv]]'];
    // 34. Perform FunctionInitialize(F, Normal, parameters, body, scope).
    $Function.FunctionInitialize(ctx, F, 'normal', $functionDeclaration, scope);
    // 35. If kind is "generator", then
    if (kind === 4 /* generator */) {
        // 35. a. Let prototype be ObjectCreate(%GeneratorPrototype%).
        const prototype = new $Object(realm, 'anonymous generator', intrinsics['%GeneratorPrototype%'], 1 /* normal */, intrinsics.empty);
        // 35. b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        $DefinePropertyOrThrow(ctx, F, intrinsics.$prototype, new $PropertyDescriptor(realm, intrinsics.$prototype, {
            '[[Value]]': prototype,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
    }
    // 36. Else if kind is "async generator", then
    else if (kind === 12 /* asyncGenerator */) {
        // 36. a. Let prototype be ObjectCreate(%AsyncGeneratorPrototype%).
        const prototype = new $Object(realm, 'anonymous async generator', intrinsics['%AsyncGeneratorPrototype%'], 1 /* normal */, intrinsics.empty);
        // 36. b. Perform DefinePropertyOrThrow(F, "prototype", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).
        $DefinePropertyOrThrow(ctx, F, intrinsics.$prototype, new $PropertyDescriptor(realm, intrinsics.$prototype, {
            '[[Value]]': prototype,
            '[[Writable]]': intrinsics.true,
            '[[Enumerable]]': intrinsics.false,
            '[[Configurable]]': intrinsics.false,
        }));
    }
    // 37. Else if kind is "normal", perform MakeConstructor(F).
    else if (kind === 0 /* normal */) {
        F.MakeConstructor(ctx);
    }
    // 38. NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a "prototype" property.
    // 39. Perform SetFunctionName(F, "anonymous").
    F.SetFunctionName(ctx, new $String(realm, 'anonymous'));
    // 40. Let prefix be the prefix associated with kind in Table 47.
    // 41. Let sourceText be the string-concatenation of prefix, " anonymous(", P, 0x000A (LINE FEED), ") {", 0x000A (LINE FEED), bodyText, 0x000A (LINE FEED), and "}".
    // 42. Set F.[[SourceText]] to sourceText.
    F['[[SourceText]]'] = new $String(realm, sourceText);
    // 43. Return F.
    return F;
}

// http://www.ecma-international.org/ecma-262/#sec-number-constructor
class $NumberConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Number%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-number-constructor-number-value
    // 20.1.1.1 Number ( value )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        let n;
        // 1. If no arguments were passed to this function invocation, let n be +0.
        if (value === void 0) {
            n = intrinsics['0'];
        }
        // 2. Else, let n be ? ToNumber(value).
        else {
            const $n = value.ToNumber(ctx);
            if ($n.isAbrupt) {
                return $n;
            }
            n = $n;
        }
        // 3. If NewTarget is undefined, return n.
        if (NewTarget.isUndefined) {
            return n;
        }
        // 4. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%NumberPrototype%", « [[NumberData]] »).
        // 5. Set O.[[NumberData]] to n.
        // 6. Return O.
        return $OrdinaryCreateFromConstructor(ctx, NewTarget, '%NumberPrototype%', { '[[NumberData]]': n });
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-number-prototype-object
class $NumberPrototype extends $Object {
    constructor(realm, objectPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%NumberPrototype%', objectPrototype, 1 /* normal */, intrinsics.empty);
        this['[[NumberData]]'] = new $Number(realm, 0);
    }
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-boolean-constructor
class $BooleanConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Boolean%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-boolean-constructor-boolean-value
    // 19.3.1.1 Boolean ( value )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        var _a;
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let b be ToBoolean(value).
        const b = (_a = value === null || value === void 0 ? void 0 : value.ToBoolean(ctx)) !== null && _a !== void 0 ? _a : intrinsics.undefined;
        if (b.isAbrupt) {
            return b;
        }
        // 2. If NewTarget is undefined, return b.
        if (NewTarget.isUndefined) {
            return b;
        }
        // 3. Let O be ? OrdinaryCreateFromConstructor(NewTarget, "%BooleanPrototype%", « [[BooleanData]] »).
        // 4. Set O.[[BooleanData]] to b.
        // 5. Return O.
        return $OrdinaryCreateFromConstructor(ctx, NewTarget, '%BooleanPrototype%', { '[[BooleanData]]': b });
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-boolean-prototype-object
class $BooleanPrototype extends $Object {
    constructor(realm, objectPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%BooleanPrototype%', objectPrototype, 1 /* normal */, intrinsics.empty);
        this['[[BooleanData]]'] = new $Boolean(realm, false);
    }
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-symbol-constructor
class $SymbolConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Symbol%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-symbol-description
    // 19.4.1.1 Symbol ( [ description ] )
    performSteps(ctx, thisArgument, [description], NewTarget) {
        const realm = ctx.Realm;
        realm['[[Intrinsics]]'];
        // 1. If NewTarget is not undefined, throw a TypeError exception.
        if (!NewTarget.isUndefined) {
            return new $TypeError(realm, `Symbol is not a constructor`);
        }
        // 2. If description is undefined, let descString be undefined.
        if (description === void 0 || description.isUndefined) {
            // 4. Return a new unique Symbol value whose [[Description]] value is descString.
            return new $Symbol(realm, new $Undefined(realm));
        }
        // 3. Else, let descString be ? ToString(description).
        else {
            const descString = description.ToString(ctx);
            if (descString.isAbrupt) {
                return descString;
            }
            // 4. Return a new unique Symbol value whose [[Description]] value is descString.
            return new $Symbol(realm, descString);
        }
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-symbol-prototype-object
class $SymbolPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    constructor(realm, objectPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%SymbolPrototype%', objectPrototype, 1 /* normal */, intrinsics.empty);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-error-constructor
class $ErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Error%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-error-message
    // 19.5.1.1 Error ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%ErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%ErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-error-prototype-object
class $ErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    get $toString() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $toString(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, objectPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%ErrorPrototype%', objectPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-error.prototype.tostring
class $ErrorPrototype_toString extends $BuiltinFunction {
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let O be the this value.
        const O = thisArgument;
        // 2. If Type(O) is not Object, throw a TypeError exception.
        if (!O.isObject) {
            return new $TypeError(realm, `Error.prototype.toString called on ${O}, but expected an object`);
        }
        // 3. Let name be ? Get(O, "name").
        let name = O['[[Get]]'](ctx, intrinsics.$name, O);
        if (name.isAbrupt) {
            return name;
        }
        // 4. If name is undefined, set name to "Error"; otherwise set name to ? ToString(name).
        if (name.isUndefined) {
            name = new $String(realm, 'Error');
        }
        else {
            name = name.ToString(ctx);
            if (name.isAbrupt) {
                return name;
            }
        }
        // 5. Let msg be ? Get(O, "message").
        let msg = O['[[Get]]'](ctx, intrinsics.message, O);
        if (msg.isAbrupt) {
            return msg;
        }
        // 6. If msg is undefined, set msg to the empty String; otherwise set msg to ? ToString(msg).
        if (msg.isUndefined) {
            msg = new $String(realm, '');
        }
        else {
            msg = msg.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
        }
        // 7. If name is the empty String, return msg.
        if (name['[[Value]]'] === '') {
            return msg;
        }
        // 8. If msg is the empty String, return name.
        if (msg['[[Value]]'] === '') {
            return name;
        }
        // 9. Return the string-concatenation of name, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.
        return new $String(realm, `${name['[[Value]]']}: ${msg['[[Value]]']}`);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors
class $EvalErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, errorConstructor) {
        super(realm, '%EvalError%', errorConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-nativeerror
    // 19.5.6.1.1 NativeError ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%EvalErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%EvalErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects
class $EvalErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, errorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%EvalErrorPrototype%', errorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors
class $RangeErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, errorConstructor) {
        super(realm, '%RangeError%', errorConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-nativeerror
    // 19.5.6.1.1 NativeError ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%RangeErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%RangeErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects
class $RangeErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, errorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%RangeErrorPrototype%', errorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors
class $ReferenceErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, errorConstructor) {
        super(realm, '%ReferenceError%', errorConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-nativeerror
    // 19.5.6.1.1 NativeError ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%ReferenceErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%ReferenceErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects
class $ReferenceErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, errorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%ReferenceErrorPrototype%', errorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors
class $SyntaxErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, errorConstructor) {
        super(realm, '%SyntaxError%', errorConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-nativeerror
    // 19.5.6.1.1 NativeError ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%SyntaxErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%SyntaxErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects
class $SyntaxErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, errorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%SyntaxErrorPrototype%', errorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors
class $TypeErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, errorConstructor) {
        super(realm, '%TypeError%', errorConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-nativeerror
    // 19.5.6.1.1 NativeError ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%TypeErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%TypeErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects
class $TypeErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, errorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%TypeErrorPrototype%', errorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors
class $URIErrorConstructor extends $BuiltinFunction {
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    constructor(realm, errorConstructor) {
        super(realm, '%URIError%', errorConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-nativeerror
    // 19.5.6.1.1 NativeError ( message )
    performSteps(ctx, thisArgument, [message], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.
        const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;
        // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, "%URIErrorPrototype%", « [[ErrorData]] »).
        const O = $OrdinaryCreateFromConstructor(ctx, newTarget, '%URIErrorPrototype%', { '[[ErrorData]]': void 0 });
        if (O.isAbrupt) {
            return O;
        }
        // 3. If message is not undefined, then
        if (message !== void 0) {
            // 3. a. Let msg be ? ToString(message).
            const msg = message.ToString(ctx);
            if (msg.isAbrupt) {
                return msg;
            }
            // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
            const msgDesc = new $PropertyDescriptor(realm, intrinsics.message, {
                '[[Value]]': msg,
                '[[Writable]]': intrinsics.true,
                '[[Enumerable]]': intrinsics.false,
                '[[Configurable]]': intrinsics.true,
            });
            // 3. c. Perform ! DefinePropertyOrThrow(O, "message", msgDesc).
            $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);
        }
        // 4. Return O.
        return O;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects
class $URIErrorPrototype extends $Object {
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);
    }
    get message() {
        return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'];
    }
    set message(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);
    }
    get $name() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'];
    }
    set $name(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);
    }
    constructor(realm, errorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%URIErrorPrototype%', errorPrototype, 1 /* normal */, intrinsics.empty);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-%throwtypeerror%
// 9.2.9.1 %ThrowTypeError% ( )
class $ThrowTypeError extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-function.prototype.call
    // 19.2.3.3 Function.prototype.call ( thisArg , ... args )
    performSteps(ctx, thisArgument, [thisArg, ...args], NewTarget) {
        // 1. Throw a TypeError exception.
        return new $TypeError(ctx.Realm);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-objects
// 25.2 GeneratorFunction Objects
// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-constructor
// #region 25.2.1 The GeneratorFunction Constructor
class $GeneratorFunctionConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype
    // 25.2.2.2 GeneratorFunction.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.length
    // 25.2.2.1 GeneratorFunction.length
    get length() {
        return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'];
    }
    set length(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].length, value, false, false, true);
    }
    constructor(realm, functionConstructor) {
        super(realm, '%GeneratorFunction%', functionConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunction
    // 25.2.1.1 GeneratorFunction ( p1 , p2 , … , pn , body )
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let C be the active function object.
        // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
        // 3. Return ? CreateDynamicFunction(C, NewTarget, "generator", args).
        return $CreateDynamicFunction(ctx, this, NewTarget, 4 /* generator */, argumentsList);
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-generatorfunction-prototype-object
// #region 25.2.3 Properties of the GeneratorFunction Prototype Object
class $GeneratorFunctionPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype.constructor
    // 25.2.3.1 GeneratorFunction.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype.prototype
    // 25.2.3.2 GeneratorFunction.prototype.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype-@@tostringtag
    // 25.2.3.3 GeneratorFunction.prototype [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, functionPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%Generator%', functionPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances
// #region 25.2.4 GeneratorFunction Instances
// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances-length
// 25.2.4.1 length
// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances-name
// 25.2.4.2 name
// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances-prototype
// 25.2.4.3 prototype
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-generator-objects
// 25.4 Generator Objects
// http://www.ecma-international.org/ecma-262/#sec-properties-of-generator-prototype
// #region 25.4.1 Properties of the Generator Prototype Object
class $GeneratorPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.constructor
    // 25.4.1.1 Generator.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.next
    // 25.4.1.2 Generator.prototype.next ( value )
    get next() {
        return this.getProperty(this.realm['[[Intrinsics]]'].next)['[[Value]]'];
    }
    set next(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].next, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.return
    // 25.4.1.3 Generator.prototype.return ( value )
    get return() {
        return this.getProperty(this.realm['[[Intrinsics]]'].return)['[[Value]]'];
    }
    set return(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].return, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.throw
    // 25.4.1.4 Generator.prototype.throw ( exception )
    get throw() {
        return this.getProperty(this.realm['[[Intrinsics]]'].throw)['[[Value]]'];
    }
    set throw(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].throw, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype-@@tostringtag
    // 25.4.1.5 Generator.prototype [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, iteratorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%GeneratorPrototype%', iteratorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
class $GeneratorPrototype_next extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.next
    // 25.4.1.2 Generator.prototype.next ( value )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let g be the this value.
        const g = thisArgument;
        // 2. Return ? GeneratorResume(g, value).
        return $GeneratorResume(ctx, g, value);
    }
}
class $GeneratorPrototype_return extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.return
    // 25.4.1.3 Generator.prototype.return ( value )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let g be the this value.
        const g = thisArgument;
        // 2. Let C be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
        const C = value.ToCompletion(4 /* return */, intrinsics.empty);
        // 3. Return ? GeneratorResumeAbrupt(g, C).
        return $GeneratorResumeAbrupt(ctx, g, C);
    }
}
class $GeneratorPrototype_throw extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.throw
    // 25.4.1.4 Generator.prototype.throw ( exception )
    performSteps(ctx, thisArgument, [exception], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (exception === void 0) {
            exception = intrinsics.undefined;
        }
        // 1. Let g be the this value.
        const g = thisArgument;
        // 2. Let C be ThrowCompletion(exception).
        const C = exception.ToCompletion(5 /* throw */, intrinsics.empty);
        // 3. Return ? GeneratorResumeAbrupt(g, C).
        return $GeneratorResumeAbrupt(ctx, g, C);
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-generator-instances
// #region 25.4.2 Properties of Generator Instances
var GeneratorState;
(function (GeneratorState) {
    GeneratorState[GeneratorState["none"] = 0] = "none";
    GeneratorState[GeneratorState["suspendedStart"] = 1] = "suspendedStart";
    GeneratorState[GeneratorState["suspendedYield"] = 2] = "suspendedYield";
    GeneratorState[GeneratorState["executing"] = 3] = "executing";
    GeneratorState[GeneratorState["completed"] = 4] = "completed";
})(GeneratorState || (GeneratorState = {}));
class $GeneratorInstance extends $Object {
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'GeneratorInstance', proto, 1 /* normal */, intrinsics.empty);
        this['[[GeneratorState]]'] = 0 /* none */;
        this['[[GeneratorContext]]'] = void 0;
    }
}
class $GeneratorState {
    constructor(value) {
        this.value = value;
    }
    get isAbrupt() { return false; }
}
// http://www.ecma-international.org/ecma-262/#sec-generatorvalidate
// 25.4.3.2 GeneratorValidate ( generator )
function $GeneratorValidate(ctx, generator) {
    const realm = ctx.Realm;
    // 1. If Type(generator) is not Object, throw a TypeError exception.
    // 2. If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.
    // 3. Assert: generator also has a [[GeneratorContext]] internal slot.
    if (!(generator instanceof $GeneratorInstance)) {
        return new $TypeError(realm, `Expected generator to be an GeneratorInstance, but got: ${generator}`);
    }
    // 4. Let state be generator.[[GeneratorState]].
    const state = generator['[[GeneratorState]]'];
    // 5. If state is "executing", throw a TypeError exception.
    if (state === 3 /* executing */) {
        return new $TypeError(realm, `Generator validation failed: already executing`);
    }
    // 6. Return state.
    return new $GeneratorState(state);
}
// http://www.ecma-international.org/ecma-262/#sec-generatorresume
// 25.4.3.3 GeneratorResume ( generator , value )
function $GeneratorResume(ctx, _generator, value) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    const stack = realm.stack;
    // 1. Let state be ? GeneratorValidate(generator).
    const $state = $GeneratorValidate(ctx, _generator);
    if ($state.isAbrupt) {
        return $state;
    }
    const state = $state.value;
    const generator = _generator;
    // 2. If state is "completed", return CreateIterResultObject(undefined, true).
    if (state === 4 /* completed */) {
        return $CreateIterResultObject(ctx, intrinsics.undefined, intrinsics.true);
    }
    // 3. Assert: state is either "suspendedStart" or "suspendedYield".
    // 4. Let genContext be generator.[[GeneratorContext]].
    const genContext = generator['[[GeneratorContext]]'];
    // 5. Let methodContext be the running execution context.
    const methodContext = ctx;
    // 6. Suspend methodContext.
    methodContext.suspend();
    // 7. Set generator.[[GeneratorState]] to "executing".
    generator['[[GeneratorState]]'] = 3 /* executing */;
    // 8. Push genContext onto the execution context stack; genContext is now the running execution context.
    stack.push(genContext);
    // 9. Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.
    genContext.resume();
    const result = genContext.onResume(value);
    // 10. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.
    // 11. Return Completion(result).
    return result;
}
// http://www.ecma-international.org/ecma-262/#sec-generatorresumeabrupt
// 25.4.3.4 GeneratorResumeAbrupt ( generator , abruptCompletion )
function $GeneratorResumeAbrupt(ctx, _generator, abruptCompletion) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    const stack = realm.stack;
    // 1. Let state be ? GeneratorValidate(generator).
    const $state = $GeneratorValidate(ctx, _generator);
    if ($state.isAbrupt) {
        return $state;
    }
    let state = $state.value;
    const generator = _generator;
    // 2. If state is "suspendedStart", then
    if (state === 1 /* suspendedStart */) {
        // 2. a. Set generator.[[GeneratorState]] to "completed".
        generator['[[GeneratorState]]'] = 4 /* completed */;
        // 2. b. Once a generator enters the "completed" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.
        // 2. c. Set state to "completed".
        state = 4 /* completed */;
    }
    // 3. If state is "completed", then
    if (state === 4 /* completed */) {
        // 3. a. If abruptCompletion.[[Type]] is return, then
        if (abruptCompletion['[[Type]]'] === 4 /* return */) {
            // 3. a. i. Return CreateIterResultObject(abruptCompletion.[[Value]], true).
            return $CreateIterResultObject(ctx, abruptCompletion, intrinsics.true);
        }
        // 3. b. Return Completion(abruptCompletion).
        return abruptCompletion;
    }
    // 4. Assert: state is "suspendedYield".
    // 5. Let genContext be generator.[[GeneratorContext]].
    const genContext = generator['[[GeneratorContext]]'];
    // 6. Let methodContext be the running execution context.
    const methodContext = ctx;
    // 7. Suspend methodContext.
    methodContext.suspend();
    // 8. Set generator.[[GeneratorState]] to "executing".
    generator['[[GeneratorState]]'] = 3 /* executing */;
    // 9. Push genContext onto the execution context stack; genContext is now the running execution context.
    stack.push(genContext);
    // 10. Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.
    genContext.resume();
    const result = genContext.onResume(abruptCompletion);
    // 11. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.
    // 12. Return Completion(result).
    return result;
}
var GeneratorKind;
(function (GeneratorKind) {
    GeneratorKind[GeneratorKind["none"] = 0] = "none";
    GeneratorKind[GeneratorKind["async"] = 1] = "async";
    GeneratorKind[GeneratorKind["sync"] = 2] = "sync";
})(GeneratorKind || (GeneratorKind = {}));
// #endregion

// http://www.ecma-international.org/ecma-262/#sec-async-function-objects
// 25.7 AsyncFunction Objects
// http://www.ecma-international.org/ecma-262/#sec-async-function-constructor
// 25.7.1 The AsyncFunction Constructor
class $AsyncFunctionConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-async-function-constructor-prototype
    // 25.7.2.2 AsyncFunction.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-async-function-constructor-length
    // 25.7.2.1 AsyncFunction.length
    get length() {
        return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'];
    }
    set length(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].length, value, false, false, true);
    }
    constructor(realm, functionConstructor) {
        super(realm, '%AsyncFunction%', functionConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-async-function-constructor-arguments
    // 25.7.1.1 AsyncFunction ( p1 , p2 , … , pn , body )
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let C be the active function object.
        // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
        // 3. Return CreateDynamicFunction(C, NewTarget, "async", args).
        return $CreateDynamicFunction(ctx, this, NewTarget, 8 /* async */, argumentsList);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-async-function-prototype-properties
// 25.7.3 Properties of the AsyncFunction Prototype Object
class $AsyncFunctionPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-async-function-prototype-properties-constructor
    // 25.7.3.1 AsyncFunction.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-async-function-prototype-properties-toStringTag
    // 25.7.3.2 AsyncFunction.prototype [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, functionPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%AsyncFunctionPrototype%', functionPrototype, 1 /* normal */, intrinsics.empty);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-objects
// 25.3 AsyncGeneratorFunction Objects
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-constructor
// #region 25.3.1 The AsyncGeneratorFunction Constructor
class $AsyncGeneratorFunctionConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype
    // 25.3.2.2 AsyncGeneratorFunction.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-length
    // 25.3.2.1 AsyncGeneratorFunction.length
    get length() {
        return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'];
    }
    set length(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].length, value, false, false, true);
    }
    constructor(realm, functionConstructor) {
        super(realm, '%AsyncGeneratorFunction%', functionConstructor);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction
    // 25.3.1.1 AsyncGeneratorFunction ( p1 , p2 , ..., pn , body )
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let C be the active function object.
        // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].
        // 3. Return ? CreateDynamicFunction(C, NewTarget, "async generator", args).
        return $CreateDynamicFunction(ctx, this, NewTarget, 12 /* asyncGenerator */, argumentsList);
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-asyncgeneratorfunction-prototype
// #region 25.3.3 Properties of the AsyncGeneratorFunction Prototype Object
class $AsyncGeneratorFunctionPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype-constructor
    // 25.3.3.1 AsyncGeneratorFunction.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype-prototype
    // 25.3.3.2 AsyncGeneratorFunction.prototype.prototype
    get $prototype() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'];
    }
    set $prototype(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype-tostringtag
    // 25.3.3.3 AsyncGeneratorFunction.prototype [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, functionPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%AsyncGenerator%', functionPrototype, 1 /* normal */, intrinsics.empty);
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instances
// #region 25.3.4 AsyncGeneratorFunction Instances
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instance-length
// 25.3.4.1 length
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instance-name
// 25.3.4.2 name
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instance-prototype
// 25.3.4.3 prototype
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-objects
// 25.5 AsyncGenerator Objects
// http://www.ecma-international.org/ecma-262/#sec-properties-of-asyncgenerator-prototype
// #region 25.5.1 Properties of the AsyncGenerator Prototype Object
class $AsyncGeneratorPrototype extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-constructor
    // 25.5.1.1 AsyncGenerator.prototype.constructor
    get $constructor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'];
    }
    set $constructor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-next
    // 25.5.1.2 AsyncGenerator.prototype.next ( value )
    get next() {
        return this.getProperty(this.realm['[[Intrinsics]]'].next)['[[Value]]'];
    }
    set next(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].next, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-return
    // 25.5.1.3 AsyncGenerator.prototype.return ( value )
    get return() {
        return this.getProperty(this.realm['[[Intrinsics]]'].return)['[[Value]]'];
    }
    set return(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].return, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-throw
    // 25.5.1.4 AsyncGenerator.prototype.throw ( exception )
    get throw() {
        return this.getProperty(this.realm['[[Intrinsics]]'].throw)['[[Value]]'];
    }
    set throw(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].throw, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-tostringtag
    // 25.5.1.5 AsyncGenerator.prototype [ @@toStringTag ]
    get '@@toStringTag'() {
        return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'];
    }
    set '@@toStringTag'(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);
    }
    constructor(realm, iteratorPrototype) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, '%AsyncGeneratorPrototype%', iteratorPrototype, 1 /* normal */, intrinsics.empty);
    }
}
class $AsyncGeneratorPrototype_next extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'AsyncGenerator.prototype.next', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-next
    // 25.5.1.2 AsyncGenerator.prototype.next ( value )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let generator be the this value.
        const generator = thisArgument;
        // 2. Let completion be NormalCompletion(value).
        const completion = value;
        // 3. Return ! AsyncGeneratorEnqueue(generator, completion).
        return $AsyncGeneratorEnqueue(ctx, generator, completion);
    }
}
class $AsyncGeneratorPrototype_return extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'AsyncGenerator.prototype.return', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-return
    // 25.5.1.3 AsyncGenerator.prototype.return ( value )
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let generator be the this value.
        const generator = thisArgument;
        // 2. Let completion be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.
        const completion = value.ToCompletion(4 /* return */, intrinsics.empty);
        // 3. Return ! AsyncGeneratorEnqueue(generator, completion).
        return $AsyncGeneratorEnqueue(ctx, generator, completion);
    }
}
class $AsyncGeneratorPrototype_throw extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'AsyncGenerator.prototype.throw', proto);
    }
    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-throw
    // 25.5.1.4 AsyncGenerator.prototype.throw ( exception )
    performSteps(ctx, thisArgument, [exception], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (exception === void 0) {
            exception = intrinsics.undefined;
        }
        // 1. Let generator be the this value.
        const generator = thisArgument;
        // 2. Let completion be ThrowCompletion(exception).
        const completion = exception.ToCompletion(5 /* throw */, intrinsics.empty);
        // 3. Return ! AsyncGeneratorEnqueue(generator, completion).
        return $AsyncGeneratorEnqueue(ctx, generator, completion);
    }
}
// #endregion
// http://www.ecma-international.org/ecma-262/#sec-properties-of-asyncgenerator-intances
// #region 25.5.2 Properties of AsyncGenerator Instances
var AsyncGeneratorState;
(function (AsyncGeneratorState) {
    AsyncGeneratorState[AsyncGeneratorState["none"] = 0] = "none";
    AsyncGeneratorState[AsyncGeneratorState["suspendedStart"] = 1] = "suspendedStart";
    AsyncGeneratorState[AsyncGeneratorState["suspendedYield"] = 2] = "suspendedYield";
    AsyncGeneratorState[AsyncGeneratorState["executing"] = 3] = "executing";
    AsyncGeneratorState[AsyncGeneratorState["awaitingReturn"] = 4] = "awaitingReturn";
    AsyncGeneratorState[AsyncGeneratorState["completed"] = 5] = "completed";
})(AsyncGeneratorState || (AsyncGeneratorState = {}));
class $AsyncGeneratorInstance extends $Object {
    constructor(realm, proto) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'AsyncGeneratorInstance', proto, 1 /* normal */, intrinsics.empty);
        this['[[AsyncGeneratorState]]'] = 0 /* none */;
        this['[[AsyncGeneratorContext]]'] = void 0;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-abstract-operations
// 25.5.3 AsyncGenerator Abstract Operations
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorrequest-records
// 25.5.3.1 AsyncGeneratorRequest Records
class $AsyncGeneratorRequest {
    constructor(completion, capability) {
        this['[[Completion]]'] = completion;
        this['[[Capability]]'] = capability;
    }
    is(other) {
        return this === other;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorresolve
// 25.5.3.3 AsyncGeneratorResolve ( generator , value , done )
function $AsyncGeneratorResolve(ctx, generator, value, done) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: generator is an AsyncGenerator instance.
    // 2. Let queue be generator.[[AsyncGeneratorQueue]].
    const queue = generator['[[AsyncGeneratorQueue]]'];
    // 3. Assert: queue is not an empty List.
    // 4. Remove the first element from queue and let next be the value of that element.
    const next = queue.shift();
    // 5. Let promiseCapability be next.[[Capability]].
    const promiseCapability = next['[[Capability]]'];
    // 6. Let iteratorResult be ! CreateIterResultObject(value, done).
    const iteratorResult = $CreateIterResultObject(ctx, value, done);
    // 7. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »).
    $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(iteratorResult));
    // 8. Perform ! AsyncGeneratorResumeNext(generator).
    $AsyncGeneratorResumeNext(ctx, generator);
    // 9. Return undefined.
    return intrinsics.undefined;
}
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorreject
// 25.5.3.4 AsyncGeneratorReject ( generator , exception )
function $AsyncGeneratorReject(ctx, generator, exception) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: generator is an AsyncGenerator instance.
    // 2. Let queue be generator.[[AsyncGeneratorQueue]].
    const queue = generator['[[AsyncGeneratorQueue]]'];
    // 3. Assert: queue is not an empty List.
    // 4. Remove the first element from queue and let next be the value of that element.
    const next = queue.shift();
    // 5. Let promiseCapability be next.[[Capability]].
    const promiseCapability = next['[[Capability]]'];
    // 6. Perform ! Call(promiseCapability.[[Reject]], undefined, « exception »).
    $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(exception));
    // 7. Perform ! AsyncGeneratorResumeNext(generator).
    $AsyncGeneratorResumeNext(ctx, generator);
    // 8. Return undefined.
    return intrinsics.undefined;
}
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorresumenext
// 25.5.3.5 AsyncGeneratorResumeNext ( generator )
function $AsyncGeneratorResumeNext(ctx, generator) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    const stack = realm.stack;
    // 1. Assert: generator is an AsyncGenerator instance.
    // 2. Let state be generator.[[AsyncGeneratorState]].
    let state = generator['[[AsyncGeneratorState]]'];
    // 3. Assert: state is not "executing".
    // 4. If state is "awaiting-return", return undefined.
    if (state === 4 /* awaitingReturn */) {
        return intrinsics.undefined;
    }
    // 5. Let queue be generator.[[AsyncGeneratorQueue]].
    const queue = generator['[[AsyncGeneratorQueue]]'];
    // 6. If queue is an empty List, return undefined.
    if (queue.length === 0) {
        return intrinsics.undefined;
    }
    // 7. Let next be the value of the first element of queue.
    const next = queue[0];
    // 8. Assert: next is an AsyncGeneratorRequest record.
    // 9. Let completion be next.[[Completion]].
    const completion = next['[[Completion]]']; // TODO: is this cast safe?
    // 10. If completion is an abrupt completion, then
    if (completion.isAbrupt) {
        // 10. a. If state is "suspendedStart", then
        if (state === 1 /* suspendedStart */) {
            // 10. a. i. Set generator.[[AsyncGeneratorState]] to "completed".
            generator['[[AsyncGeneratorState]]'] = 5 /* completed */;
            // 10. a. ii. Set state to "completed".
            state = 5 /* completed */;
        }
        // 10. b. If state is "completed", then
        if (state === 5 /* completed */) {
            // 10. b. i. If completion.[[Type]] is return, then
            if (
            // TODO: improve the $Error type / isAbrupt interaction
            completion['[[Type]]'] === 4 /* return */) {
                // 10. b. i. 1. Set generator.[[AsyncGeneratorState]] to "awaiting-return".
                generator['[[AsyncGeneratorState]]'] = 4 /* awaitingReturn */;
                // 10. b. i. 2. Let promise be ? PromiseResolve(%Promise%, « completion.[[Value]] »).
                const promise = $PromiseResolve(ctx, intrinsics['%Promise%'], new $List(completion)); // TODO: this cast urgently needs to be addressed with corrected typings
                if (promise.isAbrupt) {
                    return promise;
                }
                // 10. b. i. 3. Let stepsFulfilled be the algorithm steps defined in AsyncGeneratorResumeNext Return Processor Fulfilled Functions.
                // 10. b. i. 4. Let onFulfilled be CreateBuiltinFunction(stepsFulfilled, « [[Generator]] »).
                // 10. b. i. 5. Set onFulfilled.[[Generator]] to generator.
                const onFulfilled = new $AsyncGeneratorResumeNext_Return_Processor_Fulfilled(realm, generator);
                // 10. b. i. 6. Let stepsRejected be the algorithm steps defined in AsyncGeneratorResumeNext Return Processor Rejected Functions.
                // 10. b. i. 7. Let onRejected be CreateBuiltinFunction(stepsRejected, « [[Generator]] »).
                // 10. b. i. 8. Set onRejected.[[Generator]] to generator.
                const onRejected = new $AsyncGeneratorResumeNext_Return_Processor_Rejected(realm, generator);
                // 10. b. i. 9. Perform ! PerformPromiseThen(promise, onFulfilled, onRejected).
                $PerformPromiseThen(ctx, promise, onFulfilled, onRejected);
                // 10. b. i. 10. Return undefined.
                return intrinsics.undefined;
            }
            // 10. b. ii. Else,
            else {
                // 10. b. ii. 1. Assert: completion.[[Type]] is throw.
                // 10. b. ii. 2. Perform ! AsyncGeneratorReject(generator, completion.[[Value]]).
                $AsyncGeneratorReject(ctx, generator, completion);
                // 10. b. ii. 3. Return undefined.
                return intrinsics.undefined;
            }
        }
    }
    // 11. Else if state is "completed", return ! AsyncGeneratorResolve(generator, undefined, true).
    else if (state === 5 /* completed */) {
        return $AsyncGeneratorResolve(ctx, generator, intrinsics.undefined, intrinsics.true);
    }
    // 12. Assert: state is either "suspendedStart" or "suspendedYield".
    // 13. Let genContext be generator.[[AsyncGeneratorContext]].
    const genContext = generator['[[AsyncGeneratorContext]]'];
    // 14. Let callerContext be the running execution context.
    const callerContext = ctx;
    // 15. Suspend callerContext.
    callerContext.suspend();
    // 16. Set generator.[[AsyncGeneratorState]] to "executing".
    generator['[[AsyncGeneratorState]]'] = 3 /* executing */;
    // 17. Push genContext onto the execution context stack; genContext is now the running execution context.
    stack.push(genContext);
    // 18. Resume the suspended evaluation of genContext using completion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.
    genContext.resume();
    genContext.onResume(completion);
    // 19. Assert: result is never an abrupt completion.
    // 20. Assert: When we return here, genContext has already been removed from the execution context stack and callerContext is the currently running execution context.
    // 21. Return undefined.
    return intrinsics.undefined;
}
// http://www.ecma-international.org/ecma-262/#async-generator-resume-next-return-processor-fulfilled
// 25.5.3.5.1 AsyncGeneratorResumeNext Return Processor Fulfilled Functions
class $AsyncGeneratorResumeNext_Return_Processor_Fulfilled extends $BuiltinFunction {
    constructor(realm, generator) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'AsyncGeneratorResumeNext Return Processor Fulfilled', intrinsics['%FunctionPrototype%']);
        this['[[Generator]]'] = generator;
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Set F.[[Generator]].[[AsyncGeneratorState]] to "completed".
        F['[[Generator]]']['[[AsyncGeneratorState]]'] = 5 /* completed */;
        // 3. Return ! AsyncGeneratorResolve(F.[[Generator]], value, true).
        return $AsyncGeneratorResolve(ctx, F['[[Generator]]'], value, intrinsics.true);
    }
}
// http://www.ecma-international.org/ecma-262/#async-generator-resume-next-return-processor-rejected
// 25.5.3.5.2 AsyncGeneratorResumeNext Return Processor Rejected Functions
class $AsyncGeneratorResumeNext_Return_Processor_Rejected extends $BuiltinFunction {
    constructor(realm, generator) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'AsyncGeneratorResumeNext Return Processor Rejected', intrinsics['%FunctionPrototype%']);
        this['[[Generator]]'] = generator;
    }
    performSteps(ctx, thisArgument, [value], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (value === void 0) {
            value = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Set F.[[Generator]].[[AsyncGeneratorState]] to "completed".
        F['[[Generator]]']['[[AsyncGeneratorState]]'] = 5 /* completed */;
        // 3. Return ! AsyncGeneratorResolve(F.[[Generator]], value, true).
        return $AsyncGeneratorResolve(ctx, F['[[Generator]]'], value, intrinsics.true);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorenqueue
// 25.5.3.6 AsyncGeneratorEnqueue ( generator , completion )
function $AsyncGeneratorEnqueue(ctx, generator, completion) {
    const realm = ctx.Realm;
    const intrinsics = realm['[[Intrinsics]]'];
    // 1. Assert: completion is a Completion Record.
    // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).
    const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']);
    // 3. If Type(generator) is not Object, or if generator does not have an [[AsyncGeneratorState]] internal slot, then
    if (!(generator instanceof $AsyncGeneratorInstance)) {
        // 3. a. Let badGeneratorError be a newly created TypeError object.
        const badGeneratorError = new $TypeError(realm, `Expected generator to be AsyncGeneratorInstance, but got: ${generator}`);
        // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « badGeneratorError »).
        $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(badGeneratorError));
        // 3. c. Return promiseCapability.[[Promise]].
        return promiseCapability['[[Promise]]']; // TODO: is this cast safe?
    }
    // 4. Let queue be generator.[[AsyncGeneratorQueue]].
    const queue = generator['[[AsyncGeneratorQueue]]'];
    // 5. Let request be AsyncGeneratorRequest { [[Completion]]: completion, [[Capability]]: promiseCapability }.
    const request = new $AsyncGeneratorRequest(completion, promiseCapability);
    // 6. Append request to the end of queue.
    queue.push(request);
    // 7. Let state be generator.[[AsyncGeneratorState]].
    const state = generator['[[AsyncGeneratorState]]'];
    // 8. If state is not "executing", then
    if (state !== 3 /* executing */) {
        // 8. a. Perform ! AsyncGeneratorResumeNext(generator).
        $AsyncGeneratorResumeNext(ctx, generator);
    }
    // 9. Return promiseCapability.[[Promise]].
    return promiseCapability['[[Promise]]']; // TODO: is this cast safe?
}
// #endregion

// http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots
class $ProxyExoticObject extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-proxycreate
    // 9.5.14 ProxyCreate ( target , handler )
    constructor(realm, target, handler) {
        super(realm, 'ProxyExoticObject', realm['[[Intrinsics]]'].null, 1 /* normal */, realm['[[Intrinsics]]'].empty);
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm); // TODO: move to static method so we can return error completion
        }
        // 2. If target is a Proxy exotic object and target.[[ProxyHandler]] is null, throw a TypeError exception.
        if (target.isProxy && target['[[ProxyHandler]]'].isNull) {
            return new $TypeError(realm); // TODO: move to static method so we can return error completion
        }
        // 3. If Type(handler) is not Object, throw a TypeError exception.
        if (!handler.isObject) {
            return new $TypeError(realm); // TODO: move to static method so we can return error completion
        }
        // 4. If handler is a Proxy exotic object and handler.[[ProxyHandler]] is null, throw a TypeError exception.
        if (handler instanceof $ProxyExoticObject && handler['[[ProxyHandler]]'].isNull) {
            return new $TypeError(realm); // TODO: move to static method so we can return error completion
        }
        // 5. Let P be a newly created object.
        // 6. Set P's essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5.
        // 7. If IsCallable(target) is true, then
        // 7. a. Set P.[[Call]] as specified in 9.5.12.
        // 7. b. If IsConstructor(target) is true, then
        // 7. b. i. Set P.[[Construct]] as specified in 9.5.13.
        // 8. Set P.[[ProxyTarget]] to target.
        this['[[ProxyTarget]]'] = target;
        // 9. Set P.[[ProxyHandler]] to handler.
        this['[[ProxyHandler]]'] = handler;
        // 10. Return P.
    }
    get isProxy() { return true; }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-getprototypeof
    // 9.5.1 [[GetPrototypeOf]] ( )
    '[[GetPrototypeOf]]'(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 2. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 3. Assert: Type(handler) is Object.
        // 4. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 5. Let trap be ? GetMethod(handler, "getPrototypeOf").
        const trap = handler.GetMethod(ctx, intrinsics.$getPrototypeOf);
        if (trap.isAbrupt) {
            return trap;
        }
        // 6. If trap is undefined, then
        if (trap.isUndefined) {
            // 6. a. Return ? target.[[GetPrototypeOf]]().
            return target['[[GetPrototypeOf]]'](ctx);
        }
        // 7. Let handlerProto be ? Call(trap, handler, « target »).
        const handlerProto = $Call(ctx, trap, handler, new $List(target));
        if (handlerProto.isAbrupt) {
            return handlerProto;
        }
        // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.
        if (!handlerProto.isNull && !handlerProto.isObject) {
            return new $TypeError(realm, `Proxy handler prototype is ${handlerProto}, but expected Object or Null`);
        }
        // 9. Let extensibleTarget be ? IsExtensible(target).
        const extensibleTarget = target['[[IsExtensible]]'](ctx);
        if (extensibleTarget.isAbrupt) {
            return extensibleTarget;
        }
        // 10. If extensibleTarget is true, return handlerProto.
        if (extensibleTarget.isTruthy) {
            return handlerProto;
        }
        // 11. Let targetProto be ? target.[[GetPrototypeOf]]().
        const targetProto = target['[[GetPrototypeOf]]'](ctx);
        if (targetProto.isAbrupt) {
            return targetProto;
        }
        // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.
        if (!handlerProto.is(targetProto)) {
            return new $TypeError(realm, `Expected handler prototype ${handlerProto} to be the same value as target prototype ${targetProto}`);
        }
        // 13. Return handlerProto.
        return handlerProto;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v
    // 9.5.2 [[SetPrototypeOf]] ( V )
    '[[SetPrototypeOf]]'(ctx, V) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: Either Type(V) is Object or Type(V) is Null.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "setPrototypeOf").
        const trap = handler.GetMethod(ctx, intrinsics.$setPrototypeOf);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[SetPrototypeOf]](V).
            return target['[[SetPrototypeOf]]'](ctx, V);
        }
        // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target, V)).ToBoolean(ctx);
        if (booleanTrapResult.isAbrupt) {
            return booleanTrapResult;
        }
        // 9. If booleanTrapResult is false, return false.
        if (booleanTrapResult.isFalsey) {
            return intrinsics.false;
        }
        // 10. Let extensibleTarget be ? IsExtensible(target).
        const extensibleTarget = target['[[IsExtensible]]'](ctx);
        if (extensibleTarget.isAbrupt) {
            return extensibleTarget;
        }
        if (extensibleTarget.isTruthy) {
            // 11. If extensibleTarget is true, return true.
            return intrinsics.true;
        }
        // 12. Let targetProto be ? target.[[GetPrototypeOf]]().
        const targetProto = target['[[GetPrototypeOf]]'](ctx);
        if (targetProto.isAbrupt) {
            return targetProto;
        }
        // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.
        if (!V.is(targetProto)) {
            return new $TypeError(realm, `Expected value ${V} to be the same value as target prototype ${targetProto}`);
        }
        // 14. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-isextensible
    // 9.5.3 [[IsExtensible]] ( )
    '[[IsExtensible]]'(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 2. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 3. Assert: Type(handler) is Object.
        // 4. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 5. Let trap be ? GetMethod(handler, "isExtensible").
        const trap = handler.GetMethod(ctx, intrinsics.$isExtensible);
        if (trap.isAbrupt) {
            return trap;
        }
        // 6. If trap is undefined, then
        if (trap.isUndefined) {
            // 6. a. Return ? target.[[IsExtensible]]().
            return target['[[IsExtensible]]'](ctx);
        }
        // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target)).ToBoolean(ctx);
        // 8. Let targetResult be ? target.[[IsExtensible]]().
        const targetResult = target['[[IsExtensible]]'](ctx);
        if (targetResult.isAbrupt) {
            return targetResult;
        }
        // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.
        if (!booleanTrapResult.is(targetResult)) {
            return new $TypeError(realm, `Expected booleanTrapResult ${booleanTrapResult} to be the same value as targetResult ${targetResult}`);
        }
        // 10. Return booleanTrapResult.
        return booleanTrapResult;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-preventextensions
    // 9.5.4 [[PreventExtensions]] ( )
    '[[PreventExtensions]]'(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 2. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 3. Assert: Type(handler) is Object.
        // 4. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 5. Let trap be ? GetMethod(handler, "preventExtensions").
        const trap = handler.GetMethod(ctx, intrinsics.$preventExtensions);
        if (trap.isAbrupt) {
            return trap;
        }
        // 6. If trap is undefined, then
        if (trap.isUndefined) {
            // 6. a. Return ? target.[[PreventExtensions]]().
            return target['[[PreventExtensions]]'](ctx);
        }
        // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target)).ToBoolean(ctx);
        if (booleanTrapResult.isAbrupt) {
            return booleanTrapResult;
        }
        // 8. If booleanTrapResult is true, then
        if (booleanTrapResult.isTruthy) {
            // 8. a. Let targetIsExtensible be ? target.[[IsExtensible]]().
            const targetIsExtensible = target['[[IsExtensible]]'](ctx);
            if (targetIsExtensible.isAbrupt) {
                return targetIsExtensible;
            }
            // 8. b. If targetIsExtensible is true, throw a TypeError exception.
            if (targetIsExtensible.isTruthy) {
                return new $TypeError(realm, `Target is still extensible`);
            }
        }
        // 9. Return booleanTrapResult.
        return booleanTrapResult;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p
    // 9.5.5 [[GetOwnProperty]] ( P )
    '[[GetOwnProperty]]'(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "getOwnPropertyDescriptor").
        const trap = handler.GetMethod(ctx, intrinsics.$getOwnPropertyDescriptor);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[GetOwnProperty]](P).
            return target['[[GetOwnProperty]]'](ctx, P);
        }
        // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).
        const trapResultObj = $Call(ctx, trap, handler, new $List(target, P));
        if (trapResultObj.isAbrupt) {
            return trapResultObj;
        }
        // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.
        if (!trapResultObj.isObject && !trapResultObj.isUndefined) {
            return new $TypeError(realm, `trapResultObj from GetOwnProperty(${P}) is ${trapResultObj}, but expected Object or Undefined`);
        }
        // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
        const targetDesc = target['[[GetOwnProperty]]'](ctx, P);
        if (targetDesc.isAbrupt) {
            return targetDesc;
        }
        // 11. If trapResultObj is undefined, then
        if (trapResultObj.isUndefined) {
            // 11. a. If targetDesc is undefined, return undefined.
            if (targetDesc.isUndefined) {
                return intrinsics.undefined;
            }
            // 11. b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
            if (targetDesc['[[Configurable]]'].isFalsey) {
                return new $TypeError(realm, `The proxy returned undefined for property descriptor ${P}, but there is a backing property descriptor which is not configurable`);
            }
            // 11. c. Let extensibleTarget be ? IsExtensible(target).
            const extensibleTarget = target['[[IsExtensible]]'](ctx);
            if (extensibleTarget.isAbrupt) {
                return extensibleTarget;
            }
            // 11. d. If extensibleTarget is false, throw a TypeError exception.
            if (extensibleTarget.isFalsey) {
                return new $TypeError(realm, `The proxy returned undefined for property descriptor ${P}, but there is a backing property descriptor and the backing object is not extensible`);
            }
            // 11. e. Return undefined.
            return intrinsics.undefined;
        }
        // 12. Let extensibleTarget be ? IsExtensible(target).
        const extensibleTarget = target['[[IsExtensible]]'](ctx);
        if (extensibleTarget.isAbrupt) {
            return extensibleTarget;
        }
        // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).
        const resultDesc = $ToPropertyDescriptor(ctx, trapResultObj, P);
        if (resultDesc.isAbrupt) {
            return resultDesc;
        }
        // 14. Call CompletePropertyDescriptor(resultDesc).
        resultDesc.Complete(ctx);
        // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).
        const valid = $ValidateAndApplyPropertyDescriptor(ctx, 
        /* O */ intrinsics.undefined, 
        /* P */ intrinsics.undefined, 
        /* extensible */ extensibleTarget, 
        /* Desc */ resultDesc, 
        /* current */ targetDesc);
        // 16. If valid is false, throw a TypeError exception.
        if (valid.isFalsey) {
            return new $TypeError(realm, `Validation for property descriptor ${P} failed`);
        }
        // 17. If resultDesc.[[Configurable]] is false, then
        if (resultDesc['[[Configurable]]'].isFalsey) {
            // 17. a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then
            if (targetDesc.isUndefined || targetDesc['[[Configurable]]'].isTruthy) {
                // 17. a. i. Throw a TypeError exception.
                return new $TypeError(realm, `The proxy returned a non-configurable property descriptor for ${P}, but the backing property descriptor is either undefined or configurable`);
            }
        }
        // 18. Return resultDesc.
        return resultDesc;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc
    // 9.5.6 [[DefineOwnProperty]] ( P , Desc )
    '[[DefineOwnProperty]]'(ctx, P, Desc) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "defineProperty").
        const trap = handler.GetMethod(ctx, intrinsics.$defineProperty);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[DefineOwnProperty]](P, Desc).
            return target['[[DefineOwnProperty]]'](ctx, P, Desc);
        }
        // 8. Let descObj be FromPropertyDescriptor(Desc).
        const descObj = $FromPropertyDescriptor(ctx, Desc);
        if (descObj.isAbrupt) {
            return descObj;
        } // TODO: spec doesn't say this. maybe we need to fix the types somehow?
        // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target, P, descObj)).ToBoolean(ctx);
        if (booleanTrapResult.isAbrupt) {
            return booleanTrapResult;
        }
        // 10. If booleanTrapResult is false, return false.
        if (booleanTrapResult.isFalsey) {
            return intrinsics.false;
        }
        // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).
        const targetDesc = target['[[GetOwnProperty]]'](ctx, P);
        if (targetDesc.isAbrupt) {
            return targetDesc;
        }
        // 12. Let extensibleTarget be ? IsExtensible(target).
        const extensibleTarget = target['[[IsExtensible]]'](ctx);
        if (extensibleTarget.isAbrupt) {
            return extensibleTarget;
        }
        let settingConfigFalse;
        // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then
        if (Desc['[[Configurable]]'].hasValue && Desc['[[Configurable]]'].isFalsey) {
            // 13. a. Let settingConfigFalse be true.
            settingConfigFalse = true;
        }
        // 14. Else, let settingConfigFalse be false.
        else {
            settingConfigFalse = false;
        }
        // 15. If targetDesc is undefined, then
        if (targetDesc.isUndefined) {
            // 15. a. If extensibleTarget is false, throw a TypeError exception.
            if (extensibleTarget.isFalsey) {
                return new $TypeError(realm, `Cannot define property ${P} on non-extensible target`);
            }
            // 15. b. If settingConfigFalse is true, throw a TypeError exception.
            if (!settingConfigFalse) {
                return new $TypeError(realm, `Cannot define non-configurable property ${P} on proxy`);
            }
        }
        // 16. Else targetDesc is not undefined,
        else {
            // 16. a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.
            if ($ValidateAndApplyPropertyDescriptor(ctx, 
            /* O */ intrinsics.undefined, 
            /* P */ intrinsics.undefined, 
            /* extensible */ extensibleTarget, 
            /* Desc */ Desc, 
            /* current */ targetDesc).isFalsey) {
                return new $TypeError(realm, `The provided property descriptor for ${P} is not compatible with the proxy target's existing descriptor`);
            }
            // 16. b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.
            if (settingConfigFalse && targetDesc['[[Configurable]]'].isTruthy) {
                return new $TypeError(realm, `The provided property descriptor for ${P} is not configurable but the proxy target's existing descriptor is`);
            }
        }
        // 17. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p
    // 9.5.7 [[HasProperty]] ( P )
    '[[HasProperty]]'(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "has").
        const trap = handler.GetMethod(ctx, intrinsics.$has);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[HasProperty]](P).
            return target['[[HasProperty]]'](ctx, P);
        }
        // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target, P)).ToBoolean(ctx);
        if (booleanTrapResult.isAbrupt) {
            return booleanTrapResult;
        }
        // 9. If booleanTrapResult is false, then
        if (booleanTrapResult.isFalsey) {
            // 9. a. Let targetDesc be ? target.[[GetOwnProperty]](P).
            const targetDesc = target['[[GetOwnProperty]]'](ctx, P);
            if (targetDesc.isAbrupt) {
                return targetDesc;
            }
            // 9. b. If targetDesc is not undefined, then
            if (!targetDesc.isUndefined) {
                // 9. b. i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
                if (targetDesc['[[Configurable]]'].isFalsey) {
                    return new $TypeError(realm, `The proxy returned false for HasProperty for ${P}, but the backing object has a property with that name which is not configurable`);
                }
                // 9. b. ii. Let extensibleTarget be ? IsExtensible(target).
                const extensibleTarget = target['[[IsExtensible]]'](ctx);
                if (extensibleTarget.isAbrupt) {
                    return extensibleTarget;
                }
                if (extensibleTarget.isFalsey) {
                    // 9. b. iii. If extensibleTarget is false, throw a TypeError exception.
                    return new $TypeError(realm, `The proxy returned false for HasProperty for ${P}, but the backing object has a property with that name and is not extensible`);
                }
            }
        }
        // 10. Return booleanTrapResult.
        return booleanTrapResult;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
    // 9.5.8 [[Get]] ( P , Receiver )
    '[[Get]]'(ctx, P, Receiver) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "get").
        const trap = handler.GetMethod(ctx, intrinsics.$get);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[Get]](P, Receiver).
            return target['[[Get]]'](ctx, P, Receiver);
        }
        // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).
        const trapResult = $Call(ctx, trap, handler, new $List(target, P, Receiver));
        if (trapResult.isAbrupt) {
            return trapResult;
        }
        // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).
        const targetDesc = target['[[GetOwnProperty]]'](ctx, P);
        if (targetDesc.isAbrupt) {
            return targetDesc;
        }
        // 10. If targetDesc is not undefined and targetDesc.[[Configurable]] is false, then
        if (!targetDesc.isUndefined && targetDesc['[[Configurable]]'].isFalsey) {
            // 10. a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Writable]] is false, then
            if (targetDesc.isDataDescriptor && targetDesc['[[Writable]]'].isFalsey) {
                // 10. a. i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.
                if (!trapResult.is(targetDesc['[[Value]]'])) {
                    return new $TypeError(realm, `The value returned by the proxy's getter for ${P} (${trapResult}) is different from the backing property's value (${targetDesc}), but the backing descriptor is neither configurable nor writable`);
                }
            }
            // 10. b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Get]] is undefined, then
            if (targetDesc.isAccessorDescriptor && targetDesc['[[Get]]'].isUndefined) {
                // 10. b. i. If trapResult is not undefined, throw a TypeError exception.
                if (!trapResult.isUndefined) {
                    return new $TypeError(realm, `The proxy's getter for ${P} returned (${trapResult}), but expected undefined because the backing property's accessor descriptor has no getter and is not configurable`);
                }
            }
        }
        // 11. Return trapResult.
        return trapResult;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver
    // 9.5.9 [[Set]] ( P , V , Receiver )
    '[[Set]]'(ctx, P, V, Receiver) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "set").
        const trap = handler.GetMethod(ctx, intrinsics.$set);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[Set]](P, V, Receiver).
            return target['[[Set]]'](ctx, P, V, Receiver);
        }
        // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target, P, V, Receiver)).ToBoolean(ctx);
        if (booleanTrapResult.isAbrupt) {
            return booleanTrapResult;
        }
        // 9. If booleanTrapResult is false, return false.
        if (booleanTrapResult.isFalsey) {
            return intrinsics.false;
        }
        // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
        const targetDesc = target['[[GetOwnProperty]]'](ctx, P);
        if (targetDesc.isAbrupt) {
            return targetDesc;
        }
        // 11. If targetDesc is not undefined and targetDesc.[[Configurable]] is false, then
        if (!targetDesc.isUndefined && targetDesc['[[Configurable]]'].isFalsey) {
            // 11. a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Writable]] is false, then
            if (targetDesc.isDataDescriptor && targetDesc['[[Writable]]'].isFalsey) {
                // 11. a. i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.
                if (!V.is(targetDesc['[[Value]]'])) {
                    return new $TypeError(realm, `The value supplied to the proxy's setter for ${P} (${V}) is different from the backing property's value (${targetDesc}), but the backing descriptor is neither configurable nor writable`);
                }
            }
            // 11. b. If IsAccessorDescriptor(targetDesc) is true, then
            if (targetDesc.isAccessorDescriptor) {
                // 11. b. i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.
                if (targetDesc['[[Set]]'].isUndefined) {
                    return new $TypeError(realm, `The proxy's setter for ${P} was invoked, but the backing property's accessor descriptor has no setter and is not configurable`);
                }
            }
        }
        // 12. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-delete-p
    // 9.5.10 [[Delete]] ( P )
    '[[Delete]]'(ctx, P) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Assert: IsPropertyKey(P) is true.
        // 2. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 3. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 4. Assert: Type(handler) is Object.
        // 5. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 6. Let trap be ? GetMethod(handler, "deleteProperty").
        const trap = handler.GetMethod(ctx, intrinsics.$deleteProperty);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? target.[[Delete]](P).
            return target['[[Delete]]'](ctx, P);
        }
        // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).
        const booleanTrapResult = $Call(ctx, trap, handler, new $List(target, P)).ToBoolean(ctx);
        if (booleanTrapResult.isAbrupt) {
            return booleanTrapResult;
        }
        // 9. If booleanTrapResult is false, return false.
        if (booleanTrapResult.isFalsey) {
            return intrinsics.false;
        }
        // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).
        const targetDesc = target['[[GetOwnProperty]]'](ctx, P);
        if (targetDesc.isAbrupt) {
            return targetDesc;
        }
        // 11. If targetDesc is undefined, return true.
        if (targetDesc.isUndefined) {
            return intrinsics.true;
        }
        // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.
        if (targetDesc['[[Configurable]]'].isFalsey) {
            return new $TypeError(realm, `The [[Delete]] trap returned true for ${P}, but the backing descriptor is not configurable`);
        }
        // 13. Return true.
        return intrinsics.true;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys
    // 9.5.11 [[OwnPropertyKeys]] ( )
    '[[OwnPropertyKeys]]'(ctx) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 2. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 3. Assert: Type(handler) is Object.
        // 4. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 5. Let trap be ? GetMethod(handler, "ownKeys").
        const trap = handler.GetMethod(ctx, intrinsics.$ownKeys);
        if (trap.isAbrupt) {
            return trap;
        }
        // 6. If trap is undefined, then
        if (trap.isUndefined) {
            // 6. a. Return ? target.[[OwnPropertyKeys]]().
            return target['[[OwnPropertyKeys]]'](ctx);
        }
        // 7. Let trapResultArray be ? Call(trap, handler, « target »).
        const trapResultArray = $Call(ctx, trap, handler, new $List(target));
        if (trapResultArray.isAbrupt) {
            return trapResultArray;
        }
        // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).
        const trapResult = $CreateListFromArrayLike(ctx, trapResultArray, ['String', 'Symbol']);
        if (trapResult.isAbrupt) {
            return trapResult;
        }
        // 9. If trapResult contains any duplicate entries, throw a TypeError exception.
        if (trapResult.filter((x, i) => trapResult.findIndex(y => x.is(y)) === i).length !== trapResult.length) {
            return new $TypeError(realm, `The [[OwnPropertyKeys]] trap returned more than one of the same property key: ${trapResult.map(x => x['[[Value]]'])}`);
        }
        // 10. Let extensibleTarget be ? IsExtensible(target).
        const extensibleTarget = target['[[IsExtensible]]'](ctx);
        if (extensibleTarget.isAbrupt) {
            return extensibleTarget;
        }
        // 11. Let targetKeys be ? target.[[OwnPropertyKeys]]().
        const targetKeys = target['[[OwnPropertyKeys]]'](ctx);
        if (targetKeys.isAbrupt) {
            return targetKeys;
        }
        // 12. Assert: targetKeys is a List containing only String and Symbol values.
        // 13. Assert: targetKeys contains no duplicate entries.
        // 14. Let targetConfigurableKeys be a new empty List.
        const targetConfigurableKeys = [];
        // 15. Let targetNonconfigurableKeys be a new empty List.
        const targetNonconfigurableKeys = [];
        // 16. For each element key of targetKeys, do
        for (const key of targetKeys) {
            // 16. a. Let desc be ? target.[[GetOwnProperty]](key).
            const desc = target['[[GetOwnProperty]]'](ctx, key);
            if (desc.isAbrupt) {
                return desc;
            }
            // 16. b. If desc is not undefined and desc.[[Configurable]] is false, then
            if (!desc.isUndefined && desc['[[Configurable]]'].isFalsey) {
                // 16. b. i. Append key as an element of targetNonconfigurableKeys.
                targetNonconfigurableKeys.push(key);
            }
            // 16. c. Else,
            else {
                // 16. c. i. Append key as an element of targetConfigurableKeys.
                targetConfigurableKeys.push(key);
            }
        }
        // 17. If extensibleTarget is true and targetNonconfigurableKeys is empty, then
        if (extensibleTarget.isTruthy && targetConfigurableKeys.length === 0) {
            // 17. a. Return trapResult.
            return trapResult;
        }
        // 18. Let uncheckedResultKeys be a new List which is a copy of trapResult.
        const uncheckedResultKeys = trapResult.slice();
        // 19. For each key that is an element of targetNonconfigurableKeys, do
        for (const key of targetNonconfigurableKeys) {
            // 19. a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.
            const idx = uncheckedResultKeys.findIndex(x => x.is(key));
            if (idx === -1) {
                return new $TypeError(realm, `The [[OwnPropertyKeys]] trap did not return all non-configurable keys of the backing object: ${key}`);
            }
            // 19. b. Remove key from uncheckedResultKeys.
            uncheckedResultKeys.splice(idx, 1);
        }
        // 20. If extensibleTarget is true, return trapResult.
        if (extensibleTarget.isTruthy) {
            return trapResult;
        }
        // 21. For each key that is an element of targetConfigurableKeys, do
        for (const key of targetConfigurableKeys) {
            // 21. a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.
            const idx = uncheckedResultKeys.findIndex(x => x.is(key));
            if (idx === -1) {
                return new $TypeError(realm, `The [[OwnPropertyKeys]] trap did not return all configurable keys of the backing object: ${key}`);
            }
            // 21. b. Remove key from uncheckedResultKeys.
            uncheckedResultKeys.splice(idx, 1);
        }
        // 22. If uncheckedResultKeys is not empty, throw a TypeError exception.
        if (uncheckedResultKeys.length > 0) {
            return new $TypeError(realm, `The [[OwnPropertyKeys]] returned one or more keys that do not exist on the backing object: ${uncheckedResultKeys.map(x => x)}`);
        }
        // 23. Return trapResult.
        return trapResult;
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist
    // 9.5.12 [[Call]] ( thisArgument , argumentsList )
    '[[Call]]'(ctx, thisArgument, argumentsList) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 2. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 3. Assert: Type(handler) is Object.
        // 4. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 5. Let trap be ? GetMethod(handler, "apply").
        const trap = handler.GetMethod(ctx, intrinsics.$apply);
        if (trap.isAbrupt) {
            return trap;
        }
        // 6. If trap is undefined, then
        if (trap.isUndefined) {
            // 6. a. Return ? Call(target, thisArgument, argumentsList).
            return $Call(ctx, target, thisArgument, argumentsList);
        }
        // 7. Let argArray be CreateArrayFromList(argumentsList).
        const argArray = $CreateArrayFromList(ctx, argumentsList);
        // 8. Return ? Call(trap, handler, « target, thisArgument, argArray »).
        return $Call(ctx, trap, handler, new $List(target, thisArgument, argArray));
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget
    // 9.5.13 [[Construct]] ( argumentsList , newTarget )
    '[[Construct]]'(ctx, argumentsList, newTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        // 1. Let handler be O.[[ProxyHandler]].
        const handler = this['[[ProxyHandler]]'];
        if (handler.isNull) {
            // 2. If handler is null, throw a TypeError exception.
            return new $TypeError(realm, `ProxyHandler is null`);
        }
        // 3. Assert: Type(handler) is Object.
        // 4. Let target be O.[[ProxyTarget]].
        const target = this['[[ProxyTarget]]'];
        // 5. Assert: IsConstructor(target) is true.
        // 6. Let trap be ? GetMethod(handler, "construct").
        const trap = handler.GetMethod(ctx, intrinsics.$construct);
        if (trap.isAbrupt) {
            return trap;
        }
        // 7. If trap is undefined, then
        if (trap.isUndefined) {
            // 7. a. Return ? Construct(target, argumentsList, newTarget).
            return $Construct(ctx, target, argumentsList, newTarget);
        }
        // 8. Let argArray be CreateArrayFromList(argumentsList).
        const argArray = $CreateArrayFromList(ctx, argumentsList);
        // 9. Let newObj be ? Call(trap, handler, « target, argArray, newTarget »).
        const newObj = $Call(ctx, trap, handler, new $List(target, argArray, newTarget));
        if (newObj.isAbrupt) {
            return newObj;
        }
        // 10. If Type(newObj) is not Object, throw a TypeError exception.
        if (!newObj.isObject) {
            return new $TypeError(realm, `The [[Construct]] trap returned ${newObj}, but expected an object`);
        }
        // 11. Return newObj.
        return newObj;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-proxy-objects
// 26.2 Proxy Objects
// http://www.ecma-international.org/ecma-262/#sec-proxy-constructor
// 26.2.1 The Proxy Constructor
class $ProxyConstructor extends $BuiltinFunction {
    // http://www.ecma-international.org/ecma-262/#sec-proxy.revocable
    // 26.2.2.1 Proxy.revocable ( target , handler )
    get revocable() {
        return this.getProperty(this.realm['[[Intrinsics]]'].revocable)['[[Value]]'];
    }
    set revocable(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].revocable, value);
    }
    constructor(realm, functionPrototype) {
        super(realm, '%Proxy%', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-target-handler
    // 26.2.1.1 Proxy ( target , handler )
    performSteps(ctx, thisArgument, [target, handler], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (handler === void 0) {
            handler = intrinsics.undefined;
        }
        // 1. If NewTarget is undefined, throw a TypeError exception.
        if (NewTarget.isUndefined) {
            return new $TypeError(realm, `Proxy cannot be called as a function`);
        }
        // 2. Return ? ProxyCreate(target, handler).
        return new $ProxyExoticObject(realm, target, handler);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-proxy.revocable
// 26.2.2.1 Proxy.revocable ( target , handler )
class $Proxy_revocable extends $BuiltinFunction {
    constructor(realm, functionPrototype) {
        super(realm, 'Proxy.revocable', functionPrototype);
    }
    // http://www.ecma-international.org/ecma-262/#sec-proxy-target-handler
    // 26.2.1.1 Proxy ( target , handler )
    performSteps(ctx, thisArgument, [target, handler], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (handler === void 0) {
            handler = intrinsics.undefined;
        }
        // 1. Let p be ? ProxyCreate(target, handler).
        const p = new $ProxyExoticObject(realm, target, handler);
        if (p.isAbrupt) {
            return p;
        }
        // 2. Let steps be the algorithm steps defined in Proxy Revocation Functions.
        // 3. Let revoker be CreateBuiltinFunction(steps, « [[RevocableProxy]] »).
        // 4. Set revoker.[[RevocableProxy]] to p.
        const revoker = new $Proxy_revocation(realm, p);
        // 5. Let result be ObjectCreate(%ObjectPrototype%).
        const result = $Object.ObjectCreate(ctx, 'Revocable Proxy', intrinsics['%ObjectPrototype%']);
        // 6. Perform CreateDataProperty(result, "proxy", p).
        $CreateDataProperty(ctx, result, new $String(realm, 'proxy'), p);
        // 7. Perform CreateDataProperty(result, "revoke", revoker).
        $CreateDataProperty(ctx, result, new $String(realm, 'revoke'), revoker);
        // 8. Return result.
        return result;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-proxy-revocation-functions
// 26.2.2.1.1 Proxy Revocation Functions
class $Proxy_revocation extends $BuiltinFunction {
    constructor(realm, revocableProxy) {
        const intrinsics = realm['[[Intrinsics]]'];
        super(realm, 'Proxy Revocation', intrinsics['%FunctionPrototype%']);
        this['[[RecovableProxy]]'] = revocableProxy;
    }
    performSteps(ctx, thisArgument, [target, handler], NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (handler === void 0) {
            handler = intrinsics.undefined;
        }
        // 1. Let F be the active function object.
        const F = this;
        // 2. Let p be F.[[RevocableProxy]].
        const p = F['[[RecovableProxy]]'];
        // 3. If p is null, return undefined.
        if (p.isNull) {
            return intrinsics.undefined;
        }
        // 4. Set F.[[RevocableProxy]] to null.
        F['[[RecovableProxy]]'] = intrinsics.null;
        // 5. Assert: p is a Proxy object.
        // 6. Set p.[[ProxyTarget]] to null.
        p['[[ProxyTarget]]'] = intrinsics.null;
        // 7. Set p.[[ProxyHandler]] to null.
        p['[[ProxyHandler]]'] = intrinsics.null;
        // 8. Return undefined.
        return intrinsics.undefined;
    }
}

// http://www.ecma-international.org/ecma-262/#sec-reflection
// 26 Reflection
// http://www.ecma-international.org/ecma-262/#sec-reflect-object
// 26.1 The Reflect Object
class $Reflect extends $Object {
    // http://www.ecma-international.org/ecma-262/#sec-reflect.apply
    // 26.1.1 Reflect.apply ( target , thisArgument , argumentsList )
    get $apply() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$apply)['[[Value]]'];
    }
    set $apply(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$apply, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.construct
    // 26.1.2 Reflect.construct ( target , argumentsList [ , newTarget ] )
    get $construct() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$construct)['[[Value]]'];
    }
    set $construct(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$construct, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.defineproperty
    // 26.1.3 Reflect.defineProperty ( target , propertyKey , attributes )
    get $defineProperty() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$defineProperty)['[[Value]]'];
    }
    set $defineProperty(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$defineProperty, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.deleteproperty
    // 26.1.4 Reflect.deleteProperty ( target , propertyKey )
    get $deleteProperty() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$deleteProperty)['[[Value]]'];
    }
    set $deleteProperty(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$deleteProperty, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.get
    // 26.1.5 Reflect.get ( target , propertyKey [ , receiver ] )
    get $get() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$get)['[[Value]]'];
    }
    set $get(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$get, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.getownpropertydescriptor
    // 26.1.6 Reflect.getOwnPropertyDescriptor ( target , propertyKey )
    get $getOwnPropertyDescriptor() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor)['[[Value]]'];
    }
    set $getOwnPropertyDescriptor(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.getprototypeof
    // 26.1.7 Reflect.getPrototypeOf ( target )
    get $getPrototypeOf() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf)['[[Value]]'];
    }
    set $getPrototypeOf(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.has
    // 26.1.8 Reflect.has ( target , propertyKey )
    get $has() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$has)['[[Value]]'];
    }
    set $has(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$has, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.isextensible
    // 26.1.9 Reflect.isExtensible ( target )
    get $isExtensible() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$isExtensible)['[[Value]]'];
    }
    set $isExtensible(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$isExtensible, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.ownkeys
    // 26.1.10 Reflect.ownKeys ( target )
    get $ownKeys() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$ownKeys)['[[Value]]'];
    }
    set $ownKeys(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$ownKeys, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.preventextensions
    // 26.1.11 Reflect.preventExtensions ( target )
    get $preventExtensions() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$preventExtensions)['[[Value]]'];
    }
    set $preventExtensions(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$preventExtensions, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.set
    // 26.1.12 Reflect.set ( target , propertyKey , V [ , receiver ] )
    get $set() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$set)['[[Value]]'];
    }
    set $set(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$set, value);
    }
    // http://www.ecma-international.org/ecma-262/#sec-reflect.setprototypeof
    // 26.1.13 Reflect.setPrototypeOf ( target , proto )
    get $setPrototypeOf() {
        return this.getProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf)['[[Value]]'];
    }
    set $setPrototypeOf(value) {
        this.setDataProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf, value);
    }
    constructor(realm, proto) {
        super(realm, '%Reflect%', proto, 1 /* normal */, realm['[[Intrinsics]]'].empty);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.apply
// 26.1.1 Reflect.apply ( target , thisArgument , argumentsList )
class $Reflect_apply extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.apply', proto);
    }
    performSteps(ctx, $thisArgument, [target, thisArgument, argumentsList], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (thisArgument === void 0) {
            thisArgument = intrinsics.undefined;
        }
        if (argumentsList === void 0) {
            argumentsList = intrinsics.undefined;
        }
        // 1. If IsCallable(target) is false, throw a TypeError exception.
        if (!target.isFunction) {
            return new $TypeError(realm, `Expected target to be a function, but got: ${target}`);
        }
        // 2. Let args be ? CreateListFromArrayLike(argumentsList).
        const args = $CreateListFromArrayLike(ctx, argumentsList);
        if (args.isAbrupt) {
            return args;
        }
        // 3. Perform PrepareForTailCall().
        ctx.suspend();
        realm.stack.pop();
        // 4. Return ? Call(target, thisArgument, args).
        return $Call(ctx, target, thisArgument, args); // TODO: is this cast safe?
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.construct
// 26.1.2 Reflect.construct ( target , argumentsList [ , newTarget ] )
class $Reflect_construct extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.construct', proto);
    }
    performSteps(ctx, $thisArgument, [target, argumentsList, newTarget], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (argumentsList === void 0) {
            argumentsList = intrinsics.undefined;
        }
        // 1. If IsConstructor(target) is false, throw a TypeError exception.
        if (!target.isFunction) {
            return new $TypeError(realm, `Expected target to be a constructor function, but got: ${target}`);
        }
        // 2. If newTarget is not present, set newTarget to target.
        if (newTarget === void 0) {
            newTarget = target;
        }
        // 3. Else if IsConstructor(newTarget) is false, throw a TypeError exception.
        else if (!newTarget.isFunction) {
            return new $TypeError(realm, `Expected newTarget to be a constructor function, but got: ${newTarget}`);
        }
        // 4. Let args be ? CreateListFromArrayLike(argumentsList).
        const args = $CreateListFromArrayLike(ctx, argumentsList);
        if (args.isAbrupt) {
            return args;
        }
        // 5. Return ? Construct(target, args, newTarget).
        return $Construct(ctx, target, args, newTarget);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.defineproperty
// 26.1.3 Reflect.defineProperty ( target , propertyKey , attributes )
class $Reflect_defineProperty extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.defineProperty', proto);
    }
    performSteps(ctx, $thisArgument, [target, propertyKey, attributes], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (propertyKey === void 0) {
            propertyKey = intrinsics.undefined;
        }
        if (attributes === void 0) {
            attributes = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let key be ? ToPropertyKey(propertyKey).
        const key = propertyKey.ToPropertyKey(ctx);
        if (key.isAbrupt) {
            return key;
        }
        // 3. Let desc be ? ToPropertyDescriptor(attributes).
        const desc = $ToPropertyDescriptor(ctx, attributes, key);
        if (desc.isAbrupt) {
            return desc;
        }
        // 4. Return ? target.[[DefineOwnProperty]](key, desc).
        return target['[[DefineOwnProperty]]'](ctx, key, desc);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.deleteproperty
// 26.1.4 Reflect.deleteProperty ( target , propertyKey )
class $Reflect_deleteProperty extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.deleteProperty', proto);
    }
    performSteps(ctx, $thisArgument, [target, propertyKey], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (propertyKey === void 0) {
            propertyKey = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let key be ? ToPropertyKey(propertyKey).
        const key = propertyKey.ToPropertyKey(ctx);
        if (key.isAbrupt) {
            return key;
        }
        // 3. Return ? target.[[Delete]](key).
        return target['[[Delete]]'](ctx, key);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.get
// 26.1.5 Reflect.get ( target , propertyKey [ , receiver ] )
class $Reflect_get extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.get', proto);
    }
    performSteps(ctx, $thisArgument, [target, propertyKey, receiver], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (propertyKey === void 0) {
            propertyKey = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let key be ? ToPropertyKey(propertyKey).
        const key = propertyKey.ToPropertyKey(ctx);
        if (key.isAbrupt) {
            return key;
        }
        // 3. If receiver is not present, then
        if (receiver === void 0) {
            // 3. a. Set receiver to target.
            receiver = target;
        }
        // 4. Return ? target.[[Get]](key, receiver).
        return target['[[Get]]'](ctx, key, receiver); // TODO: is this cast safe?
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.getownpropertydescriptor
// 26.1.6 Reflect.getOwnPropertyDescriptor ( target , propertyKey )
class $Reflect_getOwnPropertyDescriptor extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.getOwnPropertyDescriptor', proto);
    }
    performSteps(ctx, $thisArgument, [target, propertyKey], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (propertyKey === void 0) {
            propertyKey = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let key be ? ToPropertyKey(propertyKey).
        const key = propertyKey.ToPropertyKey(ctx);
        if (key.isAbrupt) {
            return key;
        }
        // 3. Let desc be ? target.[[GetOwnProperty]](key).
        const desc = target['[[GetOwnProperty]]'](ctx, key);
        if (desc.isAbrupt) {
            return desc;
        }
        // 4. Return FromPropertyDescriptor(desc).
        return $FromPropertyDescriptor(ctx, desc);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.getprototypeof
// 26.1.7 Reflect.getPrototypeOf ( target )
class $Reflect_getPrototypeOf extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.getPrototypeOf', proto);
    }
    performSteps(ctx, $thisArgument, [target], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Return ? target.[[GetPrototypeOf]]().
        return target['[[GetPrototypeOf]]'](ctx);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.has
// 26.1.8 Reflect.has ( target , propertyKey )
class $Reflect_has extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.has', proto);
    }
    performSteps(ctx, $thisArgument, [target, propertyKey], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (propertyKey === void 0) {
            propertyKey = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let key be ? ToPropertyKey(propertyKey).
        const key = propertyKey.ToPropertyKey(ctx);
        if (key.isAbrupt) {
            return key;
        }
        // 3. Return ? target.[[HasProperty]](key).
        return target['[[HasProperty]]'](ctx, key);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.isextensible
// 26.1.9 Reflect.isExtensible ( target )
class $Reflect_isExtensible extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.isExtensible', proto);
    }
    performSteps(ctx, $thisArgument, [target], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Return ? target.[[IsExtensible]]().
        return target['[[IsExtensible]]'](ctx);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.ownkeys
// 26.1.10 Reflect.ownKeys ( target )
class $Reflect_ownKeys extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.ownKeys', proto);
    }
    performSteps(ctx, $thisArgument, [target], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let keys be ? target.[[OwnPropertyKeys]]().
        const keys = target['[[OwnPropertyKeys]]'](ctx);
        if (keys.isAbrupt) {
            return keys;
        }
        // 3. Return CreateArrayFromList(keys).
        return $CreateArrayFromList(ctx, keys);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.preventextensions
// 26.1.11 Reflect.preventExtensions ( target )
class $Reflect_preventExtensions extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.preventExtensions', proto);
    }
    performSteps(ctx, $thisArgument, [target], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Return ? target.[[PreventExtensions]]().
        return target['[[PreventExtensions]]'](ctx);
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.set
// 26.1.12 Reflect.set ( target , propertyKey , V [ , receiver ] )
class $Reflect_set extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.set', proto);
    }
    performSteps(ctx, $thisArgument, [target, propertyKey, V, receiver], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (propertyKey === void 0) {
            propertyKey = intrinsics.undefined;
        }
        if (V === void 0) {
            V = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. Let key be ? ToPropertyKey(propertyKey).
        const key = propertyKey.ToPropertyKey(ctx);
        if (key.isAbrupt) {
            return key;
        }
        // 3. If receiver is not present, then
        if (receiver === void 0) {
            // 3. a. Set receiver to target.
            receiver = target;
        }
        // 4. Return ? target.[[Set]](key, V, receiver).
        return target['[[Set]]'](ctx, key, V, receiver); // TODO: is this cast safe?
    }
}
// http://www.ecma-international.org/ecma-262/#sec-reflect.setprototypeof
// 26.1.13 Reflect.setPrototypeOf ( target , proto )
class $Reflect_setPrototypeOf extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, 'Reflect.setPrototypeOf', proto);
    }
    performSteps(ctx, $thisArgument, [target, proto], $NewTarget) {
        const realm = ctx.Realm;
        const intrinsics = realm['[[Intrinsics]]'];
        if (target === void 0) {
            target = intrinsics.undefined;
        }
        if (proto === void 0) {
            proto = intrinsics.undefined;
        }
        // 1. If Type(target) is not Object, throw a TypeError exception.
        if (!target.isObject) {
            return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);
        }
        // 2. If Type(proto) is not Object and proto is not null, throw a TypeError exception.
        if (!proto.isObject && !proto.isNull) {
            return new $TypeError(realm, `Expected proto to be an object or null, but got: ${proto}`);
        }
        // 3. Return ? target.[[SetPrototypeOf]](proto).
        return target['[[SetPrototypeOf]]'](ctx, proto);
    }
}

// http://www.ecma-international.org/ecma-262/#sec-eval-x
// 18.2.1 eval ( x )
class $Eval extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%eval%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Assert: The execution context stack has at least two elements.
        // 2. Let callerContext be the second to top element of the execution context stack.
        // 3. Let callerRealm be callerContext's Realm.
        // 4. Let calleeRealm be the current Realm Record.
        // 5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).
        // 6. Return ? PerformEval(x, calleeRealm, false, false).
        throw new Error('Method not implemented.');
    }
}

// http://www.ecma-international.org/ecma-262/#sec-isfinite-number
// 18.2.2 isFinite ( number )
class $IsFinite extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%isFinite%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let num be ? ToNumber(number).
        // 2. If num is NaN, +∞, or -∞, return false.
        // 3. Otherwise, return true.
        throw new Error('Method not implemented.');
    }
}

// http://www.ecma-international.org/ecma-262/#sec-isnan-number
// 18.2.3 isNaN ( number )
class $IsNaN extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%isNaN%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let num be ? ToNumber(number).
        // 2. If num is NaN, return true.
        // 3. Otherwise, return false.
        throw new Error('Method not implemented.');
    }
}

// http://www.ecma-international.org/ecma-262/#sec-parsefloat-string
// 18.2.4 parseFloat ( string )
class $ParseFloat extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%parseFloat%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let inputString be ? ToString(string).
        // 2. Let trimmedString be a substring of inputString consisting of the leftmost code unit that is not a StrWhiteSpaceChar and all code units to the right of that code unit. (In other words, remove leading white space.) If inputString does not contain any such code units, let trimmedString be the empty string.
        // 3. If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see 7.1.3.1), return NaN.
        // 4. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies the syntax of a StrDecimalLiteral.
        // 5. Let mathFloat be MV of numberString.
        // 6. If mathFloat = 0, then
        // 6. a. If the first code unit of trimmedString is the code unit 0x002D (HYPHEN-MINUS), return -0.
        // 6. b. Return +0.
        // 7. Return the Number value for mathFloat.
        throw new Error('Method not implemented.');
    }
}

// http://www.ecma-international.org/ecma-262/#sec-parseint-string-radix
// 18.2.5 parseInt ( string , radix )
class $ParseInt extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%parseInt%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let inputString be ? ToString(string).
        // 2. Let S be a newly created substring of inputString consisting of the first code unit that is not a StrWhiteSpaceChar and all code units following that code unit. (In other words, remove leading white space.) If inputString does not contain any such code unit, let S be the empty string.
        // 3. Let sign be 1.
        // 4. If S is not empty and the first code unit of S is the code unit 0x002D (HYPHEN-MINUS), set sign to -1.
        // 5. If S is not empty and the first code unit of S is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), remove the first code unit from S.
        // 6. Let R be ? ToInt32(radix).
        // 7. Let stripPrefix be true.
        // 8. If R ≠ 0, then
        // 8. a. If R < 2 or R > 36, return NaN.
        // 8. b. If R ≠ 16, set stripPrefix to false.
        // 9. Else R = 0,
        // 9. a. Set R to 10.
        // 10. If stripPrefix is true, then
        // 10. a. If the length of S is at least 2 and the first two code units of S are either "0x" or "0X", then
        // 10. a. i. Remove the first two code units from S.
        // 10. a. ii. Set R to 16.
        // 11. If S contains a code unit that is not a radix-R digit, let Z be the substring of S consisting of all code units before the first such code unit; otherwise, let Z be S.
        // 12. If Z is empty, return NaN.
        // 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the mathematical integer value that is represented by Z in radix-R notation.)
        // 14. If mathInt = 0, then
        // 14. a. If sign = -1, return -0.
        // 14. b. Return +0.
        // 15. Let number be the Number value for mathInt.
        // 16. Return sign × number.
        throw new Error('Method not implemented.');
    }
}

// http://www.ecma-international.org/ecma-262/#sec-decodeuri-encodeduri
// 18.2.6.2 decodeURI ( encodedURI )
class $DecodeURI extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%decodeURI%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let uriString be ? ToString(encodedURI).
        // 2. Let reservedURISet be a String containing one instance of each code unit valid in uriReserved plus "#".
        // 3. Return ? Decode(uriString, reservedURISet).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-decodeuricomponent-encodeduricomponent
// 18.2.6.3 decodeURIComponent ( encodedURIComponent )
class $DecodeURIComponent extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%decodeURIComponent%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let componentString be ? ToString(encodedURIComponent).
        // 2. Let reservedURIComponentSet be the empty String.
        // 3. Return ? Decode(componentString, reservedURIComponentSet).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-encodeuri-uri
// 18.2.6.4 encodeURI ( uri )
class $EncodeURI extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%encodeURI%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let uriString be ? ToString(uri).
        // 2. Let unescapedURISet be a String containing one instance of each code unit valid in uriReserved and uriUnescaped plus "#".
        // 3. Return ? Encode(uriString, unescapedURISet).
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-encodeuricomponent-uricomponent
// 18.2.6.5 encodeURIComponent ( uriComponent )
class $EncodeURIComponent extends $BuiltinFunction {
    constructor(realm, proto) {
        super(realm, '%encodeURIComponent%', proto);
    }
    performSteps(ctx, thisArgument, argumentsList, NewTarget) {
        // 1. Let componentString be ? ToString(uriComponent).
        // 2. Let unescapedURIComponentSet be a String containing one instance of each code unit valid in uriUnescaped.
        // 3. Return ? Encode(componentString, unescapedURIComponentSet).
        throw new Error('Method not implemented.');
    }
}

/**
 * http://www.ecma-international.org/ecma-262/#table-7
 *
 * Intrinsic Name                    Global Name                  ECMAScript Language Association
 * ----------                        ----------                   ----------
 * %Array%                           Array                        The Array constructor (22.1.1)
 * %ArrayBuffer%                     ArrayBuffer                  The ArrayBuffer constructor (24.1.2)
 * %ArrayBufferPrototype%            ArrayBuffer.prototype        The initial value of the prototype data property of %ArrayBuffer%.
 * %ArrayIteratorPrototype%                                       The prototype of Array iterator objects (22.1.5)
 * %ArrayPrototype%                  Array.prototype              The initial value of the prototype data property of %Array% (22.1.3)
 * %ArrayProto_entries%              Array.prototype.entries      The initial value of the entries data property of %ArrayPrototype% (22.1.3.4)
 * %ArrayProto_forEach%              Array.prototype.forEach      The initial value of the forEach data property of %ArrayPrototype% (22.1.3.12)
 * %ArrayProto_keys%                 Array.prototype.keys         The initial value of the keys data property of %ArrayPrototype% (22.1.3.16)
 * %ArrayProto_values%               Array.prototype.values       The initial value of the values data property of %ArrayPrototype% (22.1.3.32)
 * %AsyncFromSyncIteratorPrototype%                               The prototype of async-from-sync iterator objects (25.1.4)
 * %AsyncFunction%                                                The constructor of async function objects (25.7.1)
 * %AsyncFunctionPrototype%                                       The initial value of the prototype data property of %AsyncFunction%
 * %AsyncGenerator%                                               The initial value of the prototype property of %AsyncGeneratorFunction%
 * %AsyncGeneratorFunction%                                       The constructor of async iterator objects (25.3.1)
 * %AsyncGeneratorPrototype%                                      The initial value of the prototype property of %AsyncGenerator%
 * %AsyncIteratorPrototype%                                       An object that all standard built-in async iterator objects indirectly inherit from
 * %Atomics%                         Atomics                      The Atomics object (24.4)
 * %Boolean%                         Boolean                      The Boolean constructor (19.3.1)
 * %BooleanPrototype%                Boolean.prototype            The initial value of the prototype data property of %Boolean% (19.3.3)
 * %DataView%                        DataView                     The DataView constructor (24.3.2)
 * %DataViewPrototype%               DataView.prototype           The initial value of the prototype data property of %DataView%
 * %Date%                            Date                         The Date constructor (20.3.2)
 * %DatePrototype%                   Date.prototype               The initial value of the prototype data property of %Date%.
 * %decodeURI%                       decodeURI                    The decodeURI function (18.2.6.2)
 * %decodeURIComponent%              decodeURIComponent           The decodeURIComponent function (18.2.6.3)
 * %encodeURI%                       encodeURI                    The encodeURI function (18.2.6.4)
 * %encodeURIComponent%              encodeURIComponent           The encodeURIComponent function (18.2.6.5)
 * %Error%                           Error                        The Error constructor (19.5.1)
 * %ErrorPrototype%                  Error.prototype              The initial value of the prototype data property of %Error%
 * %eval%                            eval                         The eval function (18.2.1)
 * %EvalError%                       EvalError                    The EvalError constructor (19.5.5.1)
 * %EvalErrorPrototype%              EvalError.prototype          The initial value of the prototype data property of %EvalError%
 * %Float32Array%                    Float32Array                 The Float32Array constructor (22.2)
 * %Float32ArrayPrototype%           Float32Array.prototype       The initial value of the prototype data property of %Float32Array%
 * %Float64Array%                    Float64Array                 The Float64Array constructor (22.2)
 * %Float64ArrayPrototype%           Float64Array.prototype       The initial value of the prototype data property of %Float64Array%
 * %Function%                        Function                     The Function constructor (19.2.1)
 * %FunctionPrototype%               Function.prototype           The initial value of the prototype data property of %Function%
 * %Generator%                                                    The initial value of the prototype data property of %GeneratorFunction%
 * %GeneratorFunction%                                            The constructor of generator objects (25.2.1)
 * %GeneratorPrototype%                                           The initial value of the prototype data property of %Generator%
 * %Int8Array%                       Int8Array                    The Int8Array constructor (22.2)
 * %Int8ArrayPrototype%              Int8Array.prototype          The initial value of the prototype data property of %Int8Array%
 * %Int16Array%                      Int16Array                   The Int16Array constructor (22.2)
 * %Int16ArrayPrototype%             Int16Array.prototype         The initial value of the prototype data property of %Int16Array%
 * %Int32Array%                      Int32Array                   The Int32Array constructor (22.2)
 * %Int32ArrayPrototype%             Int32Array.prototype         The initial value of the prototype data property of %Int32Array%
 * %isFinite%                        isFinite                     The isFinite function (18.2.2)
 * %isNaN%                           isNaN                        The isNaN function (18.2.3)
 * %IteratorPrototype%                                            An object that all standard built-in iterator objects indirectly inherit from
 * %JSON%                            JSON                         The JSON object (24.5)
 * %JSONParse%                       JSON.parse                   The initial value of the parse data property of %JSON%
 * %JSONStringify%                   JSON.stringify               The initial value of the stringify data property of %JSON%
 * %Map%                             Map                          The Map constructor (23.1.1)
 * %MapIteratorPrototype%                                         The prototype of Map iterator objects (23.1.5)
 * %MapPrototype%                    Map.prototype                The initial value of the prototype data property of %Map%
 * %Math%                            Math                         The Math object (20.2)
 * %Number%                          Number                       The Number constructor (20.1.1)
 * %NumberPrototype%                 Number.prototype             The initial value of the prototype data property of %Number%
 * %Object%                          Object                       The Object constructor (19.1.1)
 * %ObjectPrototype%                 Object.prototype             The initial value of the prototype data property of %Object% (19.1.3)
 * %ObjProto_toString%               Object.prototype.toString    The initial value of the toString data property of %ObjectPrototype% (19.1.3.6)
 * %ObjProto_valueOf%                Object.prototype.valueOf     The initial value of the valueOf data property of %ObjectPrototype% (19.1.3.7)
 * %parseFloat%                      parseFloat                   The parseFloat function (18.2.4)
 * %parseInt%                        parseInt                     The parseInt function (18.2.5)
 * %Promise%                         Promise                      The Promise constructor (25.6.3)
 * %PromisePrototype%                Promise.prototype            The initial value of the prototype data property of %Promise%
 * %PromiseProto_then%               Promise.prototype.then       The initial value of the then data property of %PromisePrototype% (25.6.5.4)
 * %Promise_all%                     Promise.all                  The initial value of the all data property of %Promise% (25.6.4.1)
 * %Promise_reject%                  Promise.reject               The initial value of the reject data property of %Promise% (25.6.4.4)
 * %Promise_resolve%                 Promise.resolve              The initial value of the resolve data property of %Promise% (25.6.4.5)
 * %Proxy%                           Proxy                        The Proxy constructor (26.2.1)
 * %RangeError%                      RangeError                   The RangeError constructor (19.5.5.2)
 * %RangeErrorPrototype%             RangeError.prototype         The initial value of the prototype data property of %RangeError%
 * %ReferenceError%                  ReferenceError               The ReferenceError constructor (19.5.5.3)
 * %ReferenceErrorPrototype%         ReferenceError.prototype     The initial value of the prototype data property of %ReferenceError%
 * %Reflect%                         Reflect                      The Reflect object (26.1)
 * %RegExp%                          RegExp                       The RegExp constructor (21.2.3)
 * %RegExpPrototype%                 RegExp.prototype             The initial value of the prototype data property of %RegExp%
 * %Set%                             Set                          The Set constructor (23.2.1)
 * %SetIteratorPrototype%                                         The prototype of Set iterator objects (23.2.5)
 * %SetPrototype%                    Set.prototype                The initial value of the prototype data property of %Set%
 * %SharedArrayBuffer%               SharedArrayBuffer            The SharedArrayBuffer constructor (24.2.2)
 * %SharedArrayBufferPrototype%      SharedArrayBuffer.prototype  The initial value of the prototype data property of %SharedArrayBuffer%
 * %String%                          String                       The String constructor (21.1.1)
 * %StringIteratorPrototype%                                      The prototype of String iterator objects (21.1.5)
 * %StringPrototype%                 String.prototype             The initial value of the prototype data property of %String%
 * %Symbol%                          Symbol                       The Symbol constructor (19.4.1)
 * %SymbolPrototype%                 Symbol.prototype             The initial value of the prototype data property of %Symbol% (19.4.3)
 * %SyntaxError%                     SyntaxError                  The SyntaxError constructor (19.5.5.4)
 * %SyntaxErrorPrototype%            SyntaxError.prototype        The initial value of the prototype data property of %SyntaxError%
 * %ThrowTypeError%                                               A function object that unconditionally throws a new instance of %TypeError%
 * %TypedArray%                                                   The super class of all typed Array constructors (22.2.1)
 * %TypedArrayPrototype%                                          The initial value of the prototype data property of %TypedArray%
 * %TypeError%                       TypeError                    The TypeError constructor (19.5.5.5)
 * %TypeErrorPrototype%              TypeError.prototype          The initial value of the prototype data property of %TypeError%
 * %Uint8Array%                      Uint8Array                   The Uint8Array constructor (22.2)
 * %Uint8ArrayPrototype%             Uint8Array.prototype         The initial value of the prototype data property of %Uint8Array%
 * %Uint8ClampedArray%               Uint8ClampedArray            The Uint8ClampedArray constructor (22.2)
 * %Uint8ClampedArrayPrototype%      Uint8ClampedArray.prototype  The initial value of the prototype data property of %Uint8ClampedArray%
 * %Uint16Array%                     Uint16Array                  The Uint16Array constructor (22.2)
 * %Uint16ArrayPrototype%            Uint16Array.prototype        The initial value of the prototype data property of %Uint16Array%
 * %Uint32Array%                     Uint32Array                  The Uint32Array constructor (22.2)
 * %Uint32ArrayPrototype%            Uint32Array.prototype        The initial value of the prototype data property of %Uint32Array%
 * %URIError%                        URIError                     The URIError constructor (19.5.5.6)
 * %URIErrorPrototype%               URIError.prototype           The initial value of the prototype data property of %URIError%
 * %WeakMap%                         WeakMap                      The WeakMap constructor (23.3.1)
 * %WeakMapPrototype%                WeakMap.prototype            The initial value of the prototype data property of %WeakMap%
 * %WeakSet%                         WeakSet                      The WeakSet constructor (23.4.1)
 * %WeakSetPrototype%                WeakSet.prototype            The initial value of the prototype data property of %WeakSet%
 */
class Intrinsics {
    // http://www.ecma-international.org/ecma-262/#sec-createintrinsics
    // 8.2.2 CreateIntrinsics ( realmRec )
    constructor(realm) {
        realm['[[Intrinsics]]'] = this;
        const empty = this['empty'] = new $Empty(realm);
        this['undefined'] = new $Undefined(realm);
        this['null'] = new $Null(realm);
        // Synthetic root context for intrinsics that need the context to be there during initialization.
        // Creating a valid ExecutionContext requires the null value, which is why we do it right here and neither earlier nor later.
        const root = new ExecutionContext(realm);
        root.Function = this['null'];
        root.ScriptOrModule = this['null'];
        realm.stack.push(root);
        this['true'] = new $Boolean(realm, true);
        this['false'] = new $Boolean(realm, false);
        this['NaN'] = new $Number(realm, NaN);
        this['Infinity'] = new $Number(realm, Infinity);
        this['-Infinity'] = new $Number(realm, -Infinity);
        this['0'] = new $Number(realm, 0);
        this['-0'] = new $Number(realm, -0);
        this[''] = new $String(realm, '');
        this['*'] = new $String(realm, '*');
        this['*default*'] = new $String(realm, '*default*');
        this['default'] = new $String(realm, 'default');
        this['string'] = new $String(realm, 'string');
        this['number'] = new $String(realm, 'number');
        this['length'] = new $String(realm, 'length');
        this['next'] = new $String(realm, 'next');
        this['return'] = new $String(realm, 'return');
        this['throw'] = new $String(realm, 'throw');
        this['call'] = new $String(realm, 'call');
        this['all'] = new $String(realm, 'all');
        this['race'] = new $String(realm, 'race');
        this['reject'] = new $String(realm, 'reject');
        this['resolve'] = new $String(realm, 'resolve');
        this['finally'] = new $String(realm, 'finally');
        this['then'] = new $String(realm, 'then');
        this['catch'] = new $String(realm, 'catch');
        this['message'] = new $String(realm, 'message');
        this['proxy'] = new $String(realm, 'proxy');
        this['revoke'] = new $String(realm, 'revoke');
        this['revocable'] = new $String(realm, 'revocable');
        this['$arguments'] = new $String(realm, 'arguments');
        this['$callee'] = new $String(realm, 'callee');
        this['$constructor'] = new $String(realm, 'constructor');
        this['$hasOwnProperty'] = new $String(realm, 'hasOwnProperty');
        this['$isPrototypeOf'] = new $String(realm, 'isPrototypeOf');
        this['$propertyIsEnumerable'] = new $String(realm, 'propertyIsEnumerable');
        this['$toLocaleString'] = new $String(realm, 'toLocaleString');
        this['$prototype'] = new $String(realm, 'prototype');
        this['$name'] = new $String(realm, 'name');
        this['$toString'] = new $String(realm, 'toString');
        this['$valueOf'] = new $String(realm, 'valueOf');
        this['$enumerable'] = new $String(realm, 'enumerable');
        this['$configurable'] = new $String(realm, 'configurable');
        this['$writable'] = new $String(realm, 'writable');
        this['$value'] = new $String(realm, 'value');
        this['$return'] = new $String(realm, 'return');
        this['$done'] = new $String(realm, 'done');
        this['$getPrototypeOf'] = new $String(realm, 'getPrototypeOf');
        this['$setPrototypeOf'] = new $String(realm, 'setPrototypeOf');
        this['$isExtensible'] = new $String(realm, 'isExtensible');
        this['$preventExtensions'] = new $String(realm, 'preventExtensions');
        this['$getOwnPropertyDescriptor'] = new $String(realm, 'getOwnPropertyDescriptor');
        this['$defineProperty'] = new $String(realm, 'defineProperty');
        this['$has'] = new $String(realm, 'has');
        this['$get'] = new $String(realm, 'get');
        this['$set'] = new $String(realm, 'set');
        this['$deleteProperty'] = new $String(realm, 'deleteProperty');
        this['$ownKeys'] = new $String(realm, 'ownKeys');
        this['$apply'] = new $String(realm, 'apply');
        this['$construct'] = new $String(realm, 'construct');
        this['$bind'] = new $String(realm, 'bind');
        this['$call'] = new $String(realm, 'call');
        this['$assign'] = new $String(realm, 'assign');
        this['$create'] = new $String(realm, 'create');
        this['$defineProperties'] = new $String(realm, 'defineProperties');
        this['$entries'] = new $String(realm, 'entries');
        this['$freeze'] = new $String(realm, 'freeze');
        this['$fromEntries'] = new $String(realm, 'fromEntries');
        this['$getOwnPropertyDescriptors'] = new $String(realm, 'getOwnPropertyDescriptors');
        this['$getOwnPropertyNames'] = new $String(realm, 'getOwnPropertyNames');
        this['$getOwnPropertySymbols'] = new $String(realm, 'getOwnPropertySymbols');
        this['$is'] = new $String(realm, 'is');
        this['$isFrozen'] = new $String(realm, 'isFrozen');
        this['$isSealed'] = new $String(realm, 'isSealed');
        this['$keys'] = new $String(realm, 'keys');
        this['$seal'] = new $String(realm, 'seal');
        this['$values'] = new $String(realm, 'values');
        this['@@asyncIterator'] = new $Symbol(realm, new $String(realm, 'Symbol.asyncIterator'));
        this['@@hasInstance'] = new $Symbol(realm, new $String(realm, 'Symbol.hasInstance'));
        this['@@isConcatSpreadable'] = new $Symbol(realm, new $String(realm, 'Symbol.isConcatSpreadable'));
        this['@@iterator'] = new $Symbol(realm, new $String(realm, 'Symbol.iterator'));
        this['@@match'] = new $Symbol(realm, new $String(realm, 'Symbol.match'));
        this['@@replace'] = new $Symbol(realm, new $String(realm, 'Symbol.replace'));
        this['@@search'] = new $Symbol(realm, new $String(realm, 'Symbol.search'));
        this['@@species'] = new $Symbol(realm, new $String(realm, 'Symbol.species'));
        this['@@split'] = new $Symbol(realm, new $String(realm, 'Symbol.split'));
        this['@@toPrimitive'] = new $Symbol(realm, new $String(realm, 'Symbol.toPrimitive'));
        this['@@toStringTag'] = new $Symbol(realm, new $String(realm, 'Symbol.toStringTag'));
        this['@@unscopables'] = new $Symbol(realm, new $String(realm, 'Symbol.unscopables'));
        const objectPrototype = this['%ObjectPrototype%'] = new $ObjectPrototype(realm);
        const functionPrototype = this['%FunctionPrototype%'] = new $FunctionPrototype(realm, objectPrototype);
        const objectConstructor = this['%Object%'] = new $ObjectConstructor(realm, functionPrototype);
        (objectConstructor.$prototype = objectPrototype).$constructor = objectConstructor;
        const functionConstructor = this['%Function%'] = new $FunctionConstructor(realm, functionPrototype);
        (functionConstructor.$prototype = functionPrototype).$constructor = functionConstructor;
        this['%ThrowTypeError%'] = new $ThrowTypeError(realm, '%ThrowTypeError%', functionPrototype);
        objectConstructor.$assign = new $Object_assign(realm, functionPrototype);
        objectConstructor.$create = new $Object_create(realm, functionPrototype);
        objectConstructor.$defineProperties = new $Object_defineProperties(realm, functionPrototype);
        objectConstructor.$defineProperty = new $Object_defineProperty(realm, functionPrototype);
        objectConstructor.$entries = new $Object_entries(realm, functionPrototype);
        objectConstructor.$freeze = new $Object_freeze(realm, functionPrototype);
        objectConstructor.$fromEntries = new $Object_fromEntries(realm, functionPrototype);
        objectConstructor.$getOwnPropertyDescriptor = new $Object_getOwnPropertyDescriptor(realm, functionPrototype);
        objectConstructor.$getOwnPropertyDescriptors = new $Object_getOwnPropertyDescriptors(realm, functionPrototype);
        objectConstructor.$getOwnPropertyNames = new $Object_getOwnPropertyNames(realm, functionPrototype);
        objectConstructor.$getOwnPropertySymbols = new $Object_getOwnPropertySymbols(realm, functionPrototype);
        objectConstructor.$getPrototypeOf = new $Object_getPrototypeOf(realm, functionPrototype);
        objectConstructor.$is = new $Object_is(realm, functionPrototype);
        objectConstructor.$isExtensible = new $Object_isExtensible(realm, functionPrototype);
        objectConstructor.$isFrozen = new $Object_isFrozen(realm, functionPrototype);
        objectConstructor.$isSealed = new $Object_isSealed(realm, functionPrototype);
        objectConstructor.$keys = new $Object_keys(realm, functionPrototype);
        objectConstructor.$preventExtensions = new $Object_preventExtensions(realm, functionPrototype);
        objectConstructor.$seal = new $Object_seal(realm, functionPrototype);
        objectConstructor.$setPrototypeOf = new $Object_setPrototypeOf(realm, functionPrototype);
        objectConstructor.$values = new $Object_values(realm, functionPrototype);
        objectPrototype.$hasOwnProperty = new $ObjectPrototype_hasOwnProperty(realm, functionPrototype);
        objectPrototype.$isPrototypeOf = new $ObjectPrototype_isPrototypeOf(realm, functionPrototype);
        objectPrototype.$propertyIsEnumerable = new $ObjectPrototype_propertyIsEnumerable(realm, functionPrototype);
        objectPrototype.$toLocaleString = new $ObjectPrototype_toLocaleString(realm, functionPrototype);
        objectPrototype.$toString = this['%ObjProto_toString%'] = new $ObjProto_toString(realm, functionPrototype);
        objectPrototype.$valueOf = this['%ObjProto_valueOf%'] = new $ObjProto_valueOf(realm, functionPrototype);
        functionPrototype.$apply = new $FunctionPrototype_apply(realm, functionPrototype);
        functionPrototype.$bind = new $FunctionPrototype_bind(realm, functionPrototype);
        functionPrototype.$call = new $FunctionPrototype_call(realm, functionPrototype);
        functionPrototype.$toString = new $FunctionPrototype_toString(realm, functionPrototype);
        functionPrototype['@@hasInstance'] = new $FunctionPrototype_hasInstance(realm, functionPrototype);
        const stringConstructor = this['%String%'] = new $StringConstructor(realm, functionPrototype);
        const stringPrototype = this['%StringPrototype%'] = new $StringPrototype(realm, objectPrototype);
        (stringConstructor.$prototype = stringPrototype).$constructor = stringConstructor;
        const numberConstructor = this['%Number%'] = new $NumberConstructor(realm, functionPrototype);
        const numberPrototype = this['%NumberPrototype%'] = new $NumberPrototype(realm, objectPrototype);
        (numberConstructor.$prototype = numberPrototype).$constructor = numberConstructor;
        const booleanConstructor = this['%Boolean%'] = new $BooleanConstructor(realm, functionPrototype);
        const booleanPrototype = this['%BooleanPrototype%'] = new $BooleanPrototype(realm, objectPrototype);
        (booleanConstructor.$prototype = booleanPrototype).$constructor = booleanConstructor;
        const symbolConstructor = this['%Symbol%'] = new $SymbolConstructor(realm, functionPrototype);
        const symbolPrototype = this['%SymbolPrototype%'] = new $SymbolPrototype(realm, objectPrototype);
        (symbolConstructor.$prototype = symbolPrototype).$constructor = symbolConstructor;
        const errorConstructor = this['%Error%'] = new $ErrorConstructor(realm, functionPrototype);
        const errorPrototype = this['%ErrorPrototype%'] = new $ErrorPrototype(realm, objectPrototype);
        (errorConstructor.$prototype = errorPrototype).$constructor = errorConstructor;
        errorPrototype.message = new $String(realm, '');
        errorPrototype.$name = new $String(realm, 'Error');
        errorPrototype.$toString = new $ErrorPrototype_toString(realm, 'Error.prototype.toString', functionPrototype);
        const evalErrorConstructor = this['%EvalError%'] = new $EvalErrorConstructor(realm, errorConstructor);
        const evalErrorPrototype = this['%EvalErrorPrototype%'] = new $EvalErrorPrototype(realm, errorPrototype);
        (evalErrorConstructor.$prototype = evalErrorPrototype).$constructor = evalErrorConstructor;
        evalErrorPrototype.message = new $String(realm, '');
        evalErrorPrototype.$name = new $String(realm, 'EvalError');
        const rangeErrorConstructor = this['%RangeError%'] = new $RangeErrorConstructor(realm, errorConstructor);
        const rangeErrorPrototype = this['%RangeErrorPrototype%'] = new $RangeErrorPrototype(realm, errorPrototype);
        (rangeErrorConstructor.$prototype = rangeErrorPrototype).$constructor = rangeErrorConstructor;
        rangeErrorPrototype.message = new $String(realm, '');
        rangeErrorPrototype.$name = new $String(realm, 'RangeError');
        const referenceErrorConstructor = this['%ReferenceError%'] = new $ReferenceErrorConstructor(realm, errorConstructor);
        const referenceErrorPrototype = this['%ReferenceErrorPrototype%'] = new $ReferenceErrorPrototype(realm, errorPrototype);
        (referenceErrorConstructor.$prototype = referenceErrorPrototype).$constructor = referenceErrorConstructor;
        referenceErrorPrototype.message = new $String(realm, '');
        referenceErrorPrototype.$name = new $String(realm, 'ReferenceError');
        const syntaxErrorConstructor = this['%SyntaxError%'] = new $SyntaxErrorConstructor(realm, errorConstructor);
        const syntaxErrorPrototype = this['%SyntaxErrorPrototype%'] = new $SyntaxErrorPrototype(realm, errorPrototype);
        (syntaxErrorConstructor.$prototype = syntaxErrorPrototype).$constructor = syntaxErrorConstructor;
        syntaxErrorPrototype.message = new $String(realm, '');
        syntaxErrorPrototype.$name = new $String(realm, 'SyntaxError');
        const typeErrorConstructor = this['%TypeError%'] = new $TypeErrorConstructor(realm, errorConstructor);
        const typeErrorPrototype = this['%TypeErrorPrototype%'] = new $TypeErrorPrototype(realm, errorPrototype);
        (typeErrorConstructor.$prototype = typeErrorPrototype).$constructor = typeErrorConstructor;
        typeErrorPrototype.message = new $String(realm, '');
        typeErrorPrototype.$name = new $String(realm, 'TypeError');
        const URIErrorConstructor = this['%URIError%'] = new $URIErrorConstructor(realm, errorConstructor);
        const URIErrorPrototype = this['%URIErrorPrototype%'] = new $URIErrorPrototype(realm, errorPrototype);
        (URIErrorConstructor.$prototype = URIErrorPrototype).$constructor = URIErrorConstructor;
        URIErrorPrototype.message = new $String(realm, '');
        URIErrorPrototype.$name = new $String(realm, 'URIError');
        const iteratorPrototype = this['%IteratorPrototype%'] = new $IteratorPrototype(realm, objectPrototype);
        const generatorFunctionConstructor = this['%GeneratorFunction%'] = new $GeneratorFunctionConstructor(realm, functionConstructor);
        const generatorFunctionPrototype = this['%Generator%'] = new $GeneratorFunctionPrototype(realm, functionPrototype);
        (generatorFunctionConstructor.$prototype = generatorFunctionPrototype).$constructor = generatorFunctionConstructor;
        generatorFunctionConstructor.length = new $Number(realm, 1);
        const generatorPrototype = this['%GeneratorPrototype%'] = new $GeneratorPrototype(realm, iteratorPrototype);
        (generatorFunctionPrototype.$prototype = generatorPrototype).$constructor = generatorFunctionPrototype;
        generatorFunctionPrototype['@@toStringTag'] = new $String(realm, 'GeneratorFunction');
        generatorPrototype.next = new $GeneratorPrototype_next(realm, 'Generator.prototype.next', functionPrototype);
        generatorPrototype.return = new $GeneratorPrototype_return(realm, 'Generator.prototype.return', functionPrototype);
        generatorPrototype.throw = new $GeneratorPrototype_throw(realm, 'Generator.prototype.throw', functionPrototype);
        generatorPrototype['@@toStringTag'] = new $String(realm, 'Generator');
        const promiseConstructor = this['%Promise%'] = new $PromiseConstructor(realm, functionPrototype);
        const promisePrototype = this['%PromisePrototype%'] = new $PromisePrototype(realm, functionPrototype);
        (promiseConstructor.$prototype = promisePrototype).$constructor = promiseConstructor;
        promisePrototype.then = this['%PromiseProto_then%'] = new $PromiseProto_then(realm, functionPrototype);
        promisePrototype.catch = new $PromiseProto_catch(realm, functionPrototype);
        promisePrototype.finally = new $PromiseProto_finally(realm, functionPrototype);
        promisePrototype['@@toStringTag'] = new $String(realm, 'Promise');
        promiseConstructor.all = this['%Promise_all%'] = new $Promise_all(realm, functionPrototype);
        promiseConstructor.race = new $Promise_race(realm, functionPrototype);
        promiseConstructor.resolve = this['%Promise_resolve%'] = new $Promise_resolve(realm, functionPrototype);
        promiseConstructor.reject = this['%Promise_reject%'] = new $Promise_reject(realm, functionPrototype);
        promiseConstructor['@@species'] = new $GetSpecies(realm);
        const asyncFunctionConstructor = this['%AsyncFunction%'] = new $AsyncFunctionConstructor(realm, functionConstructor);
        const asyncFunctionPrototype = this['%AsyncFunctionPrototype%'] = new $AsyncFunctionPrototype(realm, functionPrototype);
        (asyncFunctionConstructor.$prototype = asyncFunctionPrototype).$constructor = asyncFunctionConstructor;
        asyncFunctionConstructor.length = new $Number(realm, 1);
        asyncFunctionPrototype['@@toStringTag'] = new $String(realm, 'AsyncFunction');
        const asyncIteratorPrototype = this['%AsyncIteratorPrototype%'] = new $AsyncIteratorPrototype(realm, objectPrototype);
        const asyncFromSyncIteratorPrototype = this['%AsyncFromSyncIteratorPrototype%'] = new $AsyncFromSyncIteratorPrototype(realm, asyncIteratorPrototype);
        asyncFromSyncIteratorPrototype.next = new $AsyncFromSyncIteratorPrototype_next(realm, functionPrototype);
        asyncFromSyncIteratorPrototype.return = new $AsyncFromSyncIteratorPrototype_return(realm, functionPrototype);
        asyncFromSyncIteratorPrototype.throw = new $AsyncFromSyncIteratorPrototype_throw(realm, functionPrototype);
        asyncFromSyncIteratorPrototype['@@toStringTag'] = new $String(realm, 'Async-from-Sync Iterator');
        const asyncGeneratorFunctionConstructor = this['%AsyncGeneratorFunction%'] = new $AsyncGeneratorFunctionConstructor(realm, functionConstructor);
        const asyncGeneratorFunctionPrototype = this['%AsyncGenerator%'] = new $AsyncGeneratorFunctionPrototype(realm, functionPrototype);
        (asyncGeneratorFunctionConstructor.$prototype = asyncGeneratorFunctionPrototype).$constructor = asyncGeneratorFunctionConstructor;
        asyncGeneratorFunctionConstructor.length = new $Number(realm, 1);
        asyncGeneratorFunctionPrototype['@@toStringTag'] = new $String(realm, 'AsyncGeneratorFunction');
        const asyncGeneratorPrototype = this['%AsyncGeneratorPrototype%'] = new $AsyncGeneratorPrototype(realm, iteratorPrototype);
        (asyncGeneratorFunctionPrototype.$prototype = asyncGeneratorPrototype).$constructor = asyncGeneratorFunctionPrototype;
        asyncGeneratorPrototype.next = new $AsyncGeneratorPrototype_next(realm, functionPrototype);
        asyncGeneratorPrototype.return = new $AsyncGeneratorPrototype_return(realm, functionPrototype);
        asyncGeneratorPrototype.throw = new $AsyncGeneratorPrototype_throw(realm, functionPrototype);
        this['%RegExpPrototype%'] = new $Object(realm, '%RegExpPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%DatePrototype%'] = new $Object(realm, '%DatePrototype%', objectPrototype, 1 /* normal */, empty);
        this['%ArrayIteratorPrototype%'] = new $Object(realm, '%ArrayIteratorPrototype%', this['%IteratorPrototype%'], 1 /* normal */, empty);
        this['%MapIteratorPrototype%'] = new $Object(realm, '%MapIteratorPrototype%', this['%IteratorPrototype%'], 1 /* normal */, empty);
        this['%SetIteratorPrototype%'] = new $Object(realm, '%SetIteratorPrototype%', this['%IteratorPrototype%'], 1 /* normal */, empty);
        this['%StringIteratorPrototype%'] = new $Object(realm, '%StringIteratorPrototype%', this['%IteratorPrototype%'], 1 /* normal */, empty);
        this['%ArrayPrototype%'] = new $Object(realm, '%ArrayPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%MapPrototype%'] = new $Object(realm, '%MapPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%WeakMapPrototype%'] = new $Object(realm, '%WeakMapPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%SetPrototype%'] = new $Object(realm, '%SetPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%WeakSetPrototype%'] = new $Object(realm, '%WeakSetPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%DataViewPrototype%'] = new $Object(realm, '%DataViewPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%ArrayBufferPrototype%'] = new $Object(realm, '%ArrayBufferPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%SharedArrayBufferPrototype%'] = new $Object(realm, '%SharedArrayBufferPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%TypedArrayPrototype%'] = new $Object(realm, '%TypedArrayPrototype%', objectPrototype, 1 /* normal */, empty);
        this['%Float32ArrayPrototype%'] = new $Object(realm, '%Float32ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Float64ArrayPrototype%'] = new $Object(realm, '%Float64ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Int8ArrayPrototype%'] = new $Object(realm, '%Int8ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Int16ArrayPrototype%'] = new $Object(realm, '%Int16ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Int32ArrayPrototype%'] = new $Object(realm, '%Int32ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Uint8ArrayPrototype%'] = new $Object(realm, '%Uint8ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Uint8ClampedArrayPrototype%'] = new $Object(realm, '%Uint8ClampedArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Uint16ArrayPrototype%'] = new $Object(realm, '%Uint16ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%Uint32ArrayPrototype%'] = new $Object(realm, '%Uint32ArrayPrototype%', this['%TypedArrayPrototype%'], 1 /* normal */, empty);
        this['%RegExp%'] = new $Object(realm, '%RegExp%', functionPrototype, 1 /* normal */, empty);
        this['%Date%'] = new $Object(realm, '%Date%', functionPrototype, 1 /* normal */, empty);
        this['%Array%'] = new $Object(realm, '%Array%', functionPrototype, 1 /* normal */, empty);
        this['%Map%'] = new $Object(realm, '%Map%', functionPrototype, 1 /* normal */, empty);
        this['%WeakMap%'] = new $Object(realm, '%WeakMap%', functionPrototype, 1 /* normal */, empty);
        this['%Set%'] = new $Object(realm, '%Set%', functionPrototype, 1 /* normal */, empty);
        this['%WeakSet%'] = new $Object(realm, '%WeakSet%', functionPrototype, 1 /* normal */, empty);
        this['%DataView%'] = new $Object(realm, '%DataView%', functionPrototype, 1 /* normal */, empty);
        this['%ArrayBuffer%'] = new $Object(realm, '%ArrayBuffer%', functionPrototype, 1 /* normal */, empty);
        this['%SharedArrayBuffer%'] = new $Object(realm, '%SharedArrayBuffer%', functionPrototype, 1 /* normal */, empty);
        this['%TypedArray%'] = new $Object(realm, '%TypedArray%', functionPrototype, 1 /* normal */, empty);
        this['%Float32Array%'] = new $Object(realm, '%Float32Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Float64Array%'] = new $Object(realm, '%Float64Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Int8Array%'] = new $Object(realm, '%Int8Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Int16Array%'] = new $Object(realm, '%Int16Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Int32Array%'] = new $Object(realm, '%Int32Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Uint8Array%'] = new $Object(realm, '%Uint8Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Uint8ClampedArray%'] = new $Object(realm, '%Uint8ClampedArray%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Uint16Array%'] = new $Object(realm, '%Uint16Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Uint32Array%'] = new $Object(realm, '%Uint32Array%', this['%TypedArray%'], 1 /* normal */, empty);
        this['%Atomics%'] = new $Object(realm, '%Atomics%', objectPrototype, 1 /* normal */, empty);
        this['%JSON%'] = new $Object(realm, '%JSON%', objectPrototype, 1 /* normal */, empty);
        this['%Math%'] = new $Object(realm, '%Math%', objectPrototype, 1 /* normal */, empty);
        const reflect = this['%Reflect%'] = new $Reflect(realm, objectPrototype);
        reflect.$apply = new $Reflect_apply(realm, functionPrototype);
        reflect.$construct = new $Reflect_construct(realm, functionPrototype);
        reflect.$defineProperty = new $Reflect_defineProperty(realm, functionPrototype);
        reflect.$deleteProperty = new $Reflect_deleteProperty(realm, functionPrototype);
        reflect.$get = new $Reflect_get(realm, functionPrototype);
        reflect.$getOwnPropertyDescriptor = new $Reflect_getOwnPropertyDescriptor(realm, functionPrototype);
        reflect.$getPrototypeOf = new $Reflect_getPrototypeOf(realm, functionPrototype);
        reflect.$has = new $Reflect_has(realm, functionPrototype);
        reflect.$isExtensible = new $Reflect_isExtensible(realm, functionPrototype);
        reflect.$ownKeys = new $Reflect_ownKeys(realm, functionPrototype);
        reflect.$preventExtensions = new $Reflect_preventExtensions(realm, functionPrototype);
        reflect.$set = new $Reflect_set(realm, functionPrototype);
        reflect.$setPrototypeOf = new $Reflect_setPrototypeOf(realm, functionPrototype);
        const proxyConstructor = this['%Proxy%'] = new $ProxyConstructor(realm, functionPrototype);
        proxyConstructor.revocable = new $Proxy_revocable(realm, functionPrototype);
        this['%decodeURI%'] = new $DecodeURI(realm, functionPrototype);
        this['%decodeURIComponent%'] = new $DecodeURIComponent(realm, functionPrototype);
        this['%encodeURI%'] = new $EncodeURI(realm, functionPrototype);
        this['%encodeURIComponent%'] = new $EncodeURIComponent(realm, functionPrototype);
        this['%eval%'] = new $Eval(realm, functionPrototype);
        this['%isFinite%'] = new $IsFinite(realm, functionPrototype);
        this['%isNaN%'] = new $IsNaN(realm, functionPrototype);
        this['%parseFloat%'] = new $ParseFloat(realm, functionPrototype);
        this['%parseInt%'] = new $ParseInt(realm, functionPrototype);
        this['%JSONParse%'] = new $Object(realm, '%JSONParse%', functionPrototype, 1 /* normal */, empty);
        this['%JSONStringify%'] = new $Object(realm, '%JSONStringify%', functionPrototype, 1 /* normal */, empty);
        this['%ArrayProto_entries%'] = new $Object(realm, '%ArrayProto_entries%', functionPrototype, 1 /* normal */, empty);
        this['%ArrayProto_forEach%'] = new $Object(realm, '%ArrayProto_forEach%', functionPrototype, 1 /* normal */, empty);
        this['%ArrayProto_keys%'] = new $Object(realm, '%ArrayProto_keys%', functionPrototype, 1 /* normal */, empty);
        this['%ArrayProto_values%'] = new $Object(realm, '%ArrayProto_values%', functionPrototype, 1 /* normal */, empty);
        this['%ObjProto_valueOf%'] = new $Object(realm, '%ObjProto_valueOf%', functionPrototype, 1 /* normal */, empty);
    }
    dispose() {
        this['true'] = void 0;
        this['false'] = void 0;
        this['NaN'] = void 0;
        this['Infinity'] = void 0;
        this['-Infinity'] = void 0;
        this['0'] = void 0;
        this['-0'] = void 0;
        this[''] = void 0;
        this['*'] = void 0;
        this['*default*'] = void 0;
        this['default'] = void 0;
        this['string'] = void 0;
        this['number'] = void 0;
        this['length'] = void 0;
        this['next'] = void 0;
        this['return'] = void 0;
        this['throw'] = void 0;
        this['call'] = void 0;
        this['message'] = void 0;
        this['$arguments'] = void 0;
        this['$callee'] = void 0;
        this['$constructor'] = void 0;
        this['$prototype'] = void 0;
        this['$name'] = void 0;
        this['$toString'] = void 0;
        this['$valueOf'] = void 0;
        this['$enumerable'] = void 0;
        this['$configurable'] = void 0;
        this['$writable'] = void 0;
        this['$value'] = void 0;
        this['$return'] = void 0;
        this['$done'] = void 0;
        this['$getPrototypeOf'] = void 0;
        this['$setPrototypeOf'] = void 0;
        this['$isExtensible'] = void 0;
        this['$preventExtensions'] = void 0;
        this['$getOwnPropertyDescriptor'] = void 0;
        this['$defineProperty'] = void 0;
        this['$has'] = void 0;
        this['$get'] = void 0;
        this['$set'] = void 0;
        this['$deleteProperty'] = void 0;
        this['$ownKeys'] = void 0;
        this['$apply'] = void 0;
        this['$construct'] = void 0;
        this['@@asyncIterator'] = void 0;
        this['@@hasInstance'] = void 0;
        this['@@isConcatSpreadable'] = void 0;
        this['@@iterator'] = void 0;
        this['@@match'] = void 0;
        this['@@replace'] = void 0;
        this['@@search'] = void 0;
        this['@@species'] = void 0;
        this['@@split'] = void 0;
        this['@@toPrimitive'] = void 0;
        this['@@toStringTag'] = void 0;
        this['@@unscopables'] = void 0;
        this['%ObjectPrototype%'].dispose();
        this['%ObjectPrototype%'] = void 0;
        this['%FunctionPrototype%'].dispose();
        this['%FunctionPrototype%'] = void 0;
        this['%Object%'].dispose();
        this['%Object%'] = void 0;
        this['%Function%'].dispose();
        this['%Function%'] = void 0;
        this['%ThrowTypeError%'].dispose();
        this['%ThrowTypeError%'] = void 0;
        this['%ObjProto_toString%'].dispose();
        this['%ObjProto_toString%'] = void 0;
        this['%String%'].dispose();
        this['%String%'] = void 0;
        this['%StringPrototype%'].dispose();
        this['%StringPrototype%'] = void 0;
        this['%Number%'].dispose();
        this['%Number%'] = void 0;
        this['%NumberPrototype%'].dispose();
        this['%NumberPrototype%'] = void 0;
        this['%Boolean%'].dispose();
        this['%Boolean%'] = void 0;
        this['%BooleanPrototype%'].dispose();
        this['%BooleanPrototype%'] = void 0;
        this['%Symbol%'].dispose();
        this['%Symbol%'] = void 0;
        this['%SymbolPrototype%'].dispose();
        this['%SymbolPrototype%'] = void 0;
        this['%Error%'].dispose();
        this['%Error%'] = void 0;
        this['%ErrorPrototype%'].dispose();
        this['%ErrorPrototype%'] = void 0;
        this['%EvalError%'].dispose();
        this['%EvalError%'] = void 0;
        this['%EvalErrorPrototype%'].dispose();
        this['%EvalErrorPrototype%'] = void 0;
        this['%RangeError%'].dispose();
        this['%RangeError%'] = void 0;
        this['%RangeErrorPrototype%'].dispose();
        this['%RangeErrorPrototype%'] = void 0;
        this['%ReferenceError%'].dispose();
        this['%ReferenceError%'] = void 0;
        this['%ReferenceErrorPrototype%'].dispose();
        this['%ReferenceErrorPrototype%'] = void 0;
        this['%SyntaxError%'].dispose();
        this['%SyntaxError%'] = void 0;
        this['%SyntaxErrorPrototype%'].dispose();
        this['%SyntaxErrorPrototype%'] = void 0;
        this['%TypeError%'].dispose();
        this['%TypeError%'] = void 0;
        this['%TypeErrorPrototype%'].dispose();
        this['%TypeErrorPrototype%'] = void 0;
        this['%URIError%'].dispose();
        this['%URIError%'] = void 0;
        this['%URIErrorPrototype%'].dispose();
        this['%URIErrorPrototype%'] = void 0;
        this['%PromisePrototype%'].dispose();
        this['%PromisePrototype%'] = void 0;
        this['%RegExpPrototype%'].dispose();
        this['%RegExpPrototype%'] = void 0;
        this['%DatePrototype%'].dispose();
        this['%DatePrototype%'] = void 0;
        this['%AsyncFunctionPrototype%'].dispose();
        this['%AsyncFunctionPrototype%'] = void 0;
        this['%Generator%'].dispose();
        this['%Generator%'] = void 0;
        this['%AsyncGenerator%'].dispose();
        this['%AsyncGenerator%'] = void 0;
        this['%IteratorPrototype%'].dispose();
        this['%IteratorPrototype%'] = void 0;
        this['%ArrayIteratorPrototype%'].dispose();
        this['%ArrayIteratorPrototype%'] = void 0;
        this['%MapIteratorPrototype%'].dispose();
        this['%MapIteratorPrototype%'] = void 0;
        this['%SetIteratorPrototype%'].dispose();
        this['%SetIteratorPrototype%'] = void 0;
        this['%StringIteratorPrototype%'].dispose();
        this['%StringIteratorPrototype%'] = void 0;
        this['%GeneratorPrototype%'].dispose();
        this['%GeneratorPrototype%'] = void 0;
        this['%AsyncIteratorPrototype%'].dispose();
        this['%AsyncIteratorPrototype%'] = void 0;
        this['%AsyncFromSyncIteratorPrototype%'].dispose();
        this['%AsyncFromSyncIteratorPrototype%'] = void 0;
        this['%AsyncGeneratorPrototype%'].dispose();
        this['%AsyncGeneratorPrototype%'] = void 0;
        this['%ArrayPrototype%'].dispose();
        this['%ArrayPrototype%'] = void 0;
        this['%MapPrototype%'].dispose();
        this['%MapPrototype%'] = void 0;
        this['%WeakMapPrototype%'].dispose();
        this['%WeakMapPrototype%'] = void 0;
        this['%SetPrototype%'].dispose();
        this['%SetPrototype%'] = void 0;
        this['%WeakSetPrototype%'].dispose();
        this['%WeakSetPrototype%'] = void 0;
        this['%DataViewPrototype%'].dispose();
        this['%DataViewPrototype%'] = void 0;
        this['%ArrayBufferPrototype%'].dispose();
        this['%ArrayBufferPrototype%'] = void 0;
        this['%SharedArrayBufferPrototype%'].dispose();
        this['%SharedArrayBufferPrototype%'] = void 0;
        this['%TypedArrayPrototype%'].dispose();
        this['%TypedArrayPrototype%'] = void 0;
        this['%Float32ArrayPrototype%'].dispose();
        this['%Float32ArrayPrototype%'] = void 0;
        this['%Float64ArrayPrototype%'].dispose();
        this['%Float64ArrayPrototype%'] = void 0;
        this['%Int8ArrayPrototype%'].dispose();
        this['%Int8ArrayPrototype%'] = void 0;
        this['%Int16ArrayPrototype%'].dispose();
        this['%Int16ArrayPrototype%'] = void 0;
        this['%Int32ArrayPrototype%'].dispose();
        this['%Int32ArrayPrototype%'] = void 0;
        this['%Uint8ArrayPrototype%'].dispose();
        this['%Uint8ArrayPrototype%'] = void 0;
        this['%Uint8ClampedArrayPrototype%'].dispose();
        this['%Uint8ClampedArrayPrototype%'] = void 0;
        this['%Uint16ArrayPrototype%'].dispose();
        this['%Uint16ArrayPrototype%'] = void 0;
        this['%Uint32ArrayPrototype%'].dispose();
        this['%Uint32ArrayPrototype%'] = void 0;
        this['%Promise%'].dispose();
        this['%Promise%'] = void 0;
        this['%RegExp%'].dispose();
        this['%RegExp%'] = void 0;
        this['%Date%'].dispose();
        this['%Date%'] = void 0;
        this['%AsyncFunction%'].dispose();
        this['%AsyncFunction%'] = void 0;
        this['%GeneratorFunction%'].dispose();
        this['%GeneratorFunction%'] = void 0;
        this['%AsyncGeneratorFunction%'].dispose();
        this['%AsyncGeneratorFunction%'] = void 0;
        this['%Array%'].dispose();
        this['%Array%'] = void 0;
        this['%Map%'].dispose();
        this['%Map%'] = void 0;
        this['%WeakMap%'].dispose();
        this['%WeakMap%'] = void 0;
        this['%Set%'].dispose();
        this['%Set%'] = void 0;
        this['%WeakSet%'].dispose();
        this['%WeakSet%'] = void 0;
        this['%DataView%'].dispose();
        this['%DataView%'] = void 0;
        this['%ArrayBuffer%'].dispose();
        this['%ArrayBuffer%'] = void 0;
        this['%SharedArrayBuffer%'].dispose();
        this['%SharedArrayBuffer%'] = void 0;
        this['%TypedArray%'].dispose();
        this['%TypedArray%'] = void 0;
        this['%Float32Array%'].dispose();
        this['%Float32Array%'] = void 0;
        this['%Float64Array%'].dispose();
        this['%Float64Array%'] = void 0;
        this['%Int8Array%'].dispose();
        this['%Int8Array%'] = void 0;
        this['%Int16Array%'].dispose();
        this['%Int16Array%'] = void 0;
        this['%Int32Array%'].dispose();
        this['%Int32Array%'] = void 0;
        this['%Uint8Array%'].dispose();
        this['%Uint8Array%'] = void 0;
        this['%Uint8ClampedArray%'].dispose();
        this['%Uint8ClampedArray%'] = void 0;
        this['%Uint16Array%'].dispose();
        this['%Uint16Array%'] = void 0;
        this['%Uint32Array%'].dispose();
        this['%Uint32Array%'] = void 0;
        this['%Atomics%'].dispose();
        this['%Atomics%'] = void 0;
        this['%JSON%'].dispose();
        this['%JSON%'] = void 0;
        this['%Math%'].dispose();
        this['%Math%'] = void 0;
        this['%Reflect%'].dispose();
        this['%Reflect%'] = void 0;
        this['%Proxy%'].dispose();
        this['%Proxy%'] = void 0;
        this['%decodeURI%'].dispose();
        this['%decodeURI%'] = void 0;
        this['%decodeURIComponent%'].dispose();
        this['%decodeURIComponent%'] = void 0;
        this['%encodeURI%'].dispose();
        this['%encodeURI%'] = void 0;
        this['%encodeURIComponent%'].dispose();
        this['%encodeURIComponent%'] = void 0;
        this['%eval%'].dispose();
        this['%eval%'] = void 0;
        this['%isFinite%'].dispose();
        this['%isFinite%'] = void 0;
        this['%isNaN%'].dispose();
        this['%isNaN%'] = void 0;
        this['%parseFloat%'].dispose();
        this['%parseFloat%'] = void 0;
        this['%parseInt%'].dispose();
        this['%parseInt%'] = void 0;
        this['%JSONParse%'].dispose();
        this['%JSONParse%'] = void 0;
        this['%JSONStringify%'].dispose();
        this['%JSONStringify%'] = void 0;
        this['%ArrayProto_entries%'].dispose();
        this['%ArrayProto_entries%'] = void 0;
        this['%ArrayProto_forEach%'].dispose();
        this['%ArrayProto_forEach%'] = void 0;
        this['%ArrayProto_keys%'].dispose();
        this['%ArrayProto_keys%'] = void 0;
        this['%ArrayProto_values%'].dispose();
        this['%ArrayProto_values%'] = void 0;
        this['%ObjProto_valueOf%'].dispose();
        this['%ObjProto_valueOf%'] = void 0;
        this['%PromiseProto_then%'].dispose();
        this['%PromiseProto_then%'] = void 0;
        this['%Promise_all%'].dispose();
        this['%Promise_all%'] = void 0;
        this['%Promise_reject%'].dispose();
        this['%Promise_reject%'] = void 0;
        this['%Promise_resolve%'].dispose();
        this['%Promise_resolve%'] = void 0;
    }
}
// export type IntrinsicObjectKey =
//   { [K in keyof Intrinsics]: Intrinsics[K] extends $Object ? K : never; } extends { [K in keyof Intrinsics]: infer U; }
//     ? ({} extends U ? never : U)
//     : never;

class ResolveSet {
    constructor() {
        this.modules = [];
        this.exportNames = [];
        this.count = 0;
    }
    has(mod, exportName) {
        const modules = this.modules;
        const exportNames = this.exportNames;
        const count = this.count;
        for (let i = 0; i < count; ++i) {
            if (exportNames[i].is(exportName) && modules[i] === mod) {
                return true;
            }
        }
        return false;
    }
    add(mod, exportName) {
        const index = this.count;
        this.modules[index] = mod;
        this.exportNames[index] = exportName;
        ++this.count;
    }
    forEach(callback) {
        const modules = this.modules;
        const exportNames = this.exportNames;
        const count = this.count;
        for (let i = 0; i < count; ++i) {
            callback(modules[i], exportNames[i]);
        }
    }
}
class ResolvedBindingRecord {
    constructor(Module, BindingName) {
        this.Module = Module;
        this.BindingName = BindingName;
    }
    get isAbrupt() { return false; }
    get isNull() { return false; }
    get isAmbiguous() { return false; }
}
class DeferredModule {
    constructor($file, realm) {
        this.$file = $file;
        this.realm = realm;
    }
    get isAbrupt() { return false; }
    ResolveExport(ctx, exportName, resolveSet) {
        throw new Error('Method not implemented.');
    }
    GetExportedNames(ctx, exportStarSet) {
        throw new Error('Method not implemented.');
    }
    Instantiate(ctx) {
        throw new Error('Method not implemented.');
    }
    _InnerModuleInstantiation(ctx, stack, index) {
        throw new Error('Method not implemented.');
    }
    dispose() {
        throw new Error('Method not implemented.');
    }
}
// http://www.ecma-international.org/ecma-262/#sec-code-realms
class Realm {
    constructor(container, logger, PromiseJobs) {
        this.container = container;
        this.logger = logger;
        this.PromiseJobs = PromiseJobs;
        this.timeout = 100;
        this.contextId = 0;
        this.stack = new ExecutionContextStack(logger);
    }
    get isAbrupt() { return false; }
    // http://www.ecma-international.org/ecma-262/#sec-createrealm
    // 8.2.1 CreateRealm ( )
    static Create(container, promiseJobs) {
        const logger = container.get(kernel.ILogger).root.scopeTo('Realm');
        logger.debug('Creating new realm');
        // 1. Let realmRec be a new Realm Record.
        const realm = new Realm(container, logger, promiseJobs);
        // 2. Perform CreateIntrinsics(realmRec).
        new Intrinsics(realm);
        // 3. Set realmRec.[[GlobalObject]] to undefined.
        realm['[[GlobalObject]]'] = (void 0);
        // 4. Set realmRec.[[GlobalEnv]] to undefined.
        realm['[[GlobalEnv]]'] = (void 0);
        // 5. Set realmRec.[[TemplateMap]] to a new empty List.
        realm['[[TemplateMap]]'] = [];
        // 6. Return realmRec.
        // http://www.ecma-international.org/ecma-262/#sec-initializehostdefinedrealm
        // 8.5 InitializeHostDefinedRealm ( )
        // 1. Let realm be CreateRealm().
        const intrinsics = realm['[[Intrinsics]]'];
        // 2. Let newContext be a new execution context.
        const newContext = new ExecutionContext(realm);
        // 3. Set the Function of newContext to null.
        newContext.Function = intrinsics.null;
        // 4. Set the Realm of newContext to realm.
        // 5. Set the ScriptOrModule of newContext to null.
        newContext.ScriptOrModule = intrinsics.null;
        // 6. Push newContext onto the execution context stack; newContext is now the running execution context.
        realm.stack.push(newContext);
        // 7. If the host requires use of an exotic object to serve as realm's global object, let global be such an object created in an implementation-defined manner. Otherwise, let global be undefined, indicating that an ordinary object should be created as the global object.
        const globalObj = $Object.ObjectCreate(newContext, 'GlobalObject', intrinsics['%ObjectPrototype%']);
        // 8. If the host requires that the this binding in realm's global scope return an object other than the global object, let thisValue be such an object created in an implementation-defined manner. Otherwise, let thisValue be undefined, indicating that realm's global this binding should be the global object.
        const thisValue = globalObj;
        // Note: the two steps above are consolidated with setrealmglobalobject steps
        // 9. Perform SetRealmGlobalObject(realm, global, thisValue).
        // http://www.ecma-international.org/ecma-262/#sec-setrealmglobalobject
        // 8.2.3 SetRealmGlobalObject ( realmRec , globalObj , thisValue )
        // 1. If globalObj is undefined, then
        // 1. a. Let intrinsics be realmRec.[[Intrinsics]].
        // 1. b. Set globalObj to ObjectCreate(intrinsics.[[%ObjectPrototype%]]).
        // 2. Assert: Type(globalObj) is Object.
        // 3. If thisValue is undefined, set thisValue to globalObj.
        // 4. Set realmRec.[[GlobalObject]] to globalObj.
        realm['[[GlobalObject]]'] = globalObj;
        // 5. Let newGlobalEnv be NewGlobalEnvironment(globalObj, thisValue).
        const newGlobalEnv = new $GlobalEnvRec(logger, realm, globalObj, thisValue);
        // 6. Set realmRec.[[GlobalEnv]] to newGlobalEnv.
        realm['[[GlobalEnv]]'] = newGlobalEnv;
        // 7. Return realmRec.
        // 10. Let globalObj be ? SetDefaultGlobalBindings(realm).
        // http://www.ecma-international.org/ecma-262/#sec-setdefaultglobalbindings
        // 8.2.4 SetDefaultGlobalBindings ( realmRec )
        // 1. Let global be realmRec.[[GlobalObject]].
        const global = realm['[[GlobalObject]]'];
        // 2. For each property of the Global Object specified in clause 18, do
        // 2. a. Let name be the String value of the property name.
        // 2. b. Let desc be the fully populated data property descriptor for the property containing the specified attributes for the property. For properties listed in 18.2, 18.3, or 18.4 the value of the [[Value]] attribute is the corresponding intrinsic object from realmRec.
        // 2. c. Perform ? DefinePropertyOrThrow(global, name, desc).
        // 3. Return global.
        function def(propertyName, intrinsicName) {
            const name = new $String(realm, propertyName);
            const desc = new $PropertyDescriptor(realm, name);
            desc['[[Writable]]'] = intrinsics.false;
            desc['[[Enumerable]]'] = intrinsics.false;
            desc['[[Configurable]]'] = intrinsics.false;
            desc['[[Value]]'] = intrinsics[intrinsicName];
            $DefinePropertyOrThrow(newContext, global, name, desc);
        }
        // http://www.ecma-international.org/ecma-262/#sec-value-properties-of-the-global-object
        // 18.1 Value Properties of the Global Object
        def('Infinity', 'Infinity');
        def('NaN', 'NaN');
        def('undefined', 'undefined');
        // http://www.ecma-international.org/ecma-262/#sec-function-properties-of-the-global-object
        // 18.2 Function Properties of the Global Object
        def('eval', '%eval%');
        def('isFinite', '%isFinite%');
        def('isNaN', '%isNaN%');
        def('parseFloat', '%parseFloat%');
        def('parseInt', '%parseInt%');
        def('decodeURI', '%decodeURI%');
        def('decodeURIComponent', '%decodeURIComponent%');
        def('encodeURI', '%encodeURI%');
        def('encodeURIComponent', '%encodeURIComponent%');
        // http://www.ecma-international.org/ecma-262/#sec-constructor-properties-of-the-global-object
        // 18.3 Constructor Properties of the Global Object
        def('Array', '%Array%');
        def('ArrayBuffer', '%ArrayBuffer%');
        def('Boolean', '%Boolean%');
        def('DataView', '%DataView%');
        def('Date', '%Date%');
        def('Error', '%Error%');
        def('EvalError', '%EvalError%');
        def('Float32Array', '%Float32Array%');
        def('Float64Array', '%Float64Array%');
        def('Function', '%Function%');
        def('Int8Array', '%Int8Array%');
        def('Int16Array', '%Int16Array%');
        def('Int32Array', '%Int32Array%');
        def('Map', '%Map%');
        def('Number', '%Number%');
        def('Object', '%Object%');
        def('Promise', '%Promise%');
        def('Proxy', '%Proxy%');
        def('RangeError', '%RangeError%');
        def('ReferenceError', '%ReferenceError%');
        def('RegExp', '%RegExp%');
        def('Set', '%Set%');
        def('SharedArrayBuffer', '%SharedArrayBuffer%');
        def('String', '%String%');
        def('Symbol', '%Symbol%');
        def('SyntaxError', '%SyntaxError%');
        def('TypeError', '%TypeError%');
        def('Uint8Array', '%Uint8Array%');
        def('Uint8ClampedArray', '%Uint8ClampedArray%');
        def('Uint16Array', '%Uint16Array%');
        def('Uint32Array', '%Uint32Array%');
        def('URIError', '%URIError%');
        def('WeakMap', '%WeakMap%');
        def('WeakSet', '%WeakSet%');
        // http://www.ecma-international.org/ecma-262/#sec-other-properties-of-the-global-object
        // 18.4 Other Properties of the Global Object
        def('Atomics', '%Atomics%');
        def('JSON', '%JSON%');
        def('Math', '%Math%');
        def('Reflect', '%Reflect%');
        // 11. Create any implementation-defined global object properties on globalObj.
        // 12. Return NormalCompletion(empty).
        logger.debug('Finished initializing realm');
        return realm;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getactivescriptormodule
    // 8.3.1 GetActiveScriptOrModule ( )
    GetActiveScriptOrModule() {
        const stack = this.stack;
        // 1. If the execution context stack is empty, return null.
        if (stack.length === 0) {
            // We're throwing here for now. Not sure in which scenario this could be null that would not throw at some point.
            throw new Error(`GetActiveScriptOrModule: stack is empty`);
        }
        // 2. Let ec be the topmost execution context on the execution context stack whose ScriptOrModule component is not null.
        let ec;
        let i = stack.length;
        while (i-- > 0) {
            ec = stack[i];
            if (!ec.ScriptOrModule.isNull) {
                return ec.ScriptOrModule;
            }
        }
        // 3. If no such execution context exists, return null. Otherwise, return ec's ScriptOrModule component.
        // We're throwing here for now. Not sure in which scenario this could be null that would not throw at some point.
        throw new Error(`GetActiveScriptOrModule: stack has no execution context with an active module`);
    }
    // http://www.ecma-international.org/ecma-262/#sec-resolvebinding
    // 8.3.2 ResolveBinding ( name [ , env ] )
    ResolveBinding(name, env) {
        // 1. If env is not present or if env is undefined, then
        if (env === void 0) {
            // 1. a. Set env to the running execution context's LexicalEnvironment.
            env = this.stack.top.LexicalEnvironment;
        }
        // 2. Assert: env is a Lexical Environment.
        // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.
        const strict = this['[[Intrinsics]]'].true; // TODO: pass strict mode from source node
        // 4. Return ? GetIdentifierReference(env, name, strict).
        return this.GetIdentifierReference(env, name, strict);
    }
    // http://www.ecma-international.org/ecma-262/#sec-getthisenvironment
    // 8.3.3 GetThisEnvironment ( )
    GetThisEnvironment() {
        // 1. Let lex be the running execution context's LexicalEnvironment.
        let envRec = this.stack.top.LexicalEnvironment;
        // 2. Repeat,
        while (true) {
            // 2. a. Let envRec be lex's EnvironmentRecord.
            // 2. b. Let exists be envRec.HasThisBinding().
            if (envRec.HasThisBinding(this.stack.top).isTruthy) {
                // 2. c. If exists is true, return envRec.
                return envRec;
            }
            // 2. d. Let outer be the value of lex's outer environment reference.
            // 2. e. Assert: outer is not null.
            // 2. f. Set lex to outer.
            envRec = envRec.outer;
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-resolvethisbinding
    // 8.3.4 ResolveThisBinding ( )
    ResolveThisBinding() {
        // 1. Let envRec be GetThisEnvironment().
        const envRec = this.GetThisEnvironment();
        // 2. Return ? envRec.GetThisBinding().
        return envRec.GetThisBinding(this.stack.top);
    }
    // #region helper methods
    GetCurrentLexicalEnvironment() {
        return this.stack.top.LexicalEnvironment;
    }
    SetCurrentLexicalEnvironment(envRec) {
        this.stack.top.LexicalEnvironment = envRec;
    }
    // #endregion
    dispose() {
        this.stack.dispose();
        this.stack = void 0;
        this['[[Intrinsics]]'].dispose();
        this['[[Intrinsics]]'] = void 0;
        this['[[GlobalObject]]'].dispose();
        this['[[GlobalObject]]'] = void 0;
        this['[[GlobalEnv]]'].dispose();
        this['[[GlobalEnv]]'] = void 0;
        this.container = void 0;
        this.logger = void 0;
    }
    // http://www.ecma-international.org/ecma-262/#sec-getidentifierreference
    // 8.1.2.1 GetIdentifierReference ( lex , name , strict )
    GetIdentifierReference(lex, name, strict) {
        const intrinsics = this['[[Intrinsics]]'];
        // 1. If lex is the value null, then
        if (lex.isNull) {
            // 1. a. Return a value of type Reference whose base value component is undefined, whose referenced name component is name, and whose strict reference flag is strict.
            return new $Reference(this, intrinsics.undefined, name, strict, intrinsics.undefined);
        }
        // 2. Let envRec be lex's EnvironmentRecord.
        const envRec = lex;
        // 3. Let exists be ? envRec.HasBinding(name).
        const exists = envRec.HasBinding(this.stack.top, name);
        if (exists.isAbrupt) {
            return exists;
        }
        // 4. If exists is true, then
        if (exists.isTruthy) {
            // 4. a. Return a value of type Reference whose base value component is envRec, whose referenced name component is name, and whose strict reference flag is strict.
            return new $Reference(this, envRec, name, strict, intrinsics.undefined);
        }
        // 5. Else,
        else {
            // 5. a. Let outer be the value of lex's outer environment reference.
            const outer = lex.outer;
            // 5. b. Return ? GetIdentifierReference(outer, name, strict).
            return this.GetIdentifierReference(outer, name, strict);
        }
    }
}
class ExecutionContextStack extends Array {
    constructor(logger) {
        super();
        this.logger = logger;
        this.logger = logger.root.scopeTo('ExecutionContextStack');
    }
    get top() {
        return this[this.length - 1];
    }
    push(context) {
        this.logger.debug(`push(#${context.id}) - new stack size: ${this.length + 1}`);
        return super.push(context);
    }
    pop() {
        this.logger.debug(`pop(#${this.top.id}) - new stack size: ${this.length - 1}`);
        return super.pop();
    }
    toString() {
        let str = '';
        for (let i = 0; i < this.length; ++i) {
            const fn = this[i].Function;
            if (fn === void 0 || fn.isNull) {
                str = `${str}  at NULL\n`;
            }
            else {
                str = `${str}  at ${fn.toString()}\n`;
            }
        }
        return str;
    }
    dispose() {
        this.forEach(x => { x.dispose(); });
        this.length = 0;
        this.logger = void 0;
    }
}
class ExecutionContext {
    constructor(Realm) {
        this.Realm = Realm;
        this.Generator = void 0;
        this.onResume = void 0;
        this.suspended = false;
        this.activityTimestamp = Date.now();
        this.activeTime = 0;
        this.timeoutCheck = 0;
        this.id = ++Realm.contextId;
        this.logger = Realm['logger'].root.scopeTo(`ExecutionContext #${this.id}`);
        this.logger.debug(`constructor()`);
    }
    checkTimeout() {
        if (!this.suspended) {
            // Reduce the number of calls to the relative expensive Date.now()
            if (++this.timeoutCheck === 100) {
                this.timeoutCheck = 0;
                this.activeTime += (Date.now() - this.activityTimestamp);
                this.activityTimestamp = Date.now();
                if (this.activeTime >= this.Realm.timeout) {
                    throw new Error(`Operation timed out`);
                }
            }
        }
    }
    resume() {
        this.logger.debug(`resume()`);
        if (!this.suspended) {
            throw new Error('ExecutionContext is not suspended');
        }
        if (this.Realm.stack.top !== this) {
            throw new Error('ExecutionContext is not at the top of the stack');
        }
        this.suspended = false;
        this.activityTimestamp = Date.now();
    }
    suspend() {
        this.logger.debug(`suspend()`);
        if (this.suspended) {
            throw new Error('ExecutionContext is already suspended');
        }
        if (this.Realm.stack.top !== this) {
            throw new Error('ExecutionContext is not at the top of the stack');
        }
        this.suspended = true;
        // Timeout on a per-execution context basis, and only count the time that this context was active.
        // This reduces false positives while still keeping potential infinite loops in deeply nested stacks (with constant popping/pushing) in check.
        this.activeTime += (Date.now() - this.activityTimestamp);
    }
    makeCopy() {
        const ctx = new ExecutionContext(this.Realm);
        ctx.Function = this.Function;
        ctx.ScriptOrModule = this.ScriptOrModule;
        ctx.LexicalEnvironment = this.LexicalEnvironment;
        ctx.VariableEnvironment = this.VariableEnvironment;
        ctx.Generator = this.Generator;
        ctx.onResume = this.onResume;
        ctx.suspended = this.suspended;
        return ctx;
    }
    dispose() {
        this.Function = void 0;
        this.ScriptOrModule.dispose();
        this.ScriptOrModule = void 0;
        this.LexicalEnvironment.dispose();
        this.LexicalEnvironment = void 0;
        this.VariableEnvironment.dispose();
        this.VariableEnvironment = void 0;
        this.Generator = void 0;
        this.Realm = void 0;
        this.logger = void 0;
    }
}

const ISourceFileProvider = kernel.DI.createInterface('ISourceFileProvider');
// http://www.ecma-international.org/ecma-262/#sec-agents
class Agent {
    constructor(logger) {
        this.logger = logger;
        this.ScriptJobs = new JobQueue(logger, 'Script');
        this.PromiseJobs = new JobQueue(logger, 'Promise');
    }
    // http://www.ecma-international.org/ecma-262/#sec-runjobs
    // 8.6 RunJobs ( )
    async RunJobs(container) {
        // 1. Perform ? InitializeHostDefinedRealm().
        const realm = Realm.Create(container, this.PromiseJobs);
        const intrinsics = realm['[[Intrinsics]]'];
        const stack = realm.stack;
        // We always have 1 synthetic root context which should not be considered to be a part of the stack.
        // It's exclusively used for initializing intrinsics, to conform to the method signatures.
        const rootCtx = stack.top;
        // 2. In an implementation-dependent manner, obtain the ECMAScript source texts (see clause 10) and any associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules. For each such sourceText and hostDefined, do
        const sfProvider = container.get(ISourceFileProvider);
        const files = await sfProvider.GetSourceFiles(rootCtx);
        for (const file of files) {
            // 2. a. If sourceText is the source code of a script, then
            if (file.isScript) {
                // 2. a. i. Perform EnqueueJob("ScriptJobs", ScriptEvaluationJob, « sourceText, hostDefined »).
                this.ScriptJobs.EnqueueJob(rootCtx, new ScriptEvaluationJob(realm, file));
            }
            // 2. b. Else sourceText is the source code of a module,
            else {
                // 2. b. i. Perform EnqueueJob("ScriptJobs", TopLevelModuleEvaluationJob, « sourceText, hostDefined »).
                this.ScriptJobs.EnqueueJob(rootCtx, new TopLevelModuleEvaluationJob(realm, file));
            }
        }
        const ctx = rootCtx;
        let lastFile = null;
        // 3. Repeat,
        while (true) {
            // 3. a. Suspend the running execution context and remove it from the execution context stack.
            if (ctx !== rootCtx) {
                ctx.suspend();
                stack.pop();
            }
            let nextPending;
            // 3. b. Assert: The execution context stack is now empty.
            // 3. c. Let nextQueue be a non-empty Job Queue chosen in an implementation-defined manner. If all Job Queues are empty, the result is implementation-defined.
            if (this.ScriptJobs.isEmpty) {
                if (this.PromiseJobs.isEmpty) {
                    this.logger.debug(`Finished successfully`);
                    return new $Empty(realm, 1 /* normal */, intrinsics.empty, lastFile);
                }
                else {
                    // 3. d. Let nextPending be the PendingJob record at the front of nextQueue. Remove that record from nextQueue.
                    nextPending = this.PromiseJobs.queue.shift();
                }
            }
            else {
                // 3. d. Let nextPending be the PendingJob record at the front of nextQueue. Remove that record from nextQueue.
                nextPending = this.ScriptJobs.queue.shift();
            }
            // 3. e. Let newContext be a new execution context.
            const newContext = new ExecutionContext(nextPending['[[Realm]]']);
            // 3. f. Set newContext's Function to null.
            newContext.Function = intrinsics.null;
            // 3. g. Set newContext's Realm to nextPending.[[Realm]].
            // 3. h. Set newContext's ScriptOrModule to nextPending.[[ScriptOrModule]].
            lastFile = newContext.ScriptOrModule = nextPending['[[ScriptOrModule]]'];
            // 3. i. Push newContext onto the execution context stack; newContext is now the running execution context.
            stack.push(newContext);
            // 3. j. Perform any implementation or host environment defined job initialization using nextPending.
            // 3. k. Let result be the result of performing the abstract operation named by nextPending.[[Job]] using the elements of nextPending.[[Arguments]] as its arguments.
            const result = nextPending.Run(newContext);
            // 3. l. If result is an abrupt completion, perform HostReportErrors(« result.[[Value]] »).
            if (result.isAbrupt) {
                this.logger.debug(`Job completed with errors`);
                return result;
            }
        }
    }
    dispose() {
        this.PromiseJobs.dispose();
        this.ScriptJobs.dispose();
        this.PromiseJobs = void 0;
        this.ScriptJobs = void 0;
        this.logger = void 0;
    }
}
class TopLevelModuleEvaluationJob extends Job {
    constructor(realm, mos) {
        super(realm.logger.scopeTo('TopLevelModuleEvaluationJob'), realm, mos);
    }
    // http://www.ecma-international.org/ecma-262/#sec-toplevelmoduleevaluationjob
    // 15.2.1.20 Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText , hostDefined )
    Run(ctx) {
        this.logger.debug(`Run(#${ctx.id})`);
        const m = this['[[ScriptOrModule]]'];
        // 1. Assert: sourceText is an ECMAScript source text (see clause 10).
        // 2. Let realm be the current Realm Record.
        // 3. Let m be ParseModule(sourceText, realm, hostDefined).
        // 4. If m is a List of errors, then
        // 4. a. Perform HostReportErrors(m).
        // 4. b. Return NormalCompletion(undefined).
        // 5. Perform ? m.Instantiate().
        const result = m.Instantiate(ctx);
        if (result.isAbrupt) {
            return result;
        }
        // 6. Assert: All dependencies of m have been transitively resolved and m is ready for evaluation.
        // 7. Return ? m.Evaluate().
        return m.EvaluateModule(ctx);
    }
}
class ScriptEvaluationJob extends Job {
    constructor(realm, mos) {
        super(realm.logger.scopeTo('ScriptEvaluationJob'), realm, mos);
    }
    // http://www.ecma-international.org/ecma-262/#sec-scriptevaluationjob
    // 15.1.12 Runtime Semantics: ScriptEvaluationJob ( sourceText , hostDefined )
    Run(ctx) {
        this.logger.debug(`Run(#${ctx.id})`);
        const m = this['[[ScriptOrModule]]'];
        // 1. Assert: sourceText is an ECMAScript source text (see clause 10).
        // 2. Let realm be the current Realm Record.
        // 3. Let s be ParseScript(sourceText, realm, hostDefined).
        // 4. If s is a List of errors, then
        // 4. a. Perform HostReportErrors(s).
        // 4. b. Return NormalCompletion(undefined).
        // 5. Return ? ScriptEvaluation(s).
        return m.EvaluateScript(ctx);
    }
}

function countSlashes(path) {
    let count = 0;
    const len = path.length;
    for (let i = 0; i < len; ++i) {
        if (path.charCodeAt(i) === 47 /* Slash */) {
            ++count;
        }
    }
    return count;
}
function createFileComparer(preferredNames) {
    const len = preferredNames.length;
    let name = '';
    return function compareFiles(a, b) {
        const aName = path.basename(a.path);
        const bName = path.basename(b.path);
        const aDepth = countSlashes(a.path);
        const bDepth = countSlashes(b.path);
        if (aDepth === bDepth) {
            /*
             * If both files are in the same folder, use "absolute" priorities between the convention-based
             * names and fall back to alphabetic sort.
             * Examples:
             *
             * - a = src/foo.js
             * - b = src/index.js <-- this one wins (the one with the convention wins)
             *
             * - a = src/foo.js
             * - b = src/startup.js <-- this one wins (the one with the convention wins)
             *
             * - a = src/startup.js
             * - b = src/index.js <-- this one wins (the one with the higher priority convention wins)
             *
             * - a = src/foo.js
             * - b = src/bar.js <-- this one wins (none match a convention, so sort alphabetically)
             */
            for (let i = 0; i < len; ++i) {
                name = preferredNames[i];
                if (aName === name) {
                    return -1;
                }
                if (bName === name) {
                    return 1;
                }
            }
            return aName < bName ? -1 : aName > bName ? 1 : 0;
        }
        if (aName === bName) {
            /*
            * The directory depth is different but the names are the same, so sort according to depth.
            * Examples:
            *
            * - a = src/foo.js <-- this one wins (the higher level path wins, even if it alphabetically comes last)
            * - b = src/bar/foo.js
            *
            * - a = src/foobarbazqux.js <-- this one wins (the higher level path wins, path length or other factors have no effect)
            * - b = src/a/b.js
            */
            return aDepth - bDepth;
        }
        /*
         * Depth is different and so are the names. Here, we group the different conventions together
         * so that they each have the same effective priority.
         * Examples:
         *
         * - a = src/foo.js
         * - b = src/bar/index.js <-- this one wins (the one with the convention wins, even if it is deeper level)
         *
         * - a = src/index.js <-- this one wins (both match same convention, so highest level wins)
         * - b = src/bar/index.js
         *
         * - a = src/startup.js <-- this one wins (both match any convention, so highest level wins)
         * - b = src/bar/index.js
         *
         * - a = src/foo.js <-- this one wins (none match a convention, so highest level wins)
         * - b = src/bar/baz.js
         */
        if (preferredNames.includes(aName)) {
            if (preferredNames.includes(bName)) {
                return aDepth - bDepth;
            }
            return -1;
        }
        if (preferredNames.includes(bName)) {
            return 1;
        }
        return aDepth - bDepth;
    };
}
// Node conventions
const compareExternalModuleEntryFile = createFileComparer([
    'index.js',
    'app.js',
    'server.js',
]);
// Aurelia conventions (TODO: make this configurable)
const compareApplicationEntryFile = createFileComparer([
    'index.ts',
    'index.js',
    'startup.ts',
    'startup.js',
    'main.ts',
    'main.js',
]);
function determineEntryFileByConvention(files, isPrimaryEntryPoint) {
    if (isPrimaryEntryPoint) {
        return files.slice().sort(compareApplicationEntryFile)[0];
    }
    return files.slice().sort(compareExternalModuleEntryFile)[0];
}
class NPMPackageLoader {
    constructor(container, logger, fs) {
        this.container = container;
        this.logger = logger;
        this.fs = fs;
        this.pkgCache = new Map();
        this.pkgPromiseCache = new Map();
        this.pkgResolveCache = new Map();
        this.pkgResolvePromiseCache = new Map();
        this.logger = logger.root.scopeTo('NPMPackageLoader');
    }
    static get inject() { return [kernel.IContainer, kernel.ILogger, IFileSystem]; }
    async loadEntryPackage(projectDir) {
        const start = Date.now();
        this.logger.info(`load()`);
        projectDir = normalizePath(projectDir);
        const entryPkg = await this.loadPackageCore(projectDir, null);
        await entryPkg.loadDependencies();
        this.pkgPromiseCache.clear();
        const end = Date.now();
        const packages = Array.from(this.pkgCache.values());
        const pkgCount = packages.length;
        const fileCount = packages.reduce((count, pkg) => count + pkg.files.length, 0);
        this.logger.info(`Discovered ${fileCount} files across ${pkgCount} packages in ${Math.round(end - start)}ms`);
        for (const pkg of packages) {
            this.logger.info(`- ${pkg.pkgName}: ${pkg.files.length} files`);
        }
        return entryPkg;
    }
    getCachedPackage(refName) {
        const pkg = this.pkgCache.get(refName);
        if (pkg === void 0) {
            throw new Error(`Cannot resolve package ${refName}`);
        }
        return pkg;
    }
    /** @internal */
    async loadPackage(issuer) {
        const pkgPromiseCache = this.pkgPromiseCache;
        let pkgPromise = pkgPromiseCache.get(issuer.refName);
        if (pkgPromise === void 0) {
            pkgPromise = this.loadPackageCore(null, issuer);
            // Multiple deps may request the same package to load before one of them finished
            // so we store the promise to ensure the action is only invoked once.
            pkgPromiseCache.set(issuer.refName, pkgPromise);
        }
        return pkgPromise;
    }
    async loadPackageCore(dir, issuer) {
        this.logger.info(`loadPackageCore(\n  dir: ${dir},\n  issuer: ${issuer === null ? 'null' : issuer.issuer.pkgName}\n)`);
        const fs = this.fs;
        const pkgCache = this.pkgCache;
        const refName = dir === null ? issuer.refName : dir;
        let pkg = pkgCache.get(refName);
        if (pkg === void 0) {
            if (dir === null) {
                dir = await this.resolvePackagePath(issuer);
            }
            const pkgPath = joinPath(dir, 'package.json');
            const files = await fs.getFiles(dir);
            const pkgJsonFile = files.find(x => x.path === pkgPath);
            if (pkgJsonFile === void 0) {
                throw new Error(`No package.json found at "${pkgPath}"`);
            }
            const pkgJsonFileContent = await pkgJsonFile.getContent();
            pkg = new NPMPackage(this, files, issuer, pkgJsonFile, dir, pkgJsonFileContent);
            pkgCache.set(refName, pkg);
        }
        return pkg;
    }
    async resolvePackagePath(dep) {
        const pkgResolvePromiseCache = this.pkgResolvePromiseCache;
        const refName = dep.refName;
        let resolvePromise = pkgResolvePromiseCache.get(refName);
        if (resolvePromise === void 0) {
            resolvePromise = this.resolvePackagePathCore(dep);
            // Multiple deps may request the same refName to be resolved before one of them finished
            // so we store the promise to ensure the action is only invoked once.
            pkgResolvePromiseCache.set(refName, resolvePromise);
        }
        return resolvePromise;
    }
    async resolvePackagePathCore(dep) {
        const fs = this.fs;
        const pkgResolveCache = this.pkgResolveCache;
        const refName = dep.refName;
        let resolvedPath = pkgResolveCache.get(refName);
        if (resolvedPath === void 0) {
            let dir = dep.issuer.dir;
            while (true) {
                resolvedPath = joinPath(dir, 'node_modules', refName, 'package.json');
                // eslint-disable-next-line no-await-in-loop
                if (await fs.isReadable(resolvedPath)) {
                    break;
                }
                const parent = normalizePath(path.dirname(dir));
                if (parent === dir) {
                    throw new Error(`Unable to resolve npm dependency "${refName}"`);
                }
                dir = parent;
            }
            const realPath = normalizePath(await fs.getRealPath(resolvedPath));
            if (realPath === resolvedPath) {
                this.logger.debug(`resolved "${refName}" directly to "${path.dirname(realPath)}"`);
            }
            else {
                this.logger.debug(`resolved "${refName}" to "${path.dirname(realPath)}" via symlink "${path.dirname(resolvedPath)}"`);
            }
            resolvedPath = normalizePath(path.dirname(realPath));
            pkgResolveCache.set(refName, resolvedPath);
        }
        return resolvedPath;
    }
}
class NPMPackage {
    constructor(loader, files, issuer, pkgJsonFile, dir, pkgJsonFileContent) {
        this.loader = loader;
        this.files = files;
        this.issuer = issuer;
        this.pkgJsonFile = pkgJsonFile;
        this.dir = dir;
        this.container = loader.container;
        const pkgJson = this.pkgJson = JSON.parse(pkgJsonFileContent);
        const pkgName = this.pkgName = typeof pkgJson.name === 'string' ? pkgJson.name : dir.slice(dir.lastIndexOf('/') + 1);
        const pkgModuleOrMain = typeof pkgJson.module === 'string' ? pkgJson.module : pkgJson.main;
        const isAureliaPkg = this.isAureliaPkg = pkgName.startsWith('@aurelia');
        const isEntryPoint = this.isEntryPoint = issuer === null;
        let entryFilePath = isAureliaPkg ? 'src/index.ts' : pkgModuleOrMain;
        let entryFile;
        if (entryFilePath === void 0) {
            entryFile = determineEntryFileByConvention(files, isEntryPoint);
        }
        else {
            if (entryFilePath.startsWith('.')) {
                entryFilePath = entryFilePath.slice(1);
            }
            entryFile = files.find(x => x.path.endsWith(entryFilePath));
            if (entryFile === void 0) {
                const withJs = `${entryFilePath}.js`;
                entryFile = files.find(x => x.path.endsWith(withJs));
                if (entryFile === void 0) {
                    const withIndexJs = joinPath(entryFilePath, 'index.js');
                    entryFile = files.find(x => x.path.endsWith(withIndexJs));
                }
            }
        }
        if (entryFile === void 0) {
            throw new Error(`No entry file could be located for package ${pkgName}`);
        }
        this.entryFile = entryFile;
        if (pkgJson.dependencies instanceof Object) {
            this.deps = Object.keys(pkgJson.dependencies).map(name => new NPMPackageDependency(this, name));
        }
        else {
            this.deps = kernel.emptyArray;
        }
    }
    /** @internal */
    async loadDependencies() {
        await Promise.all(this.deps.map(loadDependency));
    }
}
async function loadDependency(dep) {
    await dep.load();
    await dep.pkg.loadDependencies();
}
class NPMPackageDependency {
    constructor(issuer, refName) {
        this.issuer = issuer;
        this.refName = refName;
        this._pkg = void 0;
        this.loadPromise = void 0;
    }
    get pkg() {
        const pkg = this._pkg;
        if (pkg === void 0) {
            throw new Error(`Package ${this.refName} is not yet loaded`);
        }
        return pkg;
    }
    /** @internal */
    async load() {
        if (this._pkg === void 0) {
            if (this.loadPromise === void 0) {
                // Multiple deps may request the same package to load before one of them finished
                // so we store the promise to ensure the action is only invoked once.
                this.loadPromise = this.loadCore();
            }
            return this.loadPromise;
        }
    }
    async loadCore() {
        this._pkg = await this.issuer.loader.loadPackage(this);
        this.loadPromise = void 0;
        // Freeze it as an extra measure to prove that we're not getting race conditions
        Object.freeze(this);
    }
}

const lookup = new WeakMap();
class PatternMatcher {
    constructor(logger, compilerOptions) {
        this.logger = logger;
        this.compilerOptions = compilerOptions;
        this.logger = logger.scopeTo(this.constructor.name);
        this.rootDir = resolvePath(compilerOptions.__dirname);
        this.basePath = joinPath(this.rootDir, compilerOptions.baseUrl);
        this.sources = Object.keys(compilerOptions.paths).map(x => new PatternSource(this.logger, this, x));
    }
    findMatch(files, specifier) {
        const sources = this.sources;
        const len = sources.length;
        let match;
        for (let i = 0; i < len; ++i) {
            match = sources[i].findMatch(files, specifier);
            if (match === null) {
                this.logger.trace(`Source pattern "${sources[i].pattern}" (path "${sources[i].patternPath}") is NOT a match for specifier "${specifier}"`);
            }
            else {
                this.logger.debug(`Source pattern "${sources[i].pattern}" is a match for specifier "${specifier}"`);
                return match;
            }
        }
        throw new Error(`Cannot resolve "${specifier}:`);
    }
    static getOrCreate(compilerOptions, container) {
        let matcher = lookup.get(compilerOptions);
        if (matcher === void 0) {
            if (compilerOptions.baseUrl !== void 0 && compilerOptions.paths !== void 0) {
                const logger = container.get(kernel.ILogger);
                matcher = new PatternMatcher(logger, compilerOptions);
            }
            else {
                matcher = null;
            }
            lookup.set(compilerOptions, matcher);
        }
        return matcher;
    }
}
class PatternSource {
    constructor(logger, matcher, pattern) {
        this.logger = logger;
        this.matcher = matcher;
        this.pattern = pattern;
        this.logger = logger.scopeTo(this.constructor.name);
        if (pattern.endsWith('*')) {
            this.hasWildcard = true;
            this.patternPath = pattern.slice(0, -1);
        }
        else {
            this.hasWildcard = false;
            this.patternPath = pattern;
        }
        this.isWildcard = pattern === '*';
        this.targets = matcher.compilerOptions.paths[pattern].map(x => new PatternTarget(this.logger, this, x));
    }
    findMatch(files, specifier) {
        if (this.isWildcard) {
            return this.findMatchCore(files, specifier);
        }
        if (this.hasWildcard) {
            if (specifier.startsWith(this.patternPath)) {
                return this.findMatchCore(files, specifier.replace(this.patternPath, ''));
            }
            return null;
        }
        if (this.patternPath === specifier) {
            return this.findMatchCore(files, specifier);
        }
        return null;
    }
    findMatchCore(files, specifier) {
        const targets = this.targets;
        const len = targets.length;
        let target;
        let match = null;
        for (let i = 0; i < len; ++i) {
            target = targets[i];
            match = target.findMatch(files, specifier);
            if (match !== null) {
                return match;
            }
        }
        return null;
    }
}
class PatternTarget {
    constructor(logger, source, pattern) {
        this.logger = logger;
        this.source = source;
        this.pattern = pattern;
        this.logger = logger.scopeTo(this.constructor.name);
        if (pattern.endsWith('*')) {
            this.hasWildcard = true;
            this.patternPath = joinPath(source.matcher.basePath, pattern.slice(0, -1));
        }
        else {
            this.hasWildcard = false;
            this.patternPath = joinPath(source.matcher.basePath, pattern);
        }
    }
    findMatch(files, specifier) {
        const targetPath = this.hasWildcard ? joinPath(this.patternPath, specifier) : this.patternPath;
        const len = files.length;
        let file;
        for (let i = 0; i < len; ++i) {
            file = files[i];
            if (file.shortPath === targetPath || file.path === targetPath) {
                return file;
            }
        }
        return null;
    }
}

function comparePathLength(a, b) {
    return a.path.length - b.path.length;
}
class SpecificSourceFileProvider {
    constructor(host, file, mode) {
        this.host = host;
        this.file = file;
        this.mode = mode;
    }
    async GetSourceFiles(ctx) {
        return [
            await this.host.loadSpecificFile(ctx, this.file, this.mode),
        ];
    }
}
class EntrySourceFileProvider {
    constructor(host, dir) {
        this.host = host;
        this.dir = dir;
    }
    async GetSourceFiles(ctx) {
        return [
            await this.host.loadEntryFile(ctx, this.dir),
        ];
    }
}
class ServiceHost {
    constructor(container, logger = container.get(kernel.ILogger), fs = container.get(IFileSystem)) {
        this.container = container;
        this.logger = logger;
        this.fs = fs;
        this._jsdom = null;
        this.compilerOptionsCache = new Map();
        this.moduleCache = new Map();
        this.scriptCache = new Map();
        this.agent = new Agent(logger);
    }
    get jsdom() {
        let jsdom$1 = this._jsdom;
        if (jsdom$1 === null) {
            jsdom$1 = this._jsdom = new jsdom.JSDOM('');
        }
        return jsdom$1;
    }
    async loadEntryFile(ctx, dir) {
        this.logger.info(`Loading entry file at: ${dir}`);
        const pkg = await this.loadEntryPackage(dir);
        this.logger.info(`Finished loading entry file`);
        return this.getESModule(ctx, pkg.entryFile, pkg);
    }
    async loadSpecificFile(ctx, file, mode) {
        if (mode === 'module') {
            return this.getESModule(ctx, file, null);
        }
        else {
            return this.getESScript(ctx, file);
        }
    }
    executeEntryFile(dir) {
        const container = this.container.createChild();
        container.register(kernel.Registration.instance(ISourceFileProvider, new EntrySourceFileProvider(this, dir)));
        return this.agent.RunJobs(container);
    }
    executeSpecificFile(file, mode) {
        const container = this.container.createChild();
        container.register(kernel.Registration.instance(ISourceFileProvider, new SpecificSourceFileProvider(this, file, mode)));
        return this.agent.RunJobs(container);
    }
    executeProvider(provider) {
        const container = this.container.createChild();
        container.register(kernel.Registration.instance(ISourceFileProvider, provider));
        return this.agent.RunJobs(container);
    }
    // http://www.ecma-international.org/ecma-262/#sec-hostresolveimportedmodule
    ResolveImportedModule(ctx, referencingModule, $specifier) {
        const specifier = normalizePath($specifier['[[Value]]']);
        const isRelative = isRelativeModulePath(specifier);
        const pkg = referencingModule.pkg;
        // Single file scenario; lazily resolve the import
        if (pkg === null) {
            if (!isRelative) {
                throw new Error(`Absolute module resolution not yet implemented for single-file scenario.`);
            }
            // TODO: this is currently just for the 262 test suite but we need to resolve the other stuff properly too for end users that don't want to use the package eager load mechanism
            const dir = referencingModule.$file.dir;
            const ext = '.js';
            const name = path.basename(specifier);
            const shortName = name.slice(0, -3);
            const path$1 = joinPath(dir, name);
            const file = new File(this.fs, path$1, dir, specifier, name, shortName, ext);
            return this.getESModule(ctx, file, null);
        }
        if (isRelative) {
            this.logger.debug(`[ResolveImport] resolving internal relative module: '${$specifier['[[Value]]']}' for ${referencingModule.$file.name}`);
            const filePath = resolvePath(path.dirname(referencingModule.$file.path), specifier);
            const files = pkg.files.filter(x => x.shortPath === filePath || x.path === filePath).sort(comparePathLength);
            if (files.length === 0) {
                throw new Error(`Cannot find file "${filePath}" (imported as "${specifier}" by "${referencingModule.$file.name}")`);
            }
            let file = files.find(x => x.kind === 1 /* Script */);
            if (file === void 0) {
                // TODO: make this less messy/patchy
                file = files.find(x => x.kind === 2 /* Markup */);
                if (file === void 0) {
                    file = files[0];
                    let deferred = this.moduleCache.get(file.path);
                    if (deferred === void 0) {
                        deferred = new DeferredModule(file, ctx.Realm);
                        this.moduleCache.set(file.path, deferred);
                    }
                    return deferred;
                }
                return this.getHTMLModule(ctx, file, pkg);
            }
            return this.getESModule(ctx, file, pkg);
        }
        else {
            const pkgDep = pkg.deps.find(n => n.refName === specifier || specifier.startsWith(`${n.refName}/`));
            if (pkgDep === void 0) {
                this.logger.debug(`[ResolveImport] resolving internal absolute module: '${$specifier['[[Value]]']}' for ${referencingModule.$file.name}`);
                const matcher = PatternMatcher.getOrCreate(referencingModule.compilerOptions, this.container);
                if (matcher !== null) {
                    const file = matcher.findMatch(pkg.files, specifier);
                    return this.getESModule(ctx, file, pkg);
                }
                else {
                    throw new Error(`Cannot resolve absolute file path without path mappings in tsconfig`);
                }
            }
            else {
                this.logger.debug(`[ResolveImport] resolving external absolute module: '${$specifier['[[Value]]']}' for ${referencingModule.$file.name}`);
                const externalPkg = pkg.loader.getCachedPackage(pkgDep.refName);
                if (pkgDep.refName !== specifier) {
                    if (externalPkg.entryFile.shortName === specifier) {
                        return this.getESModule(ctx, externalPkg.entryFile, externalPkg);
                    }
                    let file = externalPkg.files.find(x => x.shortPath === externalPkg.dir && x.ext === '.js');
                    if (file === void 0) {
                        const indexModulePath = joinPath(externalPkg.dir, 'index');
                        file = externalPkg.files.find(f => f.shortPath === indexModulePath && f.ext === '.js');
                        if (file === void 0) {
                            const partialAbsolutePath = joinPath('node_modules', specifier);
                            file = externalPkg.files.find(f => f.shortPath.endsWith(partialAbsolutePath) && f.ext === '.js');
                            if (file === void 0) {
                                throw new Error(`Unable to resolve file "${externalPkg.dir}" or "${indexModulePath}" (refName="${pkgDep.refName}", entryFile="${externalPkg.entryFile.shortPath}", specifier=${specifier})`);
                            }
                        }
                    }
                    return this.getESModule(ctx, file, externalPkg);
                }
                else {
                    return this.getESModule(ctx, externalPkg.entryFile, externalPkg);
                }
            }
        }
    }
    dispose() {
        this.agent.dispose();
        this.agent = void 0;
        this.compilerOptionsCache.clear();
        this.compilerOptionsCache = void 0;
        for (const mod of this.moduleCache.values()) {
            mod.dispose();
        }
        this.moduleCache.clear();
        this.moduleCache = void 0;
        this.container = void 0;
    }
    loadEntryPackage(dir) {
        this.logger.trace(`loadEntryPackage(${dir})`);
        const loader = this.container.get(NPMPackageLoader);
        return loader.loadEntryPackage(dir);
    }
    getHTMLModule(ctx, file, pkg) {
        let hm = this.moduleCache.get(file.path);
        if (hm === void 0) {
            const sourceText = file.getContentSync();
            const template = this.jsdom.window.document.createElement('template');
            template.innerHTML = sourceText;
            hm = new $DocumentFragment(this.logger, file, template.content, ctx.Realm, pkg);
            this.moduleCache.set(file.path, hm);
        }
        return hm;
    }
    getESScript(ctx, file) {
        let script = this.scriptCache.get(file.path);
        if (script === void 0) {
            const sourceText = file.getContentSync();
            const sf = typescript.createSourceFile(file.path, sourceText, typescript.ScriptTarget.Latest, false);
            script = new $ESScript(this.logger, file, sf, ctx.Realm);
            this.scriptCache.set(file.path, script);
        }
        return script;
    }
    getESModule(ctx, file, pkg) {
        let esm = this.moduleCache.get(file.path);
        if (esm === void 0) {
            const compilerOptions = this.getCompilerOptions(file.path, pkg);
            const sourceText = file.getContentSync();
            const sf = typescript.createSourceFile(file.path, sourceText, typescript.ScriptTarget.Latest, false);
            esm = new $ESModule(this.logger, file, sf, ctx.Realm, pkg, this, compilerOptions);
            this.moduleCache.set(file.path, esm);
        }
        return esm;
    }
    getCompilerOptions(path$1, pkg) {
        // TODO: this is a very simple/naive impl, needs more work for inheritance etc
        path$1 = normalizePath(path$1);
        let compilerOptions = this.compilerOptionsCache.get(path$1);
        if (compilerOptions === void 0) {
            const dir = normalizePath(path.dirname(path$1));
            if (dir === path$1 || pkg === null /* TODO: maybe still try to find tsconfig? */) {
                compilerOptions = {
                    __dirname: '',
                };
            }
            else {
                const tsConfigPath = joinPath(path$1, 'tsconfig.json');
                const tsConfigFile = pkg.files.find(x => x.path === tsConfigPath);
                if (tsConfigFile === void 0) {
                    compilerOptions = this.getCompilerOptions(dir, pkg);
                }
                else {
                    const tsConfigText = tsConfigFile.getContentSync();
                    // tsconfig allows some stuff that's not valid JSON, so parse it as a JS object instead
                    // eslint-disable-next-line no-new-func,@typescript-eslint/no-implied-eval
                    const tsConfigObj = new Function(`return ${tsConfigText}`)();
                    compilerOptions = tsConfigObj.compilerOptions;
                    if (compilerOptions === null || typeof compilerOptions !== 'object') {
                        compilerOptions = {
                            __dirname: tsConfigFile.dir,
                        };
                    }
                    else {
                        compilerOptions.__dirname = tsConfigFile.dir;
                    }
                }
            }
            this.compilerOptionsCache.set(path$1, compilerOptions);
        }
        return compilerOptions;
    }
}

exports.$Boolean = $Boolean;
exports.$DocumentFragment = $DocumentFragment;
exports.$ESModule = $ESModule;
exports.$ESScript = $ESScript;
exports.$Empty = $Empty;
exports.$Error = $Error;
exports.$Null = $Null;
exports.$Number = $Number;
exports.$Object = $Object;
exports.$RangeError = $RangeError;
exports.$ReferenceError = $ReferenceError;
exports.$String = $String;
exports.$Symbol = $Symbol;
exports.$SyntaxError = $SyntaxError;
exports.$TypeError = $TypeError;
exports.$URIError = $URIError;
exports.$Undefined = $Undefined;
exports.DeferredModule = DeferredModule;
exports.ExecutionContext = ExecutionContext;
exports.IFileSystem = IFileSystem;
exports.ISourceFileProvider = ISourceFileProvider;
exports.Job = Job;
exports.Realm = Realm;
exports.ServiceHost = ServiceHost;
//# sourceMappingURL=index.js.map
