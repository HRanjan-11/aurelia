import { GetAccessorDeclaration, MethodDeclaration, ModifierFlags, SetAccessorDeclaration, SyntaxKind } from 'typescript';
import { ILogger } from '@aurelia/kernel';
import { Realm, ExecutionContext } from '../realm';
import { $String } from '../types/string';
import { $Function } from '../types/function';
import { $Object } from '../types/object';
import { $Boolean } from '../types/boolean';
import { $Empty } from '../types/empty';
import { $Error } from '../types/error';
import { I$Node, Context, $$PropertyName, $$ESDeclaration, $$ESVarDeclaration, FunctionKind } from './_shared';
import { $$ESModuleOrScript } from './modules';
import { $Decorator, $ObjectLiteralExpression } from './expressions';
import { $ClassDeclaration, $ClassExpression } from './classes';
import { MethodDefinitionRecord, $FormalParameterList } from './functions';
import { $Block } from './statements';
import { $FunctionEnvRec } from '../types/environment-record';
import { $Any, $AnyNonEmpty } from '../types/_shared';
import { $List } from '../types/list';
export declare class $MethodDeclaration implements I$Node {
    readonly node: MethodDeclaration;
    readonly parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.MethodDeclaration;
    readonly modifierFlags: ModifierFlags;
    readonly $decorators: readonly $Decorator[];
    readonly $name: $$PropertyName;
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block;
    readonly IsStatic: boolean;
    readonly PropName: $String | $Empty;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly functionKind: FunctionKind;
    constructor(node: MethodDeclaration, parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    DefineMethod(ctx: ExecutionContext, object: $Object): MethodDefinitionRecord | $Error;
    EvaluatePropertyDefinition(ctx: ExecutionContext, object: $Object, enumerable: $Boolean): $Boolean | $Error;
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
}
export declare class $GetAccessorDeclaration implements I$Node {
    readonly node: GetAccessorDeclaration;
    readonly parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.GetAccessor;
    readonly modifierFlags: ModifierFlags;
    readonly $decorators: readonly $Decorator[];
    readonly $name: $$PropertyName;
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block;
    readonly IsStatic: boolean;
    readonly PropName: $String | $Empty;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly functionKind: FunctionKind.normal;
    constructor(node: GetAccessorDeclaration, parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    EvaluatePropertyDefinition(ctx: ExecutionContext, object: $Object, enumerable: $Boolean): $Boolean | $Error;
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
}
export declare class $SetAccessorDeclaration implements I$Node {
    readonly node: SetAccessorDeclaration;
    readonly parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.SetAccessor;
    readonly modifierFlags: ModifierFlags;
    readonly $decorators: readonly $Decorator[];
    readonly $name: $$PropertyName;
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block;
    readonly IsStatic: boolean;
    readonly PropName: $String | $Empty;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly functionKind: FunctionKind.normal;
    constructor(node: SetAccessorDeclaration, parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    EvaluatePropertyDefinition(ctx: ExecutionContext, object: $Object, enumerable: $Boolean): $Boolean | $Error;
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
}
//# sourceMappingURL=methods.d.ts.map