{"version":3,"file":"index.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/system/path-utils.ts","../../src/system/file-system.ts","../../src/system/interfaces.ts","../../src/vm/types/_shared.ts","../../src/vm/types/property-descriptor.ts","../../src/vm/types/number.ts","../../src/vm/types/string.ts","../../src/vm/types/error.ts","../../src/vm/types/list.ts","../../src/vm/types/empty.ts","../../src/vm/operations.ts","../../src/vm/types/object.ts","../../src/vm/types/boolean.ts","../../src/vm/types/null.ts","../../src/vm/types/symbol.ts","../../src/vm/types/undefined.ts","../../src/vm/job.ts","../../src/vm/types/environment-record.ts","../../src/vm/types/function.ts","../../src/vm/globals/_shared.ts","../../src/vm/exotics/array.ts","../../src/vm/globals/promise.ts","../../src/vm/globals/iteration.ts","../../src/vm/exotics/string.ts","../../src/vm/globals/string.ts","../../src/vm/globals/object.ts","../../src/vm/ast/bindings.ts","../../src/vm/types/reference.ts","../../src/vm/exotics/namespace.ts","../../src/vm/ast/classes.ts","../../src/vm/ast/types.ts","../../src/vm/ast/literals.ts","../../src/vm/ast/modules.ts","../../src/vm/ast/statements.ts","../../src/vm/ast/methods.ts","../../src/vm/ast/expressions.ts","../../src/vm/ast/jsx.ts","../../src/vm/ast/_shared.ts","../../src/vm/exotics/arguments.ts","../../src/vm/ast/functions.ts","../../src/vm/globals/function.ts","../../src/vm/globals/number.ts","../../src/vm/globals/boolean.ts","../../src/vm/globals/symbol.ts","../../src/vm/globals/error.ts","../../src/vm/globals/throw-type-error.ts","../../src/vm/globals/generator-function.ts","../../src/vm/globals/async-function.ts","../../src/vm/globals/async-generator-function.ts","../../src/vm/exotics/proxy.ts","../../src/vm/globals/proxy.ts","../../src/vm/globals/reflect.ts","../../src/vm/globals/eval.ts","../../src/vm/globals/is-finite.ts","../../src/vm/globals/is-nan.ts","../../src/vm/globals/parse-float.ts","../../src/vm/globals/parse-int.ts","../../src/vm/globals/uri-handling.ts","../../src/vm/intrinsics.ts","../../src/vm/realm.ts","../../src/vm/agent.ts","../../src/system/npm-package-loader.ts","../../src/system/pattern-matcher.ts","../../src/service-host.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {\n  join,\n  resolve,\n} from 'path';\nimport {\n  Char,\n} from '@aurelia/runtime';\n\nexport const normalizePath = (function () {\n  const cache: Record<string, string | undefined> = Object.create(null);\n  const regex = /\\\\/g;\n  return function (path: string) {\n    let normalized = cache[path];\n    if (normalized === void 0) {\n      normalized = cache[path] = path.replace(regex, '/');\n    }\n    return normalized;\n  };\n})();\n\nexport function joinPath(...paths: string[]): string {\n  return normalizePath(join(...paths));\n}\n\nexport function resolvePath(...paths: string[]): string {\n  return normalizePath(resolve(...paths));\n}\n\n/**\n * Returns `true` if this is an absolute POSIX, UNC or DOS path.\n *\n * Assumes path has already been normalized with `normalizePath`\n */\nfunction isRootedDiskPath(path: string): boolean {\n  const ch0 = path.charCodeAt(0);\n  return (\n    ch0 === Char.Slash\n    || (\n      ch0 >= Char.LowerA\n      && ch0 <= Char.LowerZ\n      && path.charCodeAt(1) === Char.Colon\n    )\n  );\n}\n\nexport function isRelativeModulePath(path: string): boolean {\n  const ch0 = path.charCodeAt(0);\n  if (ch0 === Char.Dot) {\n    const ch1 = path.charCodeAt(1);\n    if (ch1 === Char.Dot) {\n      return path.charCodeAt(2) === Char.Slash || path.length === 2;\n    }\n\n    return ch1 === Char.Slash || path.length === 1;\n  }\n\n  return isRootedDiskPath(path);\n}\n","import {\n  accessSync,\n  constants,\n  Dirent,\n  exists,\n  existsSync,\n  lstatSync,\n  mkdirSync,\n  promises,\n  readdirSync,\n  readFileSync,\n  realpathSync,\n  Stats,\n  statSync,\n  writeFileSync,\n} from 'fs';\nimport {\n  dirname,\n  join,\n} from 'path';\nimport {\n  Char,\n} from '@aurelia/runtime';\nimport {\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  FileKind,\n  IFileSystem,\n  IFile,\n  Encoding,\n} from './interfaces.js';\nimport {\n  normalizePath,\n  joinPath,\n} from './path-utils.js';\n\nconst {\n  access,\n  lstat,\n  mkdir,\n  readdir,\n  readFile,\n  realpath,\n  rmdir,\n  stat,\n  unlink,\n  writeFile,\n} = promises;\n\nfunction compareFilePath(a: File, b: File) {\n  return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;\n}\n\nfunction shouldTraverse(path: string) {\n  // By default convention we don't traverse any path that starts with a dot because those shouldn't contain application code\n  // For example: .git, .vscode, .circleci, etc.\n  // We also exclude node_modules. But everything else is traversed by default.\n  // TODO: make this configurable\n  return path.charCodeAt(0) !== Char.Dot && path !== 'node_modules';\n}\n\nexport class File implements IFile {\n  /**\n   * Similar to `shortName`, but includes the rest of the path including the root.\n   *\n   * Used for conventional matching, e.g. \"try adding .js, .ts, /index.js\", etc.\n   */\n  public readonly shortPath: string;\n  public readonly kind: FileKind;\n\n  public constructor(\n    private readonly fs: IFileSystem,\n    /**\n     * The full, absolute, real path to the file.\n     *\n     * @example\n     * 'd:/foo/bar.ts' // 'd:/foo/bar.ts' is the path\n     */\n    public readonly path: string,\n    /**\n     * The full, absolute, real path to the folder containing the file.\n     *\n     * @example\n     * 'd:/foo/bar.ts' // 'd:/foo' is the path\n     */\n    public readonly dir: string,\n    /**\n     * A loosely defined human-readable identifier for the file, usually with the common root directory removed for improved clarity in logs.\n     */\n    public readonly rootlessPath: string,\n    /**\n     * The leaf file name, including the extension.\n     *\n     * @example\n     * './foo/bar.ts' // 'bar.ts' is the name\n     */\n    public readonly name: string,\n    /**\n     * The leaf file name, excluding the extension.\n     *\n     * @example\n     * './foo/bar.ts' // 'bar' is the shortName\n     */\n    public readonly shortName: string,\n    /**\n     * The file extension, including the period. For .d.ts files, the whole part \".d.ts\" must be included.\n     *\n     * @example\n     * './foo/bar.ts' // '.ts' is the extension\n     * './foo/bar.d.ts' // '.d.ts' is the extension\n     */\n    public readonly ext: string,\n  ) {\n    this.shortPath = `${dir}/${shortName}`;\n    switch (ext) {\n      case '.js':\n      case '.ts':\n      case '.d.ts':\n      case '.jsx':\n      case '.tsx':\n        this.kind = FileKind.Script;\n        break;\n      case '.html':\n        this.kind = FileKind.Markup;\n        break;\n      case '.css':\n        this.kind = FileKind.Style;\n        break;\n      case '.json':\n        this.kind = FileKind.JSON;\n        break;\n      default:\n        this.kind = FileKind.Unknown;\n    }\n  }\n\n  public static getExtension(name: string): string | undefined {\n    const lastDotIndex = name.lastIndexOf('.');\n    if (lastDotIndex <= 0) {\n      return void 0;\n    }\n\n    const lastPart = name.slice(lastDotIndex);\n    switch (lastPart) {\n      case '.ts':\n        return name.endsWith('.d.ts') ? '.d.ts' : '.ts';\n      case '.map': {\n        const extensionlessName = name.slice(0, lastDotIndex);\n        const secondDotIndex = extensionlessName.lastIndexOf('.');\n        if (secondDotIndex === -1) {\n          return void 0;\n        }\n        return name.slice(secondDotIndex);\n      }\n      default:\n        return lastPart;\n    }\n  }\n\n  public getContent(cache: boolean = false, force: boolean = false): Promise<string> {\n    return this.fs.readFile(this.path, Encoding.utf8, cache, force);\n  }\n\n  public getContentSync(cache: boolean = false, force: boolean = false): string {\n    return this.fs.readFileSync(this.path, Encoding.utf8, cache, force);\n  }\n}\n\nconst tick = {\n  current: void 0 as (undefined | Promise<void>),\n  wait() {\n    if (tick.current === void 0) {\n      tick.current = new Promise(function (resolve) {\n        setTimeout(function () {\n          tick.current = void 0;\n          resolve();\n        });\n      });\n    }\n    return tick.current;\n  }\n};\n\nexport class NodeFileSystem implements IFileSystem {\n  private readonly childrenCache: Map<string, string[]> = new Map();\n  private readonly realPathCache: Map<string, string> = new Map();\n  private readonly contentCache: Map<string, string> = new Map();\n\n  private pendingReads: number = 0;\n  private maxConcurrentReads: number = 0;\n\n  public constructor(\n    @ILogger private readonly logger: ILogger,\n  ) {\n    this.logger = logger.scopeTo(this.constructor.name);\n    this.logger.info('constructor');\n  }\n\n  public async realpath(path: string): Promise<string> {\n    this.logger.trace(`realpath(path: ${path})`);\n\n    return realpath(path);\n  }\n\n  public realpathSync(path: string): string {\n    this.logger.trace(`realpathSync(path: ${path})`);\n\n    return realpathSync(path);\n  }\n\n  public async readdir(path: string): Promise<readonly string[]>;\n  public async readdir(path: string, withFileTypes: true): Promise<readonly Dirent[]>;\n  public async readdir(path: string, withFileTypes?: true): Promise<readonly string[] | readonly Dirent[]> {\n    this.logger.trace(`readdir(path: ${path}, withFileTypes: ${withFileTypes})`);\n\n    if (withFileTypes === true) {\n      return readdir(path, { withFileTypes: true });\n    }\n\n    return readdir(path);\n  }\n\n  public readdirSync(path: string): readonly string[];\n  public readdirSync(path: string, withFileTypes: true): readonly Dirent[];\n  public readdirSync(path: string, withFileTypes?: true): readonly string[] | readonly Dirent[] {\n    this.logger.trace(`readdirSync(path: ${path}, withFileTypes: ${withFileTypes})`);\n\n    if (withFileTypes === true) {\n      return readdirSync(path, { withFileTypes: true });\n    }\n\n    return readdirSync(path);\n  }\n\n  public async mkdir(path: string): Promise<void> {\n    this.logger.trace(`mkdir(path: ${path})`);\n\n    return mkdir(path, { recursive: true }) as unknown as Promise<void>;\n  }\n\n  public mkdirSync(path: string): void {\n    this.logger.trace(`mkdirSync(path: ${path})`);\n\n    mkdirSync(path, { recursive: true });\n  }\n\n  public async isReadable(path: string): Promise<boolean> {\n    this.logger.trace(`isReadable(path: ${path})`);\n\n    try {\n      await access(path, constants.F_OK);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public isReadableSync(path: string): boolean {\n    this.logger.trace(`isReadableSync(path: ${path})`);\n\n    try {\n      accessSync(path, constants.F_OK);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public async fileExists(path: string): Promise<boolean> {\n    this.logger.trace(`fileExists(path: ${path})`);\n\n    try {\n      return (await stat(path)).isFile();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public fileExistsSync(path: string): boolean {\n    this.logger.trace(`fileExistsSync(path: ${path})`);\n\n    try {\n      return statSync(path).isFile();\n    } catch (err) {\n      return false;\n    }\n  }\n\n  public async stat(path: string): Promise<Stats> {\n    this.logger.trace(`stat(path: ${path})`);\n\n    return stat(path);\n  }\n\n  public statSync(path: string): Stats {\n    this.logger.trace(`statSync(path: ${path})`);\n\n    return statSync(path);\n  }\n\n  public async lstat(path: string): Promise<Stats> {\n    this.logger.trace(`lstat(path: ${path})`);\n\n    return lstat(path);\n  }\n\n  public lstatSync(path: string): Stats {\n    this.logger.trace(`lstatSync(path: ${path})`);\n\n    return lstatSync(path);\n  }\n\n  public async readFile(path: string, encoding: Encoding, cache: boolean = false, force: boolean = false): Promise<string> {\n    this.logger.trace(`readFile(path: ${path}, encoding: ${encoding}, cache: ${cache}, force: ${force})`);\n\n    const contentCache = this.contentCache;\n\n    let content = contentCache.get(path);\n    if (content === void 0 || force) {\n      try {\n        while (this.maxConcurrentReads > 0 && this.maxConcurrentReads < this.pendingReads) {\n          // eslint-disable-next-line no-await-in-loop\n          await tick.wait();\n        }\n        ++this.pendingReads;\n        content = await readFile(path, encoding as BufferEncoding) as string;\n        --this.pendingReads;\n      } catch (err) {\n        if (err.code === 'EMFILE') {\n          --this.pendingReads;\n          this.maxConcurrentReads = this.pendingReads;\n          await tick.wait();\n          return this.readFile(path, encoding, cache, force);\n        }\n        throw err;\n      }\n\n      if (cache) {\n        contentCache.set(path, content);\n      }\n    }\n\n    return content;\n  }\n\n  public readFileSync(path: string, encoding: Encoding, cache: boolean = false, force: boolean = false): string {\n    this.logger.trace(`readFileSync(path: ${path}, encoding: ${encoding}, cache: ${cache}, force: ${force})`);\n\n    const contentCache = this.contentCache;\n    let content = contentCache.get(path);\n    if (content === void 0 || force) {\n      content = readFileSync(path, encoding as BufferEncoding);\n      if (cache) {\n        contentCache.set(path, content);\n      }\n    }\n\n    return content;\n  }\n\n  public async ensureDir(path: string): Promise<void> {\n    this.logger.trace(`ensureDir(path: ${path})`);\n\n    if (await new Promise<boolean>(res => { exists(path, res); })) {\n      return;\n    }\n\n    return this.mkdir(path);\n  }\n\n  public ensureDirSync(path: string): void {\n    this.logger.trace(`ensureDirSync(path: ${path})`);\n\n    if (existsSync(path)) {\n      return;\n    }\n\n    this.mkdirSync(path);\n  }\n\n  public async writeFile(path: string, content: string, encoding: Encoding): Promise<void> {\n    this.logger.trace(`writeFile(path: ${path}, content: ${content}, encoding: ${encoding})`);\n\n    await this.ensureDir(dirname(path));\n\n    return writeFile(path, content, { encoding: encoding as BufferEncoding });\n  }\n\n  public writeFileSync(path: string, content: string, encoding: Encoding): void {\n    this.logger.trace(`readFileSync(path: ${path}, content: ${content}, encoding: ${encoding})`);\n\n    this.ensureDirSync(dirname(path));\n\n    writeFileSync(path, content, encoding);\n  }\n\n  public async rimraf(path: string): Promise<void> {\n    this.logger.trace(`rimraf(path: ${path})`);\n\n    try {\n      const stats = await lstat(path);\n      if (stats.isDirectory()) {\n        await Promise.all((await readdir(path)).map(async x => this.rimraf(join(path, x))));\n        await rmdir(path);\n      } else if (stats.isFile() || stats.isSymbolicLink()) {\n        await unlink(path);\n      }\n    } catch (err) {\n      this.logger.error(`rimraf failed`, err);\n    }\n  }\n\n  public async getRealPath(path: string): Promise<string> {\n    path = normalizePath(path);\n\n    const realPathCache = this.realPathCache;\n    let real = realPathCache.get(path);\n    if (real === void 0) {\n      real = normalizePath(await realpath(path));\n      realPathCache.set(path, real);\n    }\n\n    return real;\n  }\n\n  public getRealPathSync(path: string): string {\n    path = normalizePath(path);\n\n    const realPathCache = this.realPathCache;\n    let real = realPathCache.get(path);\n    if (real === void 0) {\n      real = normalizePath(realpathSync(path));\n      realPathCache.set(path, real);\n    }\n\n    return real;\n  }\n\n  public async getChildren(path: string): Promise<string[]> {\n    const childrenCache = this.childrenCache;\n    let children = childrenCache.get(path);\n    if (children === void 0) {\n      children = (await readdir(path)).filter(shouldTraverse);\n      childrenCache.set(path, children);\n    }\n\n    return children;\n  }\n\n  public getChildrenSync(path: string): string[] {\n    const childrenCache = this.childrenCache;\n    let children = childrenCache.get(path);\n    if (children === void 0) {\n      children = readdirSync(path).filter(shouldTraverse);\n      childrenCache.set(path, children);\n    }\n\n    return children;\n  }\n\n  public async getFiles(root: string, loadContent: boolean = false): Promise<File[]> {\n    const files: File[] = [];\n    const seen: Record<string, true | undefined> = {};\n\n    const walk = async (dir: string, name: string): Promise<void> => {\n      const path = await this.getRealPath(joinPath(dir, name));\n\n      if (seen[path] === void 0) {\n        seen[path] = true;\n\n        const stats = await stat(path);\n\n        if (stats.isFile()) {\n          const ext = File.getExtension(path);\n\n          if (ext !== void 0) {\n            const rootlessPath = path.slice(dirname(root).length);\n            const shortName = name.slice(0, -ext.length);\n            const file = new File(this, path, dir, rootlessPath, name, shortName, ext);\n            if (loadContent) {\n              await this.readFile(path, Encoding.utf8, true);\n            }\n            files.push(file);\n          }\n        } else if (stats.isDirectory()) {\n          await Promise.all((await this.getChildren(path)).map(async x => walk(path, x)));\n        }\n      }\n    };\n\n    await Promise.all((await this.getChildren(root)).map(async x => walk(root, x)));\n\n    return files.sort(compareFilePath);\n  }\n\n  public getFilesSync(root: string, loadContent: boolean = false): File[] {\n    const files: File[] = [];\n    const seen: Record<string, true | undefined> = {};\n\n    const walk = (dir: string, name: string): void => {\n      const path = this.getRealPathSync(joinPath(dir, name));\n\n      if (seen[path] === void 0) {\n        seen[path] = true;\n\n        const stats = statSync(path);\n\n        if (stats.isFile()) {\n          const ext = File.getExtension(path);\n\n          if (ext !== void 0) {\n            const rootlessPath = path.slice(dirname(root).length);\n            const shortName = name.slice(0, -ext.length);\n            const file = new File(this, path, dir, rootlessPath, name, shortName, ext);\n            if (loadContent) {\n              this.readFileSync(path, Encoding.utf8, true);\n            }\n            files.push(file);\n          }\n        } else if (stats.isDirectory()) {\n          this.getChildrenSync(path).forEach(x => { walk(path, x); });\n        }\n      }\n    };\n\n    this.getChildrenSync(root).forEach(x => { walk(root, x); });\n\n    return files.sort(compareFilePath);\n  }\n}\n\n","import {\n  DI,\n} from '@aurelia/kernel';\nimport {\n  CompilerOptions,\n} from 'typescript';\n\nexport const enum Encoding {\n  utf8 = 'utf8',\n  utf16le = 'utf16le',\n  latin1 = 'latin1',\n  base64 = 'base64',\n  ascii = 'ascii',\n  hex = 'hex',\n  raw = 'raw',\n}\n\nexport const enum FileKind {\n  Unknown = 0,\n  Script  = 1,\n  Markup  = 2,\n  Style   = 3,\n  JSON    = 4,\n}\n\nexport interface IStats {\n  isFile(): boolean;\n  isDirectory(): boolean;\n  isSymbolicLink(): boolean;\n}\n\nexport interface IDirent extends IStats {\n  name: string;\n}\n\nexport interface IFile {\n  readonly shortPath: string;\n  readonly kind: FileKind;\n\n  readonly path: string;\n  readonly dir: string;\n  readonly rootlessPath: string;\n  readonly name: string;\n  readonly shortName: string;\n  readonly ext: string;\n\n  getContent(force?: boolean): Promise<string>;\n  getContentSync(force?: boolean): string;\n}\n\nexport interface IFileSystem {\n  realpath(path: string): Promise<string>;\n  realpathSync(path: string): string;\n\n  readdir(path: string): Promise<readonly string[]>;\n  readdir(path: string, withFileTypes: true): Promise<readonly IDirent[]>;\n  readdirSync(path: string): readonly string[];\n  readdirSync(path: string, withFileTypes: true): readonly IDirent[];\n\n  mkdir(path: string): Promise<void>;\n  mkdirSync(path: string): void;\n\n  isReadable(path: string): Promise<boolean>;\n  isReadableSync(path: string): boolean;\n\n  fileExists(path: string): Promise<boolean>;\n  fileExistsSync(path: string): boolean;\n\n  stat(path: string): Promise<IStats>;\n  statSync(path: string): IStats;\n\n  lstat(path: string): Promise<IStats>;\n  lstatSync(path: string): IStats;\n\n  readFile(path: string, encoding: Encoding, cache?: boolean, force?: boolean): Promise<string>;\n  readFileSync(path: string, encoding: Encoding, cache?: boolean, force?: boolean): string;\n\n  ensureDir(path: string): Promise<void>;\n  ensureDirSync(path: string): void;\n\n  writeFile(path: string, content: string, encoding: Encoding): Promise<void>;\n  writeFileSync(path: string, content: string, encoding: Encoding): void;\n\n  rimraf(path: string): Promise<void>;\n\n  getRealPath(path: string): Promise<string>;\n  getRealPathSync(path: string): string;\n\n  getChildren(path: string): Promise<readonly string[]>;\n  getChildrenSync(path: string): readonly string[];\n\n  getFiles(dir: string, loadContent?: boolean): Promise<readonly IFile[]>;\n  getFilesSync(dir: string, loadContent?: boolean): readonly IFile[];\n}\n\nexport interface $CompilerOptions extends CompilerOptions {\n  readonly __dirname: string;\n}\n\nexport const IFileSystem = DI.createInterface<IFileSystem>('IFileSystem');\n","import {\n  $Undefined,\n} from './undefined.js';\nimport {\n  $Null,\n} from './null.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Symbol,\n} from './symbol.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $Empty,\n} from './empty.js';\nimport {\n  $Object,\n} from './object.js';\nimport {\n  $Function,\n  $BuiltinFunction,\n} from './function.js';\nimport {\n  $BoundFunctionExoticObject,\n} from '../exotics/bound-function.js';\nimport {\n  $ArrayExoticObject,\n} from '../exotics/array.js';\nimport {\n  $ProxyExoticObject,\n} from '../exotics/proxy.js';\nimport {\n  $ImmutablePrototypeExoticObject,\n} from '../exotics/immutable-prototype.js';\nimport {\n  $NamespaceExoticObject,\n} from '../exotics/namespace.js';\nimport {\n  $StringExoticObject,\n} from '../exotics/string.js';\nimport {\n  $IntegerIndexedExoticObject,\n} from '../exotics/integer-indexed.js';\nimport {\n  $ArgumentsExoticObject,\n} from '../exotics/arguments.js';\nimport {\n  $Error,\n} from './error.js';\n\nexport const enum CompletionType {\n  normal   = 1,\n  break    = 2,\n  continue = 3,\n  return   = 4,\n  throw    = 5,\n}\n\nexport type AbruptCompletionType = (\n  CompletionType.break |\n  CompletionType.continue |\n  CompletionType.return |\n  CompletionType.throw\n);\n\n// CompletionType.break and CompletionType.continue *always* have the value empty.\n// The other 3 (listed below) are the only possible types for values that are not empty.\nexport type PotentialNonEmptyCompletionType = (\n  CompletionType.normal |\n  CompletionType.return |\n  CompletionType.throw\n);\n\n// CompletionType.return and CompletionType.throw *never* have the value empty.\n// The other 3 (listed below) are the only possible types for the value empty.\nexport type PotentialEmptyCompletionType = (\n  CompletionType.normal |\n  CompletionType.break |\n  CompletionType.continue\n);\n\nexport type CompletionTarget = $String | $Empty;\n\nexport const nextValueId = (function () {\n  let id = 0;\n\n  return function () {\n    return ++id;\n  };\n})();\n\nexport type $Primitive = (\n  $Undefined |\n  $Null |\n  $Boolean |\n  $String |\n  $Symbol |\n  $Number\n);\n\nexport type $AnyNonEmpty = (\n  $Primitive |\n  $AnyObject |\n  $Error\n);\n\nexport type $AnyNonEmptyNonError = (\n  $Primitive |\n  $AnyObject\n);\n\nexport type $AnyObject = (\n  $ArgumentsExoticObject |\n  $ArrayExoticObject |\n  $BoundFunctionExoticObject |\n  $BuiltinFunction |\n  $Function |\n  $ImmutablePrototypeExoticObject |\n  $IntegerIndexedExoticObject |\n  $NamespaceExoticObject |\n  $Object |\n  $ProxyExoticObject |\n  $StringExoticObject\n);\n\nexport type $AnyNonError = (\n  $Empty |\n  $AnyNonEmpty\n);\n\nexport type $Any = (\n  $AnyNonError |\n  $Error\n);\n\nexport type $PropertyKey = (\n  $String |\n  $Symbol\n);\n\nexport type ESType = 'Undefined' | 'Null' | 'Boolean' | 'String' | 'Symbol' | 'Number' | 'Object';\n\nexport type $NonNumberPrimitive = Exclude<$Primitive, $Number>;\nexport type $NonNilPrimitive = Exclude<$Primitive, $Undefined | $Null>;\nexport type $NonNil = Exclude<$AnyNonError, $Undefined | $Null>;\n\nexport function getPath(obj: { path: string }): string {\n  return obj.path;\n}\n\nexport const Int32 = (function () {\n  const $ = new Int32Array(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\nexport const Uint32 = (function () {\n  const $ = new Uint32Array(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\nexport const Int16 = (function () {\n  const $ = new Int16Array(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\nexport const Uint16 = (function () {\n  const $ = new Uint16Array(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\nexport const Int8 = (function () {\n  const $ = new Int8Array(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\nexport const Uint8 = (function () {\n  const $ = new Uint8Array(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\nexport const Uint8Clamp = (function () {\n  const $ = new Uint8ClampedArray(1);\n  return function (value: unknown): number {\n    $[0] = Number(value);\n    return $[0];\n  };\n})();\n\n// Sort two strings numerically instead of alphabetically\nexport function compareIndices(a: $String, b: $String): number {\n  // Rely on coercion as natively subtracting strings has some shortcuts (for better perf) compared to explicitly converting to number first\n  return (a['[[Value]]'] as unknown as number) - (b['[[Value]]'] as unknown as number);\n}\n","import {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $Undefined,\n} from './undefined.js';\nimport {\n  $Empty,\n} from './empty.js';\nimport {\n  $Function,\n} from './function.js';\nimport {\n  $AnyNonError,\n  $PropertyKey,\n  $Any,\n} from './_shared.js';\nimport {\n  IDisposable,\n  Writable,\n} from '@aurelia/kernel';\n\nlet descriptorId = 0;\n\n// http://www.ecma-international.org/ecma-262/#sec-property-descriptor-specification-type\nexport class $PropertyDescriptor implements IDisposable {\n  public readonly '<$PropertyDescriptor>': unknown;\n\n  public readonly id: number = ++descriptorId;\n\n  public get isAbrupt(): false { return false; }\n\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isFunction(): false { return false; }\n\n  public '[[Enumerable]]': $Boolean | $Undefined | $Empty;\n  public '[[Configurable]]': $Boolean | $Undefined | $Empty;\n\n  public '[[Get]]': $Function | $Undefined | $Empty;\n  public '[[Set]]': $Function | $Undefined | $Empty;\n\n  public '[[Value]]': $Any;\n  public '[[Writable]]': $Boolean | $Undefined | $Empty;\n\n  // http://www.ecma-international.org/ecma-262/#sec-isaccessordescriptor\n  // 6.2.5.1 IsAccessorDescriptor ( Desc )\n  public get isAccessorDescriptor(): boolean {\n    // 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.\n    return !this['[[Get]]'].isEmpty || !this['[[Set]]'].isEmpty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-isdatadescriptor\n  // 6.2.5.2 IsDataDescriptor ( Desc )\n  public get isDataDescriptor(): boolean {\n    // 2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.\n    return !this['[[Value]]'].isEmpty || !this['[[Writable]]'].isEmpty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-isgenericdescriptor\n  // 6.2.5.3 IsGenericDescriptor ( Desc )\n  public get isGenericDescriptor(): boolean {\n    // 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.\n    return (\n      this['[[Get]]'].isEmpty &&\n      this['[[Set]]'].isEmpty &&\n      this['[[Value]]'].isEmpty &&\n      this['[[Writable]]'].isEmpty\n    );\n  }\n\n  public constructor(\n    public readonly realm: Realm,\n    public readonly name: $PropertyKey,\n    config?: {\n      '[[Enumerable]]'?: $Boolean | $Undefined | $Empty;\n      '[[Configurable]]'?: $Boolean | $Undefined | $Empty;\n\n      '[[Get]]'?: $Function | $Undefined | $Empty;\n      '[[Set]]'?: $Function | $Undefined | $Empty;\n\n      '[[Value]]'?: $AnyNonError;\n      '[[Writable]]'?: $Boolean | $Undefined | $Empty;\n    },\n  ) {\n    const $empty = realm['[[Intrinsics]]'].empty;\n\n    this['[[Enumerable]]'] = $empty;\n    this['[[Configurable]]'] = $empty;\n\n    this['[[Get]]'] = $empty;\n    this['[[Set]]'] = $empty;\n\n    this['[[Value]]'] = $empty;\n    this['[[Writable]]'] = $empty;\n\n    Object.assign(this, config);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-completepropertydescriptor\n  // 6.2.5.6 CompletePropertyDescriptor ( Desc )\n  public Complete(\n    ctx: ExecutionContext,\n  ): this {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: Desc is a Property Descriptor.\n    // 2. Let like be Record { [[Value]]: undefined, [[Writable]]: false, [[Get]]: undefined, [[Set]]: undefined, [[Enumerable]]: false, [[Configurable]]: false }.\n    // 3. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then\n    if (this.isGenericDescriptor || this.isDataDescriptor) {\n      // 3. a. If Desc does not have a [[Value]] field, set Desc.[[Value]] to like.[[Value]].\n      if (this['[[Value]]'].isEmpty) {\n        this['[[Value]]'] = intrinsics.undefined;\n      }\n\n      // 3. b. If Desc does not have a [[Writable]] field, set Desc.[[Writable]] to like.[[Writable]].\n      if (this['[[Writable]]'].isEmpty) {\n        this['[[Writable]]'] = intrinsics.false;\n      }\n    }\n    // 4. Else,\n    else {\n      // 4. a. If Desc does not have a [[Get]] field, set Desc.[[Get]] to like.[[Get]].\n      if (this['[[Get]]'].isEmpty) {\n        this['[[Get]]'] = intrinsics.undefined;\n      }\n\n      // 4. b. If Desc does not have a [[Set]] field, set Desc.[[Set]] to like.[[Set]].\n      if (this['[[Set]]'].isEmpty) {\n        this['[[Set]]'] = intrinsics.undefined;\n      }\n    }\n\n    // 5. If Desc does not have an [[Enumerable]] field, set Desc.[[Enumerable]] to like.[[Enumerable]].\n    if (this['[[Enumerable]]'].isEmpty) {\n      this['[[Enumerable]]'] = intrinsics.false;\n    }\n\n    // 6. If Desc does not have a [[Configurable]] field, set Desc.[[Configurable]] to like.[[Configurable]].\n    if (this['[[Configurable]]'].isEmpty) {\n      this['[[Configurable]]'] = intrinsics.false;\n    }\n\n    // 7. Return Desc.\n    return this;\n  }\n\n  public dispose(this: Writable<Partial<$PropertyDescriptor>>): void {\n    this['[[Enumerable]]'] = void 0;\n    this['[[Configurable]]'] = void 0;\n\n    this['[[Get]]'] = void 0;\n    this['[[Set]]'] = void 0;\n\n    this['[[Writable]]'] = void 0;\n    this['[[Value]]'] = void 0;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-isaccessordescriptor\nexport function $IsAccessorDescriptor(Desc: $PropertyDescriptor | $Undefined): Desc is $PropertyDescriptor {\n  // 1. If Desc is undefined, return false.\n  if (Desc.isUndefined) {\n    return false;\n  }\n\n  // 2. If both Desc.[[Get]] and Desc.[[Set]] are absent, return false.\n  // 3. Return true.\n  return Desc.isAccessorDescriptor;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-isdatadescriptor\nexport function $IsDataDescriptor(Desc: $PropertyDescriptor | $Undefined): Desc is $PropertyDescriptor {\n  // 1. If Desc is undefined, return false.\n  if (Desc.isUndefined) {\n    return false;\n  }\n\n  // 2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, return false.\n  // 3. Return true.\n  return Desc.isDataDescriptor;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-isgenericdescriptor\nexport function $IsGenericDescriptor(Desc: $PropertyDescriptor | $Undefined): Desc is $PropertyDescriptor {\n  // 1. If Desc is undefined, return false.\n  if (Desc.isUndefined) {\n    return false;\n  }\n\n  // 2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, return true.\n  // 3. Return false.\n  return Desc.isGenericDescriptor;\n}\n","import {\n  nextValueId,\n  $AnyNonError,\n  Int32,\n  Uint32,\n  Int16,\n  Uint16,\n  Int8,\n  Uint8,\n  Uint8Clamp,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Object,\n} from './object.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $NumericLiteral,\n} from '../ast/literals.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-number-type\nexport class $Number<T extends number = number> {\n  public readonly '<$Number>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'number' = 'number' as const;\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public readonly '[[Value]]': T;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): 'Number' { return 'Number'; }\n  public get isNaN(): boolean { return isNaN(this['[[Value]]']); }\n  public get isPositiveZero(): boolean { return Object.is(this['[[Value]]'], +0); }\n  public get isNegativeZero(): boolean { return Object.is(this['[[Value]]'], -0); }\n  public get isPositiveInfinity(): boolean { return Object.is(this['[[Value]]'], +Infinity); }\n  public get isNegativeInfinity(): boolean { return Object.is(this['[[Value]]'], -Infinity); }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): true { return true; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): boolean { return this['[[Value]]'] !== 0 && !isNaN(this['[[Value]]']); }\n  public get isFalsey(): boolean { return this['[[Value]]'] === 0 || isNaN(this['[[Value]]']); }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public constructor(\n    public readonly realm: Realm,\n    value: T,\n    type: PotentialNonEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n    public readonly sourceNode: $NumericLiteral | null = null,\n    public readonly conversionSource: $AnyNonError | null = null,\n  ) {\n    this['[[Value]]'] = value;\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $Number<T> {\n    return other instanceof $Number && Object.is(this['[[Value]]'], other['[[Value]]']);\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public equals(other: $Number): boolean {\n    return Object.is(this['[[Value]]'], other['[[Value]]']);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-isinteger\n  // 7.2.6 IsInteger ( argument )\n  public get IsInteger(): boolean {\n    if (isNaN(this['[[Value]]']) || Object.is(this['[[Value]]'], Infinity) || Object.is(this['[[Value]]'], -Infinity)) {\n      return false;\n    }\n    return Math.floor(Math.abs(this['[[Value]]'])) === Math.abs(this['[[Value]]']);\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $Object {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    return $Object.ObjectCreate(\n      ctx,\n      'number',\n      intrinsics['%NumberPrototype%'],\n      {\n        '[[NumberData]]': this,\n      },\n    );\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String {\n    return this.ToString(ctx);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    return new $Boolean(\n      /* realm */this.realm,\n      /* value */Boolean(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Number {\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-tointeger\n  // 7.1.4 ToInteger ( argument )\n  public ToInteger(\n    ctx: ExecutionContext,\n  ): $Number {\n    // 1. Let number be ? ToNumber(argument).\n\n    const value = this['[[Value]]'];\n    if (isNaN(value)) {\n      // 2. If number is NaN, return +0.\n      return new $Number(\n        /* realm */this.realm,\n        /* value */0,\n        /* type */this['[[Type]]'],\n        /* target */this['[[Target]]'],\n        /* sourceNode */null,\n        /* conversionSource */this,\n      );\n    }\n\n    // 3. If number is +0, -0, +∞, or -∞, return number.\n    if (Object.is(value, +0) || Object.is(value, -0) || Object.is(value, +Infinity) || Object.is(value, -Infinity)) {\n      return this;\n    }\n\n    // 4. Return the number value that is the same sign as number and whose magnitude is floor(abs(number)).\n    const sign = value < 0 ? -1 : 1;\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Math.floor(Math.abs(value)) * sign,\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-tolength\n  // 7.1.15 ToLength ( argument )\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Number {\n    // 1. Let len be ? ToInteger(argument).\n    const len = this.ToInteger(ctx);\n    if (len.isAbrupt) { return len; }\n\n    // 2. If len ≤ +0, return +0.\n    if (len['[[Value]]'] < 0) {\n      return new $Number(\n        /* realm */this.realm,\n        /* value */0,\n        /* type */this['[[Type]]'],\n        /* target */this['[[Target]]'],\n        /* sourceNode */null,\n        /* conversionSource */this,\n      );\n    }\n\n    // 3. Return min(len, 253 - 1).\n    if (len['[[Value]]'] > (2 ** 53 - 1)) {\n      return new $Number(\n        /* realm */this.realm,\n        /* value */(2 ** 53 - 1),\n        /* type */this['[[Type]]'],\n        /* target */this['[[Target]]'],\n        /* sourceNode */null,\n        /* conversionSource */this,\n      );\n    }\n\n    return this;\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8Clamp(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $String {\n    return new $String(\n      /* realm */this.realm,\n      /* value */String(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n}\n","import {\n  nextValueId,\n  $AnyNonError,\n  Int32,\n  Uint32,\n  Int16,\n  Uint16,\n  Int8,\n  Uint8,\n  Uint8Clamp,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $Undefined,\n} from './undefined.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Object,\n} from './object.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $Identifier,\n} from '../ast/expressions.js';\nimport {\n  $StringLiteral,\n  $NumericLiteral,\n} from '../ast/literals.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-string-type\nexport class $String<T extends string = string> {\n  public readonly '<$String>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'string' = 'string' as const;\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public readonly '[[Value]]': T;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): 'String' { return 'String'; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): true { return true; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): boolean { return this['[[Value]]'].length > 0; }\n  public get isFalsey(): boolean { return this['[[Value]]'].length === 0; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  // Only used in contexts where a value is always 'ambiguous' if it is a $String\n  public get isAmbiguous(): true {\n    if (this['[[Value]]'] !== 'ambiguous') {\n      // Just make sure that we don't actually violate that invariant\n      throw new Error(`Expected \"${this['[[Value]]']}\" to be \"ambiguous\"`);\n    }\n    return true;\n  }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  // http://www.ecma-international.org/ecma-262/#sec-canonicalnumericindexstring\n  // 7.1.16 CanonicalNumericIndexString ( argument )\n  public CanonicalNumericIndexString(\n    ctx: ExecutionContext,\n  ): $Number | $Undefined {\n    if (this['[[Value]]'] === '-0') {\n      return this.realm['[[Intrinsics]]']['-0'];\n    }\n\n    const n = this.ToNumber(ctx);\n    if (n.ToString(ctx).is(this) as boolean) {\n      return n;\n    }\n\n    return this.realm['[[Intrinsics]]'].undefined;\n  }\n\n  public get IsArrayIndex(): boolean {\n    if (this['[[Value]]'] === '-0') {\n      return false;\n    }\n    const num = Number(this['[[Value]]']);\n    if (num.toString() === this['[[Value]]']) {\n      return num >= 0 && num <= (2 ** 32 - 1);\n    }\n    return false;\n  }\n\n  public constructor(\n    public readonly realm: Realm,\n    value: T,\n    type: PotentialNonEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n    public readonly sourceNode: $Identifier | $StringLiteral | $NumericLiteral | null = null,\n    public readonly conversionSource: $AnyNonError | null = null,\n  ) {\n    this['[[Value]]'] = value;\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $String<T> {\n    return other instanceof $String && this['[[Value]]'] === other['[[Value]]'];\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return `\"${this['[[Value]]']}\"`;\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $Object {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    return $Object.ObjectCreate(\n      ctx,\n      'string',\n      intrinsics['%StringPrototype%'],\n      {\n        '[[StringData]]': this,\n      },\n    );\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String {\n    return this.ToString(ctx);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Number {\n    return this.ToNumber(ctx).ToLength(ctx);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    return new $Boolean(\n      /* realm */this.realm,\n      /* value */Boolean(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Number(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8Clamp(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n}\n","import {\n  nextValueId,\n  CompletionTarget,\n  CompletionType,\n  $AnyNonError,\n  PotentialNonEmptyCompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\nexport abstract class $Error<T extends Error = Error, N extends string = string> {\n  public readonly '<$Error>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: N;\n\n  public readonly '[[Type]]': CompletionType.throw = CompletionType.throw;\n  public readonly '[[Value]]': T;\n  public readonly '[[Target]]': CompletionTarget;\n\n  public get isAbrupt(): true { return true; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): true { return true; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): T { return this['[[Value]]']; }\n  public get isFalsey(): T extends true ? false : true { return !this['[[Value]]'] as T extends true ? false : true; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public constructor(\n    public readonly realm: Realm,\n    err: T,\n    intrinsicName: N,\n    // TODO: add contextual info\n  ) {\n    this.IntrinsicName = intrinsicName;\n    this['[[Value]]'] = err;\n    this['[[Target]]'] = realm['[[Intrinsics]]'].empty;\n  }\n\n  public is(other: $AnyNonError): boolean {\n    return other instanceof $Error && other.id === this.id;\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    this.nodeStack.push(node);\n    if (this.ctx === null) {\n      this.ctx = ctx;\n      this.stack = ctx.Realm.stack.toString();\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getvalue\n  // 6.2.4.8 GetValue ( V )\n  public GetValue(ctx: ExecutionContext): this {\n    // 1. ReturnIfAbrupt(V)\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToPropertyKey(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToLength(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToPrimitive(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToBoolean(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToNumber(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToInt32(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToUint32(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToInt16(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToUint16(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToInt8(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToUint8(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToUint8Clamp(ctx: ExecutionContext): this {\n    return this;\n  }\n\n  public ToString(ctx: ExecutionContext): this {\n    return this;\n  }\n\n}\n\nexport class $SyntaxError extends $Error<SyntaxError, 'SyntaxError'> {\n  public constructor(\n    realm: Realm,\n    message: string | undefined = void 0,\n  ) {\n    super(realm, new SyntaxError(message), 'SyntaxError');\n  }\n}\n\nexport class $TypeError extends $Error<TypeError, 'TypeError'> {\n  public constructor(\n    realm: Realm,\n    message: string | undefined = void 0,\n  ) {\n    super(realm, new TypeError(message), 'TypeError');\n  }\n}\n\nexport class $ReferenceError extends $Error<ReferenceError, 'ReferenceError'> {\n  public constructor(\n    realm: Realm,\n    message: string | undefined = void 0,\n  ) {\n    super(realm, new ReferenceError(message), 'ReferenceError');\n  }\n}\n\nexport class $RangeError extends $Error<RangeError, 'RangeError'> {\n  public constructor(\n    realm: Realm,\n    message: string | undefined = void 0,\n  ) {\n    super(realm, new RangeError(message), 'RangeError');\n  }\n}\n\nexport class $URIError extends $Error<URIError, 'URIError'> {\n  public constructor(\n    realm: Realm,\n    message: string | undefined = void 0,\n  ) {\n    super(realm, new URIError(message), 'URIError');\n  }\n}\n","import {\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\nexport type $ListItem = {\n  is(other: unknown): boolean;\n};\n\nexport class $List<T extends $ListItem> extends Array<T> {\n  public get isAbrupt(): false { return false; }\n  public get isList(): true { return true; }\n\n  public constructor(...items: T[]) {\n    super(...items);\n  }\n\n  public $copy<N extends $ListItem = T>(): $List<N> {\n    return new $List<N>(...(this as unknown as $List<N>));\n  }\n\n  public $contains(item: T): boolean {\n    return this.some(x => x.is(item));\n  }\n\n  public GetValue(ctx: ExecutionContext): $List<T> {\n    return this;\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    return this;\n  }\n\n  public is(other: unknown): boolean {\n    return this === other;\n  }\n}\n","import {\n  nextValueId,\n  $AnyNonError,\n  PotentialEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $TypeError,\n} from './error.js';\nimport {\n  $ESModule, $ESScript,\n} from '../ast/modules.js';\nimport {\n  $ComputedPropertyName,\n} from '../ast/bindings.js';\nimport {\n  $ContinueStatement,\n  $BreakStatement,\n} from '../ast/statements.js';\nimport {\n  $FunctionDeclaration,\n} from '../ast/functions.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\nexport interface empty { '<empty>': unknown }\nexport const empty = Symbol('empty') as unknown as empty;\nexport class $Empty {\n  public readonly '<$Empty>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'empty' = 'empty' as const;\n\n  public '[[Type]]': PotentialEmptyCompletionType;\n  public readonly '[[Value]]': empty = empty;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): $TypeError { return new $TypeError(this.realm, `[[empty]] has no Type`); }\n  public get isEmpty(): true { return true; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): false { return false; }\n  public get isFalsey(): true { return true; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): false { return false; }\n  public get isList(): false { return false; }\n\n  public constructor(\n    public readonly realm: Realm,\n    type: PotentialEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n    public readonly sourceNode: $ESModule | $ESScript | $ComputedPropertyName | $ContinueStatement | $BreakStatement | $FunctionDeclaration | null = null,\n  ) {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $Empty {\n    return other instanceof $Empty;\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return '[[empty]]';\n  }\n\n  public [Symbol.toStringTag](): string {\n    return '[object [[empty]]]';\n  }\n\n  public ToCompletion(\n    type: PotentialEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): typeof value { // Can't use generics here due to \"expression produces a type union that is too complex to represent\" :(\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n    return value.ToCompletion(this['[[Type]]'] as CompletionType.normal, this['[[Target]]']);\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to object`);\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to property key`);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to length`);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to primitive`);\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to boolean`);\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to number`);\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Int32`);\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint32`);\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Int16`);\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint16`);\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Int8`);\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint8`);\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to Uint8Clamp`);\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] cannot be converted to string`);\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): $TypeError {\n    return new $TypeError(ctx.Realm, `[[empty]] has no value`);\n  }\n}\n","import {\n  Realm,\n  ExecutionContext,\n} from './realm.js';\nimport {\n  $PropertyDescriptor,\n} from './types/property-descriptor.js';\nimport {\n  $BoundFunctionExoticObject,\n} from './exotics/bound-function.js';\nimport {\n  $ProxyExoticObject,\n} from './exotics/proxy.js';\nimport {\n  $PropertyKey,\n  $Primitive,\n  ESType,\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  $AnyObject,\n  $Any,\n  CompletionType,\n} from './types/_shared.js';\nimport {\n  $Function,\n} from './types/function.js';\nimport {\n  $Boolean,\n} from './types/boolean.js';\nimport {\n  $Undefined,\n} from './types/undefined.js';\nimport {\n  $Null,\n} from './types/null.js';\nimport {\n  $String,\n} from './types/string.js';\nimport {\n  $TypeError,\n  $Error,\n} from './types/error.js';\nimport {\n  $Object,\n} from './types/object.js';\nimport {\n  $List,\n} from './types/list.js';\nimport {\n  $StringSet,\n} from './globals/string.js';\nimport {\n  $Empty,\n} from './types/empty.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-set-o-p-v-throw\nexport function $Set(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  P: $PropertyKey,\n  V: $AnyNonEmpty ,\n  Throw: $Boolean,\n): $Boolean | $Error {\n  // 1. Assert: Type(O) is Object.\n  // 2. Assert: IsPropertyKey(P) is true.\n  // 3. Assert: Type(Throw) is Boolean.\n  // 4. Let success be ? O.[[Set]](P, V, O).\n  const success = O['[[Set]]'](ctx, P, V, O);\n  if (success.isAbrupt) { return success; }\n\n  // 5. If success is false and Throw is true, throw a TypeError exception.\n  if (success.isFalsey && Throw.isTruthy) {\n    return new $TypeError(ctx.Realm, `Cannot set property ${P}`);\n  }\n\n  // 6. Return success.\n  return success;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getv\n// 7.3.2 GetV ( V , P )\nexport function $GetV(\n  ctx: ExecutionContext,\n  V: $AnyNonEmptyNonError,\n  P: $PropertyKey,\n): $AnyNonEmpty  {\n  // 1. Assert: IsPropertyKey(P) is true.\n  // 2. Let O be ? ToObject(V).\n  const O = V.ToObject(ctx);\n  if (O.isAbrupt) { return O; }\n\n  // 3. Return ? O.[[Get]](P, V).\n  return O['[[Get]]'](ctx, P, V);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getmethod\n// 7.3.9 GetMethod ( V , P )\nexport function $GetMethod(\n  ctx: ExecutionContext,\n  V: $AnyNonEmptyNonError,\n  P: $PropertyKey,\n): $Function | $Undefined | $Error {\n  // 1. Assert: IsPropertyKey(P) is true.\n  // 2. Let func be ? GetV(V, P).\n  const func = $GetV(ctx, V, P);\n  if (func.isAbrupt) { return func; }\n\n  // 3. If func is either undefined or null, return undefined.\n  if (func.isNil) {\n    return ctx.Realm['[[Intrinsics]]'].undefined;\n  }\n\n  // 4. If IsCallable(func) is false, throw a TypeError exception.\n  if (!func.isFunction) {\n    return new $TypeError(ctx.Realm, `Property ${P} of ${V} is ${func}, but expected a callable function`);\n  }\n\n  // 5. Return func.\n  return func as $Function;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createdataproperty\nexport function $CreateDataProperty(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  P: $PropertyKey,\n  V: $AnyNonEmpty ,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(O) is Object.\n  // 2. Assert: IsPropertyKey(P) is true.\n  // 3. Let newDesc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.\n  const newDesc = new $PropertyDescriptor(realm, P);\n  newDesc['[[Value]]'] = V;\n  newDesc['[[Writable]]'] = intrinsics.true;\n  newDesc['[[Enumerable]]'] = intrinsics.true;\n  newDesc['[[Configurable]]'] = intrinsics.true;\n\n  // 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n  return O['[[DefineOwnProperty]]'](ctx, P, newDesc);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-ordinarysetwithowndescriptor\nexport function $OrdinarySetWithOwnDescriptor(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  P: $PropertyKey,\n  V: $AnyNonEmpty ,\n  Receiver: $AnyObject,\n  ownDesc: $PropertyDescriptor | $Undefined,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: IsPropertyKey(P) is true.\n  // 2. If ownDesc is undefined, then\n  if (ownDesc.isUndefined) {\n    // 2. a. Let parent be ? O.[[GetPrototypeOf]]().\n    const parent = O['[[GetPrototypeOf]]'](ctx);\n    if (parent.isAbrupt) { return parent; }\n\n    // 2. b. If parent is not null, then\n    if (!parent.isNull) {\n      // 2. b. i. Return ? parent.[[Set]](P, V, Receiver).\n      return parent['[[Set]]'](ctx, P, V, Receiver);\n    }\n    // 2. c. Else,\n    else {\n      // 2. c. i. Set ownDesc to the PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.\n      ownDesc = new $PropertyDescriptor(realm, P);\n      ownDesc['[[Value]]'] = intrinsics.undefined;\n      ownDesc['[[Writable]]'] = intrinsics.true;\n      ownDesc['[[Enumerable]]'] = intrinsics.true;\n      ownDesc['[[Configurable]]'] = intrinsics.true;\n    }\n  }\n\n  // 3. If IsDataDescriptor(ownDesc) is true, then\n  if (ownDesc.isDataDescriptor) {\n    // 3. a. If ownDesc.[[Writable]] is false, return false.\n    if (ownDesc['[[Writable]]'].isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 3. b. If Type(Receiver) is not Object, return false.\n    if (!Receiver.isObject) {\n      return intrinsics.false;\n    }\n\n    // 3. c. Let existingDescriptor be ? Receiver.[[GetOwnProperty]](P).\n    const existingDescriptor = Receiver['[[GetOwnProperty]]'](ctx, P);\n    if (existingDescriptor.isAbrupt) { return existingDescriptor; }\n\n    // 3. d. If existingDescriptor is not undefined, then\n    if (!existingDescriptor.isUndefined) {\n      // 3. d. i. If IsAccessorDescriptor(existingDescriptor) is true, return false.\n      if (existingDescriptor.isAccessorDescriptor) {\n        return intrinsics.false;\n      }\n\n      // 3. d. ii. If existingDescriptor.[[Writable]] is false, return false.\n      if (existingDescriptor['[[Writable]]'].isFalsey) {\n        return intrinsics.false;\n      }\n\n      // 3. d. iii. Let valueDesc be the PropertyDescriptor { [[Value]]: V }.\n      const valueDesc = new $PropertyDescriptor(realm, P);\n      valueDesc['[[Value]]'] = V;\n\n      // 3. d. iv. Return ? Receiver.[[DefineOwnProperty]](P, valueDesc).\n      return Receiver['[[DefineOwnProperty]]'](ctx, P, valueDesc);\n    }\n    // 3. e. Else Receiver does not currently have a property P,\n    else {\n      // 3. e. i. Return ? CreateDataProperty(Receiver, P, V).\n      return $CreateDataProperty(ctx, Receiver, P, V);\n    }\n  }\n\n  // 4. Assert: IsAccessorDescriptor(ownDesc) is true.\n  // 5. Let setter be ownDesc.[[Set]].\n  const setter = ownDesc['[[Set]]'] as $Undefined | $Function;\n\n  // 6. If setter is undefined, return false.\n  if (setter.isUndefined) {\n    return intrinsics.false;\n  }\n\n  // 7. Perform ? Call(setter, Receiver, « V »).\n  $Call(ctx, setter, Receiver, new $List(V));\n\n  // 8. Return true.\n  return intrinsics.true;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-hasownproperty\nexport function $HasOwnProperty(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  P: $PropertyKey,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(O) is Object.\n  // 2. Assert: IsPropertyKey(P) is true.\n  // 3. Let desc be ? O.[[GetOwnProperty]](P).\n  const desc = O['[[GetOwnProperty]]'](ctx, P);\n  if (desc.isAbrupt) { return desc; }\n\n  // 4. If desc is undefined, return false.\n  if (desc.isUndefined) {\n    return intrinsics.false;\n  }\n\n  // 5. Return true.\n  return intrinsics.true;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-call\nexport function $Call(\n  ctx: ExecutionContext,\n  F: $AnyNonEmpty,\n  V: $AnyNonEmptyNonError,\n  argumentsList: $List<$AnyNonEmpty> | $Undefined,\n): $AnyNonEmpty  {\n  // 1. If argumentsList is not present, set argumentsList to a new empty List.\n  if (!argumentsList.isList) {\n    argumentsList = new $List();\n  }\n\n  // 2. If IsCallable(F) is false, throw a TypeError exception.\n  if (!F.isFunction) {\n    return new $TypeError(ctx.Realm, `${F} is not callable`);\n  }\n\n  // 3. Return ? F.[[Call]](V, argumentsList).\n  return (F as $Function)['[[Call]]'](ctx, V, argumentsList);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-construct\nexport function $Construct(\n  ctx: ExecutionContext,\n  F: $Function,\n  argumentsList: $List<$AnyNonEmpty> | $Undefined,\n  newTarget: $Function | $Undefined,\n): $AnyObject | $Error {\n  // 1. If newTarget is not present, set newTarget to F.\n  if (newTarget.isUndefined) {\n    newTarget = F;\n  }\n\n  // 2. If argumentsList is not present, set argumentsList to a new empty List.\n  if (!argumentsList.isList) {\n    argumentsList = new $List();\n  }\n\n  // 3. Assert: IsConstructor(F) is true.\n  // 4. Assert: IsConstructor(newTarget) is true.\n  // 5. Return ? F.[[Construct]](argumentsList, newTarget).\n  return F['[[Construct]]'](ctx, argumentsList, newTarget);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-definepropertyorthrow\nexport function $DefinePropertyOrThrow(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  P: $PropertyKey,\n  desc: $PropertyDescriptor,\n): $Boolean | $Error {\n  // 1. Assert: Type(O) is Object.\n  // 2. Assert: IsPropertyKey(P) is true.\n  // 3. Let success be ? O.[[DefineOwnProperty]](P, desc).\n  const success = O['[[DefineOwnProperty]]'](ctx, P, desc);\n  if (success.isAbrupt) { return success; }\n\n  // 4. If success is false, throw a TypeError exception.\n  if (success.isFalsey) {\n    return new $TypeError(ctx.Realm, `Failed to define property ${P} on ${O}`);\n  }\n\n  // 5. Return success.\n  return success;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-validateandapplypropertydescriptor\nexport function $ValidateAndApplyPropertyDescriptor(\n  ctx: ExecutionContext,\n  O: $AnyObject | $Undefined,\n  P: $PropertyKey | $Undefined,\n  extensible: $Boolean,\n  Desc: $PropertyDescriptor,\n  current: $PropertyDescriptor | $Undefined,\n): $Boolean {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: If O is not undefined, then IsPropertyKey(P) is true.\n  // 2. If current is undefined, then\n  if (current.isUndefined) {\n    // 2. a. If extensible is false, return false.\n    if (extensible.isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 2. b. Assert: extensible is true.\n    // 2. c. If IsGenericDescriptor(Desc) is true or IsDataDescriptor(Desc) is true, then\n    if (Desc.isGenericDescriptor || Desc.isDataDescriptor) {\n      // 2. c. i. If O is not undefined, create an own data property named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.\n      if (!O.isUndefined) {\n        const newDesc = new $PropertyDescriptor(realm, P as $PropertyKey);\n        if (Desc['[[Value]]'].isEmpty) {\n          newDesc['[[Value]]'] = intrinsics.undefined;\n        } else {\n          newDesc['[[Value]]'] = Desc['[[Value]]'];\n        }\n        if (Desc['[[Writable]]'].isEmpty) {\n          newDesc['[[Writable]]'] = intrinsics.false;\n        } else {\n          newDesc['[[Writable]]'] = Desc['[[Writable]]'];\n        }\n        if (Desc['[[Enumerable]]'].isEmpty) {\n          newDesc['[[Enumerable]]'] = intrinsics.false;\n        } else {\n          newDesc['[[Enumerable]]'] = Desc['[[Enumerable]]'];\n        }\n        if (Desc['[[Configurable]]'].isEmpty) {\n          newDesc['[[Configurable]]'] = intrinsics.false;\n        } else {\n          newDesc['[[Configurable]]'] = Desc['[[Configurable]]'];\n        }\n\n        O['setProperty'](newDesc);\n      }\n    }\n    // 2. d. Else Desc must be an accessor Property Descriptor,\n    else {\n      // 2. d. i. If O is not undefined, create an own accessor property named P of object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.\n      if (!O.isUndefined) {\n        const newDesc = new $PropertyDescriptor(realm, P as $PropertyKey);\n        if (Desc['[[Get]]'].isEmpty) {\n          newDesc['[[Get]]'] = intrinsics.undefined;\n        } else {\n          newDesc['[[Get]]'] = Desc['[[Get]]'];\n        }\n        if (Desc['[[Set]]'].isEmpty) {\n          newDesc['[[Set]]'] = intrinsics.undefined;\n        } else {\n          newDesc['[[Set]]'] = Desc['[[Set]]'];\n        }\n        if (Desc['[[Enumerable]]'].isEmpty) {\n          newDesc['[[Enumerable]]'] = intrinsics.false;\n        } else {\n          newDesc['[[Enumerable]]'] = Desc['[[Enumerable]]'];\n        }\n        if (Desc['[[Configurable]]'].isEmpty) {\n          newDesc['[[Configurable]]'] = intrinsics.false;\n        } else {\n          newDesc['[[Configurable]]'] = Desc['[[Configurable]]'];\n        }\n\n        O['setProperty'](newDesc);\n      }\n    }\n\n    // 2. e. Return true.\n    return intrinsics.true;\n  }\n\n  // 3. If every field in Desc is absent, return true.\n  if (\n    Desc['[[Configurable]]'].isEmpty &&\n    Desc['[[Enumerable]]'].isEmpty &&\n    Desc['[[Writable]]'].isEmpty &&\n    Desc['[[Value]]'].isEmpty &&\n    Desc['[[Get]]'].isEmpty &&\n    Desc['[[Set]]'].isEmpty\n  ) {\n    return intrinsics.true;\n  }\n\n  // 4. If current.[[Configurable]] is false, then\n  if (current['[[Configurable]]'].isFalsey) {\n    // 4. a. If Desc.[[Configurable]] is present and its value is true, return false.\n    if (Desc['[[Configurable]]'].isTruthy) {\n      return intrinsics.false;\n    }\n\n    // 4. b. If Desc.[[Enumerable]] is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other, return false.\n    if (!Desc['[[Enumerable]]'].isEmpty && current['[[Enumerable]]'].isTruthy === Desc['[[Enumerable]]'].isFalsey) {\n      return intrinsics.false;\n    }\n  }\n\n  // 5. If IsGenericDescriptor(Desc) is true, no further validation is required.\n  // eslint-disable-next-line no-empty\n  if (Desc.isGenericDescriptor) {\n\n  }\n  // 6. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then\n  else if (current.isDataDescriptor !== Desc.isDataDescriptor) {\n    // 6. a. If current.[[Configurable]] is false, return false.\n    if (current['[[Configurable]]'].isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 6. b. If IsDataDescriptor(current) is true, then\n    if (current.isDataDescriptor) {\n      // 6. b. i. If O is not undefined, convert the property named P of object O from a data property to an accessor property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n      if (!O.isUndefined) {\n        const existingDesc = O['getProperty']((P as $PropertyKey))!;\n        const newDesc = new $PropertyDescriptor(realm, P as $PropertyKey);\n        newDesc['[[Configurable]]'] = existingDesc['[[Configurable]]'];\n        newDesc['[[Enumerable]]'] = existingDesc['[[Enumerable]]'];\n        newDesc['[[Get]]'] = intrinsics.undefined;\n        newDesc['[[Set]]'] = intrinsics.undefined;\n\n        O['setProperty'](newDesc);\n      }\n    }\n    // 6. c. Else,\n    else {\n      // 6. c. i. If O is not undefined, convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property's [[Configurable]] and [[Enumerable]] attributes and set the rest of the property's attributes to their default values.\n      if (!O.isUndefined) {\n        const existingDesc = O['getProperty']((P as $PropertyKey))!;\n        const newDesc = new $PropertyDescriptor(realm, P as $PropertyKey);\n        newDesc['[[Configurable]]'] = existingDesc['[[Configurable]]'];\n        newDesc['[[Enumerable]]'] = existingDesc['[[Enumerable]]'];\n        newDesc['[[Writable]]'] = intrinsics.false;\n        newDesc['[[Value]]'] = intrinsics.undefined;\n\n        O['setProperty'](newDesc);\n      }\n    }\n  }\n  // 7. Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then\n  else if (current.isDataDescriptor && Desc.isDataDescriptor) {\n    // 7. a. If current.[[Configurable]] is false and current.[[Writable]] is false, then\n    if (current['[[Configurable]]'].isFalsey && current['[[Writable]]'].isFalsey) {\n      // 7. a. i. If Desc.[[Writable]] is present and Desc.[[Writable]] is true, return false.\n      if (Desc['[[Writable]]'].isTruthy) {\n        return intrinsics.false;\n      }\n\n      // 7. a. ii. If Desc.[[Value]] is present and SameValue(Desc.[[Value]], current.[[Value]]) is false, return false.\n      if (!Desc['[[Value]]'].isEmpty && !Desc['[[Value]]'].is(current['[[Value]]'])) {\n        return intrinsics.false;\n      }\n\n      // 7. a. iii. Return true.\n      return intrinsics.true;\n    }\n  }\n  // 8. Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,\n  else {\n    // 8. a. If current.[[Configurable]] is false, then\n    if (current['[[Configurable]]'].isFalsey) {\n      // 8. a. i. If Desc.[[Set]] is present and SameValue(Desc.[[Set]], current.[[Set]]) is false, return false.\n      if (!Desc['[[Set]]'].isEmpty && !Desc['[[Set]]'].is(current['[[Set]]'])) {\n        return intrinsics.false;\n      }\n\n      // 8. a. ii. If Desc.[[Get]] is present and SameValue(Desc.[[Get]], current.[[Get]]) is false, return false.\n      if (!Desc['[[Get]]'].isEmpty && !Desc['[[Get]]'].is(current['[[Get]]'])) {\n        return intrinsics.false;\n      }\n\n      // 8. a. iii. Return true.\n      return intrinsics.true;\n    }\n  }\n\n  // 9. If O is not undefined, then\n  if (!O.isUndefined) {\n    const existingDesc = O['getProperty']((P as $PropertyKey))!;\n\n    // 9. a. For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.\n    if (!Desc['[[Configurable]]'].isEmpty) {\n      existingDesc['[[Configurable]]'] = Desc['[[Configurable]]'];\n    }\n    if (!Desc['[[Enumerable]]'].isEmpty) {\n      existingDesc['[[Enumerable]]'] = Desc['[[Enumerable]]'];\n    }\n    if (!Desc['[[Writable]]'].isEmpty) {\n      existingDesc['[[Writable]]'] = Desc['[[Writable]]'];\n    }\n    if (!Desc['[[Value]]'].isEmpty) {\n      existingDesc['[[Value]]'] = Desc['[[Value]]'];\n    }\n    if (!Desc['[[Get]]'].isEmpty) {\n      existingDesc['[[Get]]'] = Desc['[[Get]]'];\n    }\n    if (!Desc['[[Set]]'].isEmpty) {\n      existingDesc['[[Set]]'] = Desc['[[Set]]'];\n    }\n  }\n\n  // 10. Return true.\n  return intrinsics.true;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-set-immutable-prototype\nexport function $SetImmutablePrototype(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  V: $AnyObject | $Null,\n): $Boolean | $Error {\n  const intrinsics = O.realm['[[Intrinsics]]'];\n\n  // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n  // 2. Let current be ? O.[[GetPrototypeOf]]().\n  const current = O['[[GetPrototypeOf]]'](ctx);\n  if (current.isAbrupt) { return current; }\n\n  // 3. If SameValue(V, current) is true, return true.\n  if (V.is(current)) {\n    return intrinsics.true;\n  }\n\n  // 4. Return false.\n  return intrinsics.false;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison\nexport function $AbstractRelationalComparison(\n  ctx: ExecutionContext,\n  leftFirst: boolean,\n  x: $AnyNonEmpty,\n  y: $AnyNonEmpty,\n): $Boolean | $Undefined | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  let px: $Primitive | $Error;\n  let py: $Primitive | $Error;\n\n  // 1. If the LeftFirst flag is true, then\n  if (leftFirst) {\n    // 1. a. Let px be ? ToPrimitive(x, hint Number).\n    px = x.ToPrimitive(ctx, 'number');\n    if (px.isAbrupt) { return px; }\n\n    // 1. b. Let py be ? ToPrimitive(y, hint Number).\n    py = y.ToPrimitive(ctx, 'number');\n    if (py.isAbrupt) { return py; }\n  }\n  // 2. Else the order of evaluation needs to be reversed to preserve left to right evaluation,\n  else {\n    // 2. a. Let py be ? ToPrimitive(y, hint Number).\n    py = y.ToPrimitive(ctx, 'number');\n    if (py.isAbrupt) { return py; }\n\n    // 2. b. Let px be ? ToPrimitive(x, hint Number).\n    px = x.ToPrimitive(ctx, 'number');\n    if (px.isAbrupt) { return px; }\n  }\n\n  // 3. If Type(px) is String and Type(py) is String, then\n  if (px.isString && py.isString) {\n    // 3. a. If IsStringPrefix(py, px) is true, return false.\n    // 3. b. If IsStringPrefix(px, py) is true, return true.\n    // 3. c. Let k be the smallest nonnegative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)\n    // 3. d. Let m be the integer that is the numeric value of the code unit at index k within px.\n    // 3. e. Let n be the integer that is the numeric value of the code unit at index k within py.\n    // 3. f. If m < n, return true. Otherwise, return false.\n    if (px['[[Value]]'] < py['[[Value]]']) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n  // 4. Else,\n  // 4. a. NOTE: Because px and py are primitive values evaluation order is not important.\n  // 4. b. Let nx be ? ToNumber(px).\n  const nx = px.ToNumber(ctx);\n  if (nx.isAbrupt) { return nx; }\n\n  // 4. c. Let ny be ? ToNumber(py).\n  const ny = py.ToNumber(ctx);\n  if (ny.isAbrupt) { return ny; }\n\n  // 4. d. If nx is NaN, return undefined.\n  if (nx.isNaN) {\n    return intrinsics.undefined;\n  }\n\n  // 4. e. If ny is NaN, return undefined.\n  if (ny.isNaN) {\n    return intrinsics.undefined;\n  }\n\n  // 4. f. If nx and ny are the same Number value, return false.\n  if (nx.equals(ny)) {\n    return intrinsics.false;\n  }\n\n  // 4. g. If nx is +0 and ny is -0, return false.\n  if (nx.isPositiveZero && ny.isNegativeZero) {\n    return intrinsics.false;\n  }\n\n  // 4. h. If nx is -0 and ny is +0, return false.\n  if (nx.isNegativeZero && ny.isPositiveZero) {\n    return intrinsics.false;\n  }\n\n  // 4. i. If nx is +∞, return false.\n  if (nx.isPositiveInfinity) {\n    return intrinsics.false;\n  }\n\n  // 4. j. If ny is +∞, return true.\n  if (ny.isPositiveInfinity) {\n    return intrinsics.true;\n  }\n\n  // 4. k. If ny is -∞, return false.\n  if (ny.isNegativeInfinity) {\n    return intrinsics.false;\n  }\n\n  // 4. l. If nx is -∞, return true.\n  if (nx.isNegativeInfinity) {\n    return intrinsics.true;\n  }\n\n  // 4. m. If the mathematical value of nx is less than the mathematical value of ny—note that these mathematical values are both finite and not both zero—return true. Otherwise, return false.\n  if ((px['[[Value]]'] as number) < (py['[[Value]]'] as number)) {\n    return intrinsics.true;\n  }\n\n  return intrinsics.false;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison\nexport function $AbstractEqualityComparison(\n  ctx: ExecutionContext,\n  x: $AnyNonEmpty,\n  y: $AnyNonEmpty,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If Type(x) is the same as Type(y), then\n  if (x.constructor === y.constructor) {\n    // 1. a. Return the result of performing Strict Equality Comparison x === y.\n    return $StrictEqualityComparison(ctx, x, y);\n  }\n\n  // 2. If x is null and y is undefined, return true.\n  // 3. If x is undefined and y is null, return true.\n  if (x.isNil && y.isNil) {\n    return intrinsics.true;\n  }\n\n  // 4. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ! ToNumber(y).\n  if (x.isNumber && y.isString) {\n    if (x.is(y.ToNumber(ctx))) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n\n  // 5. If Type(x) is String and Type(y) is Number, return the result of the comparison ! ToNumber(x) == y.\n  if (x.isString && y.isNumber) {\n    if (x.ToNumber(ctx).is(y)) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n\n  // 6. If Type(x) is Boolean, return the result of the comparison ! ToNumber(x) == y.\n  if (x.isBoolean) {\n    if (x.ToNumber(ctx).is(y)) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n\n  // 7. If Type(y) is Boolean, return the result of the comparison x == ! ToNumber(y).\n  if (y.isBoolean) {\n    if (x.is(y.ToNumber(ctx))) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n\n  // 8. If Type(x) is either String, Number, or Symbol and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).\n  if ((x.isString || x.isNumber || x.isSymbol) && y.isObject) {\n    const yPrim = y.ToPrimitive(ctx);\n    if (yPrim.isAbrupt) { return yPrim; }\n    if (x.is(yPrim)) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n\n  // 9. If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y.\n  if (x.isObject && (y.isString || y.isNumber || y.isSymbol)) {\n    if (x.ToPrimitive(ctx).is(y)) {\n      return intrinsics.true;\n    }\n\n    return intrinsics.false;\n  }\n\n  // 10. Return false.\n  return intrinsics.false;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison\nexport function $StrictEqualityComparison(\n  ctx: ExecutionContext,\n  x: $AnyNonEmpty,\n  y: $AnyNonEmpty,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If Type(x) is different from Type(y), return false.\n  // 2. If Type(x) is Number, then\n  // 2. a. If x is NaN, return false.\n  // 2. b. If y is NaN, return false.\n  // 2. c. If x is the same Number value as y, return true.\n  // 2. d. If x is +0 and y is -0, return true.\n  // 2. e. If x is -0 and y is +0, return true.\n  // 2. f. Return false.\n  // 3. Return SameValueNonNumber(x, y).\n  if (x.is(y)) {\n    return intrinsics.true;\n  }\n\n  return intrinsics.false;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-instanceofoperator\nexport function $InstanceOfOperator(\n  ctx: ExecutionContext,\n  V: $AnyNonEmpty,\n  target: $AnyNonEmpty,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If Type(target) is not Object, throw a TypeError exception.\n  if (!target.isObject) {\n    return new $TypeError(realm, `Right-hand side of 'instanceof' operator is ${target}, but expected an object`);\n  }\n\n  // 2. Let instOfHandler be ? GetMethod(target, @@hasInstance).\n  const instOfhandler = target.GetMethod(ctx, intrinsics['@@hasInstance']);\n  if (instOfhandler.isAbrupt) { return instOfhandler; }\n\n  // 3. If instOfHandler is not undefined, then\n  if (!instOfhandler.isUndefined) {\n    // 3. a. Return ToBoolean(? Call(instOfHandler, target, « V »)).\n    return $Call(ctx, instOfhandler, target, new $List(V)).ToBoolean(ctx);\n  }\n\n  // 4. If IsCallable(target) is false, throw a TypeError exception.\n  if (!target.isFunction) {\n    return new $TypeError(realm, `Right-hand side of 'instanceof' operator is ${target}, but expected a callable function`);\n  }\n\n  // 5. Return ? OrdinaryHasInstance(target, V).\n  return $OrdinaryHasInstance(ctx, target, V);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-ordinaryhasinstance\nexport function $OrdinaryHasInstance(\n  ctx: ExecutionContext,\n  C: $AnyObject,\n  O: $AnyNonEmpty,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If IsCallable(C) is false, return false.\n  if (!C.isFunction) {\n    return intrinsics.false;\n  }\n\n  // 2. If C has a [[BoundTargetFunction]] internal slot, then\n  if (C.isBoundFunction) {\n    // 2. a. Let BC be C.[[BoundTargetFunction]].\n    const BC = (C as $BoundFunctionExoticObject)['[[BoundTargetFunction]]'];\n\n    // 2. b. Return ? InstanceofOperator(O, BC).\n    return $InstanceOfOperator(ctx, O, BC);\n  }\n\n  // 3. If Type(O) is not Object, return false.\n  if (!O.isObject) {\n    return intrinsics.false;\n  }\n\n  // 4. Let P be ? Get(C, \"prototype\").\n  const P = C['[[Get]]'](ctx, intrinsics.$prototype, C);\n  if (P.isAbrupt) { return P; }\n\n  // 5. If Type(P) is not Object, throw a TypeError exception.\n  if (!P.isObject) {\n    return new $TypeError(realm, `Prototype of right-hand side of 'instanceof' operator ${O} is ${P}, but expected an object`);\n  }\n\n  // 6. Repeat,\n  while (true) {\n    // 6. a. Set O to ? O.[[GetPrototypeOf]]().\n    const $O = (O as $AnyObject)['[[GetPrototypeOf]]'](ctx) as $AnyNonEmpty ;\n    if ($O.isAbrupt) { return $O; }\n    O = $O;\n\n    // 6. b. If O is null, return false.\n    if (O.isNull) {\n      return intrinsics.false;\n    }\n\n    // 6. c. If SameValue(P, O) is true, return true.\n    if (P.is(O)) {\n      return intrinsics.true;\n    }\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-topropertydescriptor\nexport function $ToPropertyDescriptor(\n  ctx: ExecutionContext,\n  Obj: $AnyNonEmpty,\n  key: $PropertyKey,\n): $PropertyDescriptor | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If Type(Obj) is not Object, throw a TypeError exception.\n  if (!Obj.isObject) {\n    return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: expected an object`);\n  }\n\n  // 2. Let desc be a new Property Descriptor that initially has no fields.\n  const desc = new $PropertyDescriptor(Obj.realm, key);\n\n  // 3. Let hasEnumerable be ? HasProperty(Obj, \"enumerable\").\n  const hasEnumerable = Obj['[[HasProperty]]'](ctx, intrinsics.$enumerable);\n  if (hasEnumerable.isAbrupt) { return hasEnumerable; }\n\n  // 4. If hasEnumerable is true, then\n  if (hasEnumerable.isTruthy) {\n    // 4. a. Let enumerable be ToBoolean(? Get(Obj, \"enumerable\")).\n    const enumerable = Obj['[[Get]]'](ctx, intrinsics.$enumerable, Obj).ToBoolean(ctx);\n    if (enumerable.isAbrupt) { return enumerable; }\n\n    // 4. b. Set desc.[[Enumerable]] to enumerable.\n    desc['[[Enumerable]]'] = enumerable;\n  }\n\n  // 5. Let hasConfigurable be ? HasProperty(Obj, \"configurable\").\n  const hasConfigurable = Obj['[[HasProperty]]'](ctx, intrinsics.$configurable);\n  if (hasConfigurable.isAbrupt) { return hasConfigurable; }\n\n  // 6. If hasConfigurable is true, then\n  if (hasConfigurable.isTruthy) {\n    // 6. a. Let configurable be ToBoolean(? Get(Obj, \"configurable\")).\n    const configurable = Obj['[[Get]]'](ctx, intrinsics.$configurable, Obj).ToBoolean(ctx);\n    if (configurable.isAbrupt) { return configurable; }\n\n    // 6. b. Set desc.[[Configurable]] to configurable.\n    desc['[[Enumerable]]'] = configurable;\n  }\n\n  // 7. Let hasValue be ? HasProperty(Obj, \"value\").\n  const hasValue = Obj['[[HasProperty]]'](ctx, intrinsics.$value);\n  if (hasValue.isAbrupt) { return hasValue; }\n\n  // 8. If hasValue is true, then\n  if (hasValue.isTruthy) {\n    // 8. a. Let value be ? Get(Obj, \"value\").\n    const value = Obj['[[Get]]'](ctx, intrinsics.$value, Obj).ToBoolean(ctx);\n    if (value.isAbrupt) { return value; }\n\n    // 8. b. Set desc.[[Value]] to value.\n    desc['[[Enumerable]]'] = value;\n  }\n\n  // 9. Let hasWritable be ? HasProperty(Obj, \"writable\").\n  const hasWritable = Obj['[[HasProperty]]'](ctx, intrinsics.$writable);\n  if (hasWritable.isAbrupt) { return hasWritable; }\n\n  // 10. If hasWritable is true, then\n  if (hasWritable.isTruthy) {\n    // 10. a. Let writable be ToBoolean(? Get(Obj, \"writable\")).\n    const writable = Obj['[[Get]]'](ctx, intrinsics.$writable, Obj).ToBoolean(ctx);\n    if (writable.isAbrupt) { return writable; }\n\n    // 10. b. Set desc.[[Writable]] to writable.\n    desc['[[Enumerable]]'] = writable;\n  }\n\n  // 11. Let hasGet be ? HasProperty(Obj, \"get\").\n  const hasGet = Obj['[[HasProperty]]'](ctx, intrinsics.$get);\n  if (hasGet.isAbrupt) { return hasGet; }\n\n  // 12. If hasGet is true, then\n  if (hasGet.isTruthy) {\n    // 12. a. Let getter be ? Get(Obj, \"get\").\n    const getter = Obj['[[Get]]'](ctx, intrinsics.$get, Obj);\n    if (getter.isAbrupt) { return getter; }\n\n    // 12. b. If IsCallable(getter) is false and getter is not undefined, throw a TypeError exception.\n    if (!getter.isFunction && !getter.isUndefined) {\n      return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: the getter is neither a callable function nor undefined`);\n    }\n\n    // 12. c. Set desc.[[Get]] to getter.\n    desc['[[Get]]'] = getter as $Function | $Undefined;\n  }\n\n  // 13. Let hasSet be ? HasProperty(Obj, \"set\").\n  const hasSet = Obj['[[HasProperty]]'](ctx, intrinsics.$set);\n  if (hasSet.isAbrupt) { return hasSet; }\n\n  // 14. If hasSet is true, then\n  if (hasSet.isTruthy) {\n    // 14. a. Let setter be ? Get(Obj, \"set\").\n    const setter = Obj['[[Get]]'](ctx, intrinsics.$set, Obj);\n    if (setter.isAbrupt) { return setter; }\n\n    // 14. b. If IsCallable(setter) is false and setter is not undefined, throw a TypeError exception.\n    if (!setter.isFunction && !setter.isUndefined) {\n      return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: the setter is neither a callable function nor undefined`);\n    }\n\n    // 14. c. Set desc.[[Set]] to setter.\n    desc['[[Set]]'] = setter as $Function | $Undefined;\n  }\n\n  // 15. If desc.[[Get]] is present or desc.[[Set]] is present, then\n  if (desc['[[Get]]'].hasValue || desc['[[Set]]'].hasValue) {\n    // 15. a. If desc.[[Value]] is present or desc.[[Writable]] is present, throw a TypeError exception.\n    if (desc['[[Value]]'].hasValue || desc['[[Writable]]'].hasValue) {\n      return new $TypeError(realm, `Cannot convert ${Obj} to property descriptor for property ${key}: there is a getter and/or setter, as well as a writable and/or value property`);\n    }\n  }\n\n  // 16. Return desc.\n  return desc;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-frompropertydescriptor\nexport function $FromPropertyDescriptor(\n  ctx: ExecutionContext,\n  Desc: $PropertyDescriptor,\n): $AnyObject | $Error;\nexport function $FromPropertyDescriptor(\n  ctx: ExecutionContext,\n  Desc: $Undefined,\n): $Undefined | $Error;\nexport function $FromPropertyDescriptor(\n  ctx: ExecutionContext,\n  Desc: $PropertyDescriptor | $Undefined,\n): $AnyObject | $Undefined | $Error;\nexport function $FromPropertyDescriptor(\n  ctx: ExecutionContext,\n  Desc: $PropertyDescriptor | $Undefined,\n): $AnyObject | $Undefined | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If Desc is undefined, return undefined.\n  if (Desc.isUndefined) {\n    return intrinsics.undefined;\n  }\n\n  // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n  const obj = $Object.ObjectCreate(ctx, 'PropertyDescriptor', intrinsics['%ObjectPrototype%']);\n\n  // 3. Assert: obj is an extensible ordinary object with no own properties.\n  // 4. If Desc has a [[Value]] field, then\n  if (Desc['[[Value]]'].hasValue) {\n    // 4. a. Perform CreateDataProperty(obj, \"value\", Desc.[[Value]]).\n    $CreateDataProperty(ctx, obj, intrinsics.$value, Desc['[[Value]]']);\n  }\n\n  // 5. If Desc has a [[Writable]] field, then\n  if (Desc['[[Writable]]'].hasValue) {\n    // 5. a. Perform CreateDataProperty(obj, \"writable\", Desc.[[Writable]]).\n    $CreateDataProperty(ctx, obj, intrinsics.$writable, Desc['[[Writable]]']);\n  }\n\n  // 6. If Desc has a [[Get]] field, then\n  if (Desc['[[Get]]'].hasValue) {\n    // 6. a. Perform CreateDataProperty(obj, \"get\", Desc.[[Get]]).\n    $CreateDataProperty(ctx, obj, intrinsics.$get, Desc['[[Get]]']);\n  }\n\n  // 7. If Desc has a [[Set]] field, then\n  if (Desc['[[Set]]'].hasValue) {\n    // 7. a. Perform CreateDataProperty(obj, \"set\", Desc.[[Set]]).\n    $CreateDataProperty(ctx, obj, intrinsics.$set, Desc['[[Set]]']);\n  }\n\n  // 8. If Desc has an [[Enumerable]] field, then\n  if (Desc['[[Enumerable]]'].hasValue) {\n    // 8. a. Perform CreateDataProperty(obj, \"enumerable\", Desc.[[Enumerable]]).\n    $CreateDataProperty(ctx, obj, intrinsics.$enumerable, Desc['[[Enumerable]]']);\n  }\n\n  // 9. If Desc has a [[Configurable]] field, then\n  if (Desc['[[Configurable]]'].hasValue) {\n    // 9. a. Perform CreateDataProperty(obj, \"configurable\", Desc.[[Configurable]]).\n    $CreateDataProperty(ctx, obj, intrinsics.$configurable, Desc['[[Configurable]]']);\n  }\n\n  // 10. Assert: All of the above CreateDataProperty operations return true.\n  // 11. Return obj.\n  return obj;\n}\n\nconst defaultElementTypes = [\n  'Undefined',\n  'Null',\n  'Boolean',\n  'String',\n  'Symbol',\n  'Number',\n  'Object',\n] as const;\n\n// http://www.ecma-international.org/ecma-262/#sec-createlistfromarraylike\nexport function $CreateListFromArrayLike(\n  ctx: ExecutionContext,\n  obj: $AnyNonEmpty,\n  elementTypes: readonly ESType[] = defaultElementTypes,\n): $List<$AnyNonEmpty> | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If elementTypes is not present, set elementTypes to « Undefined, Null, Boolean, String, Symbol, Number, Object ».\n  // 2. If Type(obj) is not Object, throw a TypeError exception.\n  if (!obj.isObject) {\n    return new $TypeError(realm, `Cannot convert ${obj} to list: expected an object`);\n  }\n\n  // 3. Let len be ? ToLength(? Get(obj, \"length\")).\n  const len = obj['[[Get]]'](ctx, intrinsics.length, obj).ToLength(ctx);\n  if (len.isAbrupt) { return len; }\n\n  // 4. Let list be a new empty List.\n  const list = new $List<$AnyNonEmpty>();\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat, while index < len\n  while (index < len['[[Value]]']) {\n    // 6. a. Let indexName be ! ToString(index).\n    const indexName = new $String(realm, index.toString());\n\n    // 6. b. Let next be ? Get(obj, indexName).\n    const next = obj['[[Get]]'](ctx, indexName, obj);\n    if (next.isAbrupt) { return next; }\n\n    // 6. c. If Type(next) is not an element of elementTypes, throw a TypeError exception.\n    if (!elementTypes.includes(next.Type)) {\n      return new $TypeError(realm, `Cannot convert ${obj} to list: one of the elements (${next}) is of type ${next.Type}, but expected one of: ${elementTypes}`);\n    }\n\n    // 6. d. Append next as the last element of list.\n    list[index++] = next;\n\n    // 6. e. Increase index by 1.\n  }\n\n  // 7. Return list.\n  return list;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getfunctionrealm\nexport function $GetFunctionRealm(\n  ctx: ExecutionContext,\n  obj: $AnyNonEmpty,\n): Realm | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: obj is a callable object.\n  // 2. If obj has a [[Realm]] internal slot, then\n  if ('[[Realm]]' in obj) {\n    // 2. a. Return obj.[[Realm]].\n    return obj['[[Realm]]'];\n  }\n\n  // 3. If obj is a Bound Function exotic object, then\n  if (obj.isBoundFunction) {\n    // 3. a. Let target be obj.[[BoundTargetFunction]].\n    // 3. b. Return ? GetFunctionRealm(target).\n    return $GetFunctionRealm(ctx, (obj as $BoundFunctionExoticObject)['[[BoundTargetFunction]]']);\n  }\n\n  // 4. If obj is a Proxy exotic object, then\n  if (obj.isProxy) {\n    // 4. a. If obj.[[ProxyHandler]] is null, throw a TypeError exception.\n    if ((obj as $ProxyExoticObject)['[[ProxyHandler]]'].isNull) {\n      return new $TypeError(realm, `Cannot retrieve function realm of proxy object with a null handler`);\n    }\n\n    // 4. b. Let proxyTarget be obj.[[ProxyTarget]].\n    const proxyTarget = (obj as $ProxyExoticObject)['[[ProxyTarget]]'];\n\n    // 4. c. Return ? GetFunctionRealm(proxyTarget).\n    return $GetFunctionRealm(ctx, proxyTarget);\n  }\n\n  // 5. Return the current Realm Record.\n  return realm;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-copydataproperties\n// 7.3.23 CopyDataProperties ( target , source , excludedItems )\nexport function $CopyDataProperties<T extends $AnyObject>(\n  ctx: ExecutionContext,\n  target: T,\n  source: $AnyNonEmptyNonError,\n  excludedItems: readonly $PropertyKey[],\n): T | $Error {\n  // 1. Assert: Type(target) is Object.\n  // 2. Assert: excludedItems is a List of property keys.\n  // 3. If source is undefined or null, return target.\n  if (source.isNil) {\n    return target;\n  }\n\n  // 4. Let from be ! ToObject(source).\n  const from = source.ToObject(ctx);\n\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  const keys = from['[[OwnPropertyKeys]]'](ctx);\n  if (keys.isAbrupt) { return keys; }\n\n  // 6. For each element nextKey of keys in List order, do\n  for (const nextKey of keys) {\n    // 6. a. Let excluded be false.\n    // 6. b. For each element e of excludedItems in List order, do\n      // 6. b. i. If SameValue(e, nextKey) is true, then\n        // 6. b. i. 1. Set excluded to true.\n    // 6. c. If excluded is false, then\n    if (!excludedItems.some(x => x.is(nextKey))) {\n      // 6. c. i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n      const desc = from['[[GetOwnProperty]]'](ctx, nextKey);\n      if (desc.isAbrupt) { return desc; }\n\n      // 6. c. ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n      if (!desc.isUndefined && desc['[[Enumerable]]'].isTruthy) {\n        // 6. c. ii. 1. Let propValue be ? Get(from, nextKey).\n        const propValue = from['[[Get]]'](ctx, nextKey, from);\n        if (propValue.isAbrupt) { return propValue; }\n\n        // 6. c. ii. 2. Perform ! CreateDataProperty(target, nextKey, propValue).\n        $CreateDataProperty(ctx, target, nextKey, propValue);\n      }\n    }\n  }\n\n  // 7. Return target.\n  return target;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-loopcontinues\n// 13.7.1.2 Runtime Semantics: LoopContinues ( completion , labelSet )\nexport function $LoopContinues(\n  ctx: ExecutionContext,\n  completion: $Any,\n  labelSet: $StringSet,\n): $Boolean {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If completion.[[Type]] is normal, return true.\n  if (completion['[[Type]]'] === CompletionType.normal) {\n    return intrinsics.true;\n  }\n\n  // 2. If completion.[[Type]] is not continue, return false.\n  if (completion['[[Type]]'] !== CompletionType.continue) {\n    return intrinsics.false;\n  }\n\n  // 3. If completion.[[Target]] is empty, return true.\n  if (completion['[[Target]]'].isEmpty) {\n    return intrinsics.true;\n  }\n\n  // 4. If completion.[[Target]] is an element of labelSet, return true.\n  if (labelSet.has(completion['[[Target]]'])) {\n    return intrinsics.true;\n  }\n\n  // 5. Return false.\n  return intrinsics.false;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-hostensurecancompilestrings\n// 18.2.1.2 HostEnsureCanCompileStrings ( callerRealm , calleeRealm )\nexport function $HostEnsureCanCompileStrings(\n  ctx: ExecutionContext,\n  callerRealm: Realm,\n  calleeRealm: Realm,\n): $Empty | $Error {\n  // HostEnsureCanCompileStrings is an implementation-defined abstract operation that allows host environments\n  // to block certain ECMAScript functions which allow developers to compile strings into ECMAScript code.\n\n  // An implementation of HostEnsureCanCompileStrings may complete normally or abruptly.\n  // Any abrupt completions will be propagated to its callers.\n  // The default implementation of HostEnsureCanCompileStrings is to unconditionally return an empty normal completion.\n  return new $Empty(calleeRealm);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-invoke\n// 7.3.18 Invoke ( V , P [ , argumentsList ] )\nexport function $Invoke(\n  ctx: ExecutionContext,\n  V: $AnyNonEmptyNonError,\n  P: $PropertyKey,\n  argumentsList: $List<$AnyNonEmpty> | $Undefined,\n): $Any {\n  // 1. Assert: IsPropertyKey(P) is true.\n  // 2. If argumentsList is not present, set argumentsList to a new empty List.\n  if (!argumentsList.isList) {\n    argumentsList = new $List<$AnyNonEmpty>();\n  }\n\n  // 3. Let func be ? GetV(V, P).\n  const func = $GetV(ctx, V, P);\n  if (func.isAbrupt) { return func; }\n\n  // 4. Return ? Call(func, V, argumentsList).\n  return $Call(ctx, func, V, argumentsList);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-speciesconstructor\n// 7.3.20 SpeciesConstructor ( O , defaultConstructor )\nexport function $SpeciesConstructor(\n  ctx: ExecutionContext,\n  O: $AnyObject,\n  defaultConstructor: $Function,\n): $Function | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(O) is Object.\n  // 2. Let C be ? Get(O, \"constructor\").\n  const C = O['[[Get]]'](ctx, intrinsics.$constructor, O);\n  if (C.isAbrupt) { return C; }\n\n  // 3. If C is undefined, return defaultConstructor.\n  if (C.isUndefined) { return defaultConstructor; }\n\n  // 4. If Type(C) is not Object, throw a TypeError exception.\n  if (!C.isObject) {\n    return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);\n  }\n\n  // 5. Let S be ? Get(C, @@species).\n  const S = C['[[Get]]'](ctx, intrinsics['@@species'], C);\n  if (S.isAbrupt) { return S; }\n\n  // 6. If S is either undefined or null, return defaultConstructor.\n  if (S.isNil) {\n    return defaultConstructor;\n  }\n\n  // 7. If IsConstructor(S) is true, return S.\n  if (S.isFunction) {\n    return S as $Function;\n  }\n\n  // 8. Throw a TypeError exception.\n  return new $TypeError(realm, `Expected return value of @@species to be null, undefined or a function, but got: ${S}`);\n}\n","import {\n  nextValueId,\n  $PropertyKey,\n  $AnyNonError,\n  $Primitive,\n  compareIndices,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  $AnyObject,\n  $Any,\n} from './_shared.js';\nimport {\n  $PropertyDescriptor,\n} from './property-descriptor.js';\nimport {\n  $Null,\n} from './null.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $Call,\n  $ValidateAndApplyPropertyDescriptor,\n  $OrdinarySetWithOwnDescriptor,\n} from '../operations.js';\nimport {\n  $Function,\n} from './function.js';\nimport {\n  $Undefined,\n} from './undefined.js';\nimport {\n  $Symbol,\n} from './symbol.js';\nimport {\n  $TypeError,\n  $Error,\n} from './error.js';\nimport {\n  $List,\n} from './list.js';\nimport {\n  Writable,\n  IDisposable,\n} from '@aurelia/kernel';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-object-type\nexport class $Object<\n  T extends string = string,\n> implements IDisposable {\n  public readonly '<$Object>': unknown;\n\n  public disposed: boolean = false;\n\n  public readonly id: number = nextValueId();\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public get '[[Value]]'(): Record<string, unknown> {\n    const obj = {};\n    for (const pd of this.propertyDescriptors) {\n      // Reflect.defineProperty(obj, pd.name['[[Value]]'], {\n        // TODO: materialize\n      // })\n    }\n    return obj;\n  }\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public readonly propertyMap: Map<string | symbol, number> = new Map();\n  public readonly propertyDescriptors: $PropertyDescriptor[] = [];\n  public readonly propertyKeys: $PropertyKey[] = [];\n\n  public ['[[Prototype]]']: $AnyObject | $Null;\n  public ['[[Extensible]]']: $Boolean;\n\n  public get Type(): 'Object' { return 'Object'; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): true { return true; }\n  public get isArray(): boolean { return false; }\n  public get isProxy(): boolean { return false; }\n  public get isFunction(): boolean { return false; }\n  public get isBoundFunction(): boolean { return false; }\n  public get isTruthy(): true { return true; }\n  public get isFalsey(): false { return false; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): false { return false; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public constructor(\n    public readonly realm: Realm,\n    public readonly IntrinsicName: T,\n    proto: $AnyObject | $Null,\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ) {\n    this['[[Prototype]]'] = proto;\n    this['[[Extensible]]'] = realm['[[Intrinsics]]'].true;\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-objectcreate\n  // 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] )\n  public static ObjectCreate<T extends string = string, TSlots extends {} = {}>(\n    ctx: ExecutionContext,\n    IntrinsicName: T,\n    proto: $AnyObject,\n    internalSlotsList?: TSlots,\n  ): $Object<T> & TSlots {\n    const realm = ctx.Realm;\n\n    // 1. If internalSlotsList is not present, set internalSlotsList to a new empty List.\n    // 2. Let obj be a newly created object with an internal slot for each name in internalSlotsList.\n    const obj = new $Object(realm, IntrinsicName, proto, CompletionType.normal, realm['[[Intrinsics]]'].empty);\n    Object.assign(obj, internalSlotsList);\n\n    // 3. Set obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n    // 4. Set obj.[[Prototype]] to proto.\n    // 5. Set obj.[[Extensible]] to true.\n    // 6. Return obj.\n    return obj as $Object<T> & TSlots;\n  }\n\n  public is(other: $AnyNonError): other is $Object<T> {\n    return this.id === other.id;\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String | $Error {\n    return this.ToString(ctx);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToNumber(ctx).ToLength(ctx);\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $Boolean | $Error {\n    return this.ToPrimitive(ctx, 'number').ToBoolean(ctx);\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToNumber(ctx);\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToInt32(ctx);\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToUint32(ctx);\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToInt16(ctx);\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToUint16(ctx);\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToInt8(ctx);\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToUint8(ctx);\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Number | $Error {\n    return this.ToPrimitive(ctx, 'number').ToUint8Clamp(ctx);\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $String | $Error {\n    return this.ToPrimitive(ctx,  'string').ToString(ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-toprimitive\n  // 7.1.1 ToPrimitive ( input [ , PreferredType ] )\n  public ToPrimitive(\n    ctx: ExecutionContext,\n    PreferredType: 'default' | 'string' | 'number' = 'default',\n  ): $Primitive | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const input = this;\n\n    // 1. Assert: input is an ECMAScript language value.\n    // 2. If Type(input) is Object, then\n    // 2. a. If PreferredType is not present, let hint be \"default\".\n    // 2. b. Else if PreferredType is hint String, let hint be \"string\".\n    // 2. c. Else PreferredType is hint Number, let hint be \"number\".\n    let hint = intrinsics[PreferredType];\n\n    // 2. d. Let exoticToPrim be ? GetMethod(input, @@toPrimitive).\n    const exoticToPrim = input.GetMethod(ctx, intrinsics['@@toPrimitive']);\n    if (exoticToPrim.isAbrupt) { return exoticToPrim; }\n\n    // 2. e. If exoticToPrim is not undefined, then\n    if (!exoticToPrim.isUndefined) {\n      // 2. e. i. Let result be ? Call(exoticToPrim, input, « hint »).\n      const result = $Call(ctx, exoticToPrim, input, new $List(hint));\n      if (result.isAbrupt) { return result; }\n\n      // 2. e. ii. If Type(result) is not Object, return result.\n      if (result.isPrimitive) {\n        return result;\n      }\n\n      // 2. e. iii. Throw a TypeError exception.\n      return new $TypeError(realm, `Symbol.toPrimitive returned ${result}, but expected a primitive`);\n    }\n\n    // 2. f. If hint is \"default\", set hint to \"number\".\n    if (hint['[[Value]]'] === 'default') {\n      hint = intrinsics.number;\n    }\n\n    // 2. g. Return ? OrdinaryToPrimitive(input, hint).\n    return input.OrdinaryToPrimitive(ctx, hint['[[Value]]']);\n\n    // 3. Return input.\n    // N/A since this is always an object\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinarytoprimitive\n  // 7.1.1.1 OrdinaryToPrimitive ( O , hint )\n  public OrdinaryToPrimitive(\n    ctx: ExecutionContext,\n    hint: 'string' | 'number',\n  ): $Primitive | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const O = this;\n\n    // 1. Assert: Type(O) is Object.\n    // 2. Assert: Type(hint) is String and its value is either \"string\" or \"number\".\n    // 3. If hint is \"string\", then\n    if (hint === 'string') {\n      // 3. a. Let methodNames be « \"toString\", \"valueOf\" ».\n      // 5. For each name in methodNames in List order, do\n      // 5. a. Let method be ? Get(O, name).\n      let method = O['[[Get]]'](ctx, intrinsics.$toString, O);\n      if (method.isAbrupt) { return method; }\n\n      // 5. b. If IsCallable(method) is true, then\n      if (method.isFunction) {\n        // 5. b. i. Let result be ? Call(method, O).\n        const result = $Call(ctx, method as $Function, O, intrinsics.undefined);\n        if (result.isAbrupt) { return result; }\n\n        // 5. b. ii. If Type(result) is not Object, return result.\n        if (result.isPrimitive) {\n          return result;\n        }\n      }\n\n      method = O['[[Get]]'](ctx, intrinsics.$valueOf, O);\n      if (method.isAbrupt) { return method; }\n\n      // 5. b. If IsCallable(method) is true, then\n      if (method.isFunction) {\n        // 5. b. i. Let result be ? Call(method, O).\n        const result = $Call(ctx, method as $Function, O, intrinsics.undefined);\n        if (result.isAbrupt) { return result; }\n\n        // 5. b. ii. If Type(result) is not Object, return result.\n        if (result.isPrimitive) {\n          return result;\n        }\n\n        // 6. Throw a TypeError exception.\n        return new $TypeError(realm, `valueOf returned ${result}, but expected a primitive`);\n      }\n\n      // 6. Throw a TypeError exception.\n      return new $TypeError(realm, `${this} has neither a toString nor a valueOf method that returns a primitive`);\n    }\n    // 4. Else,\n    else {\n      // 4. a. Let methodNames be « \"valueOf\", \"toString\" ».\n      // 5. For each name in methodNames in List order, do\n      // 5. a. Let method be ? Get(O, name).\n      let method = O['[[Get]]'](ctx, intrinsics.$valueOf, O);\n      if (method.isAbrupt) { return method; }\n\n      // 5. b. If IsCallable(method) is true, then\n      if (method.isFunction) {\n        // 5. b. i. Let result be ? Call(method, O).\n        const result = $Call(ctx, method as $Function, O, intrinsics.undefined);\n        if (result.isAbrupt) { return result; }\n\n        // 5. b. ii. If Type(result) is not Object, return result.\n        if (result.isPrimitive) {\n          return result;\n        }\n      }\n\n      method = O['[[Get]]'](ctx, intrinsics.$toString, O);\n      if (method.isAbrupt) { return method; }\n\n      // 5. b. If IsCallable(method) is true, then\n      if (method.isFunction) {\n        // 5. b. i. Let result be ? Call(method, O).\n        const result = $Call(ctx, method as $Function, O, intrinsics.undefined);\n        if (result.isAbrupt) { return result; }\n\n        // 5. b. ii. If Type(result) is not Object, return result.\n        if (result.isPrimitive) {\n          return result;\n        }\n\n        // 6. Throw a TypeError exception.\n        return new $TypeError(realm, `toString returned ${result}, but expected a primitive`);\n      }\n\n      // 6. Throw a TypeError exception.\n      return new $TypeError(realm, `${this} has neither a valueOf nor a toString method that returns a primitive`);\n    }\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getmethod\n  // 7.3.9 GetMethod ( V , P )\n  public GetMethod(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Function | $Undefined | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const V = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. Let func be ? GetV(V, P).\n    const func = V['[[Get]]'](ctx, P, V);\n    if (func.isAbrupt) { return func; }\n\n    // 3. If func is either undefined or null, return undefined.\n    if (func.isNil) {\n      return intrinsics.undefined;\n    }\n\n    // 4. If IsCallable(func) is false, throw a TypeError exception.\n    if (!func.isFunction) {\n      return new $TypeError(realm, `Return value from GetMethod is ${func}, but expected a callable function`);\n    }\n\n    // 5. Return func.\n    return func as $Function;\n  }\n\n  public hasProperty(key: $PropertyKey): boolean {\n    return this.propertyMap.has(key['[[Value]]']);\n  }\n\n  public getProperty(key: $PropertyKey): $PropertyDescriptor {\n    return this.propertyDescriptors[this.propertyMap.get(key['[[Value]]'])!];\n  }\n\n  public setProperty(desc: $PropertyDescriptor): void {\n    if (this.propertyMap.has(desc.name['[[Value]]'])) {\n      const idx = this.propertyMap.get(desc.name['[[Value]]'])!;\n      this.propertyDescriptors[idx] = desc;\n      this.propertyKeys[idx] = desc.name;\n    } else {\n      const idx = this.propertyDescriptors.length;\n      this.propertyDescriptors[idx] = desc;\n      this.propertyKeys[idx] = desc.name;\n      this.propertyMap.set(desc.name['[[Value]]'], idx);\n    }\n  }\n\n  public deleteProperty(key: $PropertyKey): void {\n    const idx = this.propertyMap.get(key['[[Value]]'])!;\n    this.propertyMap.delete(key['[[Value]]']);\n    this.propertyDescriptors.splice(idx, 1);\n    this.propertyKeys.splice(idx, 1);\n  }\n\n  public setDataProperty(\n    name: $PropertyKey,\n    value: $AnyNonEmpty,\n    writable: boolean = true,\n    enumerable: boolean = false,\n    configurable: boolean = true,\n  ): void {\n    const realm = this.realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const desc = new $PropertyDescriptor(realm, name);\n    desc['[[Value]]'] = value;\n    desc['[[Writable]]'] = writable ? intrinsics.true : intrinsics.false;\n    desc['[[Enumerable]]'] = enumerable ? intrinsics.true : intrinsics.false;\n    desc['[[Configurable]]'] = configurable ? intrinsics.true : intrinsics.false;\n\n    const idx = this.propertyDescriptors.length;\n    this.propertyDescriptors[idx] = desc;\n    this.propertyKeys[idx] = name;\n    this.propertyMap.set(name['[[Value]]'], idx);\n  }\n\n  public setAccessorProperty(\n    name: $String,\n    getter: $Function | null,\n    setter: $Function | null,\n    enumerable: boolean = false,\n    configurable: boolean = true,\n  ): void {\n    const realm = this.realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const desc = new $PropertyDescriptor(realm, name);\n    desc['[[Enumerable]]'] = enumerable ? intrinsics.true : intrinsics.false;\n    desc['[[Configurable]]'] = configurable ? intrinsics.true : intrinsics.false;\n    if (getter !== null) {\n      desc['[[Get]]'] = getter;\n    }\n    if (setter !== null) {\n      desc['[[Set]]'] = setter;\n    }\n\n    const idx = this.propertyDescriptors.length;\n    this.propertyDescriptors[idx] = desc;\n    this.propertyKeys[idx] = name;\n    this.propertyMap.set(name['[[Value]]'], idx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof\n  // 9.1.1 [[GetPrototypeOf]] ( )\n  public '[[GetPrototypeOf]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n  ): $AnyObject | $Null | $Error {\n    // 1. Return ! OrdinaryGetPrototypeOf(O)\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinarygetprototypeof\n    // 9.1.1.1 OrdinaryGetPrototypeOf ( O )\n    const O = this;\n\n    // 1. Return O.[[Prototype]].\n    return O['[[Prototype]]'];\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v\n  // 9.1.2 [[SetPrototypeOf]] ( V )\n  public '[[SetPrototypeOf]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    V: $AnyObject | $Null,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return ! OrdinarySetPrototypeOf(O, V).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinarysetprototypeof\n    // 9.1.2.1 OrdinarySetPrototypeOf ( O , V )\n    const O = this;\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n    // 2. Let extensible be O.[[Extensible]].\n    const extensible = O['[[Extensible]]']['[[Value]]'];\n\n    // 3. Let current be O.[[Prototype]].\n    const current = O['[[Prototype]]'];\n\n    // 4. If SameValue(V, current) is true, return true.\n    if (V.is(current)) {\n      return intrinsics.true;\n    }\n\n    // 5. If extensible is false, return false.\n    if (!extensible) {\n      return intrinsics.false;\n    }\n\n    // 6. Let p be V.\n    let p = V;\n\n    // 7. Let done be false.\n    let done = false;\n\n    // 8. Repeat, while done is false,\n    while (!done) {\n      // 8. a. If p is null, set done to true.\n      if (p.isNull) {\n        done = true;\n      }\n      // 8. b. Else if SameValue(p, O) is true, return false.\n      else if (p.is(O)) {\n        return intrinsics.false;\n      }\n      // 8. c. Else,\n      else {\n        // 8. c. i. If p.[[GetPrototypeOf]] is not the ordinary object internal method defined in 9.1.1, set done to true.\n        if (p['[[GetPrototypeOf]]'] !== $Object.prototype['[[GetPrototypeOf]]']) {\n          done = true;\n        }\n        // 8. c. ii. Else, set p to p.[[Prototype]].\n        else {\n          p = p['[[Prototype]]'];\n        }\n      }\n    }\n\n    // 9. Set O.[[Prototype]] to V.\n    O['[[Prototype]]'] = V;\n\n    // 10. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-isextensible\n  // 9.1.3 [[IsExtensible]] ( )\n  public '[[IsExtensible]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n  ): $Boolean | $Error {\n    // 1. Return ! OrdinaryIsExtensible(O).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinaryisextensible\n    // 9.1.3.1 OrdinaryIsExtensible ( O )\n    const O = this;\n\n    // 1. Return O.[[Extensible]].\n    return O['[[Extensible]]'];\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-preventextensions\n  // 9.1.4 [[PreventExtensions]] ( )\n  public '[[PreventExtensions]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return ! OrdinaryPreventExtensions(O).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinarypreventextensions\n    // 9.1.4.1 OrdinaryPreventExtensions ( O )\n    const O = this;\n\n    // 1. Set O.[[Extensible]] to false.\n    O['[[Extensible]]'] = intrinsics.false;\n\n    // 2. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p\n  // 9.1.5 [[GetOwnProperty]] ( P )\n  public '[[GetOwnProperty]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $PropertyDescriptor | $Undefined | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Return ! OrdinaryGetOwnProperty(O, P).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinarygetownproperty\n    // 9.1.5.1 OrdinaryGetOwnProperty ( O , P )\n    const O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. If O does not have an own property with key P, return undefined.\n    if (!O.hasProperty(P)) {\n      return intrinsics.undefined;\n    }\n\n    // 3. Let D be a newly created Property Descriptor with no fields.\n    const D = new $PropertyDescriptor(realm, P);\n\n    // 4. Let X be O's own property whose key is P.\n    const X = O.getProperty(P);\n\n    // 5. If X is a data property, then\n    if (X.isDataDescriptor) {\n      // 5. a. Set D.[[Value]] to the value of X's [[Value]] attribute.\n      D['[[Value]]'] = X['[[Value]]'];\n\n      // 5. b. Set D.[[Writable]] to the value of X's [[Writable]] attribute.\n      D['[[Writable]]'] = X['[[Writable]]'];\n    }\n    // 6. Else X is an accessor property,\n    else {\n      // 6. a. Set D.[[Get]] to the value of X's [[Get]] attribute.\n      D['[[Get]]'] = X['[[Get]]'];\n\n      // 6. b. Set D.[[Set]] to the value of X's [[Set]] attribute.\n      D['[[Set]]'] = X['[[Set]]'];\n    }\n\n    // 7. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute.\n    D['[[Enumerable]]'] = X['[[Enumerable]]'];\n\n    // 8. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute.\n    D['[[Configurable]]'] = X['[[Configurable]]'];\n\n    // 9. Return D.\n    return D;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc\n  // 9.1.6 [[DefineOwnProperty]] ( P , Desc )\n  public '[[DefineOwnProperty]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Desc: $PropertyDescriptor,\n  ): $Boolean | $Error {\n    // 1. Return ? OrdinaryDefineOwnProperty(O, P, Desc).\n    const O = this;\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinarydefineownproperty\n    // 9.1.6.1 OrdinaryDefineOwnProperty ( O , P , Desc )\n\n    // 1. Let current be ? O.[[GetOwnProperty]](P).\n    const current = O['[[GetOwnProperty]]'](ctx, P);\n    if (current.isAbrupt) { return current; }\n\n    // 2. Let extensible be ? IsExtensible(O).\n    const extensible = O['[[IsExtensible]]'](ctx);\n    if (extensible.isAbrupt) { return extensible; }\n\n    // 3. Return ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current).\n    return $ValidateAndApplyPropertyDescriptor(ctx, O, P, extensible, Desc, current);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p\n  // 9.1.7 [[HasProperty]] ( P )\n  public '[[HasProperty]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Return ? OrdinaryHasProperty(O, P).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinaryhasproperty\n    // 9.1.7.1 OrdinaryHasProperty ( O , P )\n    const O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let hasOwn be ? O.[[GetOwnProperty]](P).\n    const hasOwn = O['[[GetOwnProperty]]'](ctx, P);\n    if (hasOwn.isAbrupt) { return hasOwn; }\n\n    // 3. If hasOwn is not undefined, return true.\n    if (!hasOwn.isUndefined) {\n      return intrinsics.true;\n    }\n\n    // 4. Let parent be ? O.[[GetPrototypeOf]]().\n    const parent = O['[[GetPrototypeOf]]'](ctx);\n    if (parent.isAbrupt) { return parent; }\n\n    // 5. If parent is not null, then\n    if (!parent.isNull) {\n      // 5. a. Return ? parent.[[HasProperty]](P).\n      return parent['[[HasProperty]]'](ctx, P);\n    }\n\n    // 6. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver\n  // 9.1.8 [[Get]] ( P , Receiver )\n  public '[[Get]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Receiver: $AnyNonEmptyNonError,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    // 1. Return ? OrdinaryGet(O, P, Receiver).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinaryget\n    // 9.1.8.1 OrdinaryGet ( O , P , Receiver )\n    const O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. Let desc be ? O.[[GetOwnProperty]](P).\n    const desc = O['[[GetOwnProperty]]'](ctx, P);\n    if (desc.isAbrupt) { return desc; }\n\n    // 3. If desc is undefined, then\n    if (desc.isUndefined) {\n      // 3. a. Let parent be ? O.[[GetPrototypeOf]]().\n      const parent = O['[[GetPrototypeOf]]'](ctx);\n      if (parent.isAbrupt) { return parent; }\n\n      // 3. b. If parent is null, return undefined.\n      if (parent.isNull) {\n        return intrinsics.undefined;\n      }\n\n      // 3. c. Return ? parent.[[Get]](P, Receiver).\n      return parent['[[Get]]'](ctx, P, Receiver);\n    }\n\n    // 4. If IsDataDescriptor(desc) is true, return desc.[[Value]].\n    if (desc.isDataDescriptor) {\n      return desc['[[Value]]'] as $AnyNonEmpty;\n    }\n\n    // 5. Assert: IsAccessorDescriptor(desc) is true.\n    // 6. Let getter be desc.[[Get]].\n    const getter = desc['[[Get]]'] as $Function | $Undefined;\n\n    // 7. If getter is undefined, return undefined.\n    if (getter.isUndefined) {\n      return getter;\n    }\n\n    // 8. Return ? Call(getter, Receiver).\n    return $Call(ctx, getter, Receiver, intrinsics.undefined);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver\n  // 9.1.9 [[Set]] ( P , V , Receiver )\n  public '[[Set]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    V: $AnyNonEmpty ,\n    Receiver: $AnyObject,\n  ): $Boolean | $Error {\n    // 1. Return ? OrdinarySet(O, P, V, Receiver).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinaryset\n    // 9.1.9.1 OrdinarySet ( O , P , V , Receiver )\n    const O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. Let ownDesc be ? O.[[GetOwnProperty]](P).\n    const ownDesc = O['[[GetOwnProperty]]'](ctx, P);\n    if (ownDesc.isAbrupt) { return ownDesc; }\n\n    // 3. Return OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).\n    return $OrdinarySetWithOwnDescriptor(ctx, O, P, V, Receiver, ownDesc);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-delete-p\n  // 9.1.10 [[Delete]] ( P )\n  public '[[Delete]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Return ? OrdinaryDelete(O, P).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinarydelete\n    // 9.1.10.1 OrdinaryDelete ( O , P )\n    const O = this;\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. Let desc be ? O.[[GetOwnProperty]](P).\n    const desc = O['[[GetOwnProperty]]'](ctx, P);\n    if (desc.isAbrupt) { return desc; }\n\n    // 3. If desc is undefined, return true.\n    if (desc.isUndefined) {\n      return intrinsics.true;\n    }\n\n    // 4. If desc.[[Configurable]] is true, then\n    if (desc['[[Configurable]]'].isTruthy) {\n      // 4. a. Remove the own property with name P from O.\n      O.deleteProperty(P);\n\n      // 4. b. Return true.\n      return intrinsics.true;\n    }\n\n    // 5. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys\n  // 9.1.11 [[OwnPropertyKeys]] ( )\n  public '[[OwnPropertyKeys]]'(\n    this: $AnyObject,\n    ctx: ExecutionContext,\n  ): $List<$PropertyKey> | $Error {\n    // 1. Return ! OrdinaryOwnPropertyKeys(O).\n\n    // http://www.ecma-international.org/ecma-262/#sec-ordinaryownpropertykeys\n    // 9.1.11.1 OrdinaryOwnPropertyKeys ( O )\n\n    // 1. Let keys be a new empty List.\n    const keys = new $List<$PropertyKey>();\n\n    let arrayIndexLen = 0;\n    let stringLen = 0;\n    let symbolLen = 0;\n    const arrayIndexProps: $String[] = [];\n    const stringProps: $String[] = [];\n    const symbolProps: $Symbol[] = [];\n\n    const ownPropertyKeys = this.propertyKeys;\n    let ownPropertyKey: $PropertyKey;\n    for (let i = 0, ii = ownPropertyKeys.length; i < ii; ++i) {\n      ownPropertyKey = ownPropertyKeys[i];\n      if (ownPropertyKey.isString) {\n        if (ownPropertyKey.IsArrayIndex) {\n          arrayIndexProps[arrayIndexLen++] = ownPropertyKey;\n        } else {\n          stringProps[stringLen++] = ownPropertyKey;\n        }\n      } else {\n        symbolProps[symbolLen++] = ownPropertyKey;\n      }\n    }\n\n    arrayIndexProps.sort(compareIndices);\n\n    let i = 0;\n    let keysLen = 0;\n\n    // 2. For each own property key P of O that is an array index, in ascending numeric index order, do\n    for (i = 0; i < arrayIndexLen; ++i) {\n      // 2. a. Add P as the last element of keys.\n      keys[keysLen++] = arrayIndexProps[i];\n    }\n\n    // 3. For each own property key P of O that is a String but is not an array index, in ascending chronological order of property creation, do\n    for (i = 0; i < stringLen; ++i) {\n      // 3. a. Add P as the last element of keys.\n      keys[keysLen++] = stringProps[i];\n    }\n\n    // 4. For each own property key P of O that is a Symbol, in ascending chronological order of property creation, do\n    for (i = 0; i < symbolLen; ++i) {\n      // 4. a. Add P as the last element of keys.\n      keys[keysLen++] = symbolProps[i];\n    }\n\n    // 5. Return keys.\n    return keys;\n  }\n\n  public dispose(this: Writable<Partial<$Object>>): void {\n    if (this.disposed) {\n      return;\n    }\n\n    this.disposed = true;\n\n    this.propertyDescriptors!.forEach(x => { x.dispose(); });\n    this.propertyDescriptors = void 0;\n    this.propertyKeys = void 0;\n    this.propertyMap = void 0;\n\n    this['[[Target]]'] = void 0;\n    this['[[Prototype]]'] = void 0;\n    this['[[Extensible]]'] = void 0;\n\n    this.realm = void 0;\n  }\n}\n","import {\n  nextValueId,\n  $AnyNonError,\n  Int32,\n  Uint32,\n  Int16,\n  Uint16,\n  Int8,\n  Uint8,\n  Uint8Clamp,\n  CompletionType,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Object,\n} from './object.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $BooleanLiteral,\n} from '../ast/literals.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-boolean-type\nexport class $Boolean<T extends boolean = boolean> {\n  public readonly '<$Boolean>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'boolean' = 'boolean' as const;\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public readonly '[[Value]]': T;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): 'Boolean' { return 'Boolean'; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): true { return true; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): T { return this['[[Value]]']; }\n  public get isFalsey(): T extends true ? false : true { return !this['[[Value]]'] as T extends true ? false : true; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public constructor(\n    public readonly realm: Realm,\n    value: T,\n    type: PotentialNonEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n    public readonly sourceNode: $BooleanLiteral | null = null,\n    public readonly conversionSource: $AnyNonError | null = null,\n  ) {\n    this['[[Value]]'] = value;\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $Boolean<T> {\n    return other instanceof $Boolean && this['[[Value]]'] === other['[[Value]]'];\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $Object {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    return $Object.ObjectCreate(\n      ctx,\n      'boolean',\n      intrinsics['%BooleanPrototype%'],\n      {\n        '[[BooleanData]]': this,\n      },\n    );\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String {\n    return this.ToString(ctx);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Number {\n    return this.ToNumber(ctx).ToLength(ctx);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Number(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8Clamp(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $String {\n    return new $String(\n      /* realm */this.realm,\n      /* value */String(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n}\n","import {\n  nextValueId,\n  $AnyNonError,\n  Int32,\n  Uint32,\n  Int16,\n  Uint16,\n  Int8,\n  Uint8,\n  Uint8Clamp,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $TypeError,\n  $Error,\n} from './error.js';\nimport {\n  $ExportDeclaration,\n  $ExportSpecifier,\n  $ESModule,\n} from '../ast/modules.js';\nimport {\n  $ClassDeclaration,\n} from '../ast/classes.js';\nimport {\n  $FunctionDeclaration,\n} from '../ast/functions.js';\nimport {\n  $VariableStatement,\n} from '../ast/statements.js';\nimport {\n  $NullLiteral,\n} from '../ast/literals.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-null-type\nexport class $Null {\n  public readonly '<$Null>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'null' = 'null' as const;\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public readonly '[[Value]]': null = null;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): 'Null' { return 'Null'; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): true { return true; }\n  public get isNil(): true { return true; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): false { return false; }\n  public get isFalsey(): true { return true; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  public get isAmbiguous(): false { return false; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public constructor(\n    public readonly realm: Realm,\n    type: PotentialNonEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n    public readonly sourceNode: $ExportDeclaration | $ExportSpecifier | $ClassDeclaration | $FunctionDeclaration | $VariableStatement | $ESModule | $NullLiteral | null = null,\n  ) {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $Null {\n    return other instanceof $Null;\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $Error {\n    return new $TypeError(ctx.Realm, `${this} cannot be converted to object`);\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String {\n    return this.ToString(ctx);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Number {\n    return this.ToNumber(ctx).ToLength(ctx);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    return new $Boolean(\n      /* realm */this.realm,\n      /* value */Boolean(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Number(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8Clamp(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $String {\n    return new $String(\n      /* realm */this.realm,\n      /* value */String(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n}\n","import {\n  $Undefined,\n} from './undefined.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  nextValueId,\n  $AnyNonError,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Object,\n} from './object.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $TypeError,\n  $Error,\n} from './error.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-symbol-type\nexport class $Symbol<T extends $Undefined | $String = $Undefined | $String> {\n  public readonly '<$Symbol>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'symbol' = 'symbol' as const;\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public readonly '[[Value]]': symbol;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): 'Symbol' { return 'Symbol'; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): true { return true; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): true { return true; }\n  public get isFalsey(): false { return false; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public get IsArrayIndex(): false { return false; }\n\n  public constructor(\n    public readonly realm: Realm,\n    public readonly Description: T,\n    value = Symbol(Description['[[Value]]']),\n    type: PotentialNonEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n  ) {\n    this['[[Value]]'] = value;\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $Symbol<T> {\n    return other instanceof $Symbol && this['[[Value]]'] === other['[[Value]]'];\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $Object {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    return $Object.ObjectCreate(\n      ctx,\n      'symbol',\n      intrinsics['%SymbolPrototype%'],\n      {\n        '[[SymbolData]]': this,\n      },\n    );\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String {\n    return this.ToString(ctx);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    return new $Boolean(\n      /* realm */this.realm,\n      /* value */Boolean(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Error {\n    return new $TypeError(ctx.Realm, `${this} cannot be converted to number`);\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Error {\n    // Short circuit\n    return this.ToNumber(ctx);\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $String {\n    return new $String(\n      /* realm */this.realm,\n      /* value */String(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n}\n","import {\n  nextValueId,\n  $AnyNonError,\n  Int32,\n  Uint32,\n  Int16,\n  Uint16,\n  Int8,\n  Uint8,\n  Uint8Clamp,\n  PotentialNonEmptyCompletionType,\n  CompletionTarget,\n  CompletionType,\n  $Any,\n} from './_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $TypeError,\n  $Error,\n} from './error.js';\nimport {\n  $ESModule,\n  $ExportSpecifier,\n  $ImportSpecifier,\n  $ImportClause,\n  $ImportDeclaration,\n} from '../ast/modules.js';\nimport {\n  $FunctionDeclaration,\n} from '../ast/functions.js';\nimport {\n  $ClassDeclaration,\n} from '../ast/classes.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-undefined-type\nexport class $Undefined {\n  public readonly '<$Undefined>': unknown;\n\n  public readonly id: number = nextValueId();\n  public readonly IntrinsicName: 'undefined' = 'undefined' as const;\n\n  public '[[Type]]': PotentialNonEmptyCompletionType;\n  public readonly '[[Value]]': undefined = void 0;\n  public '[[Target]]': CompletionTarget;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return (this['[[Type]]'] !== CompletionType.normal) as false; }\n\n  public get Type(): 'Undefined' { return 'Undefined'; }\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): true { return true; }\n  public get isNull(): false { return false; }\n  public get isNil(): true { return true; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): true { return true; }\n  public get isObject(): false { return false; }\n  public get isArray(): false { return false; }\n  public get isProxy(): false { return false; }\n  public get isFunction(): false { return false; }\n  public get isBoundFunction(): false { return false; }\n  public get isTruthy(): false { return false; }\n  public get isFalsey(): true { return true; }\n  public get isSpeculative(): false { return false; }\n  public get hasValue(): true { return true; }\n  public get isList(): false { return false; }\n\n  public readonly nodeStack: I$Node[] = [];\n  public ctx: ExecutionContext | null = null;\n  public stack: string = '';\n\n  public get IsArrayIndex(): false { return false; }\n\n  public constructor(\n    public readonly realm: Realm,\n    type: PotentialNonEmptyCompletionType = CompletionType.normal,\n    target: CompletionTarget = realm['[[Intrinsics]]'].empty,\n    public readonly sourceNode: $ESModule | $FunctionDeclaration | $ExportSpecifier | $ImportSpecifier | $ImportClause | $ImportDeclaration | $ClassDeclaration | null = null,\n  ) {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n  }\n\n  public is(other: $AnyNonError): other is $Undefined {\n    return other instanceof $Undefined;\n  }\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    if (this['[[Type]]'] === CompletionType.throw) {\n      this.nodeStack.push(node);\n      if (this.ctx === null) {\n        this.ctx = ctx;\n        this.stack = ctx.Realm.stack.toString();\n      }\n    }\n    return this;\n  }\n\n  public [Symbol.toPrimitive](): string {\n    return String(this['[[Value]]']);\n  }\n\n  public [Symbol.toStringTag](): string {\n    return Object.prototype.toString.call(this['[[Value]]']);\n  }\n\n  public ToCompletion(\n    type: PotentialNonEmptyCompletionType,\n    target: CompletionTarget,\n  ): this {\n    this['[[Type]]'] = type;\n    this['[[Target]]'] = target;\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-updateempty\n  // 6.2.3.4 UpdateEmpty ( completionRecord , value )\n  public UpdateEmpty(value: $Any): this {\n    // 1. Assert: If completionRecord.[[Type]] is either return or throw, then completionRecord.[[Value]] is not empty.\n    // 2. If completionRecord.[[Value]] is not empty, return Completion(completionRecord).\n    return this;\n    // 3. Return Completion { [[Type]]: completionRecord.[[Type]], [[Value]]: value, [[Target]]: completionRecord.[[Target]] }.\n  }\n\n  public ToObject(\n    ctx: ExecutionContext,\n  ): $Error {\n    return new $TypeError(ctx.Realm, `${this} cannot be converted to object`);\n  }\n\n  public ToPropertyKey(\n    ctx: ExecutionContext,\n  ): $String {\n    return this.ToString(ctx);\n  }\n\n  public ToLength(\n    ctx: ExecutionContext,\n  ): $Number {\n    return this.ToNumber(ctx).ToLength(ctx);\n  }\n\n  public ToPrimitive(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n\n  public ToBoolean(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    return new $Boolean(\n      /* realm */this.realm,\n      /* value */Boolean(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToNumber(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Number(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint32(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint32(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint16(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint16(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToInt8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Int8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToUint8Clamp(\n    ctx: ExecutionContext,\n  ): $Number {\n    return new $Number(\n      /* realm */this.realm,\n      /* value */Uint8Clamp(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public ToString(\n    ctx: ExecutionContext,\n  ): $String {\n    return new $String(\n      /* realm */this.realm,\n      /* value */String(this['[[Value]]']),\n      /* type */this['[[Type]]'],\n      /* target */this['[[Target]]'],\n      /* sourceNode */null,\n      /* conversionSource */this,\n    );\n  }\n\n  public GetValue(\n    ctx: ExecutionContext,\n  ): this {\n    return this;\n  }\n}\n","import {\n  ILogger,\n  IDisposable,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  $Any,\n} from './types/_shared.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from './realm.js';\nimport {\n  $Empty,\n} from './types/empty.js';\nimport {\n  $$ESModuleOrScript,\n} from './ast/modules.js';\n\n// http://www.ecma-international.org/ecma-262/#table-25\nexport abstract class Job<MOS extends $$ESModuleOrScript = $$ESModuleOrScript> implements IDisposable {\n  public '[[Realm]]': Realm;\n  public '[[ScriptOrModule]]': MOS;\n\n  public constructor(\n    public readonly logger: ILogger,\n    realm: Realm,\n    scriptOrModule: MOS,\n  ) {\n    this.logger = logger.scopeTo(`Job`);\n\n    this['[[Realm]]'] = realm;\n    this['[[ScriptOrModule]]'] = scriptOrModule;\n  }\n\n  public abstract Run(ctx: ExecutionContext): $Any;\n\n  public dispose(this: Writable<Partial<Job>>): void {\n    this['[[Realm]]'] = void 0;\n    this['[[ScriptOrModule]]'] = void 0;\n    this.logger = void 0;\n  }\n}\n\nexport class JobQueue<T extends Job = Job> implements IDisposable {\n  public readonly queue: T[] = [];\n\n  public get isEmpty(): boolean {\n    return this.queue.length === 0;\n  }\n\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly name: string,\n  ) {\n    this.logger = logger.root.scopeTo(`JobQueue['${name}']`);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-enqueuejob\n  // 8.4.1 EnqueueJob ( queueName , job , arguments )\n  public EnqueueJob(\n    ctx: ExecutionContext,\n    job: T,\n  ): $Empty {\n    const realm = ctx.Realm;\n\n    this.logger.debug(`EnqueueJob(#${ctx.id}) currentQueueLength=${this.queue.length}`);\n\n    // 1. Assert: Type(queueName) is String and its value is the name of a Job Queue recognized by this implementation.\n    // 2. Assert: job is the name of a Job.\n    // 3. Assert: arguments is a List that has the same number of elements as the number of parameters required by job.\n    // 4. Let callerContext be the running execution context.\n    // 5. Let callerRealm be callerContext's Realm.\n    // 6. Let callerScriptOrModule be callerContext's ScriptOrModule.\n    // 7. Let pending be PendingJob { [[Job]]: job, [[Arguments]]: arguments, [[Realm]]: callerRealm, [[ScriptOrModule]]: callerScriptOrModule, [[HostDefined]]: undefined }.\n    // 8. Perform any implementation or host environment defined processing of pending. This may include modifying the [[HostDefined]] field or any other field of pending.\n    // 9. Add pending at the back of the Job Queue named by queueName.\n    this.queue.push(job);\n\n    // 10. Return NormalCompletion(empty).\n    return new $Empty(realm);\n  }\n\n  public dispose(this: Writable<Partial<JobQueue>>): void {\n    this.queue!.forEach(x => { x.dispose(); });\n    this.queue = void 0;\n    this.logger = void 0;\n  }\n}\n","import {\n  IModule,\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $DefinePropertyOrThrow,\n  $Set,\n  $HasOwnProperty,\n} from '../operations.js';\nimport {\n  $PropertyDescriptor,\n} from './property-descriptor.js';\nimport {\n  $AnyNonError,\n  $AnyNonEmpty,\n  $AnyObject,\n} from './_shared.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Null,\n} from './null.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $Empty,\n} from './empty.js';\nimport {\n  $Undefined,\n} from './undefined.js';\nimport {\n  $Function,\n} from './function.js';\nimport {\n  ILogger,\n  IDisposable,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  $Error,\n  $TypeError,\n  $ReferenceError,\n} from './error.js';\n\nexport type $EnvRec = (\n  $DeclarativeEnvRec |\n  $ObjectEnvRec |\n  $FunctionEnvRec |\n  $GlobalEnvRec |\n  $ModuleEnvRec\n);\n\nlet bindingId = 0;\n\nexport class $Binding implements IDisposable {\n  public readonly '<$Binding>': unknown;\n\n  public readonly id: number = ++bindingId;\n\n  public get isIndirect(): boolean {\n    return this.M !== null;\n  }\n\n  public constructor(\n    public isMutable: boolean,\n    public isStrict: boolean,\n    public isInitialized: boolean,\n    public canBeDeleted: boolean,\n    public value: $AnyNonError,\n    public name: string,\n    public origin: $EnvRec,\n    public M: IModule | null = null,\n    public N2: $String | null = null,\n  ) {}\n\n  public dispose(this: Writable<Partial<$Binding>>): void {\n    this.value = void 0;\n    this.origin = void 0;\n    this.M = void 0;\n    this.N2 = void 0;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records\nexport class $DeclarativeEnvRec implements IDisposable {\n  public readonly '<$DeclarativeEnvRec>': unknown;\n\n  public readonly bindings: Map<string, $Binding> = new Map();\n\n  // Everything is false because an environment record should not appear like any kind of normal ES value.\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isFunction(): false { return false; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-newdeclarativeenvironment\n  // 8.1.2.2 NewDeclarativeEnvironment ( E )\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly realm: Realm,\n    public readonly outer: $EnvRec | $Null,\n  ) {\n    this.logger = logger.scopeTo('DeclarativeEnvRec');\n    // 1. Let env be a new Lexical Environment.\n    // 2. Let envRec be a new declarative Environment Record containing no bindings.\n    // 3. Set env's EnvironmentRecord to envRec.\n    // 4. Set the outer lexical environment reference of env to E.\n    // 5. Return env.\n  }\n\n  // Overrides\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasbinding-n\n  // 8.1.1.1.1 HasBinding ( N )\n  public HasBinding(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. If envRec has a binding for the name that is the value of N, return true.\n    if (envRec.bindings.has(N['[[Value]]'])) {\n      return intrinsics.true;\n    }\n\n    // 3. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createmutablebinding-n-d\n  // 8.1.1.1.2 CreateMutableBinding ( N , D )\n  public CreateMutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    D: $Boolean,\n  ): $Empty {\n    this.logger.debug(`CreateMutableBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    // 3. Create a mutable binding in envRec for N and record that it is uninitialized. If D is true, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n    const binding = new $Binding(\n      /* isMutable */true,\n      /* isStrict */false,\n      /* isInitialized */false,\n      /* canBeDeleted */D['[[Value]]'],\n      /* value */intrinsics.empty,\n      /* name */N['[[Value]]'],\n      /* origin */this,\n    );\n    envRec.bindings.set(N['[[Value]]'], binding);\n\n    // 4. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createimmutablebinding-n-s\n  // 8.1.1.1.3 CreateImmutableBinding ( N , S )\n  public CreateImmutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $Empty {\n    this.logger.debug(`CreateImmutableBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    // 3. Create an immutable binding in envRec for N and record that it is uninitialized. If S is true, record that the newly created binding is a strict binding.\n    const binding = new $Binding(\n      /* isMutable */false,\n      /* isStrict */S['[[Value]]'],\n      /* isInitialized */false,\n      /* canBeDeleted */false,\n      /* value */intrinsics.empty,\n      /* name */N['[[Value]]'],\n      /* origin */this,\n    );\n    envRec.bindings.set(N['[[Value]]'], binding);\n\n    // 4. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-initializebinding-n-v\n  // 8.1.1.1.4 InitializeBinding ( N , V )\n  public InitializeBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n  ): $Empty {\n    this.logger.debug(`InitializeBinding(#${ctx.id}, ${N['[[Value]]']}, ${JSON.stringify(V['[[Value]]'])})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    const binding = envRec.bindings.get(N['[[Value]]'])!;\n\n    // 3. Set the bound value for N in envRec to V.\n    binding.value = V;\n\n    // 4. Record that the binding for N in envRec has been initialized.\n    binding.isInitialized = true;\n\n    // 5. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-setmutablebinding-n-v-s\n  // 8.1.1.1.5 SetMutableBinding ( N , V , S )\n  public SetMutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n    S: $Boolean,\n  ): $Empty | $Error {\n    this.logger.debug(`SetMutableBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. If envRec does not have a binding for N, then\n    const bindings = this.bindings;\n    const binding = bindings.get(N['[[Value]]']);\n    if (binding === void 0) {\n      // 2. a. If S is true, throw a ReferenceError exception.\n      if (S.isTruthy) {\n        return new $ReferenceError(ctx.Realm, `Cannot assign to non-existing binding ${N['[[Value]]']} in strict mode code.`);\n      }\n\n      // 2. b. Perform envRec.CreateMutableBinding(N, true).\n      envRec.CreateMutableBinding(ctx, N, intrinsics.true);\n\n      // 2. c. Perform envRec.InitializeBinding(N, V).\n      envRec.InitializeBinding(ctx, N, V);\n\n      // 2. d. Return NormalCompletion(empty).\n      return intrinsics.empty;\n    }\n\n    // 3. If the binding for N in envRec is a strict binding, set S to true.\n    if (binding.isStrict) {\n      S = intrinsics.true;\n    }\n\n    // 4. If the binding for N in envRec has not yet been initialized, throw a ReferenceError exception.\n    if (!binding.isInitialized) {\n      return new $ReferenceError(ctx.Realm, `Binding ${N['[[Value]]']} is not yet initialized.`);\n    }\n    // 5. Else if the binding for N in envRec is a mutable binding, change its bound value to V.\n    else if (binding.isMutable) {\n      binding.value = V;\n    }\n    // 6. Else,\n    else {\n      // 6. a. Assert: This is an attempt to change the value of an immutable binding.\n      // 6. b. If S is true, throw a TypeError exception.\n      if (S.isTruthy) {\n        return new $TypeError(ctx.Realm, `Cannot change the value of immutable binding ${N}`);\n      }\n    }\n\n    // 7. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-getbindingvalue-n-s\n  // 8.1.1.1.6 GetBindingValue ( N , S )\n  public GetBindingValue(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $AnyNonEmpty  {\n    this.logger.debug(`GetBindingValue(${N['[[Value]]']})`);\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec has a binding for N.\n    const binding = envRec.bindings.get(N['[[Value]]'])!;\n\n    // 3. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.isInitialized) {\n      return new $ReferenceError(ctx.Realm, `No binding exists for: ${N['[[Value]]']}.`);\n    }\n\n    // 4. Return the value currently bound to N in envRec.\n    return binding.value as $AnyNonEmpty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-deletebinding-n\n  // 8.1.1.1.7 DeleteBinding ( N )\n  public DeleteBinding(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean {\n    this.logger.debug(`DeleteBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the declarative Environment Record for which the method was invoked.\n    const envRec = this;\n    const bindings = envRec.bindings;\n\n    // 2. Assert: envRec has a binding for the name that is the value of N.\n    const binding = bindings.get(N['[[Value]]'])!;\n\n    // 3. If the binding for N in envRec cannot be deleted, return false.\n    if (!binding.canBeDeleted) {\n      return intrinsics.false;\n    }\n\n    // 4. Remove the binding for N from envRec.\n    bindings.delete(N['[[Value]]']);\n\n    // 5. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasthisbinding\n  // 8.1.1.1.8 HasThisBinding ( )\n  public HasThisBinding(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hassuperbinding\n  // 8.1.1.1.9 HasSuperBinding ( )\n  public HasSuperBinding(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-withbaseobject\n  // 8.1.1.1.10 WithBaseObject ( )\n  public WithBaseObject(\n    ctx: ExecutionContext,\n  ): $Undefined {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return undefined.\n    return intrinsics.undefined;\n  }\n\n  public dispose(this: Writable<Partial<$DeclarativeEnvRec>>): void {\n    for (const binding of this.bindings!.values()) {\n      binding.dispose();\n    }\n    this.bindings!.clear();\n    this.bindings = void 0;\n    this.logger = void 0;\n    this.realm = void 0;\n    this.outer = void 0;\n  }\n}\n\nexport class $ObjectEnvRec implements IDisposable {\n  public readonly '<$ObjectEnvRec>': unknown;\n\n  public withEnvironment: boolean = false;\n\n  // Everything is false because an environment record should not appear like any kind of normal ES value.\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isFunction(): false { return false; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-newobjectenvironment\n  // 8.1.2.3 NewObjectEnvironment ( O , E )\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly realm: Realm,\n    public readonly outer: $EnvRec | $Null,\n    public readonly bindingObject: $AnyObject,\n  ) {\n    this.logger = logger.scopeTo('ObjectEnvRec');\n    // 1. Let env be a new Lexical Environment.\n    // 2. Let envRec be a new object Environment Record containing O as the binding object.\n    // 3. Set env's EnvironmentRecord to envRec.\n    // 4. Set the outer lexical environment reference of env to E.\n    // 5. Return env.\n  }\n\n  // Overrides\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-hasbinding-n\n  // 8.1.1.2.1 HasBinding ( N )\n  public HasBinding(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    const bindings = envRec.bindingObject;\n\n    // 3. Let foundBinding be ? HasProperty(bindings, N).\n    const foundBinding = bindings['[[HasProperty]]'](ctx, N);\n    if (foundBinding.isAbrupt) { return foundBinding; }\n\n    // 4. If foundBinding is false, return false.\n    if (foundBinding.isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 5. If the withEnvironment flag of envRec is false, return true.\n    if (!envRec.withEnvironment) {\n      return intrinsics.true;\n    }\n\n    // 6. Let unscopables be ? Get(bindings, @@unscopables).\n    const unscopables = bindings['[[Get]]'](ctx, intrinsics['@@unscopables'], bindings);\n    if (unscopables.isAbrupt) { return unscopables; }\n\n    // 7. If Type(unscopables) is Object, then\n    if (unscopables.isObject) {\n      // 7. a. Let blocked be ToBoolean(? Get(unscopables, N)).\n      const _blocked = unscopables['[[Get]]'](ctx, N, unscopables);\n      if (_blocked.isAbrupt) { return _blocked; }\n      const blocked = _blocked.ToBoolean(ctx);\n      if (blocked.isAbrupt) { return blocked; }\n\n      // 7. b. If blocked is true, return false.\n      if (blocked.isTruthy) {\n        return intrinsics.false;\n      }\n    }\n\n    // 8. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-createmutablebinding-n-d\n  // 8.1.1.2.2 CreateMutableBinding ( N , D )\n  public CreateMutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    D: $Boolean,\n  ): $Boolean | $Error {\n    this.logger.debug(`CreateMutableBinding(${N['[[Value]]']})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    const bindings = envRec.bindingObject;\n\n    // 3. Return ? DefinePropertyOrThrow(bindings, N, PropertyDescriptor { [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }).\n    const Desc = new $PropertyDescriptor(realm, N);\n    Desc['[[Value]]'] = intrinsics.undefined;\n    Desc['[[Writable]]'] = intrinsics.true;\n    Desc['[[Enumerable]]'] = intrinsics.true;\n    Desc['[[Configurable]]'] = D;\n    return $DefinePropertyOrThrow(ctx, bindings, N, Desc);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-createimmutablebinding-n-s\n  // 8.1.1.2.3 CreateImmutableBinding ( N , S )\n  public CreateImmutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $Boolean | $Error {\n    // The concrete Environment Record method CreateImmutableBinding is never used within this specification in association with object Environment Records.\n    throw new Error('Should not be called');\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-initializebinding-n-v\n  // 8.1.1.2.4 InitializeBinding ( N , V )\n  public InitializeBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n  ): $Boolean | $Error {\n    this.logger.debug(`InitializeBinding(#${ctx.id}, ${N['[[Value]]']}, ${JSON.stringify(V['[[Value]]'])})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec must have an uninitialized binding for N.\n    // 3. Record that the binding for N in envRec has been initialized.\n    // TODO: record\n\n    // 4. Return ? envRec.SetMutableBinding(N, V, false).\n    return envRec.SetMutableBinding(ctx, N, V, intrinsics.false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-setmutablebinding-n-v-s\n  // 8.1.1.2.5 SetMutableBinding ( N , V , S )\n  public SetMutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n    S: $Boolean,\n  ): $Boolean | $Error {\n    this.logger.debug(`SetMutableBinding(${N['[[Value]]']})`);\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    const bindings = envRec.bindingObject;\n\n    // 3. Return ? Set(bindings, N, V, S).\n    return $Set(ctx, bindings, N, V, S);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-getbindingvalue-n-s\n  // 8.1.1.2.6 GetBindingValue ( N , S )\n  public GetBindingValue(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $AnyNonEmpty  {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    const bindings = envRec.bindingObject;\n\n    // 3. Let value be ? HasProperty(bindings, N).\n    const value = bindings['[[HasProperty]]'](ctx, N);\n    if (value.isAbrupt) { return value; }\n\n    // 4. If value is false, then\n    if (value.isFalsey) {\n      // 4. a. If S is false, return the value undefined; otherwise throw a ReferenceError exception.\n      if (S.isFalsey) {\n        return intrinsics.undefined;\n      }\n\n      return new $ReferenceError(ctx.Realm, `Cannot read from non-existing binding ${N['[[Value]]']} in strict mode code.`);\n    }\n\n    // 5. Return ? Get(bindings, N).\n    return bindings['[[Get]]'](ctx, N, bindings);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-deletebinding-n\n  // 8.1.1.2.7 DeleteBinding ( N )\n  public DeleteBinding(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    this.logger.debug(`DeleteBinding(${N['[[Value]]']})`);\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let bindings be the binding object for envRec.\n    const bindings = envRec.bindingObject;\n\n    // 3. Return ? bindings.[[Delete]](N).\n    return bindings['[[Delete]]'](ctx, N);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-hasthisbinding\n  // 8.1.1.2.8 HasThisBinding ( )\n  public HasThisBinding(\n    ctx: ExecutionContext,\n  ): $Boolean<false> {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-hassuperbinding\n  // 8.1.1.2.9 HasSuperBinding ( )\n  public HasSuperBinding(\n    ctx: ExecutionContext,\n  ): $Boolean<false> {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-environment-records-withbaseobject\n  // 8.1.1.2.10 WithBaseObject ( )\n  public WithBaseObject(\n    ctx: ExecutionContext,\n  ): $AnyObject | $Undefined {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the object Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. If the withEnvironment flag of envRec is true, return the binding object for envRec.\n    if (envRec.withEnvironment) {\n      return envRec.bindingObject;\n    }\n\n    // 3. Otherwise, return undefined.\n    return intrinsics.undefined;\n  }\n\n  public dispose(this: Writable<Partial<$ObjectEnvRec>>): void {\n    this.bindingObject!.dispose();\n    this.bindingObject = void 0;\n    this.logger = void 0;\n    this.realm = void 0;\n    this.outer = void 0;\n  }\n}\n\nexport type BindingStatus = 'lexical' | 'initialized' | 'uninitialized';\n\nexport class $FunctionEnvRec extends $DeclarativeEnvRec implements IDisposable {\n  public readonly '<$FunctionEnvRec>': unknown;\n\n  public '[[ThisValue]]': $AnyNonEmpty;\n  public '[[ThisBindingStatus]]': BindingStatus;\n  public '[[FunctionObject]]': $Function;\n  public '[[HomeObject]]': $AnyObject | $Undefined;\n  public '[[NewTarget]]': $AnyObject | $Undefined;\n\n  // Everything is false because an environment record should not appear like any kind of normal ES value.\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isFunction(): false { return false; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-newfunctionenvironment\n  // 8.1.2.4 NewFunctionEnvironment ( F , newTarget )\n  public constructor(\n    public readonly logger: ILogger,\n    realm: Realm,\n    F: $Function,\n    newTarget: $AnyObject | $Undefined,\n  ) {\n    super(logger, realm, F['[[Environment]]']);\n    this.logger = logger.scopeTo('FunctionEnvRec');\n\n    // 1. Assert: F is an ECMAScript function.\n    // 2. Assert: Type(newTarget) is Undefined or Object.\n    // 3. Let env be a new Lexical Environment.\n    // 4. Let envRec be a new function Environment Record containing no bindings.\n    const envRec = this;\n\n    // 5. Set envRec.[[FunctionObject]] to F.\n    envRec['[[FunctionObject]]'] = F;\n\n    // 6. If F.[[ThisMode]] is lexical, set envRec.[[ThisBindingStatus]] to \"lexical\".\n    if (F['[[ThisMode]]'] === 'lexical') {\n      envRec['[[ThisBindingStatus]]'] = 'lexical';\n    }\n    // 7. Else, set envRec.[[ThisBindingStatus]] to \"uninitialized\".\n    else {\n      envRec['[[ThisBindingStatus]]'] = 'uninitialized';\n    }\n\n    // 8. Let home be F.[[HomeObject]].\n    const home = F['[[HomeObject]]'];\n\n    // 9. Set envRec.[[HomeObject]] to home.\n    envRec['[[HomeObject]]'] = home;\n\n    // 10. Set envRec.[[NewTarget]] to newTarget.\n    envRec['[[NewTarget]]'] = newTarget;\n\n    // 11. Set env's EnvironmentRecord to envRec.\n    // 12. Set the outer lexical environment reference of env to F.[[Environment]].\n    // See super(realm, F['[[Environment]]']);\n\n    // 13. Return env.\n  }\n\n  // Overrides\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasthisbinding\n  // 8.1.1.1.8 HasThisBinding ( )\n  public HasThisBinding(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false; otherwise, return true.\n    if (envRec['[[ThisBindingStatus]]'] === 'lexical') {\n      return intrinsics.false;\n    }\n\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hassuperbinding\n  // 8.1.1.1.9 HasSuperBinding ( )\n  public HasSuperBinding(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. If envRec.[[ThisBindingStatus]] is \"lexical\", return false.\n    if (envRec['[[ThisBindingStatus]]'] === 'lexical') {\n      return intrinsics.false;\n    }\n\n    // 3. If envRec.[[HomeObject]] has the value undefined, return false; otherwise, return true.\n    if (envRec['[[HomeObject]]'].isUndefined) {\n      return intrinsics.false;\n    }\n\n    return intrinsics.true;\n  }\n\n  // Additions\n  // http://www.ecma-international.org/ecma-262/#sec-bindthisvalue\n  // 8.1.1.3.1 BindThisValue ( V )\n  public BindThisValue<T extends $AnyNonEmpty>(\n    ctx: ExecutionContext,\n    V: T,\n  ): T | $Error {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    // 3. If envRec.[[ThisBindingStatus]] is \"initialized\", throw a ReferenceError exception.\n    if (envRec['[[ThisBindingStatus]]'] === 'initialized') {\n      return new $ReferenceError(ctx.Realm, `The 'this' binding is already initialized.`);\n    }\n\n    // 4. Set envRec.[[ThisValue]] to V.\n    envRec['[[ThisValue]]'] = V;\n\n    // 5. Set envRec.[[ThisBindingStatus]] to \"initialized\".\n    envRec['[[ThisBindingStatus]]'] = 'initialized';\n\n    // 6. Return V.\n    return V;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-environment-records-getthisbinding\n  // 8.1.1.3.4 GetThisBinding ( )\n  public GetThisBinding(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec.[[ThisBindingStatus]] is not \"lexical\".\n    // 3. If envRec.[[ThisBindingStatus]] is \"uninitialized\", throw a ReferenceError exception.\n    if (envRec['[[ThisBindingStatus]]'] === 'uninitialized') {\n      return new $ReferenceError(ctx.Realm, `The 'this' binding is not yet initialized.`);\n    }\n\n    // 4. Return envRec.[[ThisValue]].\n    return envRec['[[ThisValue]]'];\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getsuperbase\n  // 8.1.1.3.5 GetSuperBase ( )\n  public GetSuperBase(\n    ctx: ExecutionContext,\n  ): $AnyObject | $Null | $Undefined | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the function Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let home be envRec.[[HomeObject]].\n    const home = envRec['[[HomeObject]]'];\n\n    // 3. If home has the value undefined, return undefined.\n    if (home.isUndefined) {\n      return intrinsics.undefined;\n    }\n\n    // 4. Assert: Type(home) is Object.\n    // 5. Return ? home.[[GetPrototypeOf]]().\n    return home['[[GetPrototypeOf]]'](ctx);\n  }\n\n  public dispose(this: Writable<Partial<$FunctionEnvRec>>): void {\n    super.dispose();\n    this['[[ThisValue]]'] = void 0;\n    this['[[FunctionObject]]'] = void 0;\n    this['[[HomeObject]]'] = void 0;\n    this['[[NewTarget]]'] = void 0;\n  }\n}\n\nexport class $GlobalEnvRec implements IDisposable {\n  public readonly '<$GlobalEnvRec>': unknown;\n\n  public '[[ObjectRecord]]': $ObjectEnvRec;\n  public '[[GlobalThisValue]]': $AnyObject;\n  public '[[DeclarativeRecord]]': $DeclarativeEnvRec;\n  public '[[VarNames]]': string[];\n\n  public readonly outer: $Null;\n\n  // Everything is false because an environment record should not appear like any kind of normal ES value.\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isFunction(): false { return false; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-newglobalenvironment\n  // 8.1.2.5 NewGlobalEnvironment ( G , thisValue )\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly realm: Realm,\n    G: $AnyObject,\n    thisValue: $AnyObject,\n  ) {\n    this.logger = logger.scopeTo('GlobalEnvRec');\n    this.outer = realm['[[Intrinsics]]'].null;\n\n    // 1. Let env be a new Lexical Environment.\n    // 2. Let objRec be a new object Environment Record containing G as the binding object.\n    const objRec = new $ObjectEnvRec(logger, realm, realm['[[Intrinsics]]'].null, G);\n\n    // 3. Let dclRec be a new declarative Environment Record containing no bindings.\n    const dclRec = new $DeclarativeEnvRec(logger, realm, realm['[[Intrinsics]]'].null);\n\n    // 4. Let globalRec be a new global Environment Record.\n    const globalRec = this;\n\n    // 5. Set globalRec.[[ObjectRecord]] to objRec.\n    globalRec['[[ObjectRecord]]'] = objRec;\n\n    // 6. Set globalRec.[[GlobalThisValue]] to thisValue.\n    globalRec['[[GlobalThisValue]]'] = thisValue;\n\n    // 7. Set globalRec.[[DeclarativeRecord]] to dclRec.\n    globalRec['[[DeclarativeRecord]]'] = dclRec;\n\n    // 8. Set globalRec.[[VarNames]] to a new empty List.\n    globalRec['[[VarNames]]'] = [];\n\n    // 9. Set env's EnvironmentRecord to globalRec.\n    // 10. Set the outer lexical environment reference of env to null.\n    // 11. Return env.\n  }\n\n  // Overrides\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-hasbinding-n\n  // 8.1.1.4.1 HasBinding ( N )\n  public HasBinding(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, return true.\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      return intrinsics.true;\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 5. Return ? ObjRec.HasBinding(N).\n    return objRec.HasBinding(ctx, N);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-createmutablebinding-n-d\n  // 8.1.1.4.2 CreateMutableBinding ( N , D )\n  public CreateMutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    D: $Boolean,\n  ): $Empty | $Error {\n    this.logger.debug(`CreateMutableBinding(${N['[[Value]]']})`);\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      return new $TypeError(ctx.Realm, `A global binding for ${N} already exists`);\n    }\n\n    // 4. Return DclRec.CreateMutableBinding(N, D).\n    return dclRec.CreateMutableBinding(ctx, N, D);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-createimmutablebinding-n-s\n  // 8.1.1.4.3 CreateImmutableBinding ( N , S )\n  public CreateImmutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $Empty | $Error {\n    this.logger.debug(`CreateImmutableBinding(${N['[[Value]]']})`);\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, throw a TypeError exception.\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      return new $TypeError(ctx.Realm, `A global binding for ${N} already exists`);\n    }\n\n    // 4. Return DclRec.CreateImmutableBinding(N, S).\n    return dclRec.CreateImmutableBinding(ctx, N, S);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-initializebinding-n-v\n  // 8.1.1.4.4 InitializeBinding ( N , V )\n  public InitializeBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n  ): $Boolean | $Empty | $Error {\n    this.logger.debug(`InitializeBinding(#${ctx.id}, ${N['[[Value]]']}, ${JSON.stringify(V['[[Value]]'])})`);\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      // 3. a. Return DclRec.InitializeBinding(N, V).\n      return dclRec.InitializeBinding(ctx, N, V);\n    }\n\n    // 4. Assert: If the binding exists, it must be in the object Environment Record.\n    // 5. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 6. Return ? ObjRec.InitializeBinding(N, V).\n    return objRec.InitializeBinding(ctx, N, V);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-setmutablebinding-n-v-s\n  // 8.1.1.4.5 SetMutableBinding ( N , V , S )\n  public SetMutableBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n    S: $Boolean,\n  ): $Boolean | $Empty | $Error {\n    this.logger.debug(`SetMutableBinding(${N['[[Value]]']})`);\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      // 3. a. Return DclRec.SetMutableBinding(N, V, S).\n      return dclRec.SetMutableBinding(ctx, N, V, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 5. Return ? ObjRec.SetMutableBinding(N, V, S).\n    return objRec.SetMutableBinding(ctx, N, V, S);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-getbindingvalue-n-s\n  // 8.1.1.4.6 GetBindingValue ( N , S )\n  public GetBindingValue(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $AnyNonEmpty  {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      // 3. a. Return DclRec.GetBindingValue(N, S).\n      return dclRec.GetBindingValue(ctx, N, S);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 5. Return ? ObjRec.GetBindingValue(N, S).\n    return objRec.GetBindingValue(ctx, N, S);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-deletebinding-n\n  // 8.1.1.4.7 DeleteBinding ( N )\n  public DeleteBinding(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    this.logger.debug(`DeleteBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. If DclRec.HasBinding(N) is true, then\n    if (dclRec.HasBinding(ctx, N).isTruthy) {\n      // 3. a. Return DclRec.DeleteBinding(N).\n      return dclRec.DeleteBinding(ctx, N);\n    }\n\n    // 4. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 5. Let globalObject be the binding object for ObjRec.\n    const globalObject = objRec.bindingObject;\n\n    // 6. Let existingProp be ? HasOwnProperty(globalObject, N).\n    const existingProp = $HasOwnProperty(ctx, globalObject, N);\n    if (existingProp.isAbrupt) { return existingProp; }\n\n    // 7. If existingProp is true, then\n    if (existingProp.isTruthy) {\n      // 7. a. Let status be ? ObjRec.DeleteBinding(N).\n      const status = objRec.DeleteBinding(ctx, N);\n      if (status.isAbrupt) { return status; }\n\n      // 7. b. If status is true, then\n      if (status.isTruthy) {\n        // 7. b. i. Let varNames be envRec.[[VarNames]].\n        const varNames = envRec['[[VarNames]]'];\n\n        // 7. b. ii. If N is an element of varNames, remove that element from the varNames.\n        const idx = varNames.indexOf(N['[[Value]]']);\n        if (idx >= 0) {\n          varNames.splice(idx, 1);\n        }\n      }\n\n      // 7. c. Return status.\n      return status;\n    }\n\n    // 8. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-hasthisbinding\n  // 8.1.1.4.8 HasThisBinding ( )\n  public HasThisBinding(\n    ctx: ExecutionContext,\n  ): $Boolean<true> {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-hassuperbinding\n  // 8.1.1.4.9 HasSuperBinding ( )\n  public HasSuperBinding(\n    ctx: ExecutionContext,\n  ): $Boolean<false> {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-withbaseobject\n  // 8.1.1.4.10 WithBaseObject ( )\n  public WithBaseObject(\n    ctx: ExecutionContext,\n  ): $Undefined {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return undefined.\n    return intrinsics.undefined;\n  }\n\n  // Additions\n  // http://www.ecma-international.org/ecma-262/#sec-global-environment-records-getthisbinding\n  // 8.1.1.4.11 GetThisBinding ( )\n  public GetThisBinding(\n    ctx: ExecutionContext,\n  ): $AnyObject {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Return envRec.[[GlobalThisValue]].\n    return envRec['[[GlobalThisValue]]'];\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-hasvardeclaration\n  // 8.1.1.4.12 HasVarDeclaration ( N )\n  public HasVarDeclaration(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let varDeclaredNames be envRec.[[VarNames]].\n    const varDeclaredNames = envRec['[[VarNames]]'];\n\n    // 3. If varDeclaredNames contains N, return true.\n    if (varDeclaredNames.includes(N['[[Value]]'])) {\n      return intrinsics.true;\n    }\n\n    // 4. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-haslexicaldeclaration\n  // 8.1.1.4.13 HasLexicalDeclaration ( N )\n  public HasLexicalDeclaration(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean {\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let DclRec be envRec.[[DeclarativeRecord]].\n    const dclRec = envRec['[[DeclarativeRecord]]'];\n\n    // 3. Return DclRec.HasBinding(N).\n    return dclRec.HasBinding(ctx, N);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-hasrestrictedglobalproperty\n  // 8.1.1.4.14 HasRestrictedGlobalProperty ( N )\n  public HasRestrictedGlobalProperty(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    const globalObject = objRec.bindingObject;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    const existingProp = globalObject['[[GetOwnProperty]]'](ctx, N);\n    if (existingProp.isAbrupt) { return existingProp; }\n\n    // 5. If existingProp is undefined, return false.\n    if (existingProp.isUndefined) {\n      return intrinsics.false;\n    }\n\n    // 6. If existingProp.[[Configurable]] is true, return false.\n    if (existingProp['[[Configurable]]'].isTruthy) {\n      return intrinsics.false;\n    }\n\n    // 7. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-candeclareglobalvar\n  // 8.1.1.4.15 CanDeclareGlobalVar ( N )\n  public CanDeclareGlobalVar(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    const globalObject = objRec.bindingObject;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    const hasProperty = $HasOwnProperty(ctx, globalObject, N);\n    if (hasProperty.isAbrupt) { return hasProperty; }\n\n    // 5. If hasProperty is true, return true.\n    if (hasProperty.isTruthy) {\n      return intrinsics.true;\n    }\n\n    // 6. Return ? IsExtensible(globalObject).\n    return globalObject['[[IsExtensible]]'](ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-candeclareglobalfunction\n  // 8.1.1.4.16 CanDeclareGlobalFunction ( N )\n  public CanDeclareGlobalFunction(\n    ctx: ExecutionContext,\n    N: $String,\n  ): $Boolean | $Error {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    const globalObject = objRec.bindingObject;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    const existingProp = globalObject['[[GetOwnProperty]]'](ctx, N);\n    if (existingProp.isAbrupt) { return existingProp; }\n\n    // 5. If existingProp is undefined, return ? IsExtensible(globalObject).\n    if (existingProp.isUndefined) {\n      return globalObject['[[IsExtensible]]'](ctx);\n    }\n\n    // 6. If existingProp.[[Configurable]] is true, return true.\n    if (existingProp['[[Configurable]]'].isTruthy) {\n      return intrinsics.true;\n    }\n\n    // 7. If IsDataDescriptor(existingProp) is true and existingProp has attribute values { [[Writable]]: true, [[Enumerable]]: true }, return true.\n    if (existingProp.isDataDescriptor && existingProp['[[Writable]]'].isTruthy && existingProp['[[Enumerable]]'].isTruthy) {\n      return intrinsics.true;\n    }\n\n    // 8. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-createglobalvarbinding\n  // 8.1.1.4.17 CreateGlobalVarBinding ( N , D )\n  public CreateGlobalVarBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    D: $Boolean,\n  ): $Empty | $Error {\n    this.logger.debug(`CreateGlobalVarBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    const globalObject = objRec.bindingObject;\n\n    // 4. Let hasProperty be ? HasOwnProperty(globalObject, N).\n    const hasProperty = $HasOwnProperty(ctx, globalObject, N);\n    if (hasProperty.isAbrupt) { return hasProperty; }\n\n    // 5. Let extensible be ? IsExtensible(globalObject).\n    const extensible = globalObject['[[IsExtensible]]'](ctx);\n    if (extensible.isAbrupt) { return extensible; }\n\n    // 6. If hasProperty is false and extensible is true, then\n    if (hasProperty.isFalsey && extensible.isTruthy) {\n      // 6. a. Perform ? ObjRec.CreateMutableBinding(N, D).\n      const $CreateMutableBinding = objRec.CreateMutableBinding(ctx, N, D);\n      if ($CreateMutableBinding.isAbrupt) { return $CreateMutableBinding; }\n\n      // 6. b. Perform ? ObjRec.InitializeBinding(N, undefined).\n      const $InitializeBinding = objRec.InitializeBinding(ctx, N, intrinsics.undefined);\n      if ($InitializeBinding.isAbrupt) { return $InitializeBinding; }\n    }\n\n    // 7. Let varDeclaredNames be envRec.[[VarNames]].\n    const varDeclaredNames = envRec['[[VarNames]]'];\n\n    // 8. If varDeclaredNames does not contain N, then\n    if (!varDeclaredNames.includes(N['[[Value]]'])) {\n      // 8. a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N['[[Value]]']);\n    }\n\n    // 9. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-createglobalfunctionbinding\n  // 8.1.1.4.18 CreateGlobalFunctionBinding ( N , V , D )\n  public CreateGlobalFunctionBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    V: $AnyNonEmpty,\n    D: $Boolean,\n  ): $Empty | $Error {\n    this.logger.debug(`CreateGlobalFunctionBinding(${N['[[Value]]']})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the global Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Let ObjRec be envRec.[[ObjectRecord]].\n    const objRec = envRec['[[ObjectRecord]]'];\n\n    // 3. Let globalObject be the binding object for ObjRec.\n    const globalObject = objRec.bindingObject;\n\n    // 4. Let existingProp be ? globalObject.[[GetOwnProperty]](N).\n    const existingProp = globalObject['[[GetOwnProperty]]'](ctx, N);\n    if (existingProp.isAbrupt) { return existingProp; }\n\n    let desc: $PropertyDescriptor;\n    // 5. If existingProp is undefined or existingProp.[[Configurable]] is true, then\n    if (existingProp.isUndefined || existingProp['[[Configurable]]'].isTruthy) {\n      // 5. a. Let desc be the PropertyDescriptor { [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: D }.\n      desc = new $PropertyDescriptor(realm, N);\n      desc['[[Enumerable]]'] = intrinsics.true;\n      desc['[[Configurable]]'] = D;\n\n      desc['[[Value]]'] = V;\n      desc['[[Writable]]'] = intrinsics.true;\n    }\n    // 6. Else,\n    else {\n      // 6. a. Let desc be the PropertyDescriptor { [[Value]]: V }.\n      desc = new $PropertyDescriptor(realm, N);\n\n      desc['[[Value]]'] = V;\n    }\n\n    // 7. Perform ? DefinePropertyOrThrow(globalObject, N, desc).\n    const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(ctx, globalObject, N, desc);\n    if ($DefinePropertyOrThrowResult.isAbrupt) { return $DefinePropertyOrThrowResult; }\n\n    // 8. Record that the binding for N in ObjRec has been initialized.\n    // TODO: record\n\n    // 9. Perform ? Set(globalObject, N, V, false).\n    const $SetResult = $Set(ctx, globalObject, N, V, intrinsics.false);\n    if ($SetResult.isAbrupt) { return $SetResult; }\n\n    // 10. Let varDeclaredNames be envRec.[[VarNames]].\n    const varDeclaredNames = envRec['[[VarNames]]'];\n\n    // 11. If varDeclaredNames does not contain N, then\n    if (!varDeclaredNames.includes(N['[[Value]]'])) {\n      // 11. a. Append N to varDeclaredNames.\n      varDeclaredNames.push(N['[[Value]]']);\n    }\n\n    // 12. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  public dispose(this: Writable<Partial<$GlobalEnvRec>>): void {\n    this['[[ObjectRecord]]'] = void 0;\n    this['[[GlobalThisValue]]'] = void 0;\n    this['[[DeclarativeRecord]]'] = void 0;\n    this['[[VarNames]]'] = void 0;\n    this.logger = void 0;\n    this.outer = void 0;\n    this.realm = void 0;\n  }\n}\n\nexport class $ModuleEnvRec extends $DeclarativeEnvRec implements IDisposable {\n  public readonly '<$ModuleEnvRec>': unknown;\n\n  // Everything is false because an environment record should not appear like any kind of normal ES value.\n  public get isEmpty(): false { return false; }\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isNil(): false { return false; }\n  public get isBoolean(): false { return false; }\n  public get isNumber(): false { return false; }\n  public get isString(): false { return false; }\n  public get isSymbol(): false { return false; }\n  public get isPrimitive(): false { return false; }\n  public get isObject(): false { return false; }\n  public get isFunction(): false { return false; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-newmoduleenvironment\n  // 8.1.2.6 NewModuleEnvironment ( E )\n  public constructor(\n    public readonly logger: ILogger,\n    realm: Realm,\n    outer: $EnvRec,\n  ) {\n    super(logger, realm, outer);\n    this.logger = logger.scopeTo('ModuleEnvRec');\n    // 1. Let env be a new Lexical Environment.\n    // 2. Let envRec be a new module Environment Record containing no bindings.\n    // 3. Set env's EnvironmentRecord to envRec.\n    // 4. Set the outer lexical environment reference of env to E.\n    // 5. Return env.\n  }\n\n  // Overrides\n  // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-getbindingvalue-n-s\n  // 8.1.1.5.1 GetBindingValue ( N , S )\n  public GetBindingValue(\n    ctx: ExecutionContext,\n    N: $String,\n    S: $Boolean,\n  ): $AnyNonEmpty  {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Assert: S is true.\n    // 2. Let envRec be the module Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 3. Assert: envRec has a binding for N.\n    const binding = envRec.bindings.get(N['[[Value]]'])!;\n\n    // 4. If the binding for N is an indirect binding, then\n    if (binding.isIndirect) {\n      // 4. a. Let M and N2 be the indirection values provided when this binding for N was created.\n      const M = binding.M!;\n      const N2 = binding.N2!;\n\n      // 4. b. Let targetEnv be M.[[Environment]].\n      const targetER = M['[[Environment]]'];\n\n      // 4. c. If targetEnv is undefined, throw a ReferenceError exception.\n      if (targetER.isUndefined) {\n        return new $ReferenceError(ctx.Realm, `Cannot resolve export: ${N['[[Value]]']}`);\n      }\n\n      // 4. d. Let targetER be targetEnv's EnvironmentRecord.\n      // 4. e. Return ? targetER.GetBindingValue(N2, true).\n      return targetER.GetBindingValue(ctx, N2, intrinsics.true);\n    }\n\n    // 5. If the binding for N in envRec is an uninitialized binding, throw a ReferenceError exception.\n    if (!binding.isInitialized) {\n      return new $ReferenceError(ctx.Realm, `Binding for ${N['[[Value]]']} is not yet initialized`);\n    }\n\n    // 6. Return the value currently bound to N in envRec.\n    return binding.value as $AnyNonEmpty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-deletebinding-n\n  // 8.1.1.5.2 DeleteBinding ( N )\n  public DeleteBinding(\n    ctx: ExecutionContext,\n    N: never,\n  ): never {\n    // 1. Assert: This method is never invoked. See 12.5.3.1.\n    throw new Error('1. Assert: This method is never invoked. See 12.5.3.1.');\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-hasthisbinding\n  // 8.1.1.5.3 HasThisBinding ( )\n  public HasThisBinding(\n    ctx: ExecutionContext,\n  ): $Boolean<true> {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return true.\n    return intrinsics.true;\n  }\n\n  // Additions\n  // http://www.ecma-international.org/ecma-262/#sec-module-environment-records-getthisbinding\n  // 8.1.1.5.4 GetThisBinding ( )\n  public GetThisBinding(\n    ctx: ExecutionContext,\n  ): $Undefined {\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Return undefined.\n    return intrinsics.undefined;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-createimportbinding\n  // 8.1.1.5.5 CreateImportBinding ( N , M , N2 )\n  public CreateImportBinding(\n    ctx: ExecutionContext,\n    N: $String,\n    M: IModule,\n    N2: $String,\n  ): $Empty {\n    this.logger.debug(`CreateImportBinding(${N['[[Value]]']})`);\n\n    const intrinsics = this.realm['[[Intrinsics]]'];\n\n    // 1. Let envRec be the module Environment Record for which the method was invoked.\n    const envRec = this;\n\n    // 2. Assert: envRec does not already have a binding for N.\n    // 3. Assert: M is a Module Record.\n    // 4. Assert: When M.[[Environment]] is instantiated it will have a direct binding for N2.\n\n    // 5. Create an immutable indirect binding in envRec for N that references M and N2 as its target binding and record that the binding is initialized.\n    const binding = new $Binding(\n      /* isMutable */false,\n      /* isStrict */true,\n      /* isInitialized */true,\n      /* canBeDeleted */false,\n      /* value */intrinsics.empty,\n      /* name */N['[[Value]]'],\n      /* origin */this,\n      /* M */M,\n      /* N2 */N2,\n    );\n    envRec.bindings.set(N['[[Value]]'], binding);\n\n    // 6. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n}\n","import {\n  $Object,\n} from './object.js';\nimport {\n  $EnvRec,\n  $FunctionEnvRec,\n} from './environment-record.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n  $AnyObject,\n} from './_shared.js';\nimport {\n  $PropertyDescriptor,\n} from './property-descriptor.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $DefinePropertyOrThrow,\n} from '../operations.js';\nimport {\n  $Symbol,\n} from './symbol.js';\nimport {\n  Intrinsics,\n  IntrinsicObjectKey,\n} from '../intrinsics.js';\nimport {\n  $Undefined,\n} from './undefined.js';\nimport {\n  ExecutionContext,\n  Realm,\n} from '../realm.js';\nimport {\n  $Null,\n} from './null.js';\nimport {\n  $TypeError,\n  $Error,\n} from './error.js';\nimport {\n  $$Function,\n} from '../ast/functions.js';\nimport {\n  $$ESModuleOrScript,\n} from '../ast/modules.js';\nimport {\n  getLineAndCharacterOfPosition\n} from 'typescript';\nimport {\n  FunctionKind,\n} from '../ast/_shared.js';\nimport {\n  $List,\n} from './list.js';\n\n// http://www.ecma-international.org/ecma-262/#table-6\n// http://www.ecma-international.org/ecma-262/#sec-ecmascript-function-objects\nexport class $Function<\n  T extends string = string,\n> extends $Object<T> {\n  public readonly '<$Function>': unknown;\n\n  public get isFunction(): true { return true; }\n\n  public ['[[Environment]]']: $EnvRec;\n  public ['[[FunctionKind]]']: FunctionKind;\n  public ['[[ECMAScriptCode]]']: $$Function;\n  public ['[[ConstructorKind]]']: ConstructorKind;\n  public ['[[Realm]]']: Realm;\n  public ['[[ScriptOrModule]]']: $$ESModuleOrScript | $Null;\n  public ['[[ThisMode]]']: ThisMode;\n  public ['[[Strict]]']: $Boolean;\n  public ['[[HomeObject]]']: $AnyObject;\n  public ['[[SourceText]]']: $String;\n\n  public constructor(\n    realm: Realm,\n    IntrinsicName: T,\n    proto: $AnyObject,\n  ) {\n    super(realm, IntrinsicName, proto, CompletionType.normal, realm['[[Intrinsics]]'].empty);\n  }\n\n  // For error stack trace\n  public toString(): string {\n    const code = this['[[ECMAScriptCode]]'];\n    const sourceFile = code.mos.node;\n    const node = code.node;\n    const path = code.path;\n\n    const text = this['[[SourceText]]']['[[Value]]'];\n    const firstLine = text.split(/\\r?\\n/)[0];\n    let line = -1;\n    let character = -1;\n    if (node.pos > -1) {\n      ({ line, character } = getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile)));\n    }\n\n    return `${firstLine}:${line + 1}:${character} (${path})`;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n  // 9.2.1 [[Call]] ( thisArgument , argumentsList )\n  public '[[Call]]'(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $AnyNonEmpty  {\n    // 1. Assert: F is an ECMAScript function object.\n    const F = this;\n    const realm = F['[[Realm]]'];\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 2. If F.[[FunctionKind]] is \"classConstructor\", throw a TypeError exception.\n    if (F['[[FunctionKind]]'] === FunctionKind.classConstructor) {\n      return new $TypeError(realm, `Cannot call classConstructor (${F.propertyMap.has('name') ? F.propertyDescriptors[F.propertyMap.get('name')!]['[[Value]]'] : 'anonymous'}) as a function`);\n    }\n\n    // 3. Let callerContext be the running execution context.\n    // 4. Let calleeContext be PrepareForOrdinaryCall(F, undefined).\n    const calleeContext = $PrepareForOrdinaryCall(ctx, F, intrinsics.undefined);\n\n    // 5. Assert: calleeContext is now the running execution context.\n    // 6. Perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    $OrdinaryCallBindThis(ctx, F, calleeContext, thisArgument);\n\n    // 7. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    const result = F['[[ECMAScriptCode]]'].EvaluateBody(calleeContext, F, argumentsList);\n\n    // 8. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.stack.pop();\n    ctx.resume();\n\n    // 9. If result.[[Type]] is return, return NormalCompletion(result.[[Value]]).\n    if (result['[[Type]]'] === CompletionType.return) {\n      return result.ToCompletion(CompletionType.normal, intrinsics.empty);\n    }\n\n    // 10. ReturnIfAbrupt(result).\n    if (result.isAbrupt) {\n      return result;\n    }\n\n    // 11. Return NormalCompletion(undefined).\n    return new $Undefined(realm, CompletionType.normal, intrinsics.empty);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ecmascript-function-objects-construct-argumentslist-newtarget\n  // 9.2.2 [[Construct]] ( argumentsList , newTarget )\n  public '[[Construct]]'(\n    ctx: ExecutionContext,\n    argumentsList: $List<$AnyNonEmpty>,\n    newTarget: $Function,\n  ): $AnyObject | $Error {\n    // 1. Assert: F is an ECMAScript function object.\n    const F = this;\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const stack = realm.stack;\n\n    // 2. Assert: Type(newTarget) is Object.\n    // 3. Let callerContext be the running execution context.\n    // 4. Let kind be F.[[ConstructorKind]].\n    const kind = F['[[ConstructorKind]]'];\n\n    let thisArgument: $AnyNonEmptyNonError;\n    // 5. If kind is \"base\", then\n    if (kind === 'base') {\n      // 5. a. Let thisArgument be ? OrdinaryCreateFromConstructor(newTarget, \"%ObjectPrototype%\").\n      const $thisArgument = $OrdinaryCreateFromConstructor(ctx, newTarget, '%ObjectPrototype%');\n      if ($thisArgument.isAbrupt) { return $thisArgument; }\n      thisArgument = $thisArgument;\n    } else {\n      thisArgument = intrinsics.undefined;\n    }\n\n    // 6. Let calleeContext be PrepareForOrdinaryCall(F, newTarget).\n    const calleeContext = $PrepareForOrdinaryCall(ctx, F, newTarget);\n\n    // 7. Assert: calleeContext is now the running execution context.\n    // 8. If kind is \"base\", perform OrdinaryCallBindThis(F, calleeContext, thisArgument).\n    if (kind === 'base') {\n      $OrdinaryCallBindThis(ctx, F, calleeContext, thisArgument);\n    }\n\n    // 9. Let constructorEnv be the LexicalEnvironment of calleeContext.\n    // 10. Let envRec be constructorEnv's EnvironmentRecord.\n    const envRec = calleeContext.LexicalEnvironment;\n\n    // 11. Let result be OrdinaryCallEvaluateBody(F, argumentsList).\n    const result = F['[[ECMAScriptCode]]'].EvaluateBody(calleeContext, F, argumentsList);\n\n    // 12. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    stack.pop();\n    ctx.resume();\n\n    // 13. If result.[[Type]] is return, then\n    if (result['[[Type]]'] === CompletionType.return) {\n      // 13. a. If Type(result.[[Value]]) is Object, return NormalCompletion(result.[[Value]]).\n      if (result.isObject) {\n        return result.ToCompletion(CompletionType.normal, intrinsics.empty);\n      }\n\n      // 13. b. If kind is \"base\", return NormalCompletion(thisArgument).\n      if (kind === 'base') {\n        return (thisArgument as $Object).ToCompletion(CompletionType.normal, intrinsics.empty);\n      }\n\n      // 13. c. If result.[[Value]] is not undefined, throw a TypeError exception.\n      if (!result.isUndefined) {\n        return new $TypeError(realm, `base constructor for ${F.propertyMap.has('name') ? F.propertyDescriptors[F.propertyMap.get('name')!]['[[Value]]'] : 'anonymous'} returned ${result}, but expected undefined`);\n      }\n    }\n    // 14. Else, ReturnIfAbrupt(result).\n    else {\n      if (result.isAbrupt) {\n        return result;\n      }\n    }\n\n    // 15. Return ? envRec.GetThisBinding().\n    return (envRec as $FunctionEnvRec).GetThisBinding(ctx) as $Object;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-functionallocate\n  // 9.2.3 FunctionAllocate ( functionPrototype , strict , functionKind )\n  public static FunctionAllocate(\n    ctx: ExecutionContext,\n    functionPrototype: $AnyObject,\n    strict: $Boolean,\n    functionKind: FunctionKind.normal | FunctionKind.nonConstructor | FunctionKind.generator | FunctionKind.async | FunctionKind.asyncGenerator,\n  ): $Function {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: Type(functionPrototype) is Object.\n    // 2. Assert: functionKind is either \"normal\", \"non-constructor\", \"generator\", \"async\", or \"async generator\".\n    // 3. If functionKind is \"normal\", let needsConstruct be true.\n    // 4. Else, let needsConstruct be false.\n    const needsConstruct = functionKind === FunctionKind.normal;\n\n    // 5. If functionKind is \"non-constructor\", set functionKind to \"normal\".\n    if (functionKind === FunctionKind.nonConstructor) {\n      functionKind = FunctionKind.normal;\n    }\n\n    // 6. Let F be a newly created ECMAScript function object with the internal slots listed in Table 27. All of those internal slots are initialized to undefined.\n    const F = new $Function(realm, 'function', functionPrototype);\n\n    // 7. Set F's essential internal methods to the default ordinary object definitions specified in 9.1.\n    // 8. Set F.[[Call]] to the definition specified in 9.2.1.\n    // 9. If needsConstruct is true, then\n    if (needsConstruct) {\n      // 9. a. Set F.[[Construct]] to the definition specified in 9.2.2.\n      // 9. b. Set F.[[ConstructorKind]] to \"base\".\n      F['[[ConstructorKind]]'] = 'base';\n    }\n\n    // 10. Set F.[[Strict]] to strict.\n    F['[[Strict]]'] = strict;\n\n    // 11. Set F.[[FunctionKind]] to functionKind.\n    F['[[FunctionKind]]'] = functionKind;\n\n    // 12. Set F.[[Prototype]] to functionPrototype.\n    F['[[Prototype]]'] = functionPrototype;\n\n    // 13. Set F.[[Extensible]] to true.\n    F['[[Extensible]]'] = intrinsics.true;\n\n    // 14. Set F.[[Realm]] to the current Realm Record.\n    F['[[Realm]]'] = realm;\n\n    // 15. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-functioninitialize\n  // 9.2.4 FunctionInitialize ( F , kind , ParameterList , Body , Scope )\n  public static FunctionInitialize(\n    ctx: ExecutionContext,\n    F: $Function,\n    kind: 'normal' | 'method' | 'arrow',\n    code: $$Function,\n    Scope: $EnvRec,\n  ): $Function {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let len be the ExpectedArgumentCount of ParameterList.\n    const len = code.$parameters.ExpectedArgumentCount;\n\n    // 2. Perform ! SetFunctionLength(F, len).\n    const Desc = new $PropertyDescriptor(realm, intrinsics.length);\n    Desc['[[Value]]'] = new $Number(realm, len);\n    Desc['[[Writable]]'] = intrinsics.false;\n    Desc['[[Enumerable]]'] = intrinsics.false;\n    Desc['[[Configurable]]'] = intrinsics.true;\n    $DefinePropertyOrThrow(ctx, F, intrinsics.length, Desc);\n\n    // 3. Let Strict be F.[[Strict]].\n    const Strict = F['[[Strict]]'];\n\n    // 4. Set F.[[Environment]] to Scope.\n    F['[[Environment]]'] = Scope;\n\n    // 5. Set F.[[FormalParameters]] to ParameterList.\n    // 6. Set F.[[ECMAScriptCode]] to Body.\n    F['[[ECMAScriptCode]]'] = code;\n\n    // 7. Set F.[[ScriptOrModule]] to GetActiveScriptOrModule().\n    F['[[ScriptOrModule]]'] = realm.GetActiveScriptOrModule();\n\n    // 8. If kind is Arrow, set F.[[ThisMode]] to lexical.\n    if (kind === 'arrow') {\n      F['[[ThisMode]]'] = 'lexical';\n    }\n    // 9. Else if Strict is true, set F.[[ThisMode]] to strict.\n    else if (Strict.isTruthy) {\n      F['[[ThisMode]]'] = 'strict';\n    }\n    // 10. Else, set F.[[ThisMode]] to global.\n    else {\n      F['[[ThisMode]]'] = 'global';\n    }\n\n    // 11. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-functioncreate\n  // 9.2.5 FunctionCreate ( kind , ParameterList , Body , Scope , Strict [ , prototype ] )\n  public static FunctionCreate(\n    ctx: ExecutionContext,\n    kind: 'normal' | 'method' | 'arrow',\n    code: $$Function,\n    Scope: $EnvRec,\n    Strict: $Boolean,\n    prototype?: $AnyObject,\n  ): $Function {\n    code.logger.debug(`$Function.FunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If prototype is not present, then\n    if (prototype === void 0) {\n      // 1. a. Set prototype to the intrinsic object %FunctionPrototype%.\n      prototype = intrinsics['%FunctionPrototype%'];\n    }\n\n    let allocKind: FunctionKind.normal | FunctionKind.nonConstructor;\n    // 2. If kind is not Normal, let allocKind be \"non-constructor\".\n    if (kind !== 'normal') {\n      allocKind = FunctionKind.nonConstructor;\n    }\n    // 3. Else, let allocKind be \"normal\".\n    else {\n      allocKind = FunctionKind.normal;\n    }\n\n    // 4. Let F be FunctionAllocate(prototype, Strict, allocKind).\n    const F = this.FunctionAllocate(ctx, prototype!, Strict, allocKind);\n\n    // 5. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(ctx, F, kind, code, Scope);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunctioncreate\n  // 9.2.6 GeneratorFunctionCreate ( kind , ParameterList , Body , Scope , Strict )\n  public static GeneratorFunctionCreate(\n    ctx: ExecutionContext,\n    kind: 'normal' | 'method' | 'arrow',\n    code: $$Function,\n    Scope: $EnvRec,\n    Strict: $Boolean,\n  ): $Function {\n    code.logger.debug(`$Function.GeneratorFunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let functionPrototype be the intrinsic object %Generator%.\n    const functionPrototype = intrinsics['%Generator%'];\n\n    // 2. Let F be FunctionAllocate(functionPrototype, Strict, \"generator\").\n    const F = this.FunctionAllocate(ctx, functionPrototype, Strict, FunctionKind.generator);\n\n    // 3. Return FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(ctx, F, kind, code, Scope);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunctioncreate\n  // 9.2.7 AsyncGeneratorFunctionCreate ( kind , ParameterList , Body , Scope , Strict )\n  public static AsyncGeneratorFunctionCreate(\n    ctx: ExecutionContext,\n    kind: 'normal' | 'method' | 'arrow',\n    code: $$Function,\n    Scope: $EnvRec,\n    Strict: $Boolean,\n  ): $Function {\n    code.logger.debug(`$Function.AsyncGeneratorFunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let functionPrototype be the intrinsic object %AsyncGenerator%.\n    const functionPrototype = intrinsics['%AsyncGenerator%'];\n\n    // 2. Let F be ! FunctionAllocate(functionPrototype, Strict, \"generator\").\n    const F = this.FunctionAllocate(ctx, functionPrototype, Strict, FunctionKind.generator);\n\n    // 3. Return ! FunctionInitialize(F, kind, ParameterList, Body, Scope).\n    return this.FunctionInitialize(ctx, F, kind, code, Scope);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-functions-abstract-operations-async-function-create\n  // 9.2.8 AsyncFunctionCreate ( kind , parameters , body , Scope , Strict )\n  public static AsyncFunctionCreate(\n    ctx: ExecutionContext,\n    kind: 'normal' | 'method' | 'arrow',\n    code: $$Function,\n    Scope: $EnvRec,\n    Strict: $Boolean,\n  ): $Function {\n    code.logger.debug(`$Function.AsyncFunctionCreate(#${ctx.id}, ${JSON.stringify(kind)})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let functionPrototype be the intrinsic object %AsyncFunctionPrototype%.\n    const functionPrototype = intrinsics['%AsyncFunctionPrototype%'];\n\n    // 2. Let F be ! FunctionAllocate(functionPrototype, Strict, \"async\").\n    const F = this.FunctionAllocate(ctx, functionPrototype, Strict, FunctionKind.async);\n\n    // 3. Return ! FunctionInitialize(F, kind, parameters, body, Scope).\n    return this.FunctionInitialize(ctx, F, kind, code, Scope);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-makeconstructor\n  // 9.2.10 MakeConstructor ( F [ , writablePrototype [ , prototype ] ] )\n  public MakeConstructor(\n    ctx: ExecutionContext,\n    writablePrototype?: $Boolean,\n    prototype?: $AnyObject,\n  ): $Undefined {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const F = this;\n\n    // 1. Assert: F is an ECMAScript function object.\n    // 2. Assert: IsConstructor(F) is true.\n    // 3. Assert: F is an extensible object that does not have a prototype own property.\n    // 4. If writablePrototype is not present, set writablePrototype to true.\n    if (writablePrototype === void 0) {\n      writablePrototype = intrinsics.true;\n    }\n\n    // 5. If prototype is not present, then\n    if (prototype === void 0) {\n      // 5. a. Set prototype to ObjectCreate(%ObjectPrototype%).\n      prototype = $Object.ObjectCreate(ctx, 'constructor', intrinsics['%ObjectPrototype%']);\n\n      // 5. b. Perform ! DefinePropertyOrThrow(prototype, \"constructor\", PropertyDescriptor { [[Value]]: F, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: true }).\n      const Desc = new $PropertyDescriptor(realm, intrinsics.$constructor);\n      Desc['[[Value]]'] = F;\n      Desc['[[Writable]]'] = writablePrototype;\n      Desc['[[Enumerable]]'] = intrinsics.false;\n      Desc['[[Configurable]]'] = intrinsics.true;\n\n      $DefinePropertyOrThrow(ctx, prototype, intrinsics.$constructor, Desc);\n    }\n\n    // 6. Perform ! DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: writablePrototype, [[Enumerable]]: false, [[Configurable]]: false }).\n    const Desc = new $PropertyDescriptor(realm, intrinsics.$prototype);\n    Desc['[[Value]]'] = prototype;\n    Desc['[[Writable]]'] = writablePrototype;\n    Desc['[[Enumerable]]'] = intrinsics.false;\n    Desc['[[Configurable]]'] = intrinsics.false;\n\n    $DefinePropertyOrThrow(ctx, F, intrinsics.$prototype, Desc);\n\n    // 7. Return NormalCompletion(undefined).\n    return intrinsics.undefined;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-setfunctionname\n  // 9.2.13 SetFunctionName ( F , name [ , prefix ] )\n  public SetFunctionName(\n    ctx: ExecutionContext,\n    name: $String | $Symbol,\n    prefix?: $String,\n  ): $Boolean {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: F is an extensible object that does not have a name own property.\n    // 2. Assert: Type(name) is either Symbol or String.\n    // 3. Assert: If prefix is present, then Type(prefix) is String.\n    // 4. If Type(name) is Symbol, then\n    if (name.isSymbol) {\n      // 4. a. Let description be name's [[Description]] value.\n      const description = name.Description;\n\n      // 4. b. If description is undefined, set name to the empty String.\n      if (description.isUndefined) {\n        name = intrinsics[''];\n      }\n      // 4. c. Else, set name to the string-concatenation of \"[\", description, and \"]\".\n      else {\n        name = new $String(realm, `[${description['[[Value]]']}]`);\n      }\n    }\n\n    // 5. If prefix is present, then\n    if (prefix !== void 0) {\n      // 5. a. Set name to the string-concatenation of prefix, the code unit 0x0020 (SPACE), and name.\n      name = new $String(realm, `${prefix['[[Value]]']} ${name['[[Value]]']}`);\n    }\n\n    // 6. Return ! DefinePropertyOrThrow(F, \"name\", PropertyDescriptor { [[Value]]: name, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }).\n    const Desc = new $PropertyDescriptor(realm, intrinsics.$name);\n    Desc['[[Value]]'] = name;\n    Desc['[[Writable]]'] = intrinsics.false;\n    Desc['[[Enumerable]]'] = intrinsics.false;\n    Desc['[[Configurable]]'] = intrinsics.true;\n\n    return $DefinePropertyOrThrow(ctx, this, intrinsics.$name, Desc) as $Boolean;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-ordinarycreatefromconstructor\nexport function $OrdinaryCreateFromConstructor<T extends IntrinsicObjectKey = IntrinsicObjectKey, TSlots extends {} = {}>(\n  ctx: ExecutionContext,\n  constructor: $Function,\n  intrinsicDefaultProto: T,\n  internalSlotsList?: TSlots,\n): ($Object<T> & TSlots) | $Error {\n  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n  // 2. Let proto be ? GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).\n  const proto = $GetPrototypeFromConstructor(ctx, constructor, intrinsicDefaultProto);\n  if (proto.isAbrupt) { return proto as ($Object<T> & TSlots) | $Error; }\n\n  // 3. Return ObjectCreate(proto, internalSlotsList).\n  return $Object.ObjectCreate(ctx, intrinsicDefaultProto, proto, internalSlotsList);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getprototypefromconstructor\nexport function $GetPrototypeFromConstructor<T extends IntrinsicObjectKey = IntrinsicObjectKey>(\n  ctx: ExecutionContext,\n  constructor: $Function,\n  intrinsicDefaultProto: T,\n): Intrinsics[T] | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: intrinsicDefaultProto is a String value that is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n  // 2. Assert: IsCallable(constructor) is true.\n  // 3. Let proto be ? Get(constructor, \"prototype\").\n  let proto = constructor['[[Get]]'](ctx, intrinsics.$prototype, constructor);\n  if (proto.isAbrupt) { return proto; }\n\n  // 4. If Type(proto) is not Object, then\n  if (!proto.isObject) {\n    // 4. a. Let realm be ? GetFunctionRealm(constructor).\n    // 4. b. Set proto to realm's intrinsic object named intrinsicDefaultProto.\n    proto = intrinsics[intrinsicDefaultProto] as $AnyNonEmpty;\n  }\n\n  // 5. Return proto.\n  return proto as Intrinsics[T];\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-prepareforordinarycall\nfunction $PrepareForOrdinaryCall(\n  ctx: ExecutionContext,\n  F: $Function,\n  newTarget: $AnyObject | $Undefined,\n): ExecutionContext<$FunctionEnvRec, $FunctionEnvRec> {\n  // 1. Assert: Type(newTarget) is Undefined or Object.\n  // 2. Let callerContext be the running execution context.\n  const callerContext = ctx;\n\n  // 3. Let calleeContext be a new ECMAScript code execution context.\n  const calleeRealm = F['[[Realm]]'];\n  const calleeContext = new ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>(calleeRealm);\n\n  // 4. Set the Function of calleeContext to F.\n  calleeContext.Function = F;\n\n  // 5. Let calleeRealm be F.[[Realm]].\n\n  // 6. Set the Realm of calleeContext to calleeRealm.\n\n  // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].\n  calleeContext.ScriptOrModule = F['[[ScriptOrModule]]'];\n\n  // 8. Let localEnv be NewFunctionEnvironment(F, newTarget).\n  const localEnv = new $FunctionEnvRec(F['[[ECMAScriptCode]]'].logger, calleeRealm, F, newTarget);\n\n  // 9. Set the LexicalEnvironment of calleeContext to localEnv.\n  calleeContext.LexicalEnvironment = localEnv;\n\n  // 10. Set the VariableEnvironment of calleeContext to localEnv.\n  calleeContext.VariableEnvironment = localEnv;\n\n  // 11. If callerContext is not already suspended, suspend callerContext.\n  if (!callerContext.suspended) {\n    callerContext.suspend();\n  }\n\n  // 12. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.\n  calleeRealm.stack.push(calleeContext);\n\n  // 13. NOTE: Any exception objects produced after this point are associated with calleeRealm.\n  // 14. Return calleeContext.\n  return calleeContext;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-ordinarycallbindthis\nfunction $OrdinaryCallBindThis(\n  ctx: ExecutionContext,\n  F: $Function,\n  calleeContext: ExecutionContext,\n  thisArgument: $AnyNonEmptyNonError,\n): $AnyNonEmpty  {\n  // 1. Let thisMode be F.[[ThisMode]].\n  const thisMode = F['[[ThisMode]]'];\n\n  // 2. If thisMode is lexical, return NormalCompletion(undefined).\n  if (thisMode === 'lexical') {\n    return new $Undefined(ctx.Realm);\n  }\n\n  // 3. Let calleeRealm be F.[[Realm]].'];\n  const calleeRealm = F['[[Realm]]'];\n\n  // 4. Let localEnv be the LexicalEnvironment of calleeContext.\n  const localEnv = calleeContext.LexicalEnvironment;\n\n  let thisValue: $AnyNonEmpty;\n  // 5. If thisMode is strict, let thisValue be thisArgument.\n  if (thisMode === 'strict') {\n    thisValue = thisArgument;\n  }\n  // 6. Else,\n  else {\n    // 6. a. If thisArgument is undefined or null, then\n    if (thisArgument.isNil) {\n      // 6. a. i. Let globalEnv be calleeRealm.[[GlobalEnv]].\n      // 6. a. ii. Let globalEnvRec be globalEnv's EnvironmentRecord.\n      const globalEnvRec = calleeRealm['[[GlobalEnv]]'];\n\n      // 6. a. iii. Assert: globalEnvRec is a global Environment Record.\n      // 6. a. iv. Let thisValue be globalEnvRec.[[GlobalThisValue]].\n      thisValue = globalEnvRec['[[GlobalThisValue]]'];\n    }\n    // 6. b. Else,\n    else {\n      // 6. b. i. Let thisValue be ! ToObject(thisArgument).\n      thisValue = thisArgument.ToObject(ctx);\n\n      // 6. b. ii. NOTE: ToObject produces wrapper objects using calleeRealm.\n    }\n  }\n\n  // 7. Let envRec be localEnv's EnvironmentRecord.\n  const envRec = localEnv as $FunctionEnvRec;\n\n  // 8. Assert: envRec is a function Environment Record.\n  // 9. Assert: The next step never returns an abrupt completion because envRec.[[ThisBindingStatus]] is not \"initialized\".\n\n  // 10. Return envRec.BindThisValue(thisValue).\n  return envRec.BindThisValue(ctx, thisValue);\n}\n\nexport type ConstructorKind = 'base' | 'derived';\nexport type ThisMode = 'lexical' | 'strict' | 'global';\n\n// http://www.ecma-international.org/ecma-262/#sec-built-in-function-objects\nexport abstract class $BuiltinFunction<\n  T extends string = string,\n> extends $Function<T> {\n  public readonly '<$BuiltinFunction>': unknown;\n\n  // http://www.ecma-international.org/ecma-262/#sec-createbuiltinfunction\n  // 9.3.3 CreateBuiltinFunction ( steps , internalSlotsList [ , realm [ , prototype ] ] )\n  public constructor(\n    realm: Realm,\n    IntrinsicName: T,\n    proto: $AnyObject,\n  ) {\n    super(realm, IntrinsicName, proto);\n\n    // 1. Assert: steps is either a set of algorithm steps or other definition of a function's behaviour provided in this specification.\n    // 2. If realm is not present, set realm to the current Realm Record.\n    // 3. Assert: realm is a Realm Record.\n    // 4. If prototype is not present, set prototype to realm.[[Intrinsics]].[[%FunctionPrototype%]].\n    // 5. Let func be a new built-in function object that when called performs the action described by steps. The new function object has internal slots whose names are the elements of internalSlotsList. The initial value of each of those internal slots is undefined.\n    // 6. Set func.[[Realm]] to realm.\n    this['[[Realm]]'] = realm;\n\n    // 7. Set func.[[Prototype]] to prototype. // done by $Object\n    // 8. Set func.[[Extensible]] to true. // done by $Object\n    // 9. Set func.[[ScriptOrModule]] to null.\n    this['[[ScriptOrModule]]'] = realm['[[Intrinsics]]'].null;\n\n    // 10. Return func.\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-built-in-function-objects-call-thisargument-argumentslist\n  // 9.3.1 [[Call]] ( thisArgument , argumentsList )\n  public '[[Call]]'(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let callerContext be the running execution context.\n    const callerContext = ctx;\n\n    // 2. If callerContext is not already suspended, suspend callerContext.\n    if (!callerContext.suspended) {\n      callerContext.suspend();\n    }\n\n    // 3. Let calleeContext be a new ECMAScript code execution context.\n    const calleeRealm = this['[[Realm]]'];\n    const calleeContext = new ExecutionContext(calleeRealm);\n\n    // 4. Set the Function of calleeContext to F.\n    calleeContext.Function = this;\n\n    // 5. Let calleeRealm be F.[[Realm]].\n    // 6. Set the Realm of calleeContext to calleeRealm.\n\n    // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].\n    calleeContext.ScriptOrModule = this['[[ScriptOrModule]]'];\n\n    // 8. Perform any necessary implementation-defined initialization of calleeContext.\n    // 9. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.\n    realm.stack.push(calleeContext);\n\n    // 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that conforms to the specification of F. thisArgument is the this value, argumentsList provides the named parameters, and the NewTarget value is undefined.\n    const result = this.performSteps(calleeContext, thisArgument, argumentsList, intrinsics.undefined);\n\n    // 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.stack.pop();\n    callerContext.resume();\n\n    // 12. Return result.\n    return result;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-built-in-function-objects-construct-argumentslist-newtarget\n  // 9.3.2 [[Construct]] ( argumentsList , newTarget )\n  public '[[Construct]]'(\n    ctx: ExecutionContext,\n    argumentsList: $List<$AnyNonEmpty>,\n    newTarget: $Function | $Undefined,\n  ): $AnyObject | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let callerContext be the running execution context.\n    const callerContext = ctx;\n\n    // 2. If callerContext is not already suspended, suspend callerContext.\n    if (!callerContext.suspended) {\n      callerContext.suspend();\n    }\n\n    // 3. Let calleeContext be a new ECMAScript code execution context.\n    const calleeRealm = this['[[Realm]]'];\n    const calleeContext = new ExecutionContext(calleeRealm);\n\n    // 4. Set the Function of calleeContext to F.\n    calleeContext.Function = this;\n\n    // 5. Let calleeRealm be F.[[Realm]].\n    // 6. Set the Realm of calleeContext to calleeRealm.\n\n    // 7. Set the ScriptOrModule of calleeContext to F.[[ScriptOrModule]].\n    calleeContext.ScriptOrModule = this['[[ScriptOrModule]]'];\n\n    // 8. Perform any necessary implementation-defined initialization of calleeContext.\n    // 9. Push calleeContext onto the execution context stack; calleeContext is now the running execution context.\n    realm.stack.push(calleeContext);\n\n    // 10. Let result be the Completion Record that is the result of evaluating F in an implementation-defined manner that conforms to the specification of F. The this value is uninitialized, argumentsList provides the named parameters, and newTarget provides the NewTarget value.\n    const result = this.performSteps(calleeContext, intrinsics.undefined, argumentsList, newTarget) as $Object;\n\n    // 11. Remove calleeContext from the execution context stack and restore callerContext as the running execution context.\n    realm.stack.pop();\n    callerContext.resume();\n\n    // 12. Return result.\n    return result;\n  }\n\n  public abstract performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty ;\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  $AnyNonEmptyNonError,\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\n\nexport class $ValueRecord<T> {\n  public '[[Value]]': T;\n\n  public constructor(\n    value: T,\n  ) {\n    this['[[Value]]'] = value;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-get-regexp-@@species\n// http://www.ecma-international.org/ecma-262/#sec-get-array-@@species\n// http://www.ecma-international.org/ecma-262/#sec-get-%typedarray%-@@species\n// http://www.ecma-international.org/ecma-262/#sec-get-map-@@species\n// http://www.ecma-international.org/ecma-262/#sec-get-set-@@species\n// http://www.ecma-international.org/ecma-262/#sec-get-arraybuffer-@@species\n// http://www.ecma-international.org/ecma-262/#sec-sharedarraybuffer-@@species\n// http://www.ecma-international.org/ecma-262/#sec-get-promise-@@species\nexport class $GetSpecies extends $BuiltinFunction<'get [@@species]'> {\n  public constructor(\n    realm: Realm,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'get [@@species]', intrinsics['%FunctionPrototype%']);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    return thisArgument;\n  }\n}\n","import {\n  $Object,\n} from '../types/object.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $PropertyKey,\n  $AnyNonEmpty,\n  $AnyObject,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $GetFunctionRealm,\n  $Construct,\n  $CreateDataProperty,\n} from '../operations.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Error,\n  $RangeError,\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-array-exotic-objects\nexport class $ArrayExoticObject extends $Object<'ArrayExoticObject'> {\n  public get isArray(): true { return true; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arraycreate\n  // 9.4.2.2 ArrayCreate ( length [ , proto ] )\n  public constructor(\n    realm: Realm,\n    length: $Number,\n    proto?: $AnyObject,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (proto === void 0) {\n      proto = intrinsics['%ArrayPrototype%'];\n    }\n\n    super(realm, 'ArrayExoticObject', proto, CompletionType.normal, intrinsics.empty);\n\n    // 1. Assert: length is an integer Number ≥ 0.\n    // 2. If length is -0, set length to +0.\n    if (length.is(intrinsics['-0'])) {\n      length = intrinsics['0'];\n    }\n\n    // 3. If length > 232 - 1, throw a RangeError exception.\n    if (length['[[Value]]'] > (2 ** 32 - 1)) {\n      // TODO: move logic to static method so we can return an error completion\n      throw new RangeError('3. If length > 2^32 - 1, throw a RangeError exception.');\n    }\n\n    // 4. If proto is not present, set proto to the intrinsic object %ArrayPrototype%.\n    // 5. Let A be a newly created Array exotic object.\n    // 6. Set A's essential internal methods except for [[DefineOwnProperty]] to the default ordinary object definitions specified in 9.1.\n    // 7. Set A.[[DefineOwnProperty]] as specified in 9.4.2.1.\n    // 8. Set A.[[Prototype]] to proto.\n    // 9. Set A.[[Extensible]] to true.\n    // 10. Perform ! OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor { [[Value]]: length, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    super['[[DefineOwnProperty]]'](\n      realm.stack.top,\n      intrinsics.length,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.length,\n        {\n          '[[Value]]': length,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n\n    // 11. Return A.\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-array-exotic-objects-defineownproperty-p-desc\n  // 9.4.2.1 [[DefineOwnProperty]] ( P , Desc )\n  public '[[DefineOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Desc: $PropertyDescriptor,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. If P is \"length\", then\n    if (P.is(intrinsics.length)) {\n      // 2. a. Return ? ArraySetLength(A, Desc).\n      return this.ArraySetLength(ctx, Desc);\n    }\n    // 3. Else if P is an array index, then\n    else if (P.IsArrayIndex) {\n      // 3. a. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n      const oldLenDesc = super['[[GetOwnProperty]]'](ctx, intrinsics.length) as $PropertyDescriptor;\n\n      // 3. b. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.\n      // 3. c. Let oldLen be oldLenDesc.[[Value]].\n      const oldLen = oldLenDesc['[[Value]]'] as $Number;\n\n      // 3. d. Let index be ! ToUint32(P).\n      const index = P.ToUint32(ctx);\n\n      // 3. e. If index ≥ oldLen and oldLenDesc.[[Writable]] is false, return false.\n      if (index['[[Value]]'] >= oldLen['[[Value]]'] && oldLenDesc['[[Writable]]'].isFalsey) {\n        return intrinsics.false;\n      }\n\n      // 3. f. Let succeeded be ! OrdinaryDefineOwnProperty(A, P, Desc).\n      const succeeded = super['[[DefineOwnProperty]]'](ctx, P, Desc) as $Boolean;\n\n      // 3. g. If succeeded is false, return false.\n      if (succeeded.isFalsey) {\n        return intrinsics.false;\n      }\n\n      // 3. h. If index ≥ oldLen, then\n      if (index['[[Value]]'] >= oldLen['[[Value]]']) {\n        // 3. h. i. Set oldLenDesc.[[Value]] to index + 1.\n        oldLenDesc['[[Value]]'] = new $Number(realm, index['[[Value]]'] + 1);\n\n        // 3. h. ii. Let succeeded be OrdinaryDefineOwnProperty(A, \"length\", oldLenDesc).\n        const succeeded = super['[[DefineOwnProperty]]'](ctx, intrinsics.length, oldLenDesc);\n\n        // 3. h. iii. Assert: succeeded is true.\n      }\n\n      // 3. i. Return true.\n      return intrinsics.true;\n    }\n\n    // 4. Return OrdinaryDefineOwnProperty(A, P, Desc).\n    return super['[[DefineOwnProperty]]'](ctx, P, Desc);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arraysetlength\n  // 9.4.2.4 ArraySetLength ( A , Desc )\n  public ArraySetLength(\n    ctx: ExecutionContext,\n    Desc: $PropertyDescriptor,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If Desc.[[Value]] is absent, then\n    if (Desc['[[Value]]'].isEmpty) {\n      // 1. a. Return OrdinaryDefineOwnProperty(A, \"length\", Desc).\n      return super['[[DefineOwnProperty]]'](ctx, intrinsics.length, Desc);\n    }\n\n    // 2. Let newLenDesc be a copy of Desc.\n    const newLenDesc = new $PropertyDescriptor(\n      Desc.realm,\n      Desc.name,\n      {\n        '[[Writable]]': Desc['[[Writable]]'],\n        '[[Enumerable]]': Desc['[[Enumerable]]'],\n        '[[Configurable]]': Desc['[[Configurable]]'],\n      },\n    );\n\n    // 3. Let newLen be ? ToUint32(Desc.[[Value]]).\n    const newLen = Desc['[[Value]]'].ToUint32(ctx);\n    if (newLen.isAbrupt) { return newLen; }\n\n    // 4. Let numberLen be ? ToNumber(Desc.[[Value]]).\n    const numberLen = Desc['[[Value]]'].ToNumber(ctx);\n    if (numberLen.isAbrupt) { return numberLen; }\n\n    // 5. If newLen ≠ numberLen, throw a RangeError exception.\n    if (!newLen.is(numberLen)) {\n      return new $RangeError(ctx.Realm, '5. If newLen ≠ numberLen, throw a RangeError exception.');\n    }\n\n    // 6. Set newLenDesc.[[Value]] to newLen.\n    newLenDesc['[[Value]]'] = newLen;\n\n    // 7. Let oldLenDesc be OrdinaryGetOwnProperty(A, \"length\").\n    const oldLenDesc = super['[[GetOwnProperty]]'](ctx, intrinsics.length) as $PropertyDescriptor;\n\n    // 8. Assert: oldLenDesc will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.\n    // 9. Let oldLen be oldLenDesc.[[Value]].\n    const oldLen = oldLenDesc['[[Value]]'] as $Number;\n\n    // 10. If newLen ≥ oldLen, then\n    if (newLen['[[Value]]'] >= oldLen['[[Value]]']) {\n      // 10. a. Return OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n      return super['[[DefineOwnProperty]]'](ctx, intrinsics.length, newLenDesc);\n    }\n\n    // 11. If oldLenDesc.[[Writable]] is false, return false.\n    if (oldLenDesc['[[Writable]]'].isFalsey) {\n      return intrinsics.false;\n    }\n\n    let newWritable: boolean;\n    // 12. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.\n    if (newLenDesc['[[Writable]]'].isEmpty || newLenDesc['[[Writable]]'].isTruthy) {\n      newWritable = true;\n    }\n    // 13. Else,\n    else {\n      // 13. a. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.\n      // 13. b. Let newWritable be false.\n      newWritable = false;\n\n      // 13. c. Set newLenDesc.[[Writable]] to true.\n      newLenDesc['[[Writable]]'] = intrinsics.true;\n    }\n\n    // 14. Let succeeded be ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n    const succeeded = super['[[DefineOwnProperty]]'](ctx, intrinsics.length, newLenDesc) as $Boolean;\n\n    // 15. If succeeded is false, return false.\n    if (succeeded.isFalsey) {\n      return intrinsics.false;\n    }\n\n    const $newLen = newLen['[[Value]]'];\n    let $oldLen = oldLen['[[Value]]'];\n\n    // 16. Repeat, while newLen < oldLen,\n    while ($newLen < $oldLen) {\n      // 16. a. Decrease oldLen by 1.\n      --$oldLen;\n\n      // 16. b. Let deleteSucceeded be ! A.[[Delete]](! ToString(oldLen)).\n      const deleteSucceeded = this['[[Delete]]'](ctx, new $Number(realm, $oldLen).ToString(ctx)) as $Boolean;\n\n      // 16. c. If deleteSucceeded is false, then\n      if (deleteSucceeded.isFalsey) {\n        // 16. c. i. Set newLenDesc.[[Value]] to oldLen + 1.\n        newLenDesc['[[Value]]'] = new $Number(realm, $oldLen + 1);\n\n        // 16. c. ii. If newWritable is false, set newLenDesc.[[Writable]] to false.\n        if (!newWritable) {\n          newLenDesc['[[Writable]]'] = intrinsics.false;\n        }\n\n        // 16. c. iii. Perform ! OrdinaryDefineOwnProperty(A, \"length\", newLenDesc).\n        super['[[DefineOwnProperty]]'](ctx, intrinsics.length, newLenDesc);\n\n        // 16. c. iv. Return false.\n        return intrinsics.false;\n      }\n    }\n\n    // 17. If newWritable is false, then\n    if (!newWritable) {\n      // 17. a. Return OrdinaryDefineOwnProperty(A, \"length\", PropertyDescriptor { [[Writable]]: false }). This call will always return true.\n      return super['[[DefineOwnProperty]]'](\n        ctx,\n        intrinsics.length,\n        new $PropertyDescriptor(\n          realm,\n          intrinsics.length,\n          {\n            '[[Writable]]': intrinsics.false,\n          },\n        ),\n      );\n    }\n\n    // 18. Return true.\n    return intrinsics.true;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-arrayspeciescreate\nexport function $ArraySpeciesCreate(\n  ctx: ExecutionContext,\n  originalArray: $AnyObject,\n  length: $Number,\n): $AnyObject | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: length is an integer Number ≥ 0.\n  // 2. If length is -0, set length to +0.\n  if (length.is(intrinsics['-0'])) {\n    length = intrinsics['0'];\n  }\n\n  // 3. Let isArray be ? IsArray(originalArray).\n  if (!originalArray.isArray) {\n    // 4. If isArray is false, return ? ArrayCreate(length).\n    return new $ArrayExoticObject(realm, length);\n  }\n\n  // 5. Let C be ? Get(originalArray, \"constructor\").\n  let C = originalArray['[[Get]]'](ctx, intrinsics.$constructor, originalArray);\n  if (C.isAbrupt) { return C; }\n\n  // 6. If IsConstructor(C) is true, then\n  if (C.isFunction) {\n    // 6. a. Let thisRealm be the current Realm Record.\n    const thisRealm = realm;\n\n    // 6. b. Let realmC be ? GetFunctionRealm(C).\n    const realmC = $GetFunctionRealm(ctx, C);\n    if (realmC.isAbrupt) { return realmC; }\n\n    // 6. c. If thisRealm and realmC are not the same Realm Record, then\n    if (thisRealm !== realmC) {\n      // 6. c. i. If SameValue(C, realmC.[[Intrinsics]].[[%Array%]]) is true, set C to undefined.\n      if (C.is(realmC['[[Intrinsics]]']['%Array%'])) {\n        C = intrinsics.undefined;\n      }\n    }\n  }\n\n  // 7. If Type(C) is Object, then\n  if (C.isObject) {\n    // 7. a. Set C to ? Get(C, @@species).\n    C = C['[[Get]]'](ctx, intrinsics['@@species'], C);\n    if (C.isAbrupt) { return C; }\n\n    // 7. b. If C is null, set C to undefined.\n    if (C.isNull) {\n      C = intrinsics.undefined;\n    }\n  }\n\n  // 8. If C is undefined, return ? ArrayCreate(length).\n  if (C.isUndefined) {\n    return new $ArrayExoticObject(realm, length);\n  }\n\n  // 9. If IsConstructor(C) is false, throw a TypeError exception.\n  if (!C.isFunction) {\n    return new $TypeError(realm, `${C} is not a constructor`);\n  }\n\n  // 10. Return ? Construct(C, « length »).\n  return $Construct(ctx, C as $Function, new $List(length), intrinsics.undefined);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createarrayfromlist\nexport function $CreateArrayFromList(\n  ctx: ExecutionContext,\n  elements: $List<$AnyNonEmpty>,\n): $ArrayExoticObject {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: elements is a List whose elements are all ECMAScript language values.\n  // 2. Let array be ! ArrayCreate(0).\n  const array = new $ArrayExoticObject(realm, intrinsics['0']);\n\n  // 3. Let n be 0.\n  let n = 0;\n\n  // 4. For each element e of elements, do\n  for (const e of elements) {\n    // 4. a. Let status be CreateDataProperty(array, ! ToString(n), e).\n    const status = $CreateDataProperty(ctx, array, new $String(realm, n.toString()), e);\n\n    // 4. b. Assert: status is true.\n    // 4. c. Increment n by 1.\n    ++n;\n  }\n\n  // 5. Return array.\n  return array;\n}\n","import {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Function,\n  $BuiltinFunction,\n  $GetPrototypeFromConstructor,\n} from '../types/function.js';\nimport {\n  ExecutionContext,\n  Realm,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  $AnyObject,\n  CompletionType,\n  $Any,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $IteratorRecord,\n  $GetIterator,\n  $IteratorStep,\n  $IteratorValue,\n  $IteratorClose,\n} from './iteration.js';\nimport {\n  $Error,\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $Call,\n  $Construct,\n  $Invoke,\n  $SpeciesConstructor,\n} from '../operations.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  Job,\n} from '../job.js';\nimport {\n  $$ESModuleOrScript,\n} from '../ast/modules.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $ValueRecord,\n  $GetSpecies,\n} from './_shared.js';\nimport {\n  $CreateArrayFromList,\n} from '../exotics/array.js';\nimport {\n  $String,\n} from '../types/string.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-promise-abstract-operations\n// #region 25.6.1 Promise Abstract Operation\n\n// http://www.ecma-international.org/ecma-262/#sec-promisecapability-records\n// 25.6.1.1 PromiseCapability Records\nexport class $PromiseCapability {\n  public '[[Promise]]': $PromiseInstance | $Undefined;\n  public '[[Resolve]]': $Function | $Undefined;\n  public '[[Reject]]': $Function | $Undefined;\n\n  public get isUndefined(): false { return false; }\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    promise: $PromiseInstance | $Undefined,\n    resolve: $Function | $Undefined,\n    reject: $Function | $Undefined,\n  ) {\n    this['[[Promise]]'] = promise;\n    this['[[Resolve]]'] = resolve;\n    this['[[Reject]]'] = reject;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-ifabruptrejectpromise\n// 25.6.1.1.1 IfAbruptRejectPromise ( value , capability )\nexport function $IfAbruptRejectPromise(\n  ctx: ExecutionContext,\n  value: $Any | $IteratorRecord,\n  capability: $PromiseCapability,\n): $Any | $IteratorRecord {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If value is an abrupt completion, then\n  if (value.isAbrupt) {\n    // 1. a. Perform ? Call(capability.[[Reject]], undefined, « value.[[Value]] »).\n    const $CallResult = $Call(ctx, capability['[[Reject]]'], intrinsics.undefined, new $List(value));\n    if ($CallResult.isAbrupt) { return $CallResult; }\n\n    // 1. b. Return capability.[[Promise]].\n    return capability['[[Promise]]'];\n  }\n\n  // 2. Else if value is a Completion Record, set value to value.[[Value]].\n  return value;\n}\n\nexport const enum PromiseReactionType {\n  Fulfill = 1,\n  Reject = 2,\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promisereaction-records\n// 25.6.1.2 PromiseReaction Records\nexport class $PromiseReaction {\n  public readonly '[[Capability]]': $PromiseCapability | $Undefined;\n  public readonly '[[Type]]': PromiseReactionType;\n  public readonly '[[Handler]]': $Function | $Undefined;\n\n  public constructor(\n    capability: $PromiseCapability | $Undefined,\n    type: PromiseReactionType,\n    handler: $Function | $Undefined,\n  ) {\n    this['[[Capability]]'] = capability;\n    this['[[Type]]'] = type;\n    this['[[Handler]]'] = handler;\n  }\n\n  public is(other: $PromiseReaction): boolean {\n    return this === other;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createresolvingfunctions\n// 25.6.1.3 CreateResolvingFunctions ( promise )\nexport class $PromiseResolvingFunctions {\n  public readonly '[[Resolve]]': $PromiseResolveFunction;\n  public readonly '[[Reject]]': $PromiseRejectFunction;\n\n  public constructor(\n    realm: Realm,\n    promise: $PromiseInstance,\n  ) {\n    // 1. Let alreadyResolved be a new Record { [[Value]]: false }.\n    const alreadyResolved = new $ValueRecord<boolean>(false);\n\n    // 2. Let stepsResolve be the algorithm steps defined in Promise Resolve Functions (25.6.1.3.2).\n    // 3. Let resolve be CreateBuiltinFunction(stepsResolve, « [[Promise]], [[AlreadyResolved]] »).\n    // 4. Set resolve.[[Promise]] to promise.\n    // 5. Set resolve.[[AlreadyResolved]] to alreadyResolved.\n    this['[[Resolve]]'] = new $PromiseResolveFunction(realm, promise, alreadyResolved);\n\n    // 6. Let stepsReject be the algorithm steps defined in Promise Reject Functions (25.6.1.3.1).\n    // 7. Let reject be CreateBuiltinFunction(stepsReject, « [[Promise]], [[AlreadyResolved]] »).\n    // 8. Set reject.[[Promise]] to promise.\n    // 9. Set reject.[[AlreadyResolved]] to alreadyResolved.\n    this['[[Reject]]'] = new $PromiseRejectFunction(realm, promise, alreadyResolved);\n\n    // 10. Return a new Record { [[Resolve]]: resolve, [[Reject]]: reject }.\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise-reject-functions\n// 25.6.1.3.1 Promise Reject Functions\nexport class $PromiseRejectFunction extends $BuiltinFunction<'PromiseRejectFunction'> {\n  public '[[Promise]]': $PromiseInstance;\n  public '[[AlreadyResolved]]': $ValueRecord<boolean>;\n\n  public constructor(\n    realm: Realm,\n    promise: $PromiseInstance,\n    alreadyResolved: $ValueRecord<boolean>,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'PromiseRejectFunction', intrinsics['%FunctionPrototype%']);\n\n    this['[[Promise]]'] = promise;\n    this['[[AlreadyResolved]]'] = alreadyResolved;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [reason]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (reason === void 0) {\n      reason = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Assert: F has a [[Promise]] internal slot whose value is an Object.\n    // 3. Let promise be F.[[Promise]].\n    const promise = F['[[Promise]]'];\n\n    // 4. Let alreadyResolved be F.[[AlreadyResolved]].\n    const alreadyResolved = F['[[AlreadyResolved]]'];\n\n    // 5. If alreadyResolved.[[Value]] is true, return undefined.\n    if (alreadyResolved['[[Value]]']) {\n      return intrinsics.undefined;\n    }\n\n    // 6. Set alreadyResolved.[[Value]] to true.\n    alreadyResolved['[[Value]]'] = true;\n\n    // 7. Return RejectPromise(promise, reason).\n    return $RejectPromise(ctx, promise, reason);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise-resolve-functions\n// 25.6.1.3.2 Promise Resolve Functions\nexport class $PromiseResolveFunction extends $BuiltinFunction<'PromiseResolveFunction'> {\n  public '[[Promise]]': $PromiseInstance;\n  public '[[AlreadyResolved]]': $ValueRecord<boolean>;\n\n  public constructor(\n    realm: Realm,\n    promise: $PromiseInstance,\n    alreadyResolved: $ValueRecord<boolean>,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'PromiseResolveFunction', intrinsics['%FunctionPrototype%']);\n\n    this['[[Promise]]'] = promise;\n    this['[[AlreadyResolved]]'] = alreadyResolved;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [resolution]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (resolution === void 0) {\n      resolution = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Assert: F has a [[Promise]] internal slot whose value is an Object.\n    // 3. Let promise be F.[[Promise]].\n    const promise = F['[[Promise]]'];\n\n    // 4. Let alreadyResolved be F.[[AlreadyResolved]].\n    const alreadyResolved = F['[[AlreadyResolved]]'];\n\n    // 5. If alreadyResolved.[[Value]] is true, return undefined.\n    if (alreadyResolved['[[Value]]']) {\n      return intrinsics.undefined;\n    }\n\n    // 6. Set alreadyResolved.[[Value]] to true.\n    alreadyResolved['[[Value]]'] = true;\n\n    // 7. If SameValue(resolution, promise) is true, then\n    if (resolution.is(promise)) {\n      // 7. a. Let selfResolutionError be a newly created TypeError object.\n      const selfResolutionError = new $TypeError(realm, `Failed to resolve self`); // ?\n\n      // 7. b. Return RejectPromise(promise, selfResolutionError).\n      return $RejectPromise(ctx, promise, selfResolutionError);\n    }\n\n    // 8. If Type(resolution) is not Object, then\n    if (!resolution.isObject) {\n      // 8. a. Return FulfillPromise(promise, resolution).\n      return $FulfillPromise(ctx, promise, resolution);\n    }\n\n    // 9. Let then be Get(resolution, \"then\").\n    const then = resolution['[[Get]]'](ctx, intrinsics.then, resolution);\n\n    // 10. If then is an abrupt completion, then\n    if (then.isAbrupt) {\n      // 10. a. Return RejectPromise(promise, then.[[Value]]).\n      return $RejectPromise(ctx, promise, then);\n    }\n\n    // 11. Let thenAction be then.[[Value]].\n    // 12. If IsCallable(thenAction) is false, then\n    if (!then.isFunction) {\n      // 12. a. Return FulfillPromise(promise, resolution).\n      return $FulfillPromise(ctx, promise, resolution);\n    }\n\n    // 13. Perform EnqueueJob(\"PromiseJobs\", PromiseResolveThenableJob, « promise, resolution, thenAction »).\n    const mos = ctx.ScriptOrModule;\n    if (mos.isNull) {\n      throw new Error(`No ScriptOrModule found in this realm`);\n    }\n    realm.PromiseJobs.EnqueueJob(ctx, new PromiseResolveThenableJob(realm, mos, promise, resolution, then));\n\n    // 14. Return undefined.\n    return new $Undefined(realm);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-fulfillpromise\n// 25.6.1.4 FulfillPromise ( promise , value )\nexport function $FulfillPromise(\n  ctx: ExecutionContext,\n  promise: $PromiseInstance,\n  value: $AnyNonEmpty,\n) {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  // 2. Let reactions be promise.[[PromiseFulfillReactions]].\n  const reactions = promise['[[PromiseFulfillReactions]]']!;\n\n  // 3. Set promise.[[PromiseResult]] to value.\n  promise['[[PromiseResult]]'] = value;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  promise['[[PromiseFulfillReactions]]'] = void 0;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  promise['[[PromiseRejectReactions]]'] = void 0;\n\n  // 6. Set promise.[[PromiseState]] to \"fulfilled\".\n  promise['[[PromiseState]]'] = PromiseState.fulfilled;\n\n  // 7. Return TriggerPromiseReactions(reactions, value).\n  return $TriggerPromiseReactions(ctx, reactions, value);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-newpromisecapability\n// 25.6.1.5 NewPromiseCapability ( C )\nexport function $NewPromiseCapability(\n  ctx: ExecutionContext,\n  C: $AnyObject,\n): $PromiseCapability | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If IsConstructor(C) is false, throw a TypeError exception.\n  if (!C.isFunction) {\n    return new $TypeError(realm, `Expected constructor, but got: ${C}`);\n  }\n\n  // 2. NOTE: C is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see 25.6.3.1).\n  // 3. Let promiseCapability be a new PromiseCapability { [[Promise]]: undefined, [[Resolve]]: undefined, [[Reject]]: undefined }.\n  const promiseCapability = new $PromiseCapability(intrinsics.undefined, intrinsics.undefined, intrinsics.undefined);\n\n  // 4. Let steps be the algorithm steps defined in GetCapabilitiesExecutor Functions.\n  // 5. Let executor be CreateBuiltinFunction(steps, « [[Capability]] »).\n  // 6. Set executor.[[Capability]] to promiseCapability.\n  const executor = new $GetCapabilitiesExecutor(realm, promiseCapability);\n\n  // 7. Let promise be ? Construct(C, « executor »).\n  const promise = $Construct(ctx, C as $Function, new $List(executor), intrinsics.undefined) as $PromiseInstance;\n\n  // 8. If IsCallable(promiseCapability.[[Resolve]]) is false, throw a TypeError exception.\n  if (!promiseCapability['[[Resolve]]'].isFunction) {\n    return new $TypeError(realm, `Expected [[Resolve]] to be callable, but got: ${promiseCapability['[[Resolve]]']}`);\n  }\n\n  // 9. If IsCallable(promiseCapability.[[Reject]]) is false, throw a TypeError exception.\n  if (!promiseCapability['[[Reject]]'].isFunction) {\n    return new $TypeError(realm, `Expected [[Reject]] to be callable, but got: ${promiseCapability['[[Reject]]']}`);\n  }\n\n  // 10. Set promiseCapability.[[Promise]] to promise.\n  promiseCapability['[[Promise]]'] = promise;\n\n  // 11. Return promiseCapability.\n  return promiseCapability;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getcapabilitiesexecutor-functions\n// 25.6.1.5.1 GetCapabilitiesExecutor Functions\nexport class $GetCapabilitiesExecutor extends $BuiltinFunction<'GetCapabilitiesExecutor'> {\n  public '[[Capability]]': $PromiseCapability;\n\n  public constructor(\n    realm: Realm,\n    capability: $PromiseCapability,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'GetCapabilitiesExecutor', intrinsics['%FunctionPrototype%']);\n\n    this['[[Capability]]'] = capability;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [resolve, reject]: $List<$Function | $Undefined>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (resolve === void 0) {\n      resolve = intrinsics.undefined;\n    }\n    if (reject === void 0) {\n      reject = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Assert: F has a [[Capability]] internal slot whose value is a PromiseCapability Record.\n    // 3. Let promiseCapability be F.[[Capability]].\n    const promiseCapability = F['[[Capability]]'];\n\n    // 4. If promiseCapability.[[Resolve]] is not undefined, throw a TypeError exception.\n    if (!promiseCapability['[[Resolve]]'].isUndefined) {\n      return new $TypeError(realm, `[[Resolve]] is already defined`);\n    }\n\n    // 5. If promiseCapability.[[Reject]] is not undefined, throw a TypeError exception.\n    if (!promiseCapability['[[Reject]]'].isUndefined) {\n      return new $TypeError(realm, `[[Reject]] is already defined`);\n    }\n\n    // 6. Set promiseCapability.[[Resolve]] to resolve.\n    promiseCapability['[[Resolve]]'] = resolve;\n\n    // 7. Set promiseCapability.[[Reject]] to reject.\n    promiseCapability['[[Reject]]'] = reject;\n\n    // 8. Return undefined.\n    return intrinsics.undefined;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-rejectpromise\n// 25.6.1.7 RejectPromise ( promise , reason )\nexport function $RejectPromise(\n  ctx: ExecutionContext,\n  promise: $PromiseInstance,\n  reason: $AnyNonEmpty,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: The value of promise.[[PromiseState]] is \"pending\".\n  // 2. Let reactions be promise.[[PromiseRejectReactions]].\n  const reactions = promise['[[PromiseRejectReactions]]']!;\n\n  // 3. Set promise.[[PromiseResult]] to reason.\n  promise['[[PromiseResult]]'] = reason;\n\n  // 4. Set promise.[[PromiseFulfillReactions]] to undefined.\n  promise['[[PromiseFulfillReactions]]'] = void 0;\n\n  // 5. Set promise.[[PromiseRejectReactions]] to undefined.\n  promise['[[PromiseRejectReactions]]'] = void 0;\n\n  // 6. Set promise.[[PromiseState]] to \"rejected\".\n  promise['[[PromiseState]]'] = PromiseState.rejected;\n\n  // 7. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"reject\").\n  if (!promise['[[PromiseIsHandled]]']) {\n    $HostPromiseRejectionTracker(ctx, promise, PromiseRejectionOperation.reject);\n  }\n\n  // 8. Return TriggerPromiseReactions(reactions, reason).\n  return $TriggerPromiseReactions(ctx, reactions, reason);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-triggerpromisereactions\n// 25.6.1.8 TriggerPromiseReactions ( reactions , argument )\nexport function $TriggerPromiseReactions(\n  ctx: ExecutionContext,\n  reactions: $List<$PromiseReaction>,\n  argument: $AnyNonEmpty,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const promiseJobs = realm.PromiseJobs;\n\n  const mos = ctx.ScriptOrModule;\n  if (mos.isNull) {\n    throw new Error(`No ScriptOrModule found in this realm`);\n  }\n\n  // 1. For each reaction in reactions, in original insertion order, do\n  for (const reaction of reactions) {\n    // 1. a. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « reaction, argument »).\n    promiseJobs.EnqueueJob(ctx, new PromiseReactionJob(realm, mos, reaction, argument));\n  }\n\n  // 2. Return undefined.\n  return new $Undefined(realm);\n}\n\nexport const enum PromiseRejectionOperation {\n  reject = 1,\n  handle = 2,\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-host-promise-rejection-tracker\n// 25.6.1.9 HostPromiseRejectionTracker ( promise , operation )\nexport function $HostPromiseRejectionTracker(\n  ctx: ExecutionContext,\n  promise: $PromiseInstance,\n  operation: PromiseRejectionOperation,\n) {\n  ctx.logger.error(`Promise rejected: ${promise}`);\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-promise-jobs\n// #region 25.6.2 Promise Jobs\n\nexport class PromiseReactionJob extends Job {\n  public constructor(\n    realm: Realm,\n    scriptOrModule: $$ESModuleOrScript,\n    public readonly reaction: $PromiseReaction,\n    public readonly argument: $AnyNonEmpty,\n  ) {\n    super(realm.logger.root, realm, scriptOrModule);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promisereactionjob\n  // 25.6.2.1 PromiseReactionJob ( reaction , argument )\n  public Run(ctx: ExecutionContext): $Any {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`Run(#${ctx.id})`);\n\n    const reaction = this.reaction;\n    const argument = this.argument;\n\n    // 1. Assert: reaction is a PromiseReaction Record.\n    // 2. Let promiseCapability be reaction.[[Capability]].\n    const promiseCapability = reaction['[[Capability]]'];\n\n    // 3. Let type be reaction.[[Type]].\n    const type = reaction['[[Type]]'];\n\n    // 4. Let handler be reaction.[[Handler]].\n    const handler = reaction['[[Handler]]'];\n\n    let handlerResult: $AnyNonEmpty;\n\n    // 5. If handler is undefined, then\n    if (handler.isUndefined) {\n      // 5. a. If type is \"Fulfill\", let handlerResult be NormalCompletion(argument).\n      if (type === PromiseReactionType.Fulfill) {\n        handlerResult = argument;\n      }\n      // 5. b. Else,\n      else {\n        // 5. b. i. Assert: type is \"Reject\".\n        // 5. b. ii. Let handlerResult be ThrowCompletion(argument).\n        handlerResult = argument.ToCompletion(CompletionType.throw, intrinsics.empty);\n      }\n    }\n    // 6. Else, let handlerResult be Call(handler, undefined, « argument »).\n    else {\n      handlerResult = $Call(ctx, handler, intrinsics.undefined, new $List(argument));\n    }\n\n    // 7. If promiseCapability is undefined, then\n    if (promiseCapability.isUndefined) {\n      // 7. a. Assert: handlerResult is not an abrupt completion.\n      // 7. b. Return NormalCompletion(empty).\n      return new $Empty(realm);\n    }\n\n    let status: $AnyNonEmpty;\n\n    // 8. If handlerResult is an abrupt completion, then\n    if (handlerResult.isAbrupt) {\n      // 8. a. Let status be Call(promiseCapability.[[Reject]], undefined, « handlerResult.[[Value]] »).\n      status = $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(handlerResult));\n    }\n    // 9. Else,\n    else {\n      // 9. a. Let status be Call(promiseCapability.[[Resolve]], undefined, « handlerResult.[[Value]] »).\n      status = $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(handlerResult));\n    }\n\n    // 10. Return Completion(status).\n    return status;\n  }\n}\n\nexport class PromiseResolveThenableJob extends Job {\n  public constructor(\n    realm: Realm,\n    scriptOrModule: $$ESModuleOrScript,\n    public readonly promiseToResolve: $PromiseInstance,\n    public readonly thenable: $AnyNonEmptyNonError,\n    public readonly then: $AnyNonEmptyNonError,\n  ) {\n    super(realm.logger.root, realm, scriptOrModule);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promiseresolvethenablejob\n  // 25.6.2.2 PromiseResolveThenableJob ( promiseToResolve , thenable , then )\n  public Run(ctx: ExecutionContext): $Any {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`Run(#${ctx.id})`);\n\n    const promiseToResolve = this.promiseToResolve;\n    const thenable = this.thenable;\n    const then = this.then;\n\n    // 1. Let resolvingFunctions be CreateResolvingFunctions(promiseToResolve).\n    const resolvingFunctions = new $PromiseResolvingFunctions(realm, promiseToResolve);\n\n    // 2. Let thenCallResult be Call(then, thenable, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).\n    const thenCallResult = $Call(ctx, then, thenable, new $List<$Object>(resolvingFunctions['[[Resolve]]'], resolvingFunctions['[[Reject]]']));\n\n    // 3. If thenCallResult is an abrupt completion, then\n    if (thenCallResult.isAbrupt) {\n      // 3. a. Let status be Call(resolvingFunctions.[[Reject]], undefined, « thenCallResult.[[Value]] »).\n      const status = $Call(ctx, resolvingFunctions['[[Reject]]'], intrinsics.undefined, new $List(thenCallResult));\n\n      // 3. b. Return Completion(status).\n      return status;\n    }\n\n    // 4. Return Completion(thenCallResult).\n    return thenCallResult;\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-promise-constructor\n// #region 25.6.3 The Promise Constructor\nexport class $PromiseConstructor extends $BuiltinFunction<'%Promise%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-promise.prototype\n  // 25.6.4.2 Promise.prototype\n  public get $prototype(): $PromisePrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $PromisePrototype;\n  }\n  public set $prototype(value: $PromisePrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.all\n  // 25.6.4.1 Promise.all ( iterable )\n  public get all(): $Promise_all {\n    return this.getProperty(this.realm['[[Intrinsics]]'].all)['[[Value]]'] as $Promise_all;\n  }\n  public set all(value: $Promise_all) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].all, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.race\n  // 25.6.4.3 Promise.race ( iterable )\n  public get race(): $Promise_race {\n    return this.getProperty(this.realm['[[Intrinsics]]'].race)['[[Value]]'] as $Promise_race;\n  }\n  public set race(value: $Promise_race) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].race, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.reject\n  // 25.6.4.4 Promise.reject ( r )\n  public get reject(): $Promise_reject {\n    return this.getProperty(this.realm['[[Intrinsics]]'].reject)['[[Value]]'] as $Promise_reject;\n  }\n  public set reject(value: $Promise_reject) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].reject, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.resolve\n  // 25.6.4.5 Promise.resolve ( x )\n  public get resolve(): $Promise_resolve {\n    return this.getProperty(this.realm['[[Intrinsics]]'].resolve)['[[Value]]'] as $Promise_resolve;\n  }\n  public set resolve(value: $Promise_resolve) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].resolve, value, false, false, false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-get-promise-@@species\n  // 25.6.4.6 get Promise [ @@species ]\n  public get ['@@species'](): $GetSpecies {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@species'])['[[Value]]'] as $GetSpecies;\n  }\n  public set ['@@species'](value: $GetSpecies) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@species'], value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Promise%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise-executor\n  // 25.6.3.1 Promise ( executor )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [executor]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, throw a TypeError exception.\n    if (NewTarget.isUndefined) {\n      return new $TypeError(realm, `Promise cannot be called as a function.`);\n    }\n\n    // 2. If IsCallable(executor) is false, throw a TypeError exception.\n    if (executor === void 0 || !executor.isFunction) {\n      return new $TypeError(realm, `The promise constructor requires an executor function`);\n    }\n\n    // 3. Let promise be ? OrdinaryCreateFromConstructor(NewTarget, \"%PromisePrototype%\", « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).\n    const promise = $PromiseInstance.Create(ctx, NewTarget);\n    if (promise.isAbrupt) { return promise; }\n\n    // 4. Set promise.[[PromiseState]] to \"pending\".\n    promise['[[PromiseState]]'] = PromiseState.pending;\n\n    // 5. Set promise.[[PromiseFulfillReactions]] to a new empty List.\n    promise['[[PromiseFulfillReactions]]'] = new $List();\n\n    // 6. Set promise.[[PromiseRejectReactions]] to a new empty List.\n    promise['[[PromiseRejectReactions]]'] = new $List();\n\n    // 7. Set promise.[[PromiseIsHandled]] to false.\n    promise['[[PromiseIsHandled]]'] = false;\n\n    // 8. Let resolvingFunctions be CreateResolvingFunctions(promise).\n    const resolvingFunctions = new $PromiseResolvingFunctions(realm, promise);\n\n    // 9. Let completion be Call(executor, undefined, « resolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]] »).\n    const completion = $Call(\n      ctx,\n      executor,\n      intrinsics.undefined,\n      new $List<$AnyNonEmpty>(resolvingFunctions['[[Resolve]]'], resolvingFunctions['[[Reject]]']),\n    );\n\n    // 10. If completion is an abrupt completion, then\n    if (completion.isAbrupt) {\n      // 10. a. Perform ? Call(resolvingFunctions.[[Reject]], undefined, « completion.[[Value]] »).\n      const $CallResult = $Call(\n        ctx,\n        resolvingFunctions['[[Reject]]'],\n        intrinsics.undefined,\n        new $List(completion),\n      );\n\n      if ($CallResult.isAbrupt) { return $CallResult; }\n    }\n\n    // 11. Return promise.\n    return promise;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-promise-constructor\n// 25.6.4 Properties of the Promise Constructor\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.all\n// 25.6.4.1 Promise.all ( iterable )\nexport class $Promise_all extends $BuiltinFunction<'%Promise_all%'> {\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Promise_all%', functionPrototype);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [iterable]: $List<$AnyNonEmptyNonError>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (iterable === void 0) {\n      iterable = intrinsics.undefined;\n    }\n\n    // 1. Let C be the this value.\n    const C = thisArgument;\n\n    // 2. If Type(C) is not Object, throw a TypeError exception.\n    if (!C.isObject) {\n      return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);\n    }\n\n    // 3. Let promiseCapability be ? NewPromiseCapability(C).\n    const promiseCapability = $NewPromiseCapability(ctx, C);\n    if (promiseCapability.isAbrupt) { return promiseCapability; }\n\n    // 4. Let iteratorRecord be GetIterator(iterable).\n    const iteratorRecord = $GetIterator(ctx, iterable);\n    if (iteratorRecord.isAbrupt) { return iteratorRecord; } // TODO: we sure about this? spec doesn't say\n\n    // 5. IfAbruptRejectPromise(iteratorRecord, promiseCapability).\n    const maybeAbrupt = $IfAbruptRejectPromise(ctx, iteratorRecord, promiseCapability);\n    if (maybeAbrupt.isAbrupt) { return maybeAbrupt; }\n\n    // 6. Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability).\n    let result = PerformPromiseAll(ctx, iteratorRecord, C as $Function, promiseCapability) as $Any;\n\n    // 7. If result is an abrupt completion, then\n    if (result.isAbrupt) {\n      // 7. a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).\n      if (iteratorRecord['[[Done]]'].isFalsey) {\n        result = $IteratorClose(ctx, iteratorRecord, result);\n      }\n\n      // 7. b. IfAbruptRejectPromise(result, promiseCapability).\n      const maybeAbrupt = $IfAbruptRejectPromise(ctx, result, promiseCapability);\n      if (maybeAbrupt.isAbrupt) { return maybeAbrupt; }\n    }\n\n    // 8. Return Completion(result).\n    return result as $AnyNonEmpty; // TODO: fix typings $Empty shenanigans\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-performpromiseall\n// 25.6.4.1.1 Runtime Semantics: PerformPromiseAll ( iteratorRecord , constructor , resultCapability )\nfunction PerformPromiseAll(\n  ctx: ExecutionContext,\n  iteratorRecord: $IteratorRecord,\n  constructor: $Function,\n  resultCapability: $PromiseCapability,\n): $AnyNonEmpty {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: IsConstructor(constructor) is true.\n  // 2. Assert: resultCapability is a PromiseCapability Record.\n  // 3. Let values be a new empty List.\n  const values = new $List<$AnyNonEmptyNonError>();\n\n  // 4. Let remainingElementsCount be a new Record { [[Value]]: 1 }.\n  const remainingElementsCount = new $ValueRecord<number>(1);\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat,\n  while (true) {\n    // 6. a. Let next be IteratorStep(iteratorRecord).\n    const next = $IteratorStep(ctx, iteratorRecord);\n\n    // 6. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n    // 6. c. ReturnIfAbrupt(next).\n    if (next.isAbrupt) {\n      iteratorRecord['[[Done]]'] = intrinsics.true;\n      return next;\n    }\n\n    // 6. d. If next is false, then\n    if (next.isFalsey) {\n      // 6. d. i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord['[[Done]]'] = intrinsics.true;\n\n      // 6. d. ii. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n      // 6. d. iii. If remainingElementsCount.[[Value]] is 0, then\n      if (--remainingElementsCount['[[Value]]'] === 0) {\n        // 6. d. iii. 1. Let valuesArray be CreateArrayFromList(values).\n        const valuesArray = $CreateArrayFromList(ctx, values);\n\n        // 6. d. iii. 2. Perform ? Call(resultCapability.[[Resolve]], undefined, « valuesArray »).\n        const $CallResult = $Call(ctx, resultCapability['[[Resolve]]'], intrinsics.undefined, new $List(valuesArray));\n        if ($CallResult.isAbrupt) { return $CallResult; }\n      }\n\n      // 6. d. iv. Return resultCapability.[[Promise]].\n      return resultCapability['[[Promise]]'];\n    }\n\n    // 6. e. Let nextValue be IteratorValue(next).\n    const nextValue = $IteratorValue(ctx, next);\n\n    // 6. f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n    // 6. g. ReturnIfAbrupt(nextValue).\n    if (nextValue.isAbrupt) {\n      iteratorRecord['[[Done]]'] = intrinsics.true;\n      return nextValue;\n    }\n\n    // 6. h. Append undefined to values.\n    values.push(new $Undefined(realm));\n\n    // 6. i. Let nextPromise be ? Invoke(constructor, \"resolve\", « nextValue »).\n    const nextPromise = $Invoke(ctx, constructor, intrinsics.resolve, new $List(nextValue)) as $AnyNonEmpty; // TODO: fix $Empty typing shenanigans\n    if (nextPromise.isAbrupt) { return nextPromise; }\n\n    // 6. j. Let steps be the algorithm steps defined in Promise.all Resolve Element Functions.\n    // 6. k. Let resolveElement be CreateBuiltinFunction(steps, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n    // 6. l. Set resolveElement.[[AlreadyCalled]] to a new Record { [[Value]]: false }.\n    // 6. m. Set resolveElement.[[Index]] to index.\n    // 6. n. Set resolveElement.[[Values]] to values.\n    // 6. o. Set resolveElement.[[Capability]] to resultCapability.\n    // 6. p. Set resolveElement.[[RemainingElements]] to remainingElementsCount.\n    const resolveElement = new $Promise_all_ResolveElement(\n      realm,\n      new $ValueRecord<boolean>(false),\n      index,\n      values,\n      resultCapability,\n      remainingElementsCount,\n    );\n\n    // 6. q. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] + 1.\n    ++remainingElementsCount['[[Value]]'];\n\n    // 6. r. Perform ? Invoke(nextPromise, \"then\", « resolveElement, resultCapability.[[Reject]] »).\n    const $InvokeResult = $Invoke(ctx, nextPromise, intrinsics.then, new $List(resolveElement, resultCapability['[[Reject]]']));\n    if ($InvokeResult.isAbrupt) { return $InvokeResult; }\n\n    // 6. s. Increase index by 1.\n    ++index;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.all-resolve-element-functions\n// 25.6.4.1.2 Promise.all Resolve Element Functions\nexport class $Promise_all_ResolveElement extends $BuiltinFunction<'Promise.all Resolve Element'> {\n  public '[[AlreadyCalled]]': $ValueRecord<boolean>;\n  public '[[Index]]': number;\n  public '[[Values]]': $List<$AnyNonEmpty>;\n  public '[[Capability]]': $PromiseCapability;\n  public '[[RemainingElements]]': $ValueRecord<number>;\n\n  public constructor(\n    realm: Realm,\n    alreadyCalled: $ValueRecord<boolean>,\n    index: number,\n    values: $List<$AnyNonEmpty>,\n    capability: $PromiseCapability,\n    remainingElements: $ValueRecord<number>,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'Promise.all Resolve Element', intrinsics['%FunctionPrototype%']);\n\n    this['[[AlreadyCalled]]'] = alreadyCalled;\n    this['[[Index]]'] = index;\n    this['[[Values]]'] = values;\n    this['[[Capability]]'] = capability;\n    this['[[RemainingElements]]'] = remainingElements;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [x]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (x === void 0) {\n      x = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Let alreadyCalled be F.[[AlreadyCalled]].\n    const alreadyCalled = F['[[AlreadyCalled]]'];\n\n    // 3. If alreadyCalled.[[Value]] is true, return undefined.\n    if (alreadyCalled['[[Value]]']) {\n      return intrinsics.undefined;\n    }\n\n    // 4. Set alreadyCalled.[[Value]] to true.\n    alreadyCalled['[[Value]]'] = true;\n\n    // 5. Let index be F.[[Index]].\n    const index = F['[[Index]]'];\n\n    // 6. Let values be F.[[Values]].\n    const values = F['[[Values]]'];\n\n    // 7. Let promiseCapability be F.[[Capability]].\n    const promiseCapability = F['[[Capability]]'];\n\n    // 8. Let remainingElementsCount be F.[[RemainingElements]].\n    const remainingElementsCount = F['[[RemainingElements]]'];\n\n    // 9. Set values[index] to x.\n    values[index] = x;\n\n    // 10. Set remainingElementsCount.[[Value]] to remainingElementsCount.[[Value]] - 1.\n    // 11. If remainingElementsCount.[[Value]] is 0, then\n    if (--remainingElementsCount['[[Value]]'] === 0) {\n      // 11. a. Let valuesArray be CreateArrayFromList(values).\n      const valuesArray = $CreateArrayFromList(ctx, values);\n\n      // 11. b. Return ? Call(promiseCapability.[[Resolve]], undefined, « valuesArray »).\n      return $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(valuesArray));\n    }\n\n    // 12. Return undefined.\n    return intrinsics.undefined;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.race\n// 25.6.4.3 Promise.race ( iterable )\nexport class $Promise_race extends $BuiltinFunction<'%Promise_race%'> {\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Promise_race%', functionPrototype);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [iterable]: $List<$AnyNonEmptyNonError>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (iterable === void 0) {\n      iterable = intrinsics.undefined;\n    }\n\n    // 1. Let C be the this value.\n    const C = thisArgument;\n\n    // 2. If Type(C) is not Object, throw a TypeError exception.\n    if (!C.isObject) {\n      return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);\n    }\n\n    // 3. Let promiseCapability be ? NewPromiseCapability(C).\n    const promiseCapability = $NewPromiseCapability(ctx, C);\n    if (promiseCapability.isAbrupt) { return promiseCapability; }\n\n    // 4. Let iteratorRecord be GetIterator(iterable).\n    const iteratorRecord = $GetIterator(ctx, iterable);\n    if (iteratorRecord.isAbrupt) { return iteratorRecord; } // TODO: we sure about this? spec doesn't say\n\n    // 5. IfAbruptRejectPromise(iteratorRecord, promiseCapability).\n    const maybeAbrupt = $IfAbruptRejectPromise(ctx, iteratorRecord, promiseCapability);\n    if (maybeAbrupt.isAbrupt) { return maybeAbrupt; }\n\n    // 6. Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability).\n    let result = PerformPromiseAll(ctx, iteratorRecord, C as $Function, promiseCapability) as $Any;\n\n    // 7. If result is an abrupt completion, then\n    if (result.isAbrupt) {\n      // 7. a. If iteratorRecord.[[Done]] is false, set result to IteratorClose(iteratorRecord, result).\n      if (iteratorRecord['[[Done]]'].isFalsey) {\n        result = $IteratorClose(ctx, iteratorRecord, result);\n      }\n\n      // 7. b. IfAbruptRejectPromise(result, promiseCapability).\n      const maybeAbrupt = $IfAbruptRejectPromise(ctx, result, promiseCapability);\n      if (maybeAbrupt.isAbrupt) { return maybeAbrupt; }\n    }\n\n    // 8. Return Completion(result).\n    return result as $AnyNonEmpty; // TODO: fix typings $Empty shenanigans\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-performpromiserace\n// 25.6.4.3.1 Runtime Semantics: PerformPromiseRace ( iteratorRecord , constructor , resultCapability )\nexport function $PerformPromiseRace(\n  ctx: ExecutionContext,\n  iteratorRecord: $IteratorRecord,\n  constructor: $Function,\n  resultCapability: $PromiseCapability,\n): $AnyNonEmpty {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: IsConstructor(constructor) is true.\n  // 2. Assert: resultCapability is a PromiseCapability Record.\n  // 3. Repeat,\n  while (true) {\n    // 3. a. Let next be IteratorStep(iteratorRecord).\n      const next = $IteratorStep(ctx, iteratorRecord);\n\n    // 3. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n    // 3. c. ReturnIfAbrupt(next).\n      if (next.isAbrupt) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n        return next;\n      }\n\n    // 3. d. If next is false, then\n    if (next.isFalsey) {\n      // 3. d. i. Set iteratorRecord.[[Done]] to true.\n      iteratorRecord['[[Done]]'] = intrinsics.true;\n\n      // 3. d. ii. Return resultCapability.[[Promise]].\n      return resultCapability['[[Promise]]'];\n    }\n\n    // 3. e. Let nextValue be IteratorValue(next).\n    const nextValue = $IteratorValue(ctx, next);\n\n    // 3. f. If nextValue is an abrupt completion, set iteratorRecord.[[Done]] to true.\n    // 3. g. ReturnIfAbrupt(nextValue).\n    if (nextValue.isAbrupt) {\n      iteratorRecord['[[Done]]'] = intrinsics.true;\n      return nextValue;\n    }\n\n    // 3. h. Let nextPromise be ? Invoke(constructor, \"resolve\", « nextValue »).\n    const nextPromise = $Invoke(ctx, constructor, intrinsics.resolve, new $List(nextValue)) as $AnyNonEmpty; // TODO: fix $Empty typing shenanigans\n    if (nextPromise.isAbrupt) { return nextPromise; }\n\n    // 3. i. Perform ? Invoke(nextPromise, \"then\", « resultCapability.[[Resolve]], resultCapability.[[Reject]] »).\n    const $InvokeResult = $Invoke(ctx, nextPromise, intrinsics.then, new $List(resultCapability['[[Resolve]]'], resultCapability['[[Reject]]']));\n    if ($InvokeResult.isAbrupt) { return $InvokeResult; }\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.reject\n// 25.6.4.4 Promise.reject ( r )\nexport class $Promise_reject extends $BuiltinFunction<'%Promise_reject%'> {\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Promise_reject%', functionPrototype);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [r]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (r === void 0) {\n      r = intrinsics.undefined;\n    }\n\n    // 1. Let C be the this value.\n    const C = thisArgument;\n\n    // 2. If Type(C) is not Object, throw a TypeError exception.\n    if (!C.isObject) {\n      return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);\n    }\n\n    // 3. Let promiseCapability be ? NewPromiseCapability(C).\n    const promiseCapability = $NewPromiseCapability(ctx, C);\n    if (promiseCapability.isAbrupt) { return promiseCapability; }\n\n    // 4. Perform ? Call(promiseCapability.[[Reject]], undefined, « r »).\n    const $CallResult = $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(r));\n    if ($CallResult.isAbrupt) { return $CallResult; }\n\n    // 5. Return promiseCapability.[[Promise]].\n    return promiseCapability['[[Promise]]'] as $PromiseInstance; // TODO: verify if cast is safe\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.resolve\n// 25.6.4.5 Promise.resolve ( x )\nexport class $Promise_resolve extends $BuiltinFunction<'%Promise_resolve%'> {\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Promise_resolve%', functionPrototype);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [x]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (x === void 0) {\n      x = intrinsics.undefined;\n    }\n\n    // 1. Let C be the this value.\n    const C = thisArgument;\n\n    // 2. If Type(C) is not Object, throw a TypeError exception.\n    if (!C.isObject) {\n      return new $TypeError(realm, `Expected 'this' to be an object, but got: ${C}`);\n    }\n\n    // 3. Return ? PromiseResolve(C, x).\n    return $PromiseResolve(ctx, C, x);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise-resolve\n// 25.6.4.5.1 PromiseResolve ( C , x )\nexport function $PromiseResolve(\n  ctx: ExecutionContext,\n  C: $AnyObject,\n  x: $AnyNonEmpty,\n): $PromiseInstance | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(C) is Object.\n  // 2. If IsPromise(x) is true, then\n  if (x instanceof $PromiseInstance) {\n    // 2. a. Let xConstructor be ? Get(x, \"constructor\").\n    const xConstructor = x['[[Get]]'](ctx, intrinsics.$constructor, x);\n\n    // 2. b. If SameValue(xConstructor, C) is true, return x.\n    if (xConstructor.is(C)) {\n      return x;\n    }\n  }\n\n  // 3. Let promiseCapability be ? NewPromiseCapability(C).\n  const promiseCapability = $NewPromiseCapability(ctx, C);\n  if (promiseCapability.isAbrupt) { return promiseCapability; }\n\n  // 4. Perform ? Call(promiseCapability.[[Resolve]], undefined, « x »).\n  const $CallResult = $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(x));\n  if ($CallResult.isAbrupt) { return $CallResult; }\n\n  // 5. Return promiseCapability.[[Promise]].\n  return promiseCapability['[[Promise]]'] as $PromiseInstance; // TODO: verify if cast is safe\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-promise-prototype-object\n// #region 25.6.5 Properties of the Promise Prototype Object\n\nexport class $PromisePrototype extends $Object<'%PromisePrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch\n  // 25.6.5.1 Promise.prototype.catch ( onRejected )\n  public get catch(): $PromiseProto_catch {\n    return this.getProperty(this.realm['[[Intrinsics]]'].catch)['[[Value]]'] as $PromiseProto_catch;\n  }\n  public set catch(value: $PromiseProto_catch) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].catch, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.constructor\n  // 25.6.5.2 Promise.prototype.constructor\n  public get $constructor(): $PromiseConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $PromiseConstructor;\n  }\n  public set $constructor(value: $PromiseConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.finally\n  // 25.6.5.3 Promise.prototype.finally ( onFinally )\n  public get finally(): $PromiseProto_finally {\n    return this.getProperty(this.realm['[[Intrinsics]]'].finally)['[[Value]]'] as $PromiseProto_finally;\n  }\n  public set finally(value: $PromiseProto_finally) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].finally, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.prototype.then\n  // 25.6.5.4 Promise.prototype.then ( onFulfilled , onRejected )\n  public get then(): $PromiseProto_then {\n    return this.getProperty(this.realm['[[Intrinsics]]'].then)['[[Value]]'] as $PromiseProto_then;\n  }\n  public set then(value: $PromiseProto_then) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].then, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-promise.prototype-@@tostringtag\n  // 25.6.5.5 Promise.prototype [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'Promise'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'Promise'>;\n  }\n  public set '@@toStringTag'(value: $String<'Promise'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%PromisePrototype%', proto, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch\n// 25.6.5.1 Promise.prototype.catch ( onRejected )\nexport class $PromiseProto_catch extends $BuiltinFunction<'%PromiseProto_catch%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%PromiseProto_catch%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [onRejected]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (onRejected === void 0) {\n      onRejected = intrinsics.undefined;\n    }\n\n    // 1. Let promise be the this value.\n    const promise = thisArgument;\n\n    // 2. Return ? Invoke(promise, \"then\", « undefined, onRejected »).\n    return $Invoke(ctx, promise, intrinsics.then, new $List(intrinsics.undefined, onRejected)) as $AnyNonEmpty; // TODO: fix $Empty typings\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.prototype.finally\n// 25.6.5.3 Promise.prototype.finally ( onFinally )\nexport class $PromiseProto_finally extends $BuiltinFunction<'%PromiseProto_finally%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%PromiseProto_finally%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [onFinally]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (onFinally === void 0) {\n      onFinally = intrinsics.undefined;\n    }\n\n    // 1. Let promise be the this value.\n    const promise = thisArgument;\n\n    // 2. If Type(promise) is not Object, throw a TypeError exception.\n    if (!promise.isObject) {\n      return new $TypeError(realm, `Expected 'this' to be an object, but got: ${promise}`);\n    }\n\n    // 3. Let C be ? SpeciesConstructor(promise, %Promise%).\n    const C = $SpeciesConstructor(ctx, promise, intrinsics['%Promise%']);\n    if (C.isAbrupt) { return C; }\n\n    let thenFinally: $AnyNonEmpty;\n    let catchFinally: $AnyNonEmpty;\n\n    // 4. Assert: IsConstructor(C) is true.\n    // 5. If IsCallable(onFinally) is false, then\n    if (!onFinally.isFunction) {\n      // 5. a. Let thenFinally be onFinally.\n      thenFinally = onFinally;\n\n      // 5. b. Let catchFinally be onFinally.\n      catchFinally = onFinally;\n    }\n    // 6. Else,\n    else {\n      // 6. a. Let stepsThenFinally be the algorithm steps defined in Then Finally Functions.\n      // 6. b. Let thenFinally be CreateBuiltinFunction(stepsThenFinally, « [[Constructor]], [[OnFinally]] »).\n      // 6. c. Set thenFinally.[[Constructor]] to C.\n      // 6. d. Set thenFinally.[[OnFinally]] to onFinally.\n      thenFinally = new $ThenFinally(realm, C, onFinally);\n\n      // 6. e. Let stepsCatchFinally be the algorithm steps defined in Catch Finally Functions.\n      // 6. f. Let catchFinally be CreateBuiltinFunction(stepsCatchFinally, « [[Constructor]], [[OnFinally]] »).\n      // 6. g. Set catchFinally.[[Constructor]] to C.\n      // 6. h. Set catchFinally.[[OnFinally]] to onFinally.\n      catchFinally = new $CatchFinally(realm, C, onFinally);\n    }\n\n    // 7. Return ? Invoke(promise, \"then\", « thenFinally, catchFinally »).\n    return $Invoke(ctx, promise, intrinsics.then, new $List(thenFinally, catchFinally)) as $AnyNonEmpty; // TODO: fix typings $Empty shenanigans\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-thenfinallyfunctions\n// 25.6.5.3.1 Then Finally Functions\nexport class $ThenFinally extends $BuiltinFunction<'Then Finally'> {\n  public '[[Constructor]]': $Function;\n  public '[[OnFinally]]': $AnyNonEmpty;\n\n  public constructor(\n    realm: Realm,\n    constructor: $Function,\n    onFinally: $AnyNonEmpty,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'Then Finally', intrinsics['%FunctionPrototype%']);\n\n    this['[[Constructor]]'] = constructor;\n    this['[[OnFinally]]'] = onFinally;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Let onFinally be F.[[OnFinally]].\n    const onFinally = F['[[OnFinally]]'];\n\n    // 3. Assert: IsCallable(onFinally) is true.\n    // 4. Let result be ? Call(onFinally, undefined).\n    const result = $Call(ctx, onFinally, intrinsics.undefined, intrinsics.undefined);\n    if (result.isAbrupt) { return result; }\n\n    // 5. Let C be F.[[Constructor]].\n    const C = F['[[Constructor]]'];\n\n    // 6. Assert: IsConstructor(C) is true.\n    // 7. Let promise be ? PromiseResolve(C, result).\n    const promise = $PromiseResolve(ctx, C, result);\n    if (promise.isAbrupt) { return promise; }\n\n    // 8. Let valueThunk be equivalent to a function that returns value.\n    const valueThunk = new $ValueThunk(realm, value);\n\n    // 9. Return ? Invoke(promise, \"then\", « valueThunk »).\n    return $Invoke(ctx, promise, intrinsics.then, new $List(valueThunk)) as $AnyNonEmpty; // TODO: fix typings $Empty shenanigans\n  }\n}\n\nexport class $ValueThunk extends $BuiltinFunction<'ValueThunk'> {\n  public readonly value: $AnyNonEmpty;\n\n  public constructor(\n    realm: Realm,\n    value: $AnyNonEmpty,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'ValueThunk', intrinsics['%FunctionPrototype%']);\n\n    this.value = value;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    return this.value;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-catchfinallyfunctions\n// 25.6.5.3.2 Catch Finally Functions\nexport class $CatchFinally extends $BuiltinFunction<'Catch Finally'> {\n  public '[[Constructor]]': $Function;\n  public '[[OnFinally]]': $AnyNonEmpty;\n\n  public constructor(\n    realm: Realm,\n    constructor: $Function,\n    onFinally: $AnyNonEmpty,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'Catch Finally', intrinsics['%FunctionPrototype%']);\n\n    this['[[Constructor]]'] = constructor;\n    this['[[OnFinally]]'] = onFinally;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Let onFinally be F.[[OnFinally]].\n    const onFinally = F['[[OnFinally]]'];\n\n    // 3. Assert: IsCallable(onFinally) is true.\n    // 4. Let result be ? Call(onFinally, undefined).\n    const result = $Call(ctx, onFinally, intrinsics.undefined, intrinsics.undefined);\n    if (result.isAbrupt) { return result; }\n\n    // 5. Let C be F.[[Constructor]].\n    const C = F['[[Constructor]]'];\n\n    // 6. Assert: IsConstructor(C) is true.\n    // 7. Let promise be ? PromiseResolve(C, result).\n    const promise = $PromiseResolve(ctx, C, result);\n    if (promise.isAbrupt) { return promise; }\n\n    // 8. Let thrower be equivalent to a function that throws reason.\n    const thrower = new $Thrower(realm, value);\n\n    // 9. Return ? Invoke(promise, \"then\", « thrower »).\n    return $Invoke(ctx, promise, intrinsics.then, new $List(thrower)) as $AnyNonEmpty; // TODO: fix typings $Empty shenanigans\n  }\n}\n\nexport class $Thrower extends $BuiltinFunction<'Thrower'> {\n  public readonly reason: $AnyNonEmpty;\n\n  public constructor(\n    realm: Realm,\n    reason: $AnyNonEmpty,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'Thrower', intrinsics['%FunctionPrototype%']);\n\n    this.reason = reason;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // TODO: double check if this is the correct way to throw\n    return this.reason.ToCompletion(CompletionType.throw, ctx.Realm['[[Intrinsics]]'].empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-promise.prototype.then\n// 25.6.5.4 Promise.prototype.then ( onFulfilled , onRejected )\nexport class $PromiseProto_then extends $BuiltinFunction<'%PromiseProto_then%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%PromiseProto_then%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [onFulfilled, onRejected]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (onFulfilled === void 0) {\n      onFulfilled = intrinsics.undefined;\n    }\n    if (onRejected === void 0) {\n      onRejected = intrinsics.undefined;\n    }\n\n    // 1. Let promise be the this value.\n    const promise = thisArgument;\n\n    // 2. If IsPromise(promise) is false, throw a TypeError exception.\n    if (!promise.isObject) {\n      return new $TypeError(realm, `Expected 'this' to be an object, but got: ${promise}`);\n    }\n\n    // 3. Let C be ? SpeciesConstructor(promise, %Promise%).\n    const C = $SpeciesConstructor(ctx, promise, intrinsics['%Promise%']);\n    if (C.isAbrupt) { return C; }\n\n    // 4. Let resultCapability be ? NewPromiseCapability(C).\n    const resultCapability = $NewPromiseCapability(ctx, C);\n    if (resultCapability.isAbrupt) { return resultCapability; }\n\n    // 5. Return PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability).\n    return $PerformPromiseThen(\n      ctx,\n      // TODO: verify if this cast is safe\n      promise as $PromiseInstance,\n      onFulfilled,\n      onRejected,\n      resultCapability,\n    );\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-performpromisethen\n// 25.6.5.4.1 PerformPromiseThen ( promise , onFulfilled , onRejected [ , resultCapability ] )\nexport function $PerformPromiseThen(\n  ctx: ExecutionContext,\n  promise: $PromiseInstance,\n  onFulfilled: $AnyNonEmpty,\n  onRejected: $AnyNonEmpty,\n  resultCapability?: $PromiseCapability | $Undefined,\n): $PromiseInstance | $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: IsPromise(promise) is true.\n  // 2. If resultCapability is present, then\n  if (resultCapability !== void 0) {\n    // 2. a. Assert: resultCapability is a PromiseCapability Record.\n  }\n  // 3. Else,\n  else {\n    // 3. a. Set resultCapability to undefined.\n    resultCapability = intrinsics.undefined;\n  }\n\n  // 4. If IsCallable(onFulfilled) is false, then\n  if (!onFulfilled.isFunction) {\n    // 4. a. Set onFulfilled to undefined.\n    onFulfilled = intrinsics.undefined;\n  }\n\n  // 5. If IsCallable(onRejected) is false, then\n  if (!onRejected.isFunction) {\n    // 5. a. Set onRejected to undefined.\n    onRejected = intrinsics.undefined;\n  }\n\n  // 6. Let fulfillReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: \"Fulfill\", [[Handler]]: onFulfilled }.\n  const fulfillReaction = new $PromiseReaction(\n    resultCapability,\n    PromiseReactionType.Fulfill,\n    onFulfilled as $Function | $Undefined,\n  );\n\n  // 7. Let rejectReaction be the PromiseReaction { [[Capability]]: resultCapability, [[Type]]: \"Reject\", [[Handler]]: onRejected }.\n  const rejectReaction = new $PromiseReaction(\n    resultCapability,\n    PromiseReactionType.Reject,\n    onRejected as $Function | $Undefined,\n  );\n\n  // 8. If promise.[[PromiseState]] is \"pending\", then\n  if (promise['[[PromiseState]]'] === PromiseState.pending) {\n    // 8. a. Append fulfillReaction as the last element of the List that is promise.[[PromiseFulfillReactions]].\n    promise['[[PromiseFulfillReactions]]']!.push(fulfillReaction);\n\n    // 8. b. Append rejectReaction as the last element of the List that is promise.[[PromiseRejectReactions]].\n    promise['[[PromiseRejectReactions]]']!.push(rejectReaction);\n  }\n  // 9. Else if promise.[[PromiseState]] is \"fulfilled\", then\n  else if (promise['[[PromiseState]]'] === PromiseState.fulfilled) {\n    // 9. a. Let value be promise.[[PromiseResult]].\n    const value = promise['[[PromiseResult]]']!;\n\n    // 9. b. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « fulfillReaction, value »).\n    realm.PromiseJobs.EnqueueJob(ctx, new PromiseReactionJob(realm, ctx.ScriptOrModule as $$ESModuleOrScript, fulfillReaction, value));\n  }\n  // 10. Else,\n  else {\n    // 10. a. Assert: The value of promise.[[PromiseState]] is \"rejected\".\n    // 10. b. Let reason be promise.[[PromiseResult]].\n    const reason = promise['[[PromiseResult]]']!;\n\n    // 10. c. If promise.[[PromiseIsHandled]] is false, perform HostPromiseRejectionTracker(promise, \"handle\").\n    if (!promise['[[PromiseIsHandled]]']) {\n      $HostPromiseRejectionTracker(ctx, promise, PromiseRejectionOperation.handle);\n    }\n\n    // 10. d. Perform EnqueueJob(\"PromiseJobs\", PromiseReactionJob, « rejectReaction, reason »).\n    realm.PromiseJobs.EnqueueJob(ctx, new PromiseReactionJob(realm, ctx.ScriptOrModule as $$ESModuleOrScript, rejectReaction, reason));\n  }\n\n  // 11. Set promise.[[PromiseIsHandled]] to true.\n  promise['[[PromiseIsHandled]]'] = true;\n\n  // 12. If resultCapability is undefined, then\n  if (resultCapability === void 0 || resultCapability.isUndefined) {\n    // 12. a. Return undefined.\n    return intrinsics.undefined;\n  }\n  // 13. Else,\n  else {\n    // 13. a. Return resultCapability.[[Promise]].\n    return resultCapability['[[Promise]]'];\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-promise-instances\n// #region 25.6.6 Properties of Promise Instances\n\nexport const enum PromiseState {\n  pending = 1,\n  fulfilled = 2,\n  rejected = 3,\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-promise-instances\n// 25.6.6 Properties of Promise Instances\nexport class $PromiseInstance extends $Object<'PromiseInstance'> {\n  public '[[PromiseState]]': PromiseState;\n  public '[[PromiseResult]]': $AnyNonEmpty | undefined;\n  public '[[PromiseFulfillReactions]]': $List<$PromiseReaction> | undefined;\n  public '[[PromiseRejectReactions]]': $List<$PromiseReaction> | undefined;\n  public '[[PromiseIsHandled]]': boolean;\n\n  private constructor(\n    realm: Realm,\n    proto: $PromisePrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'PromiseInstance', proto, CompletionType.normal, intrinsics.empty);\n\n    // 4. Set promise.[[PromiseState]] to \"pending\".\n    this['[[PromiseState]]'] = PromiseState.pending;\n    this['[[PromiseResult]]'] = void 0;\n    // 5. Set promise.[[PromiseFulfillReactions]] to a new empty List.\n    this['[[PromiseFulfillReactions]]'] = new $List();\n    // 6. Set promise.[[PromiseRejectReactions]] to a new empty List.\n    this['[[PromiseRejectReactions]]'] = new $List();\n    // 7. Set promise.[[PromiseIsHandled]] to false.\n    this['[[PromiseIsHandled]]'] = false;\n  }\n\n  public static Create(\n    ctx: ExecutionContext,\n    NewTarget: $Function,\n  ): $PromiseInstance | $Error {\n    const proto = $GetPrototypeFromConstructor(ctx, NewTarget, '%PromisePrototype%');\n    if (proto.isAbrupt) { return proto; }\n\n    return new $PromiseInstance(ctx.Realm, proto);\n  }\n}\n\n// #endregion\n","import {\n  ExecutionContext,\n  Realm,\n} from '../realm.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Function,\n  $BuiltinFunction,\n} from '../types/function.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $AnyNonError,\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n  $AnyObject,\n  $Any,\n} from '../types/_shared.js';\nimport {\n  $CreateDataProperty,\n  $Call,\n  $DefinePropertyOrThrow,\n  $GetMethod,\n} from '../operations.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $TypeError,\n  $Error,\n} from '../types/error.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $NewPromiseCapability,\n  $PromiseCapability,\n  $IfAbruptRejectPromise,\n  $PromiseInstance,\n  $PromiseResolve,\n  $PerformPromiseThen,\n} from './promise.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-getiterator\nexport function $GetIterator(\n  ctx: ExecutionContext,\n  obj: $AnyNonEmptyNonError,\n  hint?: 'sync' | 'async',\n  method?: $Function | $Undefined,\n): $IteratorRecord | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. If hint is not present, set hint to sync.\n  if (hint === void 0) {\n    hint = 'sync';\n  }\n\n  // 2. Assert: hint is either sync or async.\n  // 3. If method is not present, then\n  if (method === void 0) {\n    // 3. a. If hint is async, then\n    if (hint === 'async') {\n      // 3. a. i. Set method to ? GetMethod(obj, @@asyncIterator).\n      const $method = $GetMethod(ctx, obj, intrinsics['@@asyncIterator']);\n      if ($method.isAbrupt) { return $method; }\n      method = $method;\n\n      // 3. a. ii. If method is undefined, then\n      if (method.isUndefined) {\n        // 3. a. ii. 1. Let syncMethod be ? GetMethod(obj, @@iterator).\n        const syncMethod = $GetMethod(ctx, obj, intrinsics['@@iterator']);\n        if (syncMethod.isAbrupt) { return syncMethod; }\n\n        // 3. a. ii. 2. Let syncIteratorRecord be ? GetIterator(obj, sync, syncMethod).\n        const syncIteratorRecord = $GetIterator(ctx, obj, 'sync', syncMethod);\n        if (syncIteratorRecord.isAbrupt) { return syncIteratorRecord; }\n\n        // 3. a. ii. 3. Return ? CreateAsyncFromSyncIterator(syncIteratorRecord).\n        return $CreateAsyncFromSyncIterator(ctx, syncIteratorRecord);\n      }\n    } else {\n      // 3. b. Otherwise, set method to ? GetMethod(obj, @@iterator).\n      const $method = $GetMethod(ctx, obj, intrinsics['@@iterator']);\n      if ($method.isAbrupt) { return $method; }\n      method = $method;\n    }\n  }\n\n  // 4. Let iterator be ? Call(method, obj).\n  const iterator = $Call(ctx, method as $Function, obj, intrinsics.undefined);\n  if (iterator.isAbrupt) { return iterator; }\n\n  // 5. If Type(iterator) is not Object, throw a TypeError exception.\n  if (!iterator.isObject) {\n    return new $TypeError(realm, `The iterator is ${iterator}, but expected an object`);\n  }\n\n  // 6. Let nextMethod be ? GetV(iterator, \"next\").\n  const nextMethod = iterator['[[Get]]'](ctx, intrinsics.next, iterator) as $Function | $Error;\n  if (nextMethod.isAbrupt) { return nextMethod; }\n\n  // 7. Let iteratorRecord be Record { [[Iterator]]: iterator, [[NextMethod]]: nextMethod, [[Done]]: false }.\n  const iteratorRecord = new $IteratorRecord(\n    /* [[Iterator]] */iterator,\n    /* [[NextMethod]] */nextMethod,\n    /* [[Done]] */intrinsics.false,\n  );\n\n  // 8. Return iteratorRecord.\n  return iteratorRecord;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-iteratornext\nexport function $IteratorNext(\n  ctx: ExecutionContext,\n  iteratorRecord: $IteratorRecord,\n  value?: $AnyNonEmpty,\n): $AnyObject | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  let result: $AnyNonEmpty;\n\n  // 1. If value is not present, then\n  if (value === void 0) {\n    // 1. a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « »).\n    const $result = $Call(ctx, iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], intrinsics.undefined);\n    if ($result.isAbrupt) { return $result; }\n    result = $result;\n  }\n  // 2. Else,\n  else {\n    // 2. a. Let result be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « value »).\n    const $result = $Call(ctx, iteratorRecord['[[NextMethod]]'], iteratorRecord['[[Iterator]]'], new $List(value));\n    if ($result.isAbrupt) { return $result; }\n    result = $result;\n  }\n\n  // 3. If Type(result) is not Object, throw a TypeError exception.\n  if (!result.isObject) {\n    return new $TypeError(ctx.Realm, `The iterator next result is ${result}, but expected an object`);\n  }\n\n  // 4. Return result.\n  return result;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-iteratorcomplete\nexport function $IteratorComplete(\n  ctx: ExecutionContext,\n  iterResult: $AnyObject,\n): $Boolean | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(iterResult) is Object.\n  // 2. Return ToBoolean(? Get(iterResult, \"done\")).\n  return iterResult['[[Get]]'](ctx, intrinsics.$done, iterResult).ToBoolean(ctx);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-iteratorvalue\nexport function $IteratorValue(\n  ctx: ExecutionContext,\n  iterResult: $AnyObject,\n): $AnyNonEmpty  {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(iterResult) is Object.\n  // 2. Return ? Get(iterResult, \"value\").\n  return iterResult['[[Get]]'](ctx, intrinsics.$value, iterResult);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-iteratorstep\nexport function $IteratorStep(\n  ctx: ExecutionContext,\n  iteratorRecord: $IteratorRecord,\n): $AnyObject | $Boolean<false> | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let result be ? IteratorNext(iteratorRecord).\n  const result = $IteratorNext(ctx, iteratorRecord);\n  if (result.isAbrupt) { return result; }\n\n  // 2. Let done be ? IteratorComplete(result).\n  const done = $IteratorComplete(ctx, result);\n  if (done.isAbrupt) { return done; }\n\n  // 3. If done is true, return false.\n  if (done.isTruthy) {\n    return intrinsics.false;\n  }\n\n  // 4. Return result.\n  return result;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-iteratorclose\nexport function $IteratorClose(\n  ctx: ExecutionContext,\n  iteratorRecord: $IteratorRecord,\n  completion: $Any,\n): $Any {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(iteratorRecord.[[Iterator]]) is Object.\n  // 2. Assert: completion is a Completion Record.\n  // 3. Let iterator be iteratorRecord.[[Iterator]].\n  const iterator = iteratorRecord['[[Iterator]]'];\n\n  // 4. Let return be ? GetMethod(iterator, \"return\").\n  const $return = iterator.GetMethod(ctx, intrinsics.$return);\n  if ($return.isAbrupt) { return $return; }\n\n  // 5. If return is undefined, return Completion(completion).\n  if ($return.isUndefined) {\n    return completion;\n  }\n\n  // 6. Let innerResult be Call(return, iterator, « »).\n  const innerResult = $Call(ctx, $return, iterator, intrinsics.undefined);\n\n  // 7. If completion.[[Type]] is throw, return Completion(completion).\n  if (completion['[[Type]]'] === CompletionType.throw) {\n    return completion;\n  }\n\n  // 8. If innerResult.[[Type]] is throw, return Completion(innerResult).\n  if (innerResult['[[Type]]'] === CompletionType.throw) {\n    return innerResult;\n  }\n\n  // 9. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.\n  if (!innerResult.isObject) {\n    return new $TypeError(realm, `The iterator close innerResult is ${innerResult}, but expected an object`);\n  }\n\n  // 10. Return Completion(completion).\n  return completion;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asynciteratorclose\nexport function $AsyncIteratorClose(\n  ctx: ExecutionContext,\n  iteratorRecord: $IteratorRecord,\n  completion: $AnyNonError,\n): $AnyNonError | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(iteratorRecord.[[Iterator]]) is Object.\n  // 2. Assert: completion is a Completion Record.\n  // 3. Let iterator be iteratorRecord.[[Iterator]].\n  const iterator = iteratorRecord['[[Iterator]]'];\n\n  // 4. Let return be ? GetMethod(iterator, \"return\").\n  const $return = iterator.GetMethod(ctx, intrinsics.$return);\n  if ($return.isAbrupt) { return $return; }\n\n  // 5. If return is undefined, return Completion(completion).\n  if ($return.isUndefined) {\n    return completion;\n  }\n\n  // 6. Let innerResult be Call(return, iterator, « »).\n  const innerResult = $Call(ctx, $return, iterator, intrinsics.undefined);\n\n  // 7. If innerResult.[[Type]] is normal, set innerResult to Await(innerResult.[[Value]]).\n  if (innerResult['[[Type]]'] === CompletionType.normal) {\n    // TODO: implement await\n    // http://www.ecma-international.org/ecma-262/#await\n    // 6.2.3.1 Await\n  }\n\n  // 8. If completion.[[Type]] is throw, return Completion(completion).\n  if (completion['[[Type]]'] === CompletionType.throw) {\n    return completion;\n  }\n\n  // 9. If innerResult.[[Type]] is throw, return Completion(innerResult).\n  if (innerResult['[[Type]]'] === CompletionType.throw) {\n    return innerResult;\n  }\n\n  // 10. If Type(innerResult.[[Value]]) is not Object, throw a TypeError exception.\n  if (!innerResult.isObject) {\n    return new $TypeError(realm, `The async iterator close innerResult is ${innerResult}, but expected an object`);\n  }\n\n  // 11. Return Completion(completion).\n  return completion;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createiterresultobject\nexport function $CreateIterResultObject(\n  ctx: ExecutionContext,\n  value: $AnyNonEmpty,\n  done: $Boolean,\n) {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: Type(done) is Boolean.\n  // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n  const obj = $Object.ObjectCreate(ctx, 'IterResultObject', intrinsics['%ObjectPrototype%']);\n\n  // 3. Perform CreateDataProperty(obj, \"value\", value).\n  $CreateDataProperty(ctx, obj, intrinsics.$value, value);\n\n  // 4. Perform CreateDataProperty(obj, \"done\", done).\n  $CreateDataProperty(ctx, obj, intrinsics.$done, done);\n\n  // 5. Return obj.\n  return obj;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createlistiteratorRecord\nexport function $CreateListIteratorRecord(\n  ctx: ExecutionContext,\n  list: $List<$AnyNonEmpty>,\n) {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let iterator be ObjectCreate(%IteratorPrototype%, « [[IteratedList]], [[ListIteratorNextIndex]] »).\n  // 4. Let steps be the algorithm steps defined in ListIterator next (7.4.9.1).\n  // 5. Let next be CreateBuiltinFunction(steps, « »).\n  // 6. Return Record { [[Iterator]]: iterator, [[NextMethod]]: next, [[Done]]: false }.\n  return new $IteratorRecord(\n    /* [[Iterator]] */new $ListIterator(realm, list),\n    /* [[NextMethod]] */new $ListIterator_next(realm),\n    /* [[Done]] */intrinsics.false,\n  );\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-listiterator-next\nexport class $ListIterator_next extends $BuiltinFunction<'ListIterator_next'> {\n  public constructor(\n    realm: Realm,\n  ) {\n    super(realm, 'ListIterator_next', realm['[[Intrinsics]]']['%FunctionPrototype%']);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let O be the this value.\n    const O = thisArgument as $ListIterator;\n\n    // 2. Assert: Type(O) is Object.\n    // 3. Assert: O has an [[IteratedList]] internal slot.\n    // 4. Let list be O.[[IteratedList]].\n    const list = O['[[IteratedList]]'];\n\n    // 5. Let index be O.[[ListIteratorNextIndex]].\n    const index = O['[[ListIteratorNextIndex]]'];\n\n    // 6. Let len be the number of elements of list.\n    const len = list.length;\n\n    // 7. If index ≥ len, then\n    if (index['[[Value]]'] >= len) {\n      // 7. a. Return CreateIterResultObject(undefined, true).\n      return $CreateIterResultObject(ctx, intrinsics.undefined, intrinsics.true);\n    }\n\n    // 8. Set O.[[ListIteratorNextIndex]] to index + 1.\n    O['[[ListIteratorNextIndex]]'] = new $Number(realm, index['[[Value]]'] + 1);\n\n    // 9. Return CreateIterResultObject(list[index], false).\n    return $CreateIterResultObject(ctx, list[index['[[Value]]']], intrinsics.false);\n  }\n}\n\nexport class $ListIterator extends $Object<'ListIterator'> {\n  public readonly '[[IteratedList]]': $List<$AnyNonEmpty>;\n  public '[[ListIteratorNextIndex]]': $Number;\n\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    realm: Realm,\n    list: $List<$AnyNonEmpty>,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    super(realm, 'ListIterator', intrinsics['%IteratorPrototype%'], CompletionType.normal, intrinsics.empty);\n\n    this['[[IteratedList]]'] = list;\n    this['[[ListIteratorNextIndex]]'] = new $Number(realm, 0);\n  }\n}\n\nexport class $IteratorRecord {\n  public readonly '[[Iterator]]': $AnyObject;\n  public readonly '[[NextMethod]]': $Function;\n  public '[[Done]]': $Boolean;\n\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    iterator: $AnyObject,\n    next: $Function,\n    done: $Boolean,\n  ) {\n    this['[[Iterator]]'] = iterator;\n    this['[[NextMethod]]'] = next;\n    this['[[Done]]'] = done;\n  }\n}\n\nexport class $AsyncFromSyncIterator extends $Object<'AsyncFromSyncIterator'> {\n  public readonly '[[SyncIteratorRecord]]': $IteratorRecord;\n\n  public constructor(\n    realm: Realm,\n    syncIteratorRecord: $IteratorRecord,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    // 1. Let asyncIterator be ! ObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).\n    super(realm, 'AsyncFromSyncIterator', intrinsics['%AsyncFromSyncIteratorPrototype%'], CompletionType.normal, intrinsics.empty);\n\n    // 2. Set asyncIterator.[[SyncIteratorRecord]] to syncIteratorRecord.\n    this['[[SyncIteratorRecord]]'] = syncIteratorRecord;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-%iteratorprototype%-@@iterator\n// 25.1.2.1 %IteratorPrototype% [ @@iterator ] ( )\nexport class $Symbol_Iterator extends $BuiltinFunction<'[Symbol.iterator]'> {\n  public constructor(\n    realm: Realm,\n  ) {\n    super(realm, '[Symbol.iterator]', realm['[[Intrinsics]]']['%FunctionPrototype%']);\n    this.SetFunctionName(realm.stack.top, new $String(realm, '[Symbol.iterator]'));\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // 1. Return the this value.\n    return thisArgument;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asynciteratorprototype-asynciterator\n// 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )\nexport class $Symbol_AsyncIterator extends $BuiltinFunction<'[Symbol.asyncIterator]'> {\n  public constructor(\n    realm: Realm,\n  ) {\n    super(realm, '[Symbol.asyncIterator]', realm['[[Intrinsics]]']['%FunctionPrototype%']);\n    this.SetFunctionName(realm.stack.top, new $String(realm, '[Symbol.asyncIterator]'));\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // 1. Return the this value.\n    return thisArgument;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-%iteratorprototype%-object\n// 25.1.2 The %IteratorPrototype% Object\nexport class $IteratorPrototype extends $Object<'%IteratorPrototype%'> {\n  public constructor(\n    realm: Realm,\n    proto: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%IteratorPrototype%', proto, CompletionType.normal, intrinsics.empty);\n\n    $DefinePropertyOrThrow(\n      realm.stack.top,\n      this,\n      intrinsics['@@iterator'],\n      new $PropertyDescriptor(\n        realm,\n        intrinsics['@@iterator'],\n        {\n          '[[Value]]': new $Symbol_Iterator(realm),\n        },\n      ),\n    );\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asynciteratorprototype\n// 25.1.3 The %AsyncIteratorPrototype% Object\nexport class $AsyncIteratorPrototype extends $Object<'%AsyncIteratorPrototype%'> {\n  public constructor(\n    realm: Realm,\n    proto: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%AsyncIteratorPrototype%', proto, CompletionType.normal, intrinsics.empty);\n\n    $DefinePropertyOrThrow(\n      realm.stack.top,\n      this,\n      intrinsics['@@asyncIterator'],\n      new $PropertyDescriptor(\n        realm,\n        intrinsics['@@asyncIterator'],\n        {\n          '[[Value]]': new $Symbol_AsyncIterator(realm),\n        },\n      ),\n    );\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-async-from-sync-iterator-objects\n// #region 25.1.4 Async-from-Sync Iterator Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-createasyncfromsynciterator\n// 25.1.4.1 CreateAsyncFromSyncIterator ( syncIteratorRecord )\nexport function $CreateAsyncFromSyncIterator(\n  ctx: ExecutionContext,\n  syncIteratorRecord: $IteratorRecord,\n): $IteratorRecord | $Error {\n  const realm = ctx.Realm;\n\n  // 1. Let asyncIterator be ! ObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).\n  // 2. Set asyncIterator.[[SyncIteratorRecord]] to syncIteratorRecord.\n  const asyncIterator = new $AsyncFromSyncIterator(realm, syncIteratorRecord);\n\n  // 3. Return ? GetIterator(asyncIterator, async).\n  return $GetIterator(ctx, asyncIterator, 'async');\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%-object\n// 25.1.4.2 The %AsyncFromSyncIteratorPrototype% Object\nexport class $AsyncFromSyncIteratorPrototype extends $Object<'%AsyncFromSyncIteratorPrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.next\n  // 25.1.4.2.1 %AsyncFromSyncIteratorPrototype%.next ( value )\n  public get next(): $AsyncFromSyncIteratorPrototype_next {\n    return this.getProperty(this.realm['[[Intrinsics]]'].next)['[[Value]]'] as $AsyncFromSyncIteratorPrototype_next;\n  }\n  public set next(value: $AsyncFromSyncIteratorPrototype_next) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].next, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.return\n  // 25.1.4.2.2 %AsyncFromSyncIteratorPrototype%.return ( value )\n  public get return(): $AsyncFromSyncIteratorPrototype_return {\n    return this.getProperty(this.realm['[[Intrinsics]]'].return)['[[Value]]'] as $AsyncFromSyncIteratorPrototype_return;\n  }\n  public set return(value: $AsyncFromSyncIteratorPrototype_return) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].return, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.throw\n  // 25.1.4.2.3 %AsyncFromSyncIteratorPrototype%.throw ( value )\n  public get throw(): $AsyncFromSyncIteratorPrototype_throw {\n    return this.getProperty(this.realm['[[Intrinsics]]'].throw)['[[Value]]'] as $AsyncFromSyncIteratorPrototype_throw;\n  }\n  public set throw(value: $AsyncFromSyncIteratorPrototype_throw) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].throw, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%-@@tostringtag\n  // 25.1.4.2.4 %AsyncFromSyncIteratorPrototype% [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'Async-from-Sync Iterator'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'Async-from-Sync Iterator'>;\n  }\n  public set '@@toStringTag'(value: $String<'Async-from-Sync Iterator'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    proto: $AsyncIteratorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%AsyncFromSyncIteratorPrototype%', proto, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.next\n// 25.1.4.2.1 %AsyncFromSyncIteratorPrototype%.next ( value )\nexport class $AsyncFromSyncIteratorPrototype_next extends $BuiltinFunction<'%AsyncFromSyncIteratorPrototype%.next'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%AsyncFromSyncIteratorPrototype%.next', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let O be the this value.\n    const O = thisArgument;\n\n    // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).\n    const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']) as $PromiseCapability;\n\n    // 3. If Type(O) is not Object, or if O does not have a [[SyncIteratorRecord]] internal slot, then\n    if (!(O instanceof $AsyncFromSyncIterator)) {\n      // 3. a. Let invalidIteratorError be a newly created TypeError object.\n      const invalidIteratorError = new $TypeError(realm, `Expected AsyncFromSyncIterator, but got: ${O}`);\n\n      // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « invalidIteratorError »).\n      $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(invalidIteratorError));\n\n      // 3. c. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 4. Let syncIteratorRecord be O.[[SyncIteratorRecord]].\n    const syncIteratorRecord = O['[[SyncIteratorRecord]]'];\n\n    // 5. Let result be IteratorNext(syncIteratorRecord, value).\n    const result = $IteratorNext(ctx, syncIteratorRecord, value);\n\n    // 6. IfAbruptRejectPromise(result, promiseCapability).\n    const $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, result, promiseCapability);\n    if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n    // 7. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability).\n    return $AsyncFromSyncIteratorContinuation(ctx, result as $AnyObject, promiseCapability);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.return\n// 25.1.4.2.2 %AsyncFromSyncIteratorPrototype%.return ( value )\nexport class $AsyncFromSyncIteratorPrototype_return extends $BuiltinFunction<'%AsyncFromSyncIteratorPrototype%.return'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%AsyncFromSyncIteratorPrototype%.return', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let O be the this value.\n    const O = thisArgument;\n\n    // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).\n    const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']) as $PromiseCapability;\n\n    // 3. If Type(O) is not Object, or if O does not have a [[SyncIteratorRecord]] internal slot, then\n    if (!(O instanceof $AsyncFromSyncIterator)) {\n      // 3. a. Let invalidIteratorError be a newly created TypeError object.\n      const invalidIteratorError = new $TypeError(realm, `Expected AsyncFromSyncIterator, but got: ${O}`);\n\n      // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « invalidIteratorError »).\n      $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(invalidIteratorError));\n\n      // 3. c. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 4. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]].\n    const syncIterator = O['[[SyncIteratorRecord]]']['[[Iterator]]'];\n\n    // 5. Let return be GetMethod(syncIterator, \"return\").\n    const $return = $GetMethod(ctx, syncIterator, intrinsics.return);\n\n    // 6. IfAbruptRejectPromise(return, promiseCapability).\n    let $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, $return, promiseCapability);\n    if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n    // 7. If return is undefined, then\n    if ($return.isUndefined) {\n      // 7. a. Let iterResult be ! CreateIterResultObject(value, true).\n      const iterResult = $CreateIterResultObject(ctx, value, intrinsics.true);\n\n      // 7. b. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iterResult »).\n      $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(iterResult));\n\n      // 7. c. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 8. Let result be Call(return, syncIterator, « value »).\n    const result = $Call(ctx, $return, syncIterator, new $List(value));\n\n    // 9. IfAbruptRejectPromise(result, promiseCapability).\n    $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, result, promiseCapability);\n    if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n    // 10. If Type(result) is not Object, then\n    if (!result.isObject) {\n      // 10. a. Perform ! Call(promiseCapability.[[Reject]], undefined, « a newly created TypeError object »).\n      const err = new $TypeError(realm, `Expected syncIterator return result to be an object, but got: ${result}`);\n      $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(err));\n\n      // 10. b. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 11. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability).\n    return $AsyncFromSyncIteratorContinuation(ctx, result, promiseCapability);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-%asyncfromsynciteratorprototype%.throw\n// 25.1.4.2.3 %AsyncFromSyncIteratorPrototype%.throw ( value )\nexport class $AsyncFromSyncIteratorPrototype_throw extends $BuiltinFunction<'%AsyncFromSyncIteratorPrototype%.throw'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%AsyncFromSyncIteratorPrototype%.throw', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let O be the this value.\n    const O = thisArgument;\n\n    // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).\n    const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']) as $PromiseCapability;\n\n    // 3. If Type(O) is not Object, or if O does not have a [[SyncIteratorRecord]] internal slot, then\n    if (!(O instanceof $AsyncFromSyncIterator)) {\n      // 3. a. Let invalidIteratorError be a newly created TypeError object.\n      const invalidIteratorError = new $TypeError(realm, `Expected AsyncFromSyncIterator, but got: ${O}`);\n\n      // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « invalidIteratorError »).\n      $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(invalidIteratorError));\n\n      // 3. c. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 4. Let syncIterator be O.[[SyncIteratorRecord]].[[Iterator]].\n    const syncIterator = O['[[SyncIteratorRecord]]']['[[Iterator]]'];\n\n    // 5. Let throw be GetMethod(syncIterator, \"throw\").\n    const $throw = $GetMethod(ctx, syncIterator, intrinsics.throw);\n\n    // 6. IfAbruptRejectPromise(throw, promiseCapability).\n    let $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, $throw, promiseCapability);\n    if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n    // 7. If throw is undefined, then\n    if ($throw.isUndefined) {\n      // 7. a. Perform ! Call(promiseCapability.[[Reject]], undefined, « value »).\n      $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(value));\n\n      // 7. b. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 8. Let result be Call(throw, syncIterator, « value »).\n    const result = $Call(ctx, $throw, syncIterator, new $List(value));\n\n    // 9. IfAbruptRejectPromise(result, promiseCapability).\n    $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, result, promiseCapability);\n    if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n    // 10. If Type(result) is not Object, then\n    if (!result.isObject) {\n      // 10. a. Perform ! Call(promiseCapability.[[Reject]], undefined, « a newly created TypeError object »).\n      const err = new $TypeError(realm, `Expected syncIterator return result to be an object, but got: ${result}`);\n      $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(err));\n\n      // 10. b. Return promiseCapability.[[Promise]].\n      return promiseCapability['[[Promise]]'];\n    }\n\n    // 11. Return ! AsyncFromSyncIteratorContinuation(result, promiseCapability).\n    return $AsyncFromSyncIteratorContinuation(ctx, result, promiseCapability);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-async-from-sync-iterator-value-unwrap-functions\n// 25.1.4.2.5 Async-from-Sync Iterator Value Unwrap Functions\nexport class $AsyncFromSyncIterator_Value_Unwrap extends $BuiltinFunction<'Async-from-Sync Iterator Value Unwrap'> {\n  public '[[Done]]': $Boolean;\n\n  public constructor(\n    realm: Realm,\n    done: $Boolean,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'Async-from-Sync Iterator Value Unwrap', intrinsics['%FunctionPrototype%']);\n\n    this['[[Done]]'] = done;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Return ! CreateIterResultObject(value, F.[[Done]]).\n    return $CreateIterResultObject(ctx, value, F['[[Done]]']);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-async-from-sync-iterator-instances\n// 25.1.4.3 Properties of Async-from-Sync Iterator Instances\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncfromsynciteratorcontinuation\n// 25.1.4.4 AsyncFromSyncIteratorContinuation ( result , promiseCapability )\nexport function $AsyncFromSyncIteratorContinuation(\n  ctx: ExecutionContext,\n  result: $AnyObject,\n  promiseCapability: $PromiseCapability,\n): $PromiseInstance | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let done be IteratorComplete(result).\n  const done = $IteratorComplete(ctx, result);\n\n  // 2. IfAbruptRejectPromise(done, promiseCapability).\n  let $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, done, promiseCapability);\n  if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n  // 3. Let value be IteratorValue(result).\n  const value = $IteratorValue(ctx, result);\n\n  // 4. IfAbruptRejectPromise(value, promiseCapability).\n  $IfAbruptRejectPromiseResult = $IfAbruptRejectPromise(ctx, value, promiseCapability);\n  if ($IfAbruptRejectPromiseResult.isAbrupt) { return $IfAbruptRejectPromiseResult; }\n\n  // 5. Let valueWrapper be ? PromiseResolve(%Promise%, « value »).\n  const valueWrapper = $PromiseResolve(ctx, intrinsics['%Promise%'], new $List(value) as unknown as $AnyNonEmpty); // TODO: fix types\n  if (valueWrapper.isAbrupt) { return valueWrapper; }\n\n  // 6. Let steps be the algorithm steps defined in Async-from-Sync Iterator Value Unwrap Functions.\n  // 7. Let onFulfilled be CreateBuiltinFunction(steps, « [[Done]] »).\n  // 8. Set onFulfilled.[[Done]] to done.\n  const onFulfilled = new $AsyncFromSyncIterator_Value_Unwrap(realm, done as $Boolean);\n\n  // 9. Perform ! PerformPromiseThen(valueWrapper, onFulfilled, undefined, promiseCapability).\n  $PerformPromiseThen(ctx, valueWrapper, onFulfilled, intrinsics.undefined, promiseCapability);\n\n  // 10. Return promiseCapability.[[Promise]].\n  return promiseCapability['[[Promise]]'] as $PromiseInstance;\n}\n\n// #endregion\n","import {\n  $Object,\n} from '../types/object.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $DefinePropertyOrThrow,\n  $ValidateAndApplyPropertyDescriptor,\n} from '../operations.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $PropertyKey,\n  $AnyObject,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects\nexport class $StringExoticObject extends $Object<'StringExoticObject'> {\n  public readonly '[[StringData]]': $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-stringcreate\n  // 9.4.3.4 StringCreate ( value , prototype )\n  public constructor(\n    realm: Realm,\n    value: $String,\n    proto: $AnyObject,\n  ) {\n    super(realm, 'StringExoticObject', proto, CompletionType.normal, realm['[[Intrinsics]]'].empty);\n\n    // 1. Assert: Type(value) is String.\n    // 2. Let S be a newly created String exotic object.\n    // 3. Set S.[[StringData]] to value.\n    this['[[StringData]]'] = value;\n\n    // 4. Set S's essential internal methods to the default ordinary object definitions specified in 9.1.\n    // 5. Set S.[[GetOwnProperty]] as specified in 9.4.3.1.\n    // 6. Set S.[[DefineOwnProperty]] as specified in 9.4.3.2.\n    // 7. Set S.[[OwnPropertyKeys]] as specified in 9.4.3.3.\n    // 8. Set S.[[Prototype]] to prototype.\n    // 9. Set S.[[Extensible]] to true.\n    // 10. Let length be the number of code unit elements in value.\n    const length = value['[[Value]]'].length;\n\n    // 11. Perform ! DefinePropertyOrThrow(S, \"length\", PropertyDescriptor { [[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }).\n    $DefinePropertyOrThrow(\n      realm.stack.top,\n      this,\n      realm['[[Intrinsics]]'].length,\n      new $PropertyDescriptor(\n        realm,\n        realm['[[Intrinsics]]'].length,\n        {\n          '[[Value]]': new $Number(realm, length),\n          '[[Writable]]': realm['[[Intrinsics]]'].false,\n          '[[Enumerable]]': realm['[[Intrinsics]]'].false,\n          '[[Configurable]]': realm['[[Intrinsics]]'].false,\n        },\n      ),\n    );\n\n    // 12. Return S.\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects-getownproperty-p\n  // 9.4.3.1 [[GetOwnProperty]] ( P )\n  public '[[GetOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $PropertyDescriptor | $Undefined {\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. Let desc be OrdinaryGetOwnProperty(S, P).\n    const desc = super['[[GetOwnProperty]]'](ctx, P) as $PropertyDescriptor | $Undefined;\n\n    // 3. If desc is not undefined, return desc.\n    if (!desc.isUndefined) {\n      return desc;\n    }\n\n    // 4. Return ! StringGetOwnProperty(S, P).\n    return $StringGetOwnProperty(ctx, this, P);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects-defineownproperty-p-desc\n  // 9.4.3.2 [[DefineOwnProperty]] ( P , Desc )\n  public '[[DefineOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Desc: $PropertyDescriptor,\n  ): $Boolean {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. Let stringDesc be ! StringGetOwnProperty(S, P).\n    const stringDesc = $StringGetOwnProperty(ctx, this, P);\n\n    // 3. If stringDesc is not undefined, then\n    if (!stringDesc.isUndefined) {\n      // 3. a. Let extensible be S.[[Extensible]].\n      const extensible = this['[[Extensible]]'];\n\n      // 3. b. Return ! IsCompatiblePropertyDescriptor(extensible, Desc, stringDesc).\n      return $ValidateAndApplyPropertyDescriptor(\n        ctx,\n        /* O */intrinsics.undefined,\n        /* P */intrinsics.undefined,\n        /* extensible */extensible,\n        /* Desc */Desc,\n        /* current */stringDesc,\n      );\n    }\n\n    // 4. Return ! OrdinaryDefineOwnProperty(S, P, Desc).\n    return super['[[DefineOwnProperty]]'](ctx, P, Desc) as $Boolean;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-string-exotic-objects-ownpropertykeys\n  // 9.4.3.3 [[OwnPropertyKeys]] ( )\n  public '[[OwnPropertyKeys]]'(\n    ctx: ExecutionContext,\n  ): $List<$PropertyKey> {\n    const realm = ctx.Realm;\n\n    // 1. Let keys be a new empty List.\n    const keys = new $List<$PropertyKey>();\n\n    // 2. Let str be O.[[StringData]].\n    const str = this['[[StringData]]'];\n\n    // 3. Assert: Type(str) is String.\n    // 4. Let len be the length of str.\n    const len = str['[[Value]]'].length;\n    let i = 0;\n    let keysLen = 0;\n\n    // 5. For each integer i starting with 0 such that i < len, in ascending order, do\n    for (; i < len; ++i) {\n      // 5. a. Add ! ToString(i) as the last element of keys.\n      keys[keysLen++] = new $String(realm, i.toString());\n    }\n\n    // 6. For each own property key P of O such that P is an array index and ToInteger(P) ≥ len, in ascending numeric index order, do\n    // 6. a. Add P as the last element of keys.\n    // 7. For each own property key P of O such that Type(P) is String and P is not an array index, in ascending chronological order of property creation, do\n    // 7. a. Add P as the last element of keys.\n    // 8. For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, do\n    // 8. a. Add P as the last element of keys.\n    // 9. Return keys.\n    return keys;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-stringgetownproperty\nfunction $StringGetOwnProperty(\n  ctx: ExecutionContext,\n  S: $StringExoticObject,\n  P: $PropertyKey,\n): $PropertyDescriptor | $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: S is an Object that has a [[StringData]] internal slot.\n  // 2. Assert: IsPropertyKey(P) is true.\n  // 3. If Type(P) is not String, return undefined.\n  if (!P.isString) {\n    return intrinsics.undefined;\n  }\n\n  // 4. Let index be ! CanonicalNumericIndexString(P).\n  const index = P.CanonicalNumericIndexString(ctx);\n\n  // 5. If index is undefined, return undefined.\n  if (index.isUndefined) {\n    return intrinsics.undefined;\n  }\n\n  // 6. If IsInteger(index) is false, return undefined.\n  if (!index.IsInteger) {\n    return intrinsics.undefined;\n  }\n\n  // 7. If index = -0, return undefined.\n  if (index.is(intrinsics['-0'])) {\n    return intrinsics.undefined;\n  }\n\n  // 8. Let str be S.[[StringData]].\n  const str = S['[[StringData]]'];\n\n  // 9. Assert: Type(str) is String.\n  // 10. Let len be the length of str.\n  const len = str['[[Value]]'].length;\n\n  // 11. If index < 0 or len ≤ index, return undefined.\n  if (index['[[Value]]'] < 0 || len <= index['[[Value]]']) {\n    return intrinsics.undefined;\n  }\n\n  // 12. Let resultStr be the String value of length 1, containing one code unit from str, specifically the code unit at index index.\n  const resultStr = new $String(realm, str['[[Value]]'][index['[[Value]]']]);\n\n  // 13. Return a PropertyDescriptor { [[Value]]: resultStr, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.\n  return new $PropertyDescriptor(\n    realm,\n    P,\n    {\n      '[[Value]]': resultStr,\n      '[[Writable]]': intrinsics.false,\n      '[[Enumerable]]': intrinsics.true,\n      '[[Configurable]]': intrinsics.false,\n    },\n  );\n}\n","import {\n  $BuiltinFunction,\n  $GetPrototypeFromConstructor,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  CompletionType,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $StringExoticObject,\n} from '../exotics/string.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-string-constructor\nexport class $StringConstructor extends $BuiltinFunction<'%String%'> {\n  public get $prototype(): $StringPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $StringPrototype;\n  }\n  public set $prototype(value: $StringPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%String%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-string-constructor-string-value\n  // 21.1.1.1 String ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    let s: $String;\n\n    // 1. If no arguments were passed to this function invocation, let s be \"\".\n    if (argumentsList.length === 0) {\n      s = new $String(realm, '');\n    }\n    // 2. Else,\n    else {\n      const [value] = argumentsList;\n\n      // 2. a. If NewTarget is undefined and Type(value) is Symbol, return SymbolDescriptiveString(value).\n      if (NewTarget.isUndefined && value.isSymbol) {\n        // TODO: implement this\n      }\n\n      // 2. b. Let s be ? ToString(value).\n      const $s = value.ToString(ctx);\n      if ($s.isAbrupt) { return $s; }\n\n      s = $s;\n    }\n\n    // 3. If NewTarget is undefined, return s.\n    if (NewTarget.isUndefined) {\n      return s;\n    }\n\n    // 4. Return ! StringCreate(s, ? GetPrototypeFromConstructor(NewTarget, \"%StringPrototype%\")).\n    const proto = $GetPrototypeFromConstructor(ctx, NewTarget, '%StringPrototype%');\n    if (proto.isAbrupt) { return proto; }\n\n    return new $StringExoticObject(realm, s, proto);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-string-prototype-object\nexport class $StringPrototype extends $Object<'%StringPrototype%'> {\n  public get $constructor(): $StringConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $StringConstructor;\n  }\n  public set $constructor(value: $StringConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public '[[StringData]]': $String;\n\n  public constructor(\n    realm: Realm,\n    objectPrototype: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%StringPrototype%', objectPrototype, CompletionType.normal, intrinsics.empty);\n\n    this['[[StringData]]'] = new $String(realm, '');\n  }\n}\n\nexport class $StringSet {\n  private readonly arr: $String[] = [];\n  private readonly map: Map<string, number> = new Map();\n\n  public has(item: $String): boolean {\n    return this.map.has(item['[[Value]]']);\n  }\n\n  public add(item: $String): void {\n    const arr = this.arr;\n    const map = this.map;\n    const value = item['[[Value]]'];\n\n    let idx = map.get(value);\n    if (idx === void 0) {\n      arr[idx = arr.length] = item;\n      map.set(value, idx);\n    } else {\n      arr[idx] = item;\n    }\n  }\n\n  public [Symbol.iterator](): IterableIterator<$String> {\n    return this.arr[Symbol.iterator]();\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n  $OrdinaryCreateFromConstructor,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $StringExoticObject,\n} from '../exotics/string.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-object-constructor\n// #region 19.1.1 The Object Constructor\nexport class $ObjectConstructor extends $BuiltinFunction<'%Object%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype\n  // 19.1.2.19 Object.prototype\n  public get $prototype(): $ObjectPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $ObjectPrototype;\n  }\n  public set $prototype(value: $ObjectPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.assign\n  // 19.1.2.1 Object.assign ( target , ... sources )\n  public get $assign(): $Object_assign {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$assign)['[[Value]]'] as $Object_assign;\n  }\n  public set $assign(value: $Object_assign) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$assign, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.create\n  // 19.1.2.2 Object.create ( O , Properties )\n  public get $create(): $Object_create {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$create)['[[Value]]'] as $Object_create;\n  }\n  public set $create(value: $Object_create) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$create, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.defineproperties\n  // 19.1.2.3 Object.defineProperties ( O , Properties )\n  public get $defineProperties(): $Object_defineProperties {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$defineProperties)['[[Value]]'] as $Object_defineProperties;\n  }\n  public set $defineProperties(value: $Object_defineProperties) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$defineProperties, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.defineproperty\n  // 19.1.2.4 Object.defineProperty ( O , P , Attributes )\n  public get $defineProperty(): $Object_defineProperty {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$defineProperty)['[[Value]]'] as $Object_defineProperty;\n  }\n  public set $defineProperty(value: $Object_defineProperty) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$defineProperty, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.entries\n  // 19.1.2.5 Object.entries ( O )\n  public get $entries(): $Object_entries {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$entries)['[[Value]]'] as $Object_entries;\n  }\n  public set $entries(value: $Object_entries) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$entries, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.freeze\n  // 19.1.2.6 Object.freeze ( O )\n  public get $freeze(): $Object_freeze {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$freeze)['[[Value]]'] as $Object_freeze;\n  }\n  public set $freeze(value: $Object_freeze) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$freeze, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.fromentries\n  // 19.1.2.7 Object.fromEntries ( iterable )\n  public get $fromEntries(): $Object_fromEntries {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$fromEntries)['[[Value]]'] as $Object_fromEntries;\n  }\n  public set $fromEntries(value: $Object_fromEntries) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$fromEntries, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptor\n  // 19.1.2.8 Object.getOwnPropertyDescriptor ( O , P )\n  public get $getOwnPropertyDescriptor(): $Object_getOwnPropertyDescriptor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor)['[[Value]]'] as $Object_getOwnPropertyDescriptor;\n  }\n  public set $getOwnPropertyDescriptor(value: $Object_getOwnPropertyDescriptor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptors\n  // 19.1.2.9 Object.getOwnPropertyDescriptors ( O )\n  public get $getOwnPropertyDescriptors(): $Object_getOwnPropertyDescriptors {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptors)['[[Value]]'] as $Object_getOwnPropertyDescriptors;\n  }\n  public set $getOwnPropertyDescriptors(value: $Object_getOwnPropertyDescriptors) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptors, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertynames\n  // 19.1.2.10 Object.getOwnPropertyNames ( O )\n  public get $getOwnPropertyNames(): $Object_getOwnPropertyNames {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyNames)['[[Value]]'] as $Object_getOwnPropertyNames;\n  }\n  public set $getOwnPropertyNames(value: $Object_getOwnPropertyNames) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyNames, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.getownpropertysymbols\n  // 19.1.2.11 Object.getOwnPropertySymbols ( O )\n  public get $getOwnPropertySymbols(): $Object_getOwnPropertySymbols {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertySymbols)['[[Value]]'] as $Object_getOwnPropertySymbols;\n  }\n  public set $getOwnPropertySymbols(value: $Object_getOwnPropertySymbols) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertySymbols, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.getprototypeof\n  // 19.1.2.12 Object.getPrototypeOf ( O )\n  public get $getPrototypeOf(): $Object_getPrototypeOf {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf)['[[Value]]'] as $Object_getPrototypeOf;\n  }\n  public set $getPrototypeOf(value: $Object_getPrototypeOf) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.is\n  // 19.1.2.13 Object.is ( value1 , value2 )\n  public get $is(): $Object_is {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$is)['[[Value]]'] as $Object_is;\n  }\n  public set $is(value: $Object_is) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$is, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.isextensible\n  // 19.1.2.14 Object.isExtensible ( O )\n  public get $isExtensible(): $Object_isExtensible {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$isExtensible)['[[Value]]'] as $Object_isExtensible;\n  }\n  public set $isExtensible(value: $Object_isExtensible) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$isExtensible, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.isfrozen\n  // 19.1.2.15 Object.isFrozen ( O )\n  public get $isFrozen(): $Object_isFrozen {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$isFrozen)['[[Value]]'] as $Object_isFrozen;\n  }\n  public set $isFrozen(value: $Object_isFrozen) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$isFrozen, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.issealed\n  // 19.1.2.16 Object.isSealed ( O )\n  public get $isSealed(): $Object_isSealed {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$isSealed)['[[Value]]'] as $Object_isSealed;\n  }\n  public set $isSealed(value: $Object_isSealed) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$isSealed, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.keys\n  // 19.1.2.17 Object.keys ( O )\n  public get $keys(): $Object_keys {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$keys)['[[Value]]'] as $Object_keys;\n  }\n  public set $keys(value: $Object_keys) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$keys, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.preventextensions\n  // 19.1.2.18 Object.preventExtensions ( O )\n  public get $preventExtensions(): $Object_preventExtensions {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$preventExtensions)['[[Value]]'] as $Object_preventExtensions;\n  }\n  public set $preventExtensions(value: $Object_preventExtensions) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$preventExtensions, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.seal\n  // 19.1.2.20 Object.seal ( O )\n  public get $seal(): $Object_seal {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$seal)['[[Value]]'] as $Object_seal;\n  }\n  public set $seal(value: $Object_seal) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$seal, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.setprototypeof\n  // 19.1.2.21 Object.setPrototypeOf ( O , proto )\n  public get $setPrototypeOf(): $Object_setPrototypeOf {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf)['[[Value]]'] as $Object_setPrototypeOf;\n  }\n  public set $setPrototypeOf(value: $Object_setPrototypeOf) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.values\n  // 19.1.2.22 Object.values ( O )\n  public get $values(): $Object_values {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$values)['[[Value]]'] as $Object_values;\n  }\n  public set $values(value: $Object_values) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$values, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Object%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-value\n  // 19.1.1.1 Object ( [ value ] )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is neither undefined nor the active function, then\n    if (!NewTarget.isUndefined && NewTarget !== this) {\n      // 1. a. Return ? OrdinaryCreateFromConstructor(NewTarget, \"%ObjectPrototype%\").\n      return $OrdinaryCreateFromConstructor(ctx, NewTarget, '%ObjectPrototype%');\n    }\n\n    // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).\n    if (value === void 0 || value.isNil) {\n      return $Object.ObjectCreate(ctx, 'Object', intrinsics['%ObjectPrototype%']);\n    }\n\n    // 3. Return ! ToObject(value).\n    return value.ToObject(ctx);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.assign\n// 19.1.2.1 Object.assign ( target , ... sources )\nexport class $Object_assign extends $BuiltinFunction<'Object.assign'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.assign', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let to be ? ToObject(target).\n    // 2. If only one argument was passed, return to.\n    // 3. Let sources be the List of argument values starting with the second argument.\n    // 4. For each element nextSource of sources, in ascending index order, do\n      // 4. a. If nextSource is neither undefined nor null, then\n        // 4. a. i. Let from be ! ToObject(nextSource).\n        // 4. a. ii. Let keys be ? from.[[OwnPropertyKeys]]().\n        // 4. a. iii. For each element nextKey of keys in List order, do\n          // 4. a. iii. 1. Let desc be ? from.[[GetOwnProperty]](nextKey).\n          // 4. a. iii. 2. If desc is not undefined and desc.[[Enumerable]] is true, then\n            // 4. a. iii. 2. a. Let propValue be ? Get(from, nextKey).\n            // 4. a. iii. 2. b. Perform ? Set(to, nextKey, propValue, true).\n    // 5. Return to.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.create\n// 19.1.2.2 Object.create ( O , Properties )\nexport class $Object_create extends $BuiltinFunction<'Object.create'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.create', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is neither Object nor Null, throw a TypeError exception.\n    // 2. Let obj be ObjectCreate(O).\n    // 3. If Properties is not undefined, then\n      // 3. a. Return ? ObjectDefineProperties(obj, Properties).\n    // 4. Return obj.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.defineproperties\n// 19.1.2.3 Object.defineProperties ( O , Properties )\nexport class $Object_defineProperties extends $BuiltinFunction<'Object.defineProperties'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.defineProperties', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Return ? ObjectDefineProperties(O, Properties).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-objectdefineproperties\n// 19.1.2.3.1 Runtime Semantics: ObjectDefineProperties ( O , Properties )\nexport function $ObjectDefineProperties(\n  ctx: ExecutionContext,\n  O: any,\n  Properties: any,\n): any {\n  // 1. If Type(O) is not Object, throw a TypeError exception.\n  // 2. Let props be ? ToObject(Properties).\n  // 3. Let keys be ? props.[[OwnPropertyKeys]]().\n  // 4. Let descriptors be a new empty List.\n  // 5. For each element nextKey of keys in List order, do\n    // 5. a. Let propDesc be ? props.[[GetOwnProperty]](nextKey).\n    // 5. b. If propDesc is not undefined and propDesc.[[Enumerable]] is true, then\n      // 5. b. i. Let descObj be ? Get(props, nextKey).\n      // 5. b. ii. Let desc be ? ToPropertyDescriptor(descObj).\n      // 5. b. iii. Append the pair (a two element List) consisting of nextKey and desc to the end of descriptors.\n  // 6. For each pair from descriptors in list order, do\n    // 6. a. Let P be the first element of pair.\n    // 6. b. Let desc be the second element of pair.\n    // 6. c. Perform ? DefinePropertyOrThrow(O, P, desc).\n  // 7. Return O.\n\n  throw new Error('Method not implemented.');\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.defineproperty\n// 19.1.2.4 Object.defineProperty ( O , P , Attributes )\nexport class $Object_defineProperty extends $BuiltinFunction<'Object.defineProperty'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.defineProperty', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, throw a TypeError exception.\n    // 2. Let key be ? ToPropertyKey(P).\n    // 3. Let desc be ? ToPropertyDescriptor(Attributes).\n    // 4. Perform ? DefinePropertyOrThrow(O, key, desc).\n    // 5. Return O.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.entries\n// 19.1.2.5 Object.entries ( O )\nexport class $Object_entries extends $BuiltinFunction<'Object.entries'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.entries', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let obj be ? ToObject(O).\n    // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, \"key+value\").\n    // 3. Return CreateArrayFromList(nameList).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.freeze\n// 19.1.2.6 Object.freeze ( O )\nexport class $Object_freeze extends $BuiltinFunction<'Object.freeze'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.freeze', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, return O.\n    // 2. Let status be ? SetIntegrityLevel(O, \"frozen\").\n    // 3. If status is false, throw a TypeError exception.\n    // 4. Return O.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.fromentries\n// 19.1.2.7 Object.fromEntries ( iterable )\nexport class $Object_fromEntries extends $BuiltinFunction<'Object.fromEntries'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.fromEntries', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Perform ? RequireObjectCoercible(iterable).\n    // 2. Let obj be ObjectCreate(%ObjectPrototype%).\n    // 3. Assert: obj is an extensible ordinary object with no own properties.\n    // 4. Let stepsDefine be the algorithm steps defined in CreateDataPropertyOnObject Functions.\n    // 5. Let adder be CreateBuiltinFunction(stepsDefine, « »).\n    // 6. Return ? AddEntriesFromIterable(obj, iterable, adder).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-create-data-property-on-object-functions\n// 19.1.2.7.1 CreateDataPropertyOnObject Functions\nexport class $CreateDataPropertyOnObject extends $BuiltinFunction<'CreateDataPropertyOnObject'> {\n  public constructor(\n    realm: Realm,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'CreateDataPropertyOnObject', intrinsics['%FunctionPrototype%']);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n    // 1. Let O be the this value.\n    // 2. Assert: Type(O) is Object.\n    // 3. Assert: O is an extensible ordinary object.\n    // 4. Let propertyKey be ? ToPropertyKey(key).\n    // 5. Perform ! CreateDataPropertyOrThrow(O, propertyKey, value).\n    // 6. Return undefined.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptor\n// 19.1.2.8 Object.getOwnPropertyDescriptor ( O , P )\nexport class $Object_getOwnPropertyDescriptor extends $BuiltinFunction<'Object.getOwnPropertyDescriptor'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.getOwnPropertyDescriptor', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let obj be ? ToObject(O).\n    // 2. Let key be ? ToPropertyKey(P).\n    // 3. Let desc be ? obj.[[GetOwnProperty]](key).\n    // 4. Return FromPropertyDescriptor(desc).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertydescriptors\n// 19.1.2.9 Object.getOwnPropertyDescriptors ( O )\nexport class $Object_getOwnPropertyDescriptors extends $BuiltinFunction<'Object.getOwnPropertyDescriptors'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.getOwnPropertyDescriptors', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let obj be ? ToObject(O).\n    // 2. Let ownKeys be ? obj.[[OwnPropertyKeys]]().\n    // 3. Let descriptors be ! ObjectCreate(%ObjectPrototype%).\n    // 4. For each element key of ownKeys in List order, do\n      // 4. a. Let desc be ? obj.[[GetOwnProperty]](key).\n      // 4. b. Let descriptor be ! FromPropertyDescriptor(desc).\n      // 4. c. If descriptor is not undefined, perform ! CreateDataProperty(descriptors, key, descriptor).\n    // 5. Return descriptors.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertynames\n// 19.1.2.10 Object.getOwnPropertyNames ( O )\nexport class $Object_getOwnPropertyNames extends $BuiltinFunction<'Object.getOwnPropertyNames'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.getOwnPropertyNames', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Return ? GetOwnPropertyKeys(O, String).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.getownpropertysymbols\n// 19.1.2.11 Object.getOwnPropertySymbols ( O )\nexport class $Object_getOwnPropertySymbols extends $BuiltinFunction<'Object.getOwnPropertySymbols'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.getOwnPropertySymbols', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Return ? GetOwnPropertyKeys(O, Symbol).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getownpropertykeys\n// 19.1.2.11.1 Runtime Semantics: GetOwnPropertyKeys ( O , type )\nexport function $GetOwnPropertyKeys(\n  ctx: ExecutionContext,\n  O: any,\n  type: any,\n): any {\n  // 1. Let obj be ? ToObject(O).\n  // 2. Let keys be ? obj.[[OwnPropertyKeys]]().\n  // 3. Let nameList be a new empty List.\n  // 4. For each element nextKey of keys in List order, do\n    // 4. a. If Type(nextKey) is type, then\n      // 4. a. i. Append nextKey as the last element of nameList.\n  // 5. Return CreateArrayFromList(nameList).\n\n  throw new Error('Method not implemented.');\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.getprototypeof\n// 19.1.2.12 Object.getPrototypeOf ( O )\nexport class $Object_getPrototypeOf extends $BuiltinFunction<'Object.getPrototypeOf'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.getPrototypeOf', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let obj be ? ToObject(O).\n    // 2. Return ? obj.[[GetPrototypeOf]]().\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.is\n// 19.1.2.13 Object.is ( value1 , value2 )\nexport class $Object_is extends $BuiltinFunction<'Object.is'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.is', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Return SameValue(value1, value2).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.isextensible\n// 19.1.2.14 Object.isExtensible ( O )\nexport class $Object_isExtensible extends $BuiltinFunction<'Object.isExtensible'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.isExtensible', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, return false.\n    // 2. Return ? IsExtensible(O).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.isfrozen\n// 19.1.2.15 Object.isFrozen ( O )\nexport class $Object_isFrozen extends $BuiltinFunction<'Object.isFrozen'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.isFrozen', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, return true.\n    // 2. Return ? TestIntegrityLevel(O, \"frozen\").\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.issealed\n// 19.1.2.16 Object.isSealed ( O )\nexport class $Object_isSealed extends $BuiltinFunction<'Object.isSealed'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.isSealed', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, return true.\n    // 2. Return ? TestIntegrityLevel(O, \"sealed\").\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.keys\n// 19.1.2.17 Object.keys ( O )\nexport class $Object_keys extends $BuiltinFunction<'Object.keys'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.keys', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let obj be ? ToObject(O).\n    // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, \"key\").\n    // 3. Return CreateArrayFromList(nameList).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.preventextensions\n// 19.1.2.18 Object.preventExtensions ( O )\nexport class $Object_preventExtensions extends $BuiltinFunction<'Object.preventExtensions'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.preventExtensions', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, return O.\n    // 2. Let status be ? O.[[PreventExtensions]]().\n    // 3. If status is false, throw a TypeError exception.\n    // 4. Return O.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.seal\n// 19.1.2.20 Object.seal ( O )\nexport class $Object_seal extends $BuiltinFunction<'Object.seal'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.seal', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. If Type(O) is not Object, return O.\n    // 2. Let status be ? SetIntegrityLevel(O, \"sealed\").\n    // 3. If status is false, throw a TypeError exception.\n    // 4. Return O.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.setprototypeof\n// 19.1.2.21 Object.setPrototypeOf ( O , proto )\nexport class $Object_setPrototypeOf extends $BuiltinFunction<'Object.setPrototypeOf'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.setPrototypeOf', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Set O to ? RequireObjectCoercible(O).\n    // 2. If Type(proto) is neither Object nor Null, throw a TypeError exception.\n    // 3. If Type(O) is not Object, return O.\n    // 4. Let status be ? O.[[SetPrototypeOf]](proto).\n    // 5. If status is false, throw a TypeError exception.\n    // 6. Return O.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.values\n// 19.1.2.22 Object.values ( O )\nexport class $Object_values extends $BuiltinFunction<'Object.values'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.values', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [O]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (O === void 0) {\n      O = intrinsics.undefined;\n    }\n\n    // 1. Let obj be ? ToObject(O).\n    // 2. Let nameList be ? EnumerableOwnPropertyNames(obj, \"value\").\n    // 3. Return CreateArrayFromList(nameList).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-object-prototype-object\n// #region 19.1.3 Properties of the Object Prototype Object\nexport class $ObjectPrototype extends $Object<'%ObjectPrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.constructor\n  // 19.1.3.1 Object.prototype.constructor\n  public get $constructor(): $ObjectConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $ObjectConstructor;\n  }\n  public set $constructor(value: $ObjectConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.hasownproperty\n  // 19.1.3.2 Object.prototype.hasOwnProperty ( V )\n  public get $hasOwnProperty(): $ObjectPrototype_hasOwnProperty {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$hasOwnProperty)['[[Value]]'] as $ObjectPrototype_hasOwnProperty;\n  }\n  public set $hasOwnProperty(value: $ObjectPrototype_hasOwnProperty) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$hasOwnProperty, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.isprototypeof\n  // 19.1.3.3 Object.prototype.isPrototypeOf ( V )\n  public get $isPrototypeOf(): $ObjectPrototype_isPrototypeOf {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$isPrototypeOf)['[[Value]]'] as $ObjectPrototype_isPrototypeOf;\n  }\n  public set $isPrototypeOf(value: $ObjectPrototype_isPrototypeOf) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$isPrototypeOf, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.propertyisenumerable\n  // 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )\n  public get $propertyIsEnumerable(): $ObjectPrototype_propertyIsEnumerable {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$propertyIsEnumerable)['[[Value]]'] as $ObjectPrototype_propertyIsEnumerable;\n  }\n  public set $propertyIsEnumerable(value: $ObjectPrototype_propertyIsEnumerable) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$propertyIsEnumerable, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.tolocalestring\n  // 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )\n  public get $toLocaleString(): $ObjectPrototype_toLocaleString {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$toLocaleString)['[[Value]]'] as $ObjectPrototype_toLocaleString;\n  }\n  public set $toLocaleString(value: $ObjectPrototype_toLocaleString) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$toLocaleString, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.tostring\n  // 19.1.3.6 Object.prototype.toString ( )\n  public get $toString(): $ObjProto_toString {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$toString)['[[Value]]'] as $ObjProto_toString;\n  }\n  public set $toString(value: $ObjProto_toString) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$toString, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object.prototype.valueof\n  // 19.1.3.7 Object.prototype.valueOf ( )\n  public get $valueOf(): $ObjProto_valueOf {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$valueOf)['[[Value]]'] as $ObjProto_valueOf;\n  }\n  public set $valueOf(value: $ObjProto_valueOf) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$valueOf, value);\n  }\n\n  public constructor(\n    realm: Realm,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%ObjectPrototype%', intrinsics.null, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.prototype.hasownproperty\n// 19.1.3.2 Object.prototype.hasOwnProperty ( V )\nexport class $ObjectPrototype_hasOwnProperty extends $BuiltinFunction<'Object.prototype.hasOwnProperty'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.prototype.hasOwnProperty', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let P be ? ToPropertyKey(V).\n    // 2. Let O be ? ToObject(this value).\n    // 3. Return ? HasOwnProperty(O, P).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.prototype.isprototypeof\n// 19.1.3.3 Object.prototype.isPrototypeOf ( V )\nexport class $ObjectPrototype_isPrototypeOf extends $BuiltinFunction<'Object.prototype.isPrototypeOf'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.prototype.isPrototypeOf', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If Type(V) is not Object, return false.\n    // 2. Let O be ? ToObject(this value).\n    // 3. Repeat,\n      // 3. a. Set V to ? V.[[GetPrototypeOf]]().\n      // 3. b. If V is null, return false.\n      // 3. c. If SameValue(O, V) is true, return true.\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.prototype.propertyisenumerable\n// 19.1.3.4 Object.prototype.propertyIsEnumerable ( V )\nexport class $ObjectPrototype_propertyIsEnumerable extends $BuiltinFunction<'Object.prototype.propertyIsEnumerable'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.prototype.propertyIsEnumerable', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let P be ? ToPropertyKey(V).\n    // 2. Let O be ? ToObject(this value).\n    // 3. Let desc be ? O.[[GetOwnProperty]](P).\n    // 4. If desc is undefined, return false.\n    // 5. Return desc.[[Enumerable]].\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.prototype.tolocalestring\n// 19.1.3.5 Object.prototype.toLocaleString ( [ reserved1 [ , reserved2 ] ] )\nexport class $ObjectPrototype_toLocaleString extends $BuiltinFunction<'Object.prototype.toLocaleString'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.prototype.toLocaleString', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let O be the this value.\n    // 2. Return ? Invoke(O, \"toString\").\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.prototype.tostring\n// 19.1.3.6 Object.prototype.toString ( )\nexport class $ObjProto_toString extends $BuiltinFunction<'Object.prototype.toString'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Object.prototype.toString', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If the this value is undefined, return \"[object Undefined]\".\n    if (thisArgument.isUndefined) {\n      return new $String(realm, '[object Undefined]');\n    }\n\n    // 2. If the this value is null, return \"[object Null]\".\n    if (thisArgument.isNull) {\n      return new $String(realm, '[object Null]');\n    }\n\n    // 3. Let O be ! ToObject(this value).\n    const O = thisArgument.ToObject(ctx);\n\n    const tag = O['[[Get]]'](ctx, intrinsics['@@toStringTag'], O);\n    if (tag.isAbrupt) { return tag; }\n\n    if (tag.isString) {\n      return new $String(realm, `[object ${tag['[[Value]]']}]`);\n    }\n\n    // 4. Let isArray be ? IsArray(O).\n    // 5. If isArray is true, let builtinTag be \"Array\".\n    if (O.isArray) {\n      // TODO: implement IsArray semantics for proxy with null handler (which throws type error)\n      return new $String(realm, `[object Array]`);\n    }\n\n    // 6. Else if O is a String exotic object, let builtinTag be \"String\".\n    if (O instanceof $StringExoticObject) {\n      return new $String(realm, `[object String]`);\n    }\n\n    // 7. Else if O has a [[ParameterMap]] internal slot, let builtinTag be \"Arguments\".\n    if ('[[ParameterMap]]' in O) {\n      return new $String(realm, `[object Arguments]`);\n    }\n\n    // 8. Else if O has a [[Call]] internal method, let builtinTag be \"Function\".\n    if ('[[Call]]' in O) {\n      return new $String(realm, `[object Function]`);\n    }\n\n    // 9. Else if O has an [[ErrorData]] internal slot, let builtinTag be \"Error\".\n    if ('[[ErrorData]]' in O) {\n      return new $String(realm, `[object Error]`);\n    }\n\n    // 10. Else if O has a [[BooleanData]] internal slot, let builtinTag be \"Boolean\".\n    if ('[[BooleanData]]' in O) {\n      return new $String(realm, `[object Boolean]`);\n    }\n\n    // 11. Else if O has a [[NumberData]] internal slot, let builtinTag be \"Number\".\n    if ('[[NumberData]]' in O) {\n      return new $String(realm, `[object Number]`);\n    }\n\n    // 12. Else if O has a [[DateValue]] internal slot, let builtinTag be \"Date\".\n    if ('[[DateValue]]' in O) {\n      return new $String(realm, `[object Date]`);\n    }\n\n    // 13. Else if O has a [[RegExpMatcher]] internal slot, let builtinTag be \"RegExp\".\n    if ('[[RegExpMatcher]]' in O) {\n      return new $String(realm, `[object RegExp]`);\n    }\n\n    // 14. Else, let builtinTag be \"Object\".\n    return new $String(realm, `[object Object]`);\n\n    // 15. Let tag be ? Get(O, @@toStringTag).\n    // 16. If Type(tag) is not String, set tag to builtinTag.\n    // 17. Return the string-concatenation of \"[object \", tag, and \"]\".\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-object.prototype.valueof\n// 19.1.3.7 Object.prototype.valueOf ( )\nexport class $ObjProto_valueOf extends $BuiltinFunction<'%ObjProto_valueOf%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%ObjProto_valueOf%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Return ? ToObject(this value).\n\n    throw new Error('Method not implemented.');\n  }\n}\n\n// #endregion\n","import {\n  ArrayBindingElement,\n  ArrayBindingPattern,\n  BindingElement,\n  ComputedPropertyName,\n  ModifierFlags,\n  ObjectBindingPattern,\n  OmittedExpression,\n  SpreadElement,\n  SyntaxKind,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $EnvRec,\n} from '../types/environment-record.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Any,\n  $AnyNonEmpty,\n  $AnyObject,\n} from '../types/_shared.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  $IteratorRecord,\n  $IteratorStep,\n  $IteratorValue,\n  $GetIterator,\n  $IteratorClose,\n} from '../globals/iteration.js';\nimport {\n  $TypeError,\n  $Error,\n} from '../types/error.js';\nimport {\n  I$Node,\n  Context,\n  clearBit,\n  modifiersToModifierFlags,\n  $$PropertyName,\n  $$AssignmentExpressionOrHigher,\n  $$propertyName,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$BindingName,\n  $$bindingName,\n  getBoundNames,\n  $$DestructurableBinding,\n  getContainsExpression,\n  getHasInitializer,\n  getIsSimpleParameterList,\n  $i,\n} from './_shared.js';\nimport {\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Identifier,\n  $PropertyAssignment,\n  $ShorthandPropertyAssignment,\n  $SpreadAssignment,\n  $NodeWithSpreadElements,\n  $ArrayLiteralExpression,\n  $NewExpression,\n  $CallExpression,\n} from './expressions.js';\nimport {\n  $PropertyDeclaration,\n} from './classes.js';\nimport {\n  $GetAccessorDeclaration,\n  $SetAccessorDeclaration,\n  $MethodDeclaration,\n} from './methods.js';\nimport {\n  $EnumMember,\n} from './types.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $ArrayExoticObject,\n} from '../exotics/array.js';\nimport {\n  $CreateDataProperty,\n} from '../operations.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $List,\n} from '../types/list.js';\n\nexport type $$NamedDeclaration = (\n  $GetAccessorDeclaration |\n  $SetAccessorDeclaration |\n  $MethodDeclaration |\n  $PropertyAssignment |\n  $ShorthandPropertyAssignment |\n  $SpreadAssignment |\n  $BindingElement |\n  $EnumMember |\n  $PropertyDeclaration\n);\n\nexport class $ComputedPropertyName implements I$Node {\n  public get $kind(): SyntaxKind.ComputedPropertyName { return SyntaxKind.ComputedPropertyName; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: $String | $Empty;\n\n  public constructor(\n    public readonly node: ComputedPropertyName,\n    public readonly parent: $$NamedDeclaration,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ComputedPropertyName`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.PropName = new $Empty(realm, void 0, void 0, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation\n  // 12.2.6.7 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $String | $Error {\n    ctx.checkTimeout();\n\n    // ComputedPropertyName : [ AssignmentExpression ]\n\n    // 1. Let exprValue be the result of evaluating AssignmentExpression.\n    const exprValue = this.$expression.Evaluate(ctx);\n\n    // 2. Let propName be ? GetValue(exprValue).\n    const propName = exprValue.GetValue(ctx);\n    if (propName.isAbrupt) { return propName.enrichWith(ctx, this); }\n\n    // 3. Return ? ToPropertyKey(propName).\n    return propName.ToPropertyKey(ctx).enrichWith(ctx, this);\n  }\n\n  // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation\n  public EvaluatePropName(\n    ctx: ExecutionContext,\n  ): $String | $Error {\n    ctx.checkTimeout();\n\n    return this.Evaluate(ctx);\n  }\n}\n\nexport class $ObjectBindingPattern implements I$Node {\n  public get $kind(): SyntaxKind.ObjectBindingPattern { return SyntaxKind.ObjectBindingPattern; }\n\n  public readonly combinedModifierFlags: ModifierFlags;\n\n  public readonly $elements: readonly $BindingElement[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames\n  // 13.3.3.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression\n  // 13.3.3.2 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer\n  // 13.3.3.3 Static Semantics: HasInitializer\n  public readonly HasInitializer: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist\n  // 13.3.3.4 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: boolean;\n\n  public constructor(\n    public readonly node: ObjectBindingPattern,\n    public readonly parent: $$DestructurableBinding,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ObjectBindingPattern`,\n  ) {\n    this.combinedModifierFlags = parent.combinedModifierFlags;\n\n    ctx |= Context.InBindingPattern;\n\n    const $elements = this.$elements = $bindingElementList(node.elements, this, ctx);\n\n    this.BoundNames = $elements.flatMap(getBoundNames);\n    this.ContainsExpression = $elements.some(getContainsExpression);\n    this.HasInitializer = $elements.some(getHasInitializer);\n    this.IsSimpleParameterList = $elements.every(getIsSimpleParameterList);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization\n  // 13.3.3.5 Runtime Semantics: BindingInitialization\n  public InitializeBinding(\n    ctx: ExecutionContext,\n    value: $AnyNonEmpty,\n    environment: $EnvRec | undefined,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n\n    // BindingPattern : ObjectBindingPattern\n\n    // 1. Perform ? RequireObjectCoercible(value).\n    if (value.isNil) {\n      return new $TypeError(realm, `Cannot destructure ${value['[[Value]]']} into object`).enrichWith(ctx, this);\n    }\n\n    // 2. Return the result of performing BindingInitialization for ObjectBindingPattern using value and environment as arguments.\n\n    // ObjectBindingPattern : { }\n\n    // 1. Return NormalCompletion(empty).\n\n    // ObjectBindingPattern : { BindingPropertyList } { BindingPropertyList , }\n\n    // 1. Perform ? PropertyBindingInitialization for BindingPropertyList using value and environment as the arguments.\n    // 2. Return NormalCompletion(empty).\n\n    // ObjectBindingPattern : { BindingRestProperty }\n\n    // 1. Let excludedNames be a new empty List.\n    // 2. Return the result of performing RestBindingInitialization of BindingRestProperty with value, environment, and excludedNames as the arguments.\n\n    // ObjectBindingPattern : { BindingPropertyList , BindingRestProperty }\n\n    // 1. Let excludedNames be the result of performing ? PropertyBindingInitialization of BindingPropertyList using value and environment as arguments.\n    // 2. Return the result of performing RestBindingInitialization of BindingRestProperty with value, environment, and excludedNames as the arguments.\n\n    // TODO: implement rest element thingy\n\n    const excludedNames: $String[] = [];\n    const elements = this.$elements;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      const el = elements[i];\n      const result = el.InitializePropertyBinding(ctx, value, environment);\n      if (result.isAbrupt) { return result.enrichWith(ctx, this); }\n      if (i + 1 === ii) {\n        // return result;\n      }\n    }\n\n    return new $Empty(realm);\n  }\n}\n\nexport type $$ArrayBindingElement = (\n  $BindingElement |\n  $OmittedExpression\n);\n\nexport function $$arrayBindingElement(\n  node: ArrayBindingElement,\n  parent: $ArrayBindingPattern,\n  ctx: Context,\n  idx: number,\n): $$ArrayBindingElement {\n  switch (node.kind) {\n    case SyntaxKind.BindingElement:\n      return new $BindingElement(node, parent, ctx, idx);\n    case SyntaxKind.OmittedExpression:\n      return new $OmittedExpression(node, parent, ctx, idx);\n  }\n}\n\nexport function $$arrayBindingElementList(\n  nodes: readonly ArrayBindingElement[],\n  parent: $ArrayBindingPattern,\n  ctx: Context,\n): readonly $$ArrayBindingElement[] {\n  const len = nodes.length;\n  const $nodes: $$ArrayBindingElement[] = Array(len);\n\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = $$arrayBindingElement(nodes[i], parent, ctx, i);\n  }\n\n  return $nodes;\n}\n\nexport function $bindingElementList(\n  nodes: readonly BindingElement[],\n  parent: $$BindingPattern,\n  ctx: Context,\n): readonly $BindingElement[] {\n  const len = nodes.length;\n  const $nodes: $BindingElement[] = Array(len);\n\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $BindingElement(nodes[i], parent, ctx, i);\n  }\n\n  return $nodes;\n}\n\nexport class $ArrayBindingPattern implements I$Node {\n  public get $kind(): SyntaxKind.ArrayBindingPattern { return SyntaxKind.ArrayBindingPattern; }\n\n  public readonly combinedModifierFlags: ModifierFlags;\n\n  public readonly $elements: readonly $$ArrayBindingElement[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames\n  // 13.3.3.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression\n  // 13.3.3.2 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer\n  // 13.3.3.3 Static Semantics: HasInitializer\n  public readonly HasInitializer: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist\n  // 13.3.3.4 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: boolean;\n\n  public constructor(\n    public readonly node: ArrayBindingPattern,\n    public readonly parent: $$DestructurableBinding,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ArrayBindingPattern`,\n  ) {\n    this.combinedModifierFlags = parent.combinedModifierFlags;\n\n    ctx |= Context.InBindingPattern;\n\n    const $elements = this.$elements = $$arrayBindingElementList(node.elements, this, ctx);\n\n    this.BoundNames = $elements.flatMap(getBoundNames);\n    this.ContainsExpression = $elements.some(getContainsExpression);\n    this.HasInitializer = $elements.some(getHasInitializer);\n    this.IsSimpleParameterList = $elements.every(getIsSimpleParameterList);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization\n  // 13.3.3.5 Runtime Semantics: BindingInitialization\n  public InitializeBinding(\n    ctx: ExecutionContext,\n    value: $AnyObject,\n    environment: $EnvRec | undefined,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeBinding(#${ctx.id})`);\n\n    // BindingPattern : ArrayBindingPattern\n\n    // 1. Let iteratorRecord be ? GetIterator(value).\n    const iteratorRecord = $GetIterator(ctx, value);\n    if (iteratorRecord.isAbrupt) { return iteratorRecord.enrichWith(ctx, this); }\n\n    // 2. Let result be IteratorBindingInitialization for ArrayBindingPattern using iteratorRecord and environment as arguments.\n    const result = this.InitializeIteratorBinding(ctx, iteratorRecord, environment);\n    if (result.isAbrupt) { return result.enrichWith(ctx, this); } // TODO: we sure about this? Spec doesn't say it\n\n    // 3. If iteratorRecord.[[Done]] is false, return ? IteratorClose(iteratorRecord, result).\n    if (iteratorRecord['[[Done]]'].isFalsey) {\n      return $IteratorClose(ctx, iteratorRecord, result).enrichWith(ctx, this);\n    }\n\n    // 4. Return result.\n    return result;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization\n  // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization\n  public InitializeIteratorBinding(\n    ctx: ExecutionContext,\n    iteratorRecord: $IteratorRecord,\n    environment: $EnvRec | undefined,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n\n    const elements = this.$elements;\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      const el = elements[i];\n      switch (el.$kind) {\n        case SyntaxKind.OmittedExpression: {\n          if (i + 1 === ii) {\n            // If the last element is an elision, skip it as per the runtime semantics:\n\n            // ArrayBindingPattern : [ BindingElementList , ]\n\n            // 1. Return the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.\n\n            // ArrayBindingPattern : [ Elision ]\n\n            // 1. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.\n            break;\n          }\n          const result = el.EvaluateDestructuringAssignmentIterator(ctx, iteratorRecord);\n          if (result.isAbrupt) { return result.enrichWith(ctx, this); }\n          break;\n        }\n        case SyntaxKind.BindingElement: {\n          // ArrayBindingPattern : [ Elision opt BindingRestElement ]\n\n          // 1. If Elision is present, then\n            // 1. a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.\n          // 2. Return the result of performing IteratorBindingInitialization for BindingRestElement with iteratorRecord and environment as arguments.\n\n          // ArrayBindingPattern : [ BindingElementList ]\n\n          // 1. Return the result of performing IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.\n\n          // ArrayBindingPattern : [ BindingElementList , Elision ]\n\n          // 1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.\n          // 2. Return the result of performing IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.\n\n          // ArrayBindingPattern : [ BindingElementList , Elision opt BindingRestElement ]\n\n          // 1. Perform ? IteratorBindingInitialization for BindingElementList with iteratorRecord and environment as arguments.\n          // 2. If Elision is present, then\n            // 2. a. Perform ? IteratorDestructuringAssignmentEvaluation of Elision with iteratorRecord as the argument.\n          // 3. Return the result of performing IteratorBindingInitialization for BindingRestElement with iteratorRecord and environment as arguments.\n\n          const result = el.InitializeIteratorBinding(ctx, iteratorRecord, environment);\n          if (result.isAbrupt) { return result.enrichWith(ctx, this); }\n          if (i + 1 === ii) {\n            return result;\n          }\n        }\n      }\n    }\n\n    // ArrayBindingPattern : [ ]\n\n    // 1. Return NormalCompletion(empty).\n    return new $Empty(realm);\n  }\n}\n\nexport type $$BindingPattern = (\n  $ArrayBindingPattern |\n  $ObjectBindingPattern\n);\n\nexport class $BindingElement implements I$Node {\n  public get $kind(): SyntaxKind.BindingElement { return SyntaxKind.BindingElement; }\n\n  public readonly modifierFlags: ModifierFlags;\n  public readonly combinedModifierFlags: ModifierFlags;\n\n  public readonly $propertyName: $$PropertyName | undefined;\n  public readonly $name: $$BindingName;\n  public readonly $initializer: $$AssignmentExpressionOrHigher | undefined;\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames\n  // 13.3.3.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression\n  // 13.3.3.2 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer\n  // 13.3.3.3 Static Semantics: HasInitializer\n  public readonly HasInitializer: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist\n  // 13.3.3.4 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: boolean;\n\n  public constructor(\n    public readonly node: BindingElement,\n    public readonly parent: $$BindingPattern,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.BindingElement`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n    this.combinedModifierFlags = this.modifierFlags | parent.combinedModifierFlags;\n\n    ctx = clearBit(ctx, Context.IsBindingName);\n\n    if (node.propertyName === void 0) {\n      this.$propertyName = void 0;\n      const $name = this.$name = $$bindingName(node.name, this, ctx | Context.IsBindingName, -1);\n\n      this.BoundNames = $name.BoundNames;\n\n      if (node.initializer === void 0) {\n        this.$initializer = void 0;\n\n        this.ContainsExpression = $name.ContainsExpression;\n        this.HasInitializer = false;\n        this.IsSimpleParameterList = $name.$kind === SyntaxKind.Identifier;\n      } else {\n        this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n        this.ContainsExpression = true;\n        this.HasInitializer = true;\n        this.IsSimpleParameterList = false;\n      }\n\n    } else {\n      const $propertyName = this.$propertyName = $$propertyName(node.propertyName, this, ctx, -1);\n      const $name = this.$name = $$bindingName(node.name, this, ctx | Context.IsBindingName, -1);\n\n      this.BoundNames = $name.BoundNames;\n\n      if (node.initializer === void 0) {\n        this.$initializer = void 0;\n\n        this.ContainsExpression = $propertyName.$kind === SyntaxKind.ComputedPropertyName || $name.ContainsExpression;\n        this.HasInitializer = false;\n        this.IsSimpleParameterList = $name.$kind === SyntaxKind.Identifier;\n      } else {\n        this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n        this.ContainsExpression = true;\n        this.HasInitializer = true;\n        this.IsSimpleParameterList = false;\n      }\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization\n  // 13.3.3.6 Runtime Semantics: PropertyBindingInitialization\n  public InitializePropertyBinding(\n    ctx: ExecutionContext,\n    value: $AnyNonEmpty,\n    environment: $EnvRec | undefined,\n  ): $List<$String> | $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializePropertyBinding(#${ctx.id})`);\n\n    const PropertyName = this.$propertyName;\n\n    // BindingProperty : SingleNameBinding\n\n    if (PropertyName === void 0) {\n      // 1. Let name be the string that is the only element of BoundNames of SingleNameBinding.\n      // 2. Perform ? KeyedBindingInitialization for SingleNameBinding using value, environment, and name as the arguments.\n      // 3. Return a new List containing name.\n\n      // Cast is safe because when propertyName is undefined, destructuring is syntactically not possible\n      return (this.$name as $Identifier).InitializePropertyBinding(ctx, value, environment).enrichWith(ctx, this);\n    }\n\n    // BindingProperty : PropertyName : BindingElement\n\n    // 1. Let P be the result of evaluating PropertyName.\n    const P = PropertyName.Evaluate(ctx);\n\n    // 2. ReturnIfAbrupt(P).\n    if (P.isAbrupt) { return P.enrichWith(ctx, this); }\n\n    // 3. Perform ? KeyedBindingInitialization of BindingElement with value, environment, and P as the arguments.\n    const result = this.InitializeKeyedBinding(ctx, value, environment, P as $String); // TODO: this cast is very wrong. Need to revisit later\n    if (result.isAbrupt) { return result.enrichWith(ctx, this); }\n\n    // 4. Return a new List containing P.\n    return new $List(P as $String); // TODO: this cast is very wrong. Need to revisit later\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-keyedbindinginitialization\n  // 13.3.3.9 Runtime Semantics: KeyedBindingInitialization\n  public InitializeKeyedBinding(\n    ctx: ExecutionContext,\n    value: $AnyNonEmpty,\n    environment: $EnvRec | undefined,\n    propertyName: $String,\n    initializer?: $$AssignmentExpressionOrHigher,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeKeyedBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n\n    const BindingElement = this.$name;\n\n    // SingleNameBinding : BindingIdentifier Initializer opt\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n    // 3. Let v be ? GetV(value, propertyName).\n    // 4. If Initializer is present and v is undefined, then\n      // 4. a. If IsAnonymousFunctionDefinition(Initializer) is true, then\n        // 4. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.\n      // 4. b. Else,\n        // 4. b. i. Let defaultValue be the result of evaluating Initializer.\n        // 4. b. ii. Set v to ? GetValue(defaultValue).\n    // 5. If environment is undefined, return ? PutValue(lhs, v).\n    // 6. Return InitializeReferencedBinding(lhs, v).\n    if (BindingElement.$kind === SyntaxKind.Identifier) {\n      return BindingElement.InitializeKeyedBinding(ctx, value, environment, propertyName, initializer).enrichWith(ctx, this);\n    }\n\n    // BindingElement : BindingPattern Initializer opt\n\n    // 1. Let v be ? GetV(value, propertyName).\n    const obj = value.ToObject(ctx);\n    if (obj.isAbrupt) { return obj.enrichWith(ctx, this); }\n    let v = obj['[[Get]]'](ctx, propertyName, obj);\n    if (v.isAbrupt) { return v.enrichWith(ctx, this); }\n\n    // 2. If Initializer is present and v is undefined, then\n    if (initializer !== void 0 && v.isUndefined) {\n      // 2. a. Let defaultValue be the result of evaluating Initializer.\n      const defaultValue = initializer.Evaluate(ctx);\n\n      // 2. b. Set v to ? GetValue(defaultValue).\n      v = defaultValue.GetValue(ctx);\n      if (v.isAbrupt) { return v.enrichWith(ctx, this); }\n    }\n\n    // 3. Return the result of performing BindingInitialization for BindingPattern passing v and environment as arguments.\n    return BindingElement.InitializeBinding(ctx, v as $Object, environment).enrichWith(ctx, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization\n  // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization\n  public InitializeIteratorBinding(\n    ctx: ExecutionContext,\n    iteratorRecord: $IteratorRecord,\n    environment: $EnvRec | undefined,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const BindingElement = this.$name;\n\n    // BindingElement : SingleNameBinding\n\n    // 1. Return the result of performing IteratorBindingInitialization for SingleNameBinding with iteratorRecord and environment as the arguments.\n\n    // SingleNameBinding : BindingIdentifier Initializer opt\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n    // 3. If iteratorRecord.[[Done]] is false, then\n      // 3. a. Let next be IteratorStep(iteratorRecord).\n      // 3. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n      // 3. c. ReturnIfAbrupt(next).\n      // 3. d. If next is false, set iteratorRecord.[[Done]] to true.\n      // 3. e. Else,\n        // 3. e. i. Let v be IteratorValue(next).\n        // 3. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        // 3. e. iii. ReturnIfAbrupt(v).\n    // 4. If iteratorRecord.[[Done]] is true, let v be undefined.\n    // 5. If Initializer is present and v is undefined, then\n      // 5. a. If IsAnonymousFunctionDefinition(Initializer) is true, then\n        // 5. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.\n      // 5. b. Else,\n        // 5. b. i. Let defaultValue be the result of evaluating Initializer.\n        // 5. b. ii. Set v to ? GetValue(defaultValue).\n    // 6. If environment is undefined, return ? PutValue(lhs, v).\n    // 7. Return InitializeReferencedBinding(lhs, v).\n\n    if (BindingElement.$kind === SyntaxKind.Identifier) {\n      return BindingElement.InitializeIteratorBinding(ctx, iteratorRecord, environment, this.$initializer).enrichWith(ctx, this);\n    }\n\n    // NOTE: this section is duplicated in ParameterDeclaration\n    // BindingElement : BindingPattern Initializer opt\n\n    let v: $Any = intrinsics.undefined; // TODO: sure about this?\n\n    // 1. If iteratorRecord.[[Done]] is false, then\n    if (iteratorRecord['[[Done]]'].isFalsey) {\n      // 1. a. Let next be IteratorStep(iteratorRecord).\n      const next = $IteratorStep(ctx, iteratorRecord);\n\n      // 1. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n      if (next.isAbrupt) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n\n        // 1. c. ReturnIfAbrupt(next).\n        if (next.isAbrupt) { return next.enrichWith(ctx, this); }\n      }\n\n      // 1. d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next.isFalsey) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n      }\n      // 1. e. Else,\n      else {\n        // 1. e. i. Let v be IteratorValue(next).\n        v = $IteratorValue(ctx, next);\n\n        // 1. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (v.isAbrupt) {\n          iteratorRecord['[[Done]]'] = intrinsics.true;\n\n          // 1. e. iii. ReturnIfAbrupt(v).\n          if (v.isAbrupt) { return v.enrichWith(ctx, this); }\n        }\n      }\n    }\n\n    // 2. If iteratorRecord.[[Done]] is true, let v be undefined.\n    if (iteratorRecord['[[Done]]'].isTruthy) {\n      v = intrinsics.undefined;\n    }\n\n    const initializer = this.$initializer;\n\n    // 3. If Initializer is present and v is undefined, then\n    if (initializer !== void 0 && v.isUndefined) {\n      // 3. a. Let defaultValue be the result of evaluating Initializer.\n      const defaultValue = initializer.Evaluate(ctx);\n\n      // 3. b. Set v to ? GetValue(defaultValue).\n      v = defaultValue.GetValue(ctx);\n      if (v.isAbrupt) { return v.enrichWith(ctx, this); }\n    }\n\n    // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.\n    return BindingElement.InitializeBinding(ctx, v as $Object, environment).enrichWith(ctx, this);\n  }\n}\n\nexport class $SpreadElement implements I$Node {\n  public get $kind(): SyntaxKind.SpreadElement { return SyntaxKind.SpreadElement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: SpreadElement,\n    public readonly parent: $NodeWithSpreadElements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.SpreadElement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-argument-lists-runtime-semantics-argumentlistevaluation\n  // 12.3.6.1 Runtime Semantics: ArgumentListEvaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $List<$AnyNonEmpty> | $Error {\n    ctx.checkTimeout();\n    // ArgumentList :\n    //     ... AssignmentExpression\n\n    // 1. Let list be a new empty List.\n    const list = new $List<$AnyNonEmpty>();\n\n    // 2. Let spreadRef be the result of evaluating AssignmentExpression.\n    const spreadRef = this.$expression.Evaluate(ctx);\n\n    // 3. Let spreadObj be ? GetValue(spreadRef).\n    const spreadObj = spreadRef.GetValue(ctx);\n    if (spreadObj.isAbrupt) { return spreadObj.enrichWith(ctx, this); }\n\n    // 4. Let iteratorRecord be ? GetIterator(spreadObj).\n    const iteratorRecord = $GetIterator(ctx, spreadObj);\n    if (iteratorRecord.isAbrupt) { return iteratorRecord.enrichWith(ctx, this); }\n\n    // 5. Repeat,\n    while (true) {\n      // 5. a. Let next be ? IteratorStep(iteratorRecord).\n      const next = $IteratorStep(ctx, iteratorRecord);\n      if (next.isAbrupt) { return next.enrichWith(ctx, this); }\n\n      // 5. b. If next is false, return list.\n      if (next.isFalsey) {\n        return list;\n      }\n\n      // 5. c. Let nextArg be ? IteratorValue(next).\n      const nextArg = $IteratorValue(ctx, next);\n      if (nextArg.isAbrupt) { return nextArg.enrichWith(ctx, this); }\n\n      // 5. d. Append nextArg as the last element of list.\n      list.push(nextArg);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-arrayaccumulation\n  // 12.2.5.2 Runtime Semantics: ArrayAccumulation\n  public AccumulateArray(\n    ctx: ExecutionContext,\n    array: $ArrayExoticObject,\n    nextIndex: $Number,\n  ): $Number | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n\n    // SpreadElement : ... AssignmentExpression\n\n    // 1. Let spreadRef be the result of evaluating AssignmentExpression.\n    const spreadRef = this.$expression.Evaluate(ctx);\n\n    // 2. Let spreadObj be ? GetValue(spreadRef).\n    const spreadObj = spreadRef.GetValue(ctx);\n    if (spreadObj.isAbrupt) { return spreadObj.enrichWith(ctx, this); }\n\n    // 3. Let iteratorRecord be ? GetIterator(spreadObj).\n    const iteratorRecord = $GetIterator(ctx, spreadObj as $Object);\n    if (iteratorRecord.isAbrupt) { return iteratorRecord.enrichWith(ctx, this); }\n\n    // 4. Repeat,\n    while (true) {\n      // 4. a. Let next be ? IteratorStep(iteratorRecord).\n      const next = $IteratorStep(ctx, iteratorRecord);\n      if (next.isAbrupt) { return next.enrichWith(ctx, this); }\n\n      // 4. b. If next is false, return nextIndex.\n      if (next.isFalsey) {\n        return nextIndex;\n      }\n\n      // 4. c. Let nextValue be ? IteratorValue(next).\n      const nextValue = $IteratorValue(ctx, next);\n      if (nextValue.isAbrupt) { return nextValue.enrichWith(ctx, this); }\n\n      // 4. d. Let status be CreateDataProperty(array, ToString(ToUint32(nextIndex)), nextValue).\n      const status = $CreateDataProperty(ctx, array, nextIndex.ToUint32(ctx).ToString(ctx), nextValue) as $Boolean;\n\n      // 4. e. Assert: status is true.\n      // 4. f. Increase nextIndex by 1.\n      nextIndex = new $Number(realm, nextIndex['[[Value]]'] + 1);\n    }\n  }\n}\n\nexport class $OmittedExpression implements I$Node {\n  public get $kind(): SyntaxKind.OmittedExpression { return SyntaxKind.OmittedExpression; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames\n  // 13.3.3.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression\n  // 13.3.3.2 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer\n  // 13.3.3.3 Static Semantics: HasInitializer\n  public readonly HasInitializer: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist\n  // 13.3.3.4 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: false = false;\n\n  public constructor(\n    public readonly node: OmittedExpression,\n    public readonly parent: $ArrayBindingPattern | $ArrayLiteralExpression | $NewExpression | $CallExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.OmittedExpression`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-iteratordestructuringassignmentevaluation\n  // 12.15.5.5 Runtime Semantics: IteratorDestructuringAssignmentEvaluation\n  public EvaluateDestructuringAssignmentIterator(\n    ctx: ExecutionContext,\n    iteratorRecord: $IteratorRecord,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.EvaluateDestructuringAssignmentIterator(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // Elision : ,\n\n    // 1. If iteratorRecord.[[Done]] is false, then\n    if (iteratorRecord['[[Done]]'].isFalsey) {\n      // 1. a. Let next be IteratorStep(iteratorRecord).\n      const next = $IteratorStep(ctx, iteratorRecord);\n\n      // 1. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n      if (next.isAbrupt) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n\n        // 1. c. ReturnIfAbrupt(next).\n        return next;\n      }\n\n      // 1. d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next.isFalsey) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n      }\n    }\n\n    // 2. Return NormalCompletion(empty).\n    return new $Empty(realm);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    return null as any; // TODO: implement this;\n  }\n}\n\n// #endregion\n","import {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Object,\n} from './object.js';\nimport {\n  $Boolean,\n} from './boolean.js';\nimport {\n  $String,\n} from './string.js';\nimport {\n  $Symbol,\n} from './symbol.js';\nimport {\n  $Number,\n} from './number.js';\nimport {\n  $EnvRec,\n} from './environment-record.js';\nimport {\n  $Undefined,\n} from './undefined.js';\nimport {\n  $AnyNonEmpty,\n  $AnyObject,\n} from './_shared.js';\nimport {\n  $Empty,\n} from './empty.js';\nimport {\n  $Set,\n} from '../operations.js';\nimport {\n  $TypeError,\n  $ReferenceError,\n  $Error,\n} from './error.js';\nimport {\n  I$Node,\n} from '../ast/_shared.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-reference-specification-type\nexport class $Reference {\n  public readonly '<$Reference>': unknown;\n\n  // Note: this typing is incorrect, but we do it this way to prevent having to cast in 100+ places.\n  // The purpose is to ensure the `isAbrupt === true` flow narrows down to the $Error type.\n  // It could be done correctly, but that would require complex conditional types which is not worth the effort right now.\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    public readonly realm: Realm,\n    public readonly baseValue: $AnyObject | $Boolean | $String | $Symbol | $Number | $EnvRec | $Undefined,\n    public readonly referencedName: $String,\n    public readonly strict: $Boolean,\n    public readonly thisValue: $AnyObject | $Boolean | $String | $Symbol | $Number | $Undefined,\n  ) {}\n\n  public enrichWith(ctx: ExecutionContext, node: I$Node): this {\n    return this;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getbase\n  // 6.2.4.1 GetBase ( V )\n  public GetBase(): $AnyObject | $Boolean | $String | $Symbol | $Number | $EnvRec | $Undefined {\n    // 1. Assert: Type(V) is Reference.\n    // 2. Return the base value component of V.\n    return this.baseValue;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getreferencedname\n  // 6.2.4.2 GetReferencedName ( V )\n  public GetReferencedName(): $String {\n    // 1. Assert: Type(V) is Reference.\n    // 2. Return the referenced name component of V.\n    return this.referencedName;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-isstrictreference\n  // 6.2.4.3 IsStrictReference ( V )\n  public IsStrictReference(): $Boolean {\n    // 1. Assert: Type(V) is Reference.\n    // 2. Return the strict reference flag of V.\n    return this.strict;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-hasprimitivebase\n  // 6.2.4.4 HasPrimitiveBase ( V )\n  public HasPrimitiveBase(): $Boolean {\n    // 1. Assert: Type(V) is Reference.\n    // 2. If Type(V's base value component) is Boolean, String, Symbol, or Number, return true; otherwise return false.\n    if (this.baseValue.isPrimitive && !this.baseValue.isUndefined) {\n      return this.realm['[[Intrinsics]]'].true;\n    }\n\n    return this.realm['[[Intrinsics]]'].false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-ispropertyreference\n  // 6.2.4.5 IsPropertyReference ( V )\n  public IsPropertyReference(): $Boolean {\n    // 1. Assert: Type(V) is Reference.\n    // 2. If either the base value component of V is an Object or HasPrimitiveBase(V) is true, return true; otherwise return false.\n    if (this.baseValue.isObject || this.HasPrimitiveBase().isTruthy) {\n      return this.realm['[[Intrinsics]]'].true;\n    }\n\n    return this.realm['[[Intrinsics]]'].false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-isunresolvablereference\n  // 6.2.4.6 IsUnresolvableReference ( V )\n  public IsUnresolvableReference(): $Boolean {\n    // 1. Assert: Type(V) is Reference.\n    // 2. If the base value component of V is undefined, return true; otherwise return false.\n    if (this.baseValue.isUndefined) {\n      return this.realm['[[Intrinsics]]'].true;\n    }\n\n    return this.realm['[[Intrinsics]]'].false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-issuperreference\n  // 6.2.4.7 IsSuperReference ( V )\n  public IsSuperReference(): $Boolean {\n    // 1. Assert: Type(V) is Reference.\n    // 2. If V has a thisValue component, return true; otherwise return false.\n    if (!this.thisValue.isUndefined) {\n      return this.realm['[[Intrinsics]]'].true;\n    }\n\n    return this.realm['[[Intrinsics]]'].false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getvalue\n  // 6.2.4.8 GetValue ( V )\n  public GetValue(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    // 1. ReturnIfAbrupt(V).\n    // 2. If Type(V) is not Reference, return V.\n    // 3. Let base be GetBase(V).\n    let base = this.GetBase();\n\n    // 4. If IsUnresolvableReference(V) is true, throw a ReferenceError exception.\n    if (this.IsUnresolvableReference().isTruthy) {\n      return new $ReferenceError(ctx.Realm, `${this.referencedName['[[Value]]']} is not defined.`);\n    }\n\n    // 5. If IsPropertyReference(V) is true, then\n    if (this.IsPropertyReference().isTruthy) {\n      // 5. a. If HasPrimitiveBase(V) is true, then\n      if (this.HasPrimitiveBase().isTruthy) {\n        // 5. a. i. Assert: In this case, base will never be undefined or null.\n        // 5. a. ii. Set base to ! ToObject(base).\n        base = (base as $Boolean | $String | $Symbol | $Number).ToObject(ctx);\n      }\n\n      // 5. b. Return ? base.[[Get]](GetReferencedName(V), GetThisValue(V)).\n      return (base as $Object)['[[Get]]'](ctx, this.GetReferencedName(), this.GetThisValue());\n    }\n    // 6. Else base must be an Environment Record,\n    else {\n      // 6. a. Return ? base.GetBindingValue(GetReferencedName(V), IsStrictReference(V)) (see 8.1.1).\n      return (base as $EnvRec).GetBindingValue(ctx, this.GetReferencedName(), this.IsStrictReference());\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-putvalue\n  // 6.2.4.9 PutValue ( V , W )\n  public PutValue(\n    ctx: ExecutionContext,\n    W: $AnyNonEmpty,\n  ): $Boolean | $Undefined | $Empty | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n    // 3. If Type(V) is not Reference, throw a ReferenceError exception.\n    // 4. Let base be GetBase(V).\n    let base = this.GetBase();\n\n    // 5. If IsUnresolvableReference(V) is true, then\n    if (this.IsUnresolvableReference().isTruthy) {\n      // 5. a. If IsStrictReference(V) is true, then\n      if (this.IsStrictReference().isTruthy) {\n        // 5. a. i. Throw a ReferenceError exception.\n        return new $ReferenceError(realm, `${this.referencedName['[[Value]]']} is not defined.`);\n      }\n\n      // 5. b. Let globalObj be GetGlobalObject().\n      const globalObj = realm['[[GlobalObject]]'];\n\n      // 5. c. Return ? Set(globalObj, GetReferencedName(V), W, false).\n      return $Set(ctx, globalObj, this.GetReferencedName(), W, intrinsics.false);\n    }\n    // 6. Else if IsPropertyReference(V) is true, then\n    else if (this.IsPropertyReference().isTruthy) {\n      // 6. a. If HasPrimitiveBase(V) is true, then\n      if (this.HasPrimitiveBase().isTruthy) {\n        // 6. a. i. Assert: In this case, base will never be undefined or null.\n        // 6. a. ii. Set base to ! ToObject(base).\n        base = (base as $Boolean | $String | $Symbol | $Number).ToObject(ctx);\n      }\n\n      // 6. b. Let succeeded be ? base.[[Set]](GetReferencedName(V), W, GetThisValue(V)).\n      const succeeded = (base as $Object)['[[Set]]'](ctx, this.GetReferencedName(), W, this.GetThisValue() as $Object);\n      if (succeeded.isAbrupt) { return succeeded; }\n\n      // 6. c. If succeeded is false and IsStrictReference(V) is true, throw a TypeError exception.\n      if (succeeded.isFalsey && this.IsStrictReference().isTruthy) {\n        return new $TypeError(realm, `${this.referencedName['[[Value]]']} is not writable.`);\n      }\n\n      // 6. d. Return.\n      return intrinsics.undefined;\n    }\n    // 7. Else base must be an Environment Record,\n    else {\n      // 7. a. Return ? base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V)) (see 8.1.1).\n      return (base as $EnvRec).SetMutableBinding(ctx, this.GetReferencedName(), W, this.IsStrictReference());\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getthisvalue\n  // 6.2.4.10 GetThisValue ( V )\n  public GetThisValue(): $AnyObject | $Boolean | $String | $Symbol | $Number {\n    // 1. Assert: IsPropertyReference(V) is true.\n    // 2. If IsSuperReference(V) is true, then\n    if (this.IsSuperReference().isTruthy) {\n      // 2. a. Return the value of the thisValue component of the reference V.\n      return this.thisValue as $Object | $Boolean | $String | $Symbol | $Number;\n    }\n\n    // 3. Return GetBase(V).\n    return this.GetBase() as $Object | $Boolean | $String | $Symbol | $Number;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-initializereferencedbinding\n  // 6.2.4.11 InitializeReferencedBinding ( V , W )\n  public InitializeReferencedBinding(\n    ctx: ExecutionContext,\n    W: $AnyNonEmpty,\n  ): $Boolean | $Empty | $Error {\n    // 1. ReturnIfAbrupt(V).\n    // 2. ReturnIfAbrupt(W).\n    // 3. Assert: Type(V) is Reference.\n    // 4. Assert: IsUnresolvableReference(V) is false.\n    // 5. Let base be GetBase(V).\n    const base = this.GetBase();\n\n    // 6. Assert: base is an Environment Record.\n    // 7. Return base.InitializeBinding(GetReferencedName(V), W).\n    return (base as $EnvRec).InitializeBinding(ctx, this.GetReferencedName(), W);\n  }\n}\n","import {\n  $Object,\n} from '../types/object.js';\nimport {\n  IModule,\n  ResolveSet,\n  ResolvedBindingRecord,\n  ExecutionContext,\n  Realm,\n} from '../realm.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $SetImmutablePrototype,\n} from '../operations.js';\nimport {\n  $PropertyKey,\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  $AnyObject,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Error,\n  $ReferenceError,\n} from '../types/error.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects\nexport class $NamespaceExoticObject extends $Object<'NamespaceExoticObject'> {\n  public readonly '[[Module]]': IModule;\n  public readonly '[[Exports]]': $List<$String>;\n\n  // http://www.ecma-international.org/ecma-262/#sec-modulenamespacecreate\n  // 9.4.6.11 ModuleNamespaceCreate ( module , exports )\n  public constructor(\n    realm: Realm,\n    mod: IModule,\n    exports: $List<$String>,\n  ) {\n    super(realm, 'NamespaceExoticObject', realm['[[Intrinsics]]'].null, CompletionType.normal, realm['[[Intrinsics]]'].empty);\n    // 1. Assert: module is a Module Record.\n    // 2. Assert: module.[[Namespace]] is undefined.\n    // 3. Assert: exports is a List of String values.\n    // 4. Let M be a newly created object.\n    // 5. Set M's essential internal methods to the definitions specified in 9.4.6.\n    // 6. Set M.[[Module]] to module.\n    this['[[Module]]'] = mod;\n\n    // 7. Let sortedExports be a new List containing the same values as the list exports where the values are ordered as if an Array of the same values had been sorted using Array.prototype.sort using undefined as comparefn.\n    // 8. Set M.[[Exports]] to sortedExports.\n    this['[[Exports]]'] = exports.$copy();\n\n    // 9. Create own properties of M corresponding to the definitions in 26.3.\n    // 10. Set module.[[Namespace]] to M.\n    mod['[[Namespace]]'] = this;\n\n    // 11. Return M.\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-setprototypeof-v\n  // 9.4.6.1 [[SetPrototypeOf]] ( V )\n  public '[[SetPrototypeOf]]'(\n    ctx: ExecutionContext,\n    V: $AnyObject,\n  ): $Boolean | $Error {\n    // 1. Return ? SetImmutablePrototype(O, V).\n    return $SetImmutablePrototype(ctx, this, V);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-isextensible\n  // 9.4.6.2 [[IsExtensible]] ( )\n  public '[[IsExtensible]]'(\n    ctx: ExecutionContext,\n  ): $Boolean<false> {\n    // 1. Return false.\n    return this.realm['[[Intrinsics]]'].false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-preventextensions\n  // 9.4.6.3 [[PreventExtensions]] ( )\n  public '[[PreventExtensions]]'(\n    ctx: ExecutionContext,\n  ): $Boolean<true> {\n    // 1. Return true.\n    return this.realm['[[Intrinsics]]'].true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-getownproperty-p\n  // 9.4.6.4 [[GetOwnProperty]] ( P )\n  public '[[GetOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $PropertyDescriptor | $Undefined | $Error {\n    // 1. If Type(P) is Symbol, return OrdinaryGetOwnProperty(O, P).\n    if (P.isSymbol) {\n      return super['[[GetOwnProperty]]'](ctx, P);\n    }\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const O = this;\n\n    // 2. Let exports be O.[[Exports]].\n    const exports = O['[[Exports]]'];\n\n    // 3. If P is not an element of exports, return undefined.\n    if (exports.every(x => !x.is(P))) {\n      return intrinsics.undefined;\n    }\n\n    // 4. Let value be ? O.[[Get]](P, O).\n    const value = O['[[Get]]'](ctx, P, O);\n    if (value.isAbrupt) { return value; }\n\n    // 5. Return PropertyDescriptor { [[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false }.\n    const desc = new $PropertyDescriptor(realm, P);\n    desc['[[Value]]'] = value;\n    desc['[[Writable]]'] = intrinsics.true;\n    desc['[[Enumerable]]'] = intrinsics.true;\n    desc['[[Configurable]]'] = intrinsics.false;\n\n    return desc;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-defineownproperty-p-desc\n  // 9.4.6.5 [[DefineOwnProperty]] ( P , Desc )\n  public '[[DefineOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Desc: $PropertyDescriptor,\n  ): $Boolean | $Error {\n    // 1. If Type(P) is Symbol, return OrdinaryDefineOwnProperty(O, P, Desc).\n    if (P.isSymbol) {\n      return super['[[DefineOwnProperty]]'](ctx, P, Desc);\n    }\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const O = this;\n\n    // 2. Let current be ? O.[[GetOwnProperty]](P).\n    const current = O['[[GetOwnProperty]]'](ctx, P);\n    if (current.isAbrupt) { return current; }\n\n    // 3. If current is undefined, return false.\n    if (current.isUndefined) {\n      return intrinsics.false;\n    }\n\n    // 4. If IsAccessorDescriptor(Desc) is true, return false.\n    if (Desc.isAccessorDescriptor) {\n      return intrinsics.false;\n    }\n\n    // 5. If Desc.[[Writable]] is present and has value false, return false.\n    if (Desc['[[Writable]]'].hasValue && Desc['[[Writable]]'].isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 6. If Desc.[[Enumerable]] is present and has value false, return false.\n    if (Desc['[[Enumerable]]'].hasValue && Desc['[[Enumerable]]'].isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 7. If Desc.[[Configurable]] is present and has value true, return false.\n    if (Desc['[[Configurable]]'].hasValue === Desc['[[Configurable]]'].isTruthy) {\n      return intrinsics.false;\n    }\n\n    // 8. If Desc.[[Value]] is present, return SameValue(Desc.[[Value]], current.[[Value]]).\n    if (!Desc['[[Value]]'].isEmpty) {\n      if (Desc['[[Value]]'].is(current['[[Value]]'])) {\n        return intrinsics.true;\n      }\n      return intrinsics.false;\n    }\n\n    // 9. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-hasproperty-p\n  // 9.4.6.6 [[HasProperty]] ( P )\n  public '[[HasProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    // 1. If Type(P) is Symbol, return OrdinaryHasProperty(O, P).\n    if (P.isSymbol) {\n      return super['[[HasProperty]]'](ctx, P);\n    }\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const O = this;\n\n    // 2. Let exports be O.[[Exports]].\n    const exports = O['[[Exports]]'];\n\n    // 3. If P is an element of exports, return true.\n    if (exports.some(x => x.is(P))) {\n      return intrinsics.true;\n    }\n\n    // 4. Return false.\n    return intrinsics.false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-get-p-receiver\n  // 9.4.6.7 [[Get]] ( P , Receiver )\n  public '[[Get]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Receiver: $AnyNonEmptyNonError,\n  ): $AnyNonEmpty  {\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. If Type(P) is Symbol, then\n    // 2. a. Return ? OrdinaryGet(O, P, Receiver).\n    if (P.isSymbol) {\n      return super['[[Get]]'](ctx, P, Receiver);\n    }\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const O = this;\n\n    // 3. Let exports be O.[[Exports]].\n    const exports = O['[[Exports]]'];\n\n    // 4. If P is not an element of exports, return undefined.\n    if (exports.every(x => !x.is(P))) {\n      return intrinsics.undefined;\n    }\n\n    // 5. Let m be O.[[Module]].\n    const m = O['[[Module]]'];\n\n    // 6. Let binding be ! m.ResolveExport(P, « »).\n    const binding = m.ResolveExport(ctx, P, new ResolveSet()) as ResolvedBindingRecord;\n\n    // 7. Assert: binding is a ResolvedBinding Record.\n    // 8. Let targetModule be binding.[[Module]].\n    const targetModule = binding.Module;\n\n    // 9. Assert: targetModule is not undefined.\n    // 10. Let targetEnv be targetModule.[[Environment]].\n    const targetEnv = targetModule['[[Environment]]'];\n\n    // 11. If targetEnv is undefined, throw a ReferenceError exception.\n    if (targetEnv.isUndefined) {\n      return new $ReferenceError(realm, `${P['[[Value]]']} cannot be resolved from namespace.`);\n    }\n\n    // 12. Let targetEnvRec be targetEnv's EnvironmentRecord.\n    // 13. Return ? targetEnvRec.GetBindingValue(binding.[[BindingName]], true).\n    return targetEnv.GetBindingValue(ctx, binding.BindingName, intrinsics.true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-set-p-v-receiver\n  // 9.4.6.8 [[Set]] ( P , V , Receiver )\n  public '[[Set]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    V: $AnyNonEmpty ,\n    Receiver: $AnyObject,\n  ): $Boolean<false> {\n    // 1. Return false.\n    return ctx.Realm['[[Intrinsics]]'].false;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-delete-p\n  // 9.4.6.9 [[Delete]] ( P )\n  public '[[Delete]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    // 1. Assert: IsPropertyKey(P) is true.\n    // 2. If Type(P) is Symbol, then\n    // 2. a. Return ? OrdinaryDelete(O, P).\n    if (P.isSymbol) {\n      return super['[[Delete]]'](ctx, P);\n    }\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const O = this;\n\n    // 3. Let exports be O.[[Exports]].\n    const exports = O['[[Exports]]'];\n\n    // 4. If P is an element of exports, return false.\n    if (exports.some(x => x.is(P))) {\n      return intrinsics.false;\n    }\n\n    // 5. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-namespace-exotic-objects-ownpropertykeys\n  // 9.4.6.10 [[OwnPropertyKeys]] ( )\n  public '[[OwnPropertyKeys]]'(\n    ctx: ExecutionContext,\n  ): $List<$PropertyKey> {\n    // 1. Let exports be a copy of O.[[Exports]].\n    const $exports = this['[[Exports]]'].$copy<$PropertyKey>();\n\n    // 2. Let symbolKeys be ! OrdinaryOwnPropertyKeys(O).\n    const symbolKeys = super['[[OwnPropertyKeys]]'](ctx) as $List<$PropertyKey>;\n\n    // 3. Append all the entries of symbolKeys to the end of exports.\n    $exports.push(...symbolKeys);\n\n    // 4. Return exports.\n    return $exports;\n  }\n}\n","import {\n  ClassDeclaration,\n  ClassExpression,\n  createIdentifier,\n  ExpressionWithTypeArguments,\n  HeritageClause,\n  ModifierFlags,\n  NodeArray,\n  PropertyDeclaration,\n  SemicolonClassElement,\n  SyntaxKind,\n  createConstructor,\n  createParameter,\n  createToken,\n  createBlock,\n  createExpressionStatement,\n  createCall,\n  createSuper,\n  createSpread,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $DeclarativeEnvRec,\n  $FunctionEnvRec,\n} from '../types/environment-record.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $Any,\n  CompletionType,\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Null,\n} from '../types/null.js';\nimport {\n  $Empty,\n  empty,\n} from '../types/empty.js';\nimport {\n  $TypeError,\n  $Error,\n} from '../types/error.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  I$Node,\n  Context,\n  $$ESDeclaration,\n  $NodeWithStatements,\n  modifiersToModifierFlags,\n  hasBit,\n  $identifier,\n  $heritageClauseList,\n  $$PropertyName,\n  $$AssignmentExpressionOrHigher,\n  $$propertyName,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$TSDeclaration,\n  $$LHSExpressionOrHigher,\n  $LHSExpression,\n  $LHSExpressionNode,\n  $$ClassElement,\n  $$MethodDefinition,\n  $AnyParentNode,\n  $$classElementList,\n  $ClassElementNode,\n  hasAllBits,\n  $decoratorList,\n  $i,\n  $$ESVarDeclaration,\n  FunctionKind,\n} from './_shared.js';\nimport {\n  ExportEntryRecord,\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Identifier,\n  $Decorator,\n} from './expressions.js';\nimport {\n  $InterfaceDeclaration,\n} from './types.js';\nimport {\n  $ConstructorDeclaration,\n} from './functions.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// #region Declaration members\n\nexport type $$NodeWithHeritageClauses = (\n  $ClassDeclaration |\n  $ClassExpression |\n  $InterfaceDeclaration\n);\n\nexport function $expressionWithTypeArgumentsList(\n  nodes: readonly ExpressionWithTypeArguments[],\n  parent: $HeritageClause,\n  ctx: Context,\n): readonly $ExpressionWithTypeArguments[] {\n  if (nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $ExpressionWithTypeArguments[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $ExpressionWithTypeArguments(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\nexport class $HeritageClause implements I$Node {\n  public get $kind(): SyntaxKind.HeritageClause { return SyntaxKind.HeritageClause; }\n\n  public readonly $types: readonly $ExpressionWithTypeArguments[];\n\n  public constructor(\n    public readonly node: HeritageClause,\n    public readonly parent: $$NodeWithHeritageClauses,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.HeritageClause`,\n  ) {\n    this.$types = $expressionWithTypeArgumentsList(node.types, this, ctx);\n  }\n}\n\nexport class $ExpressionWithTypeArguments implements I$Node {\n  public get $kind(): SyntaxKind.ExpressionWithTypeArguments { return SyntaxKind.ExpressionWithTypeArguments; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n\n  public constructor(\n    public readonly node: ExpressionWithTypeArguments,\n    public readonly parent: $HeritageClause,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ExpressionWithTypeArguments`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n  }\n}\n\n// #endregion\n\nexport class $ClassExpression implements I$Node {\n  public get $kind(): SyntaxKind.ClassExpression { return SyntaxKind.ClassExpression; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $Identifier | undefined;\n  public readonly $heritageClauses: readonly $HeritageClause[];\n  public readonly $members: readonly $$ClassElement[];\n\n  public readonly ClassHeritage: $HeritageClause | undefined;\n\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-boundnames\n  // 14.6.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-constructormethod\n  // 14.6.3 Static Semantics: ConstructorMethod\n  public readonly ConstructorMethod: $ConstructorDeclaration | undefined = void 0;\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-hasname\n  // 14.6.6 Static Semantics: HasName\n  public readonly HasName: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isconstantdeclaration\n  // 14.6.7 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isfunctiondefinition\n  // 14.6.8 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: true = true;\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-nonconstructormethoddefinitions\n  // 14.6.10 Static Semantics: NonConstructorMethodDefinitions\n  public readonly NonConstructorMethodDefinitions: $$MethodDefinition[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-prototypepropertynamelist\n  // 14.6.11 Static Semantics: PrototypePropertyNameList\n  public readonly PrototypePropertyNameList: readonly $String[];\n\n  public constructor(\n    public readonly node: ClassExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ClassExpression`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n    const $heritageClauses = this.$heritageClauses = $heritageClauseList(node.heritageClauses, this, ctx);\n    const $members = this.$members = $$classElementList(node.members as NodeArray<$ClassElementNode>, this, ctx);\n\n    this.ClassHeritage = $heritageClauses.find(h => h.node.token === SyntaxKind.ExtendsKeyword);\n\n    if ($name === void 0) {\n      this.BoundNames = [intrinsics['*default*']];\n    } else {\n      if (hasAllBits(modifierFlags, ModifierFlags.ExportDefault)) {\n        this.BoundNames = [...$name.BoundNames, intrinsics['*default*']];\n      } else {\n        this.BoundNames = $name.BoundNames;\n      }\n    }\n\n    const NonConstructorMethodDefinitions = this.NonConstructorMethodDefinitions = [] as $$MethodDefinition[];\n    const PrototypePropertyNameList = this.PrototypePropertyNameList = [] as $String[];\n\n    let $member: $$ClassElement;\n    for (let i = 0, ii = $members.length; i < ii; ++i) {\n      $member = $members[i];\n      switch ($member.$kind) {\n        case SyntaxKind.PropertyDeclaration:\n          break;\n        case SyntaxKind.Constructor:\n          this.ConstructorMethod = $member;\n          break;\n        case SyntaxKind.MethodDeclaration:\n        case SyntaxKind.GetAccessor:\n        case SyntaxKind.SetAccessor:\n          NonConstructorMethodDefinitions.push($member);\n          if (!$member.PropName.isEmpty && !$member.IsStatic) {\n            PrototypePropertyNameList.push($member.PropName as $String);\n          }\n          break;\n        case SyntaxKind.SemicolonClassElement:\n      }\n    }\n\n    this.HasName = $name !== void 0;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-runtime-semantics-namedevaluation\n  // 14.6.15 Runtime Semantics: NamedEvaluation\n  public EvaluateNamed(\n    ctx: ExecutionContext,\n    name: $String,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // ClassExpression : class ClassTail\n\n    // 1. Return the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and name.\n    return $ClassDeclaration.prototype.EvaluateClassDefinition.call(this, ctx, intrinsics.undefined, name);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-runtime-semantics-evaluation\n  // 14.6.16 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ClassExpression : class BindingIdentifier opt ClassTail\n\n    // 1. If BindingIdentifieropt is not present, let className be undefined.\n    // 2. Else, let className be StringValue of BindingIdentifier.\n    const className = this.$name === void 0 ? intrinsics.undefined : this.$name.StringValue;\n\n    // 3. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments className and className.\n    const value = $ClassDeclaration.prototype.EvaluateClassDefinition.call(this, ctx, className, className);\n\n    // 4. ReturnIfAbrupt(value).\n    if (value.isAbrupt) { return value.enrichWith(ctx, this); }\n\n    // 5. Set value.[[SourceText]] to the source text matched by ClassExpression.\n    value['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 6. Return value.\n    return value;\n  }\n}\n\nexport class $ClassDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.ClassDeclaration { return SyntaxKind.ClassDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $Identifier | $Undefined;\n  public readonly $heritageClauses: readonly $HeritageClause[];\n  public readonly $members: readonly $$ClassElement[];\n\n  public readonly ClassHeritage: $HeritageClause | undefined;\n\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-boundnames\n  // 14.6.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-constructormethod\n  // 14.6.3 Static Semantics: ConstructorMethod\n  public readonly ConstructorMethod: $ConstructorDeclaration | undefined;\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-hasname\n  // 14.6.6 Static Semantics: HasName\n  public readonly HasName: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isconstantdeclaration\n  // 14.6.7 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-static-semantics-isfunctiondefinition\n  // 14.6.8 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: true = true;\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-nonconstructormethoddefinitions\n  // 14.6.10 Static Semantics: NonConstructorMethodDefinitions\n  public readonly NonConstructorMethodDefinitions: readonly $$MethodDefinition[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-prototypepropertynamelist\n  // 14.6.11 Static Semantics: PrototypePropertyNameList\n  public readonly PrototypePropertyNameList: readonly $String[];\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray; // TODO: this is actually not explicitly specced. Need to double check\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportedbindings\n  // 15.2.3.3 Static Semantics: ExportedBindings\n  public readonly ExportedBindings: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportednames\n  // 15.2.3.4 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportentries\n  // 15.2.3.5 Static Semantics: ExportEntries\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-lexicallyscopeddeclarations\n  // 15.2.3.8 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray; // TODO: this is actually not explicitly specced. Need to double check\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-modulerequests\n  // 15.2.3.9 Static Semantics: ModuleRequests\n  public readonly ModuleRequests: readonly $String[];\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public constructor(\n    public readonly node: ClassDeclaration,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ClassDeclaration`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (hasBit(modifierFlags, ModifierFlags.Export)) {\n      ctx |= Context.InExport;\n    }\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    let $name: $Identifier | $Undefined;\n    if (node.name === void 0) {\n      $name = this.$name = new $Undefined(realm, void 0, void 0, this);\n    } else {\n      $name = this.$name = new $Identifier(node.name, this, ctx, -1);\n    }\n    const $heritageClauses = this.$heritageClauses = $heritageClauseList(node.heritageClauses, this, ctx);\n    const $members = this.$members = $$classElementList(node.members as NodeArray<$ClassElementNode>, this, ctx);\n\n    this.ClassHeritage = $heritageClauses.find(h => h.node.token === SyntaxKind.ExtendsKeyword);\n\n    const NonConstructorMethodDefinitions = this.NonConstructorMethodDefinitions = [] as $$MethodDefinition[];\n    const PrototypePropertyNameList = this.PrototypePropertyNameList = [] as $String[];\n\n    let $member: $$ClassElement;\n    for (let i = 0, ii = $members.length; i < ii; ++i) {\n      $member = $members[i];\n      switch ($member.$kind) {\n        case SyntaxKind.PropertyDeclaration:\n          break;\n        case SyntaxKind.Constructor:\n          this.ConstructorMethod = $member;\n          break;\n        case SyntaxKind.MethodDeclaration:\n        case SyntaxKind.GetAccessor:\n        case SyntaxKind.SetAccessor:\n          NonConstructorMethodDefinitions.push($member);\n          if (!$member.PropName.isEmpty && !$member.IsStatic) {\n            PrototypePropertyNameList.push($member.PropName as $String);\n          }\n          break;\n        case SyntaxKind.SemicolonClassElement:\n      }\n    }\n\n    const HasName = this.HasName = !$name.isUndefined;\n\n    if (hasBit(ctx, Context.InExport)) {\n      if (hasBit(this.modifierFlags, ModifierFlags.Default)) {\n        if (HasName) {\n          const [localName] = ($name as $Identifier).BoundNames;\n          const BoundNames = this.BoundNames = [localName, intrinsics['*default*']];\n\n          this.ExportedBindings = BoundNames;\n          this.ExportedNames = [intrinsics['default']];\n          this.ExportEntries = [\n            new ExportEntryRecord(\n              /* source */this,\n              /* ExportName */intrinsics['default'],\n              /* ModuleRequest */intrinsics.null,\n              /* ImportName */intrinsics.null,\n              /* LocalName */localName,\n            ),\n          ];\n        } else {\n          const BoundNames = this.BoundNames = [intrinsics['*default*']];\n\n          this.ExportedBindings = BoundNames;\n          this.ExportedNames = [intrinsics['default']];\n          this.ExportEntries = [\n            new ExportEntryRecord(\n              /* source */this,\n              /* ExportName */intrinsics['default'],\n              /* ModuleRequest */intrinsics.null,\n              /* ImportName */intrinsics.null,\n              /* LocalName */intrinsics['*default*'],\n            ),\n          ];\n        }\n\n        this.LexicallyScopedDeclarations = [this];\n      } else {\n        // Must have a name, so we assume it does\n        const BoundNames = this.BoundNames = ($name as $Identifier).BoundNames;\n        const [localName] = BoundNames;\n\n        this.ExportedBindings = BoundNames;\n        this.ExportedNames = BoundNames;\n        this.ExportEntries = [\n          new ExportEntryRecord(\n            /* source */this,\n            /* ExportName */localName,\n            /* ModuleRequest */intrinsics.null,\n            /* ImportName */intrinsics.null,\n            /* LocalName */localName,\n          ),\n        ];\n\n        this.LexicallyScopedDeclarations = [this];\n      }\n    } else {\n      // Must have a name, so we assume it does\n      this.BoundNames = ($name as $Identifier).BoundNames;\n\n      this.ExportedBindings = emptyArray;\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = emptyArray;\n\n      this.LexicallyScopedDeclarations = emptyArray;\n    }\n\n    this.ModuleRequests = emptyArray;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-classdefinitionevaluation\n  // 14.6.13 Runtime Semantics: ClassDefinitionEvaluation\n  public EvaluateClassDefinition(\n    this: $ClassDeclaration | $ClassExpression,\n    ctx: ExecutionContext,\n    classBinding: $String | $Undefined,\n    className: $String | $Undefined,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // ClassTail : ClassHeritage opt { ClassBody opt }\n\n    // 1. Let lex be the LexicalEnvironment of the running execution context.\n    const lex = ctx.LexicalEnvironment;\n\n    // 2. Let classScope be NewDeclarativeEnvironment(lex).\n    const classScope = new $DeclarativeEnvRec(this.logger, realm, lex);\n\n    // 3. Let classScopeEnvRec be classScope's EnvironmentRecord.\n    // 4. If classBinding is not undefined, then\n    if (!classBinding.isUndefined) {\n      // 4. a. Perform classScopeEnvRec.CreateImmutableBinding(classBinding, true).\n      classScope.CreateImmutableBinding(ctx, classBinding, intrinsics.true);\n    }\n\n    let protoParent: $Object | $Null;\n    let constructorParent: $Object;\n\n    // 5. If ClassHeritageopt is not present, then\n    if (this.ClassHeritage === void 0) {\n      // 5. a. Let protoParent be the intrinsic object %ObjectPrototype%.\n      protoParent = intrinsics['%ObjectPrototype%'];\n\n      // 5. b. Let constructorParent be the intrinsic object %FunctionPrototype%.\n      constructorParent = intrinsics['%FunctionPrototype%'];\n    }\n    // 6. Else,\n    else {\n      // 6. a. Set the running execution context's LexicalEnvironment to classScope.\n      ctx.LexicalEnvironment = classScope;\n\n      // 6. b. Let superclassRef be the result of evaluating ClassHeritage.\n      const superClassRef = this.ClassHeritage.$types[0].$expression.Evaluate(ctx);\n\n      // 6. c. Set the running execution context's LexicalEnvironment to lex.\n      ctx.LexicalEnvironment = lex;\n\n      // 6. d. Let superclass be ? GetValue(superclassRef).\n      const superClass = superClassRef.GetValue(ctx);\n      if (superClass.isAbrupt) { return superClass.enrichWith(ctx, this); }\n\n      // 6. e. If superclass is null, then\n      if (superClass.isNull) {\n        // 6. e. i. Let protoParent be null.\n        protoParent = intrinsics.null;\n\n        // 6. e. ii. Let constructorParent be the intrinsic object %FunctionPrototype%.\n        constructorParent = intrinsics['%FunctionPrototype%'];\n      }\n      // 6. f. Else if IsConstructor(superclass) is false, throw a TypeError exception.\n      else if (!superClass.isFunction) {\n        return new $TypeError(realm, `Superclass is ${superClass}, but expected a function`);\n      }\n      // 6. g. Else,\n      else {\n        // 6. g. i. Let protoParent be ? Get(superclass, \"prototype\").\n        const $protoParent = superClass['[[Get]]'](ctx, intrinsics.$prototype, superClass);\n        if ($protoParent.isAbrupt) { return $protoParent.enrichWith(ctx, this); }\n\n        // 6. g. ii. If Type(protoParent) is neither Object nor Null, throw a TypeError exception.\n        if (!$protoParent.isObject && !$protoParent.isNull) {\n          return new $TypeError(realm, `Superclass prototype is ${superClass}, but expected null or an object`);\n        }\n\n        protoParent = $protoParent;\n\n        // 6. g. iii. Let constructorParent be superclass.\n        constructorParent = superClass;\n      }\n    }\n\n    // 7. Let proto be ObjectCreate(protoParent).\n    const proto = new $Object(realm, 'proto', protoParent, CompletionType.normal, intrinsics.empty);\n\n    let constructor: $ConstructorDeclaration | $Empty;\n\n    // 8. If ClassBodyopt is not present, let constructor be empty.\n    if (this.ConstructorMethod === void 0) {\n      constructor = intrinsics.empty;\n    }\n    // 9. Else, let constructor be ConstructorMethod of ClassBody.\n    else {\n      constructor = this.ConstructorMethod;\n    }\n\n    // 10. If constructor is empty, then\n    if (constructor instanceof $Empty) {\n      // 10. a. If ClassHeritageopt is present, then\n      if (this.ClassHeritage !== void 0) {\n        // 10. a. i. Set constructor to the result of parsing the source text constructor(... args){ super (...args);} using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].\n        constructor = (this as Writable<$ClassDeclaration>).ConstructorMethod = new $ConstructorDeclaration(\n          createConstructor(\n            void 0,\n            void 0,\n            [\n              createParameter(\n                void 0,\n                void 0,\n                createToken(SyntaxKind.DotDotDotToken),\n                createIdentifier('args'),\n              ),\n            ],\n            createBlock(\n              [\n                createExpressionStatement(\n                  createCall(\n                    createSuper(),\n                    void 0,\n                    [\n                      createSpread(\n                        createIdentifier('args'),\n                      ),\n                    ],\n                  ),\n                ),\n              ],\n            ),\n          ),\n          this,\n          this.ctx,\n          -1,\n        );\n      }\n      // 10. b. Else,\n      else {\n        // 10. b. i. Set constructor to the result of parsing the source text constructor(){ } using the syntactic grammar with the goal symbol MethodDefinition[~Yield, ~Await].\n        constructor = (this as Writable<$ClassDeclaration>).ConstructorMethod = new $ConstructorDeclaration(\n          createConstructor(\n            void 0,\n            void 0,\n            [],\n            createBlock([]),\n          ),\n          this,\n          this.ctx,\n          -1,\n        );\n      }\n    }\n\n    // 11. Set the running execution context's LexicalEnvironment to classScope.\n    ctx.LexicalEnvironment = classScope;\n\n    // 12. Let constructorInfo be the result of performing DefineMethod for constructor with arguments proto and constructorParent as the optional functionPrototype argument.\n    const constructorInfo = constructor.DefineMethod(ctx, proto, constructorParent);\n\n    // 13. Assert: constructorInfo is not an abrupt completion.\n    // 14. Let F be constructorInfo.[[Closure]].\n    const F = constructorInfo['[[Closure]]'];\n\n    // 15. If ClassHeritageopt is present, set F.[[ConstructorKind]] to \"derived\".\n    if (this.ClassHeritage !== void 0) {\n      F['[[ConstructorKind]]'] = 'derived';\n    }\n\n    // 16. Perform MakeConstructor(F, false, proto).\n    F.MakeConstructor(ctx, intrinsics.false, proto);\n\n    // 17. Perform MakeClassConstructor(F).\n    F['[[FunctionKind]]'] = FunctionKind.classConstructor;\n\n    // 18. If className is not undefined, then\n    if (!className.isUndefined) {\n      // 18. a. Perform SetFunctionName(F, className).\n      F.SetFunctionName(ctx, className);\n    }\n\n    // 19. Perform CreateMethodProperty(proto, \"constructor\", F).\n    proto['[[DefineOwnProperty]]'](\n      ctx,\n      intrinsics.$constructor,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$constructor,\n        {\n          '[[Value]]': F,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      ),\n    );\n\n    // 20. If ClassBodyopt is not present, let methods be a new empty List.\n    // 21. Else, let methods be NonConstructorMethodDefinitions of ClassBody.\n    const methods = this.NonConstructorMethodDefinitions;\n\n    let status: $Any;\n\n    // 22. For each ClassElement m in order from methods, do\n    for (const m of methods) {\n      // 22. a. If IsStatic of m is false, then\n      if (!m.IsStatic) {\n        // 22. a. i. Let status be the result of performing PropertyDefinitionEvaluation for m with arguments proto and false.\n        status = m.EvaluatePropertyDefinition(ctx, proto, intrinsics.false);\n      }\n      // 22. b. Else,\n      else {\n        // 22. b. i. Let status be the result of performing PropertyDefinitionEvaluation for m with arguments F and false.\n        status = m.EvaluatePropertyDefinition(ctx, F, intrinsics.false);\n      }\n\n      // 22. c. If status is an abrupt completion, then\n      if (status.isAbrupt) {\n        // 22. c. i. Set the running execution context's LexicalEnvironment to lex.\n        ctx.LexicalEnvironment = lex;\n\n        // 22. c. ii. Return Completion(status).\n        return status;\n      }\n    }\n\n    // 23. Set the running execution context's LexicalEnvironment to lex.\n    ctx.LexicalEnvironment = lex;\n\n    // 24. If classBinding is not undefined, then\n    if (!classBinding.isUndefined) {\n      // 24. a. Perform classScopeEnvRec.InitializeBinding(classBinding, F).\n      classScope.InitializeBinding(ctx, classBinding, F);\n    }\n\n    // 25. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-bindingclassdeclarationevaluation\n  // 14.6.14 Runtime Semantics: BindingClassDeclarationEvaluation\n  public EvaluateBindingClassDeclaration(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const name = this.$name;\n    if (name.isUndefined) {\n      // ClassDeclaration : class ClassTail\n\n      // 1. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments undefined and \"default\".\n      const value = this.EvaluateClassDefinition(ctx, intrinsics.undefined, intrinsics.default);\n\n      // 2. ReturnIfAbrupt(value).\n      if (value.isAbrupt) { return value.enrichWith(ctx, this); }\n\n      // 3. Set value.[[SourceText]] to the source text matched by ClassDeclaration.\n      value['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n      // 4. Return value.\n      return value;\n    }\n\n    // ClassDeclaration : class BindingIdentifier ClassTail\n\n    // 1. Let className be StringValue of BindingIdentifier.\n    const className = name.StringValue;\n\n    // 2. Let value be the result of ClassDefinitionEvaluation of ClassTail with arguments className and className.\n    const value = this.EvaluateClassDefinition(ctx, className, className);\n\n    // 3. ReturnIfAbrupt(value).\n    if (value.isAbrupt) { return value.enrichWith(ctx, this); }\n\n    // 4. Set value.[[SourceText]] to the source text matched by ClassDeclaration.\n    value['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 5. Let env be the running execution context's LexicalEnvironment.\n    // 6. Perform ? InitializeBoundName(className, value, env).\n    const $InitializeBoundNameResult = ctx.LexicalEnvironment.InitializeBinding(ctx, className, value);\n    if ($InitializeBoundNameResult.isAbrupt) { return $InitializeBoundNameResult.enrichWith(ctx, this); }\n\n    // 7. Return value.\n    return value;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-class-definitions-runtime-semantics-evaluation\n  // 14.6.16 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Empty | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // ClassDeclaration : class BindingIdentifier ClassTail\n\n    // 1. Perform ? BindingClassDeclarationEvaluation of this ClassDeclaration.\n    const $EvaluateBindingClassDeclarationResult = this.EvaluateBindingClassDeclaration(ctx);\n    if ($EvaluateBindingClassDeclarationResult.isAbrupt) { return $EvaluateBindingClassDeclarationResult.enrichWith(ctx, this); }\n\n    // 2. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    ctx.checkTimeout();\n\n    return this.ConstructorMethod!.EvaluateBody(ctx, functionObject, argumentsList);\n  }\n}\n\nexport class $PropertyDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.PropertyDeclaration { return SyntaxKind.PropertyDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $$PropertyName;\n  public readonly $initializer: $$AssignmentExpressionOrHigher | undefined;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-isstatic\n  // 14.6.9 Static Semantics: IsStatic\n  public readonly IsStatic: boolean;\n\n  public constructor(\n    public readonly node: PropertyDeclaration,\n    public readonly parent: $ClassDeclaration | $ClassExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.PropertyDeclaration`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    this.$name = $$propertyName(node.name, this, ctx | Context.IsMemberName, -1);\n    this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.IsStatic = hasBit(modifierFlags, ModifierFlags.Static);\n  }\n}\n\nexport class $SemicolonClassElement implements I$Node {\n  public get $kind(): SyntaxKind.SemicolonClassElement { return SyntaxKind.SemicolonClassElement; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-isstatic\n  // 14.6.9 Static Semantics: IsStatic\n  public readonly IsStatic: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-static-semantics-propname\n  // 14.3.5 Static Semantics: PropName\n  public readonly PropName: empty = empty;\n\n  public constructor(\n    public readonly node: SemicolonClassElement,\n    public readonly parent: $ClassDeclaration | $ClassExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.SemicolonClassElement`,\n  ) {}\n}\n\n","import {\n  EnumDeclaration,\n  EnumMember,\n  InterfaceDeclaration,\n  ModifierFlags,\n  SyntaxKind,\n  TypeAliasDeclaration,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n} from '../realm.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  I$Node,\n  Context,\n  $$ESDeclaration,\n  $NodeWithStatements,\n  modifiersToModifierFlags,\n  hasBit,\n  $identifier,\n  $heritageClauseList,\n  $$PropertyName,\n  $$AssignmentExpressionOrHigher,\n  $$propertyName,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $i,\n  $$ESVarDeclaration,\n} from './_shared.js';\nimport {\n  ExportEntryRecord,\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Identifier,\n} from './expressions.js';\nimport {\n  $HeritageClause,\n} from './classes.js';\n\nexport class $InterfaceDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.InterfaceDeclaration { return SyntaxKind.InterfaceDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly BoundNames: readonly [$String];\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n\n  public readonly ExportedBindings: readonly $String[];\n  public readonly ExportedNames: readonly $String[];\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n\n  public readonly TypeDeclarations: readonly [$InterfaceDeclaration];\n  public readonly IsType: true = true;\n\n  public readonly $name: $Identifier;\n  public readonly $heritageClauses: readonly $HeritageClause[];\n\n  public constructor(\n    public readonly node: InterfaceDeclaration,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.InterfaceDeclaration`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    ctx |= Context.InTypeElement;\n\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (hasBit(modifierFlags, ModifierFlags.Export)) {\n      ctx |= Context.InExport;\n    }\n\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n    this.$heritageClauses = $heritageClauseList(node.heritageClauses, this, ctx);\n\n    const BoundNames = this.BoundNames = $name.BoundNames;\n    this.TypeDeclarations = [this];\n\n    if (hasBit(ctx, Context.InExport)) {\n      const [localName] = BoundNames;\n\n      this.ExportedBindings = BoundNames;\n      this.ExportedNames = BoundNames;\n      this.ExportEntries = [\n        new ExportEntryRecord(\n          /* source */this,\n          /* ExportName */localName,\n          /* ModuleRequest */intrinsics.null,\n          /* ImportName */intrinsics.null,\n          /* LocalName */localName,\n        ),\n      ];\n    } else {\n      this.ExportedBindings = emptyArray;\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = emptyArray;\n    }\n  }\n}\n\nexport class $TypeAliasDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.TypeAliasDeclaration { return SyntaxKind.TypeAliasDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly BoundNames: readonly [$String];\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n\n  public readonly ExportedBindings: readonly $String[];\n  public readonly ExportedNames: readonly $String[];\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n\n  public readonly TypeDeclarations: readonly [$TypeAliasDeclaration];\n  public readonly IsType: true = true;\n\n  public readonly $name: $Identifier;\n\n  public constructor(\n    public readonly node: TypeAliasDeclaration,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TypeAliasDeclaration`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    ctx |= Context.InTypeElement;\n\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (hasBit(modifierFlags, ModifierFlags.Export)) {\n      ctx |= Context.InExport;\n    }\n\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n\n    const BoundNames = this.BoundNames = $name.BoundNames;\n    this.TypeDeclarations = [this];\n\n    if (hasBit(ctx, Context.InExport)) {\n      const [localName] = BoundNames;\n\n      this.ExportedBindings = BoundNames;\n      this.ExportedNames = BoundNames;\n      this.ExportEntries = [\n        new ExportEntryRecord(\n          /* source */this,\n          /* ExportName */localName,\n          /* ModuleRequest */intrinsics.null,\n          /* ImportName */intrinsics.null,\n          /* LocalName */localName,\n        ),\n      ];\n    } else {\n      this.ExportedBindings = emptyArray;\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = emptyArray;\n    }\n  }\n}\n\nexport function $enumMemberList(\n  nodes: readonly EnumMember[],\n  parent: $EnumDeclaration,\n  ctx: Context,\n): readonly $EnumMember[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $EnumMember[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $EnumMember(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\nexport class $EnumDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.EnumDeclaration { return SyntaxKind.EnumDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly BoundNames: readonly [$String];\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n\n  public readonly ExportedBindings: readonly $String[];\n  public readonly ExportedNames: readonly $String[];\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n\n  public readonly TypeDeclarations: readonly [$EnumDeclaration];\n  public readonly IsType: true = true;\n\n  public readonly $name: $Identifier;\n  public readonly $members: readonly $EnumMember[];\n\n  public constructor(\n    public readonly node: EnumDeclaration,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.EnumDeclaration`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (hasBit(modifierFlags, ModifierFlags.Export)) {\n      ctx |= Context.InExport;\n    }\n\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n    this.$members = $enumMemberList(node.members, this, ctx);\n\n    const BoundNames = this.BoundNames = $name.BoundNames;\n    this.TypeDeclarations = [this];\n\n    if (hasBit(ctx, Context.InExport)) {\n      const [localName] = BoundNames;\n\n      this.ExportedBindings = BoundNames;\n      this.ExportedNames = BoundNames;\n      this.ExportEntries = [\n        new ExportEntryRecord(\n          /* source */this,\n          /* ExportName */localName,\n          /* ModuleRequest */intrinsics.null,\n          /* ImportName */intrinsics.null,\n          /* LocalName */localName,\n        ),\n      ];\n    } else {\n      this.ExportedBindings = emptyArray;\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = emptyArray;\n    }\n  }\n}\n\nexport class $EnumMember implements I$Node {\n  public get $kind(): SyntaxKind.EnumMember { return SyntaxKind.EnumMember; }\n\n  public readonly $name: $$PropertyName;\n  public readonly $initializer: $$AssignmentExpressionOrHigher | undefined;\n\n  public constructor(\n    public readonly node: EnumMember,\n    public readonly parent: $EnumDeclaration,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.EnumMember`,\n  ) {\n    this.$name = $$propertyName(node.name, this, ctx | Context.IsMemberName, -1);\n    this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n  }\n}\n","import {\n  BigIntLiteral,\n  BooleanLiteral,\n  NoSubstitutionTemplateLiteral,\n  NullLiteral,\n  NumericLiteral,\n  RegularExpressionLiteral,\n  StringLiteral,\n  SyntaxKind,\n  TemplateHead,\n  TemplateMiddle,\n  TemplateSpan,\n  TemplateTail,\n} from 'typescript';\nimport {\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Null,\n} from '../types/null.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  I$Node,\n  Context,\n  $$AssignmentExpressionOrHigher,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $AnyParentNode,\n  $i,\n} from './_shared.js';\nimport {\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $TemplateExpression,\n} from './expressions.js';\n\n// #region Pseudo-literals\n\nexport class $TemplateHead implements I$Node {\n  public get $kind(): SyntaxKind.TemplateHead { return SyntaxKind.TemplateHead; }\n\n  public constructor(\n    public readonly node: TemplateHead,\n    public readonly parent: $TemplateExpression,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.TemplateHead`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation\n  // 12.2.9.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $TemplateMiddle implements I$Node {\n  public get $kind(): SyntaxKind.TemplateMiddle { return SyntaxKind.TemplateMiddle; }\n\n  public constructor(\n    public readonly node: TemplateMiddle,\n    public readonly parent: $TemplateExpression | $TemplateSpan,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.TemplateMiddle`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation\n  // 12.2.9.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $TemplateTail implements I$Node {\n  public get $kind(): SyntaxKind.TemplateTail { return SyntaxKind.TemplateTail; }\n\n  public constructor(\n    public readonly node: TemplateTail,\n    public readonly parent: $TemplateExpression | $TemplateSpan,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.TemplateTail`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation\n  // 12.2.9.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    // TemplateSpans : TemplateTail\n\n    // 1. Let tail be the TV of TemplateTail as defined in 11.8.6.\n    // 2. Return the String value consisting of the code units of tail.\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $TemplateSpan implements I$Node {\n  public get $kind(): SyntaxKind.TemplateSpan { return SyntaxKind.TemplateSpan; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $literal: $TemplateMiddle | $TemplateTail;\n\n  public constructor(\n    public readonly node: TemplateSpan,\n    public readonly parent: $TemplateExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TemplateSpan`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    if (node.literal.kind === SyntaxKind.TemplateMiddle) {\n      this.$literal = new $TemplateMiddle(node.literal, this, ctx);\n    } else {\n      this.$literal = new $TemplateTail(node.literal, this, ctx);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation\n  // 12.2.9.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // TemplateSpans : TemplateMiddleList TemplateTail\n\n    // 1. Let head be the result of evaluating TemplateMiddleList.\n    // 2. ReturnIfAbrupt(head).\n    // 3. Let tail be the TV of TemplateTail as defined in 11.8.6.\n    // 4. Return the string-concatenation of head and tail.\n\n    // TemplateMiddleList : TemplateMiddle Expression\n\n    // 1. Let head be the TV of TemplateMiddle as defined in 11.8.6.\n    // 2. Let subRef be the result of evaluating Expression.\n    // 3. Let sub be ? GetValue(subRef).\n    // 4. Let middle be ? ToString(sub).\n    // 5. Return the sequence of code units consisting of the code units of head followed by the elements of middle.\n\n    // TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression\n\n    // 1. Let rest be the result of evaluating TemplateMiddleList.\n    // 2. ReturnIfAbrupt(rest).\n    // 3. Let middle be the TV of TemplateMiddle as defined in 11.8.6.\n    // 4. Let subRef be the result of evaluating Expression.\n    // 5. Let sub be ? GetValue(subRef).\n    // 6. Let last be ? ToString(sub).\n    // 7. Return the sequence of code units consisting of the elements of rest followed by the code units of middle followed by the elements of last.\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\n// #endregion\n\nexport class $NumericLiteral implements I$Node {\n  public get $kind(): SyntaxKind.NumericLiteral { return SyntaxKind.NumericLiteral; }\n\n  public readonly Value: $Number;\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $NumericLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: NumericLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.NumericLiteral`,\n  ) {\n    const num = Number(node.text);\n    this.PropName = new $String(realm, num.toString(), void 0, void 0, this);\n    this.Value = new $Number(realm, num, void 0, void 0, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation\n  // 12.2.4.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Number {\n    ctx.checkTimeout();\n\n    // 1. Return the number whose value is MV of NumericLiteral as defined in 11.8.3.\n    return this.Value;\n  }\n\n  // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation\n  public EvaluatePropName(\n    ctx: ExecutionContext,\n  ): $String {\n    ctx.checkTimeout();\n\n    return this.PropName;\n  }\n}\n\nexport class $BigIntLiteral implements I$Node {\n  public get $kind(): SyntaxKind.BigIntLiteral { return SyntaxKind.BigIntLiteral; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $BigIntLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: BigIntLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.BigIntLiteral`,\n  ) {}\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Number {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics['0']; // TODO: implement this\n  }\n}\n\nexport class $StringLiteral implements I$Node {\n  public get $kind(): SyntaxKind.StringLiteral { return SyntaxKind.StringLiteral; }\n\n  public readonly Value: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-string-literals-static-semantics-stringvalue\n  // 11.8.4.1 Static Semantics: StringValue\n  public readonly StringValue: $String;\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $StringLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: StringLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.StringLiteral`,\n  ) {\n    const StringValue = this.StringValue = new $String(realm, node.text, void 0, void 0, this);\n    this.PropName = StringValue;\n    this.Value = StringValue;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation\n  // 12.2.4.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $String {\n    ctx.checkTimeout();\n\n    // Literal : StringLiteral\n\n    // 1. Return the StringValue of StringLiteral as defined in 11.8.4.1.\n    return this.Value;\n  }\n\n  // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation\n  public EvaluatePropName(\n    ctx: ExecutionContext,\n  ): $String {\n    ctx.checkTimeout();\n\n    return this.PropName;\n  }\n}\n\nexport class $RegularExpressionLiteral implements I$Node {\n  public get $kind(): SyntaxKind.RegularExpressionLiteral { return SyntaxKind.RegularExpressionLiteral; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-regexp-identifier-names-static-semantics-stringvalue\n  // 21.2.1.6 Static Semantics: StringValue\n  public readonly StringValue: string;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $RegularExpressionLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: RegularExpressionLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.RegularExpressionLiteral`,\n  ) {\n    this.StringValue = node.text;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-regular-expression-literals-runtime-semantics-evaluation\n  // 12.2.8.2 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Object {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // PrimaryExpression : RegularExpressionLiteral\n\n    // 1. Let pattern be the String value consisting of the UTF16Encoding of each code point of BodyText of RegularExpressionLiteral.\n    // 2. Let flags be the String value consisting of the UTF16Encoding of each code point of FlagText of RegularExpressionLiteral.\n    // 3. Return RegExpCreate(pattern, flags).\n    return intrinsics['%ObjectPrototype%']; // TODO: implement this\n  }\n}\n\nexport class $NoSubstitutionTemplateLiteral implements I$Node {\n  public get $kind(): SyntaxKind.NoSubstitutionTemplateLiteral { return SyntaxKind.NoSubstitutionTemplateLiteral; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $NoSubstitutionTemplateLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: NoSubstitutionTemplateLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.NoSubstitutionTemplateLiteral`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation\n  // 12.2.9.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $String {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // TemplateLiteral : NoSubstitutionTemplate\n\n    // 1. Return the String value whose code units are the elements of the TV of NoSubstitutionTemplate as defined in 11.8.6.\n    return intrinsics['']; // TODO: implement this\n  }\n}\n\nexport class $NullLiteral implements I$Node {\n  public get $kind(): SyntaxKind.NullKeyword { return SyntaxKind.NullKeyword; }\n\n  public readonly Value: $Null;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $NullLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: NullLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.NullLiteral`,\n  ) {\n    this.Value = new $Null(realm, void 0, void 0, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation\n  // 12.2.4.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Null {\n    ctx.checkTimeout();\n\n    // Literal : NullLiteral\n\n    // 1. Return null.\n    return this.Value;\n  }\n}\n\nexport class $BooleanLiteral implements I$Node {\n  public readonly $kind: SyntaxKind.TrueKeyword | SyntaxKind.FalseKeyword;\n\n  public readonly Value: $Boolean;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $BooleanLiteral = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: BooleanLiteral,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.BooleanLiteral`,\n  ) {\n    this.$kind = node.kind;\n\n    this.Value = new $Boolean(realm, node.kind === SyntaxKind.TrueKeyword, void 0, void 0, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-literals-runtime-semantics-evaluation\n  // 12.2.4.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    ctx.checkTimeout();\n\n    // Literal : BooleanLiteral\n\n    // 1. If BooleanLiteral is the token false, return false.\n    // 2. If BooleanLiteral is the token true, return true.\n    return this.Value;\n  }\n}\n","import {\n  ExportAssignment,\n  ExportDeclaration,\n  ExportSpecifier,\n  ExternalModuleReference,\n  ImportClause,\n  ImportDeclaration,\n  ImportEqualsDeclaration,\n  ImportSpecifier,\n  ModifierFlags,\n  ModuleBlock,\n  ModuleDeclaration,\n  NamedExports,\n  NamedImports,\n  NamespaceExportDeclaration,\n  NamespaceImport,\n  Node,\n  QualifiedName,\n  SourceFile,\n  StringLiteral,\n  SyntaxKind,\n} from 'typescript';\nimport {\n  ILogger,\n  Writable,\n  emptyArray,\n} from '@aurelia/kernel';\nimport {\n  IFile,\n  $CompilerOptions,\n} from '../../system/interfaces';\nimport {\n  NPMPackage,\n} from '../../system/npm-package-loader';\nimport {\n  IModule,\n  ResolveSet,\n  ResolvedBindingRecord,\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $ModuleEnvRec,\n  $EnvRec,\n  $FunctionEnvRec,\n  $GlobalEnvRec,\n} from '../types/environment-record.js';\nimport {\n  $NamespaceExoticObject,\n} from '../exotics/namespace.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Any,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Null,\n} from '../types/null.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  IModuleResolver,\n} from '../../service-host';\nimport {\n  $Error,\n  $SyntaxError,\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  I$Node,\n  Context,\n  $$ESDeclaration,\n  modifiersToModifierFlags,\n  hasBit,\n  $identifier,\n  $$AssignmentExpressionOrHigher,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$TSDeclaration,\n  getBoundNames,\n  $StatementNode,\n  $$ESStatementListItem,\n  GetDirectivePrologue,\n  getLocalName,\n  getImportEntriesForModule,\n  getExportedNames,\n  getExportEntriesForModule,\n  getReferencedBindings,\n  $$ModuleDeclarationParent,\n  $i,\n  $ESStatementListItemNode,\n  $$ESVarDeclaration,\n} from './_shared.js';\nimport {\n  $Identifier,\n} from './expressions.js';\nimport {\n  $ClassDeclaration,\n} from './classes.js';\nimport {\n  DirectivePrologue,\n  $VariableStatement,\n  $Block,\n  $EmptyStatement,\n  $ExpressionStatement,\n  $IfStatement,\n  $DoStatement,\n  $WhileStatement,\n  $ForStatement,\n  $ForInStatement,\n  $ForOfStatement,\n  $ContinueStatement,\n  $BreakStatement,\n  $ReturnStatement,\n  $WithStatement,\n  $SwitchStatement,\n  $LabeledStatement,\n  $ThrowStatement,\n  $TryStatement,\n  $DebuggerStatement,\n} from './statements.js';\nimport {\n  $FunctionDeclaration,\n} from './functions.js';\nimport {\n  $InterfaceDeclaration,\n  $TypeAliasDeclaration,\n  $EnumDeclaration,\n} from './types.js';\nimport {\n  $StringLiteral,\n} from './literals.js';\nimport {\n  $StringSet,\n} from '../globals/string.js';\n\nexport type $$ESModuleItem = (\n  $$ESStatementListItem |\n  $ImportDeclaration |\n  $ExportDeclaration\n);\n\nexport type $$TSModuleItem = (\n  $$ESModuleItem |\n  $$TSDeclaration |\n  $ExportAssignment |\n  $ImportEqualsDeclaration |\n  $ModuleDeclaration |\n  $NamespaceExportDeclaration\n);\n\nexport type $$ESModuleOrScript = (\n  $ESModule |\n  $ESScript\n);\n\n// http://www.ecma-international.org/ecma-262/#sec-scripts\nexport class $ESScript implements I$Node {\n  public readonly '<$ESScript>': unknown;\n\n  public disposed: boolean = false;\n\n  public '[[Environment]]': $Undefined;\n  public '[[HostDefined]]': any;\n\n  public readonly path: string;\n\n  public readonly mos: $ESScript = this;\n  public readonly parent: $ESScript = this;\n  public readonly ctx: Context = Context.None;\n  public readonly depth: number = 0;\n\n  public readonly $statements: readonly $$ESStatementListItem[];\n\n  public readonly DirectivePrologue: DirectivePrologue;\n\n  public ExecutionResult: $Any; // Temporary property for testing purposes\n\n  // http://www.ecma-international.org/ecma-262/#sec-scripts-static-semantics-lexicallydeclarednames\n  // 15.1.3 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-scripts-static-semantics-lexicallyscopeddeclarations\n  // 15.1.4 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-scripts-static-semantics-vardeclarednames\n  // 15.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-scripts-static-semantics-varscopeddeclarations\n  // 15.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly Exclude<$$ESDeclaration, $ClassDeclaration>[];\n\n  public get isNull(): false { return false; }\n  public get isScript(): true { return true; }\n  public get isModule(): false { return false; }\n\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly $file: IFile,\n    public readonly node: SourceFile,\n    public readonly realm: Realm,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.ExecutionResult = intrinsics.empty;\n\n    this['[[Environment]]'] = intrinsics.undefined;\n\n    this.path = `ESScript<(...)${$file.rootlessPath}>`;\n    this.logger = logger.root;\n\n    let ctx = Context.None;\n    this.DirectivePrologue = GetDirectivePrologue(node.statements);\n    if (this.DirectivePrologue.ContainsUseStrict) {\n      ctx |= Context.InStrictMode;\n    }\n\n    const LexicallyDeclaredNames = this.LexicallyDeclaredNames = [] as $String[];\n    const LexicallyScopedDeclarations = this.LexicallyScopedDeclarations = [] as $$ESDeclaration[];\n    const VarDeclaredNames = this.VarDeclaredNames = [] as $String[];\n    const VarScopedDeclarations = this.VarScopedDeclarations = [] as Exclude<$$ESDeclaration, $ClassDeclaration>[];\n\n    const $statements = this.$statements = [] as $$ESStatementListItem[];\n    const statements = node.statements as readonly $ESStatementListItemNode[];\n    let stmt: $ESStatementListItemNode;\n    let $stmt: $$ESStatementListItem;\n    let s = 0;\n    for (let i = 0, ii = statements.length; i < ii; ++i) {\n      stmt = statements[i];\n\n      switch (stmt.kind) {\n        case SyntaxKind.VariableStatement:\n          $stmt = $statements[s] = new $VariableStatement(stmt, this, ctx, s);\n          ++s;\n\n          if ($stmt.isLexical) {\n            LexicallyDeclaredNames.push(...$stmt.BoundNames);\n            LexicallyScopedDeclarations.push($stmt);\n          } else {\n            VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n            VarScopedDeclarations.push($stmt);\n          }\n\n          break;\n        case SyntaxKind.FunctionDeclaration:\n          $stmt = $statements[s] = new $FunctionDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.BoundNames);\n          VarScopedDeclarations.push($stmt);\n          break;\n        case SyntaxKind.ClassDeclaration:\n          $stmt = $statements[s] = new $ClassDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          LexicallyDeclaredNames.push(...$stmt.BoundNames);\n          LexicallyScopedDeclarations.push($stmt);\n          break;\n        case SyntaxKind.Block:\n          $stmt = $statements[s] = new $Block(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.EmptyStatement:\n          $stmt = $statements[s] = new $EmptyStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ExpressionStatement:\n          $stmt = $statements[s] = new $ExpressionStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.IfStatement:\n          $stmt = $statements[s] = new $IfStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.DoStatement:\n          $stmt = $statements[s] = new $DoStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.WhileStatement:\n          $stmt = $statements[s] = new $WhileStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ForStatement:\n          $stmt = $statements[s] = new $ForStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ForInStatement:\n          $stmt = $statements[s] = new $ForInStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ForOfStatement:\n          $stmt = $statements[s] = new $ForOfStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ContinueStatement:\n          $stmt = $statements[s] = new $ContinueStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.BreakStatement:\n          $stmt = $statements[s] = new $BreakStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ReturnStatement:\n          $stmt = $statements[s] = new $ReturnStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.WithStatement:\n          $stmt = $statements[s] = new $WithStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.SwitchStatement:\n          $stmt = $statements[s] = new $SwitchStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.LabeledStatement:\n          $stmt = $statements[s] = new $LabeledStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.TopLevelVarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.TopLevelVarScopedDeclarations);\n          break;\n        case SyntaxKind.ThrowStatement:\n          $stmt = $statements[s] = new $ThrowStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.TryStatement:\n          $stmt = $statements[s] = new $TryStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarDeclaredNames.push(...$stmt.VarDeclaredNames);\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.DebuggerStatement:\n          $stmt = $statements[s] = new $DebuggerStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        default:\n          throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as Node).kind]}.`);\n      }\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-globaldeclarationinstantiation\n  // 15.1.11 Runtime Semantics: GlobalDeclarationInstantiation ( script , env )\n  public InstantiateGlobalDeclaration(\n    ctx: ExecutionContext,\n    env: $GlobalEnvRec,\n  ): $Empty | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const script = this;\n\n    // 1. Let envRec be env's EnvironmentRecord.\n    const envRec = env;\n\n    // 2. Assert: envRec is a global Environment Record.\n    // 3. Let lexNames be the LexicallyDeclaredNames of script.\n    const lexNames = script.LexicallyDeclaredNames;\n\n    // 4. Let varNames be the VarDeclaredNames of script.\n    const varNames = script.VarDeclaredNames;\n\n    // 5. For each name in lexNames, do\n    for (const name of lexNames) {\n      // 5. a. If envRec.HasVarDeclaration(name) is true, throw a SyntaxError exception.\n      if (envRec.HasVarDeclaration(ctx, name).isTruthy) {\n        return new $SyntaxError(realm, `${name} is already var-declared in global scope`).enrichWith(ctx, this);\n      }\n\n      // 5. b. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n      if (envRec.HasLexicalDeclaration(ctx, name).isTruthy) {\n        return new $SyntaxError(realm, `${name} is already lexically-declared in global scope`).enrichWith(ctx, this);\n      }\n\n      // 5. c. Let hasRestrictedGlobal be ? envRec.HasRestrictedGlobalProperty(name).\n      const hasRestrictedGlobal = envRec.HasRestrictedGlobalProperty(ctx, name);\n      if (hasRestrictedGlobal.isAbrupt) { return hasRestrictedGlobal.enrichWith(ctx, this); }\n\n      // 5. d. If hasRestrictedGlobal is true, throw a SyntaxError exception.\n      if (hasRestrictedGlobal.isTruthy) {\n        return new $SyntaxError(realm, `${name} is a restricted global property`).enrichWith(ctx, this);\n      }\n    }\n\n    // 6. For each name in varNames, do\n    for (const name of varNames) {\n      // 6. a. If envRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n      if (envRec.HasLexicalDeclaration(ctx, name).isTruthy) {\n        return new $SyntaxError(realm, `${name} is already lexically-declared in global scope`).enrichWith(ctx, this);\n      }\n    }\n\n    // 7. Let varDeclarations be the VarScopedDeclarations of script.\n    const varDeclarations = script.VarScopedDeclarations;\n\n    // 8. Let functionsToInitialize be a new empty List.\n    const functionsToInitialize: $FunctionDeclaration[] = [];\n\n    // 9. Let declaredFunctionNames be a new empty List.\n    const declaredFunctionNames = new $StringSet();\n\n    // 10. For each d in varDeclarations, in reverse list order, do\n    for (let i = varDeclarations.length - 1; i >= 0; --i) {\n      const d = varDeclarations[i];\n\n      // 10. a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then\n      if (d instanceof $FunctionDeclaration) {\n        // 10. a. i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.\n        // 10. a. ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n        // 10. a. iii. Let fn be the sole element of the BoundNames of d.\n        const [fn] = d.BoundNames;\n\n        // 10. a. iv. If fn is not an element of declaredFunctionNames, then\n        if (!declaredFunctionNames.has(fn)) {\n          // 10. a. iv. 1. Let fnDefinable be ? envRec.CanDeclareGlobalFunction(fn).\n          const fnDefinable = envRec.CanDeclareGlobalFunction(ctx, fn);\n          if (fnDefinable.isAbrupt) { return fnDefinable.enrichWith(ctx, this); }\n\n          // 10. a. iv. 2. If fnDefinable is false, throw a TypeError exception.\n          if (fnDefinable.isFalsey) {\n            return new $TypeError(realm, `function declaration ${fn} cannot be defined in global scope.`).enrichWith(ctx, this);\n          }\n\n          // 10. a. iv. 3. Append fn to declaredFunctionNames.\n          declaredFunctionNames.add(fn);\n\n          // 10. a. iv. 4. Insert d as the first element of functionsToInitialize.\n          functionsToInitialize.unshift(d);\n        }\n      }\n    }\n\n    // 11. Let declaredVarNames be a new empty List.\n    const declaredVarNames = new $StringSet();\n\n    // 12. For each d in varDeclarations, do\n    for (const d of varDeclarations) {\n      // 12. a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then\n      if (!(d instanceof $FunctionDeclaration)) {\n        // 12. a. i. For each String vn in the BoundNames of d, do\n        for (const vn of d.BoundNames) {\n          // 12. a. i. 1. If vn is not an element of declaredFunctionNames, then\n          if (!declaredFunctionNames.has(vn)) {\n            // 12. a. i. 1. a. Let vnDefinable be ? envRec.CanDeclareGlobalVar(vn).\n            const vnDefinable = envRec.CanDeclareGlobalVar(ctx, vn);\n            if (vnDefinable.isAbrupt) { return vnDefinable.enrichWith(ctx, this); }\n\n            // 12. a. i. 1. b. If vnDefinable is false, throw a TypeError exception.\n            if (vnDefinable.isFalsey) {\n              return new $TypeError(realm, `var declaration ${vn} cannot be defined in global scope.`).enrichWith(ctx, this);\n            }\n\n            // 12. a. i. 1. c. If vn is not an element of declaredVarNames, then\n            if (!declaredVarNames.has(vn)) {\n              // 12. a. i. 1. c. i. Append vn to declaredVarNames.\n              declaredVarNames.add(vn);\n            }\n          }\n        }\n      }\n    }\n\n    // 13. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n    // 14. NOTE: Annex B.3.3.2 adds additional steps at this point.\n    // 15. Let lexDeclarations be the LexicallyScopedDeclarations of script.\n    const lexDeclarations = script.LexicallyScopedDeclarations;\n\n    // 16. For each element d in lexDeclarations, do\n    for (const d of lexDeclarations) {\n      // 16. a. NOTE: Lexically declared names are only instantiated here but not initialized.\n      // 16. b. For each element dn of the BoundNames of d, do\n      for (const dn of d.BoundNames) {\n        // 16. b. i. If IsConstantDeclaration of d is true, then\n        if (d.IsConstantDeclaration) {\n          // 16. b. i. 1. Perform ? envRec.CreateImmutableBinding(dn, true).\n          const $CreateImmutableBindingResult = envRec.CreateImmutableBinding(ctx, dn, intrinsics.true);\n          if ($CreateImmutableBindingResult.isAbrupt) { return $CreateImmutableBindingResult.enrichWith(ctx, this); }\n        }\n        // 16. b. ii. Else,\n        else {\n          // 16. b. ii. 1. Perform ? envRec.CreateMutableBinding(dn, false).\n          const $CreateImmutableBindingResult = envRec.CreateImmutableBinding(ctx, dn, intrinsics.false);\n          if ($CreateImmutableBindingResult.isAbrupt) { return $CreateImmutableBindingResult.enrichWith(ctx, this); }\n        }\n      }\n    }\n\n    // 17. For each Parse Node f in functionsToInitialize, do\n    for (const f of functionsToInitialize) {\n      // 17. a. Let fn be the sole element of the BoundNames of f.\n      const [fn] = f.BoundNames;\n\n      // 17. b. Let fo be the result of performing InstantiateFunctionObject for f with argument env.\n      const fo = f.InstantiateFunctionObject(ctx, env);\n      if (fo.isAbrupt) { return fo.enrichWith(ctx, this); }\n\n      // 17. c. Perform ? envRec.CreateGlobalFunctionBinding(fn, fo, false).\n      const $CreateGlobalFunctionBindingResult = envRec.CreateGlobalFunctionBinding(ctx, fn, fo, intrinsics.false);\n      if ($CreateGlobalFunctionBindingResult.isAbrupt) { return $CreateGlobalFunctionBindingResult.enrichWith(ctx, this); }\n    }\n\n    // 18. For each String vn in declaredVarNames, in list order, do\n    for (const vn of declaredVarNames) {\n      // 18. a. Perform ? envRec.CreateGlobalVarBinding(vn, false).\n      const $CreateGlobalVarBindingResult = envRec.CreateGlobalVarBinding(ctx, vn, intrinsics.false);\n      if ($CreateGlobalVarBindingResult.isAbrupt) { return $CreateGlobalVarBindingResult.enrichWith(ctx, this); }\n    }\n\n    // 19. Return NormalCompletion(empty).\n    return new $Empty(realm);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-scriptevaluation\n  // 15.1.10 ScriptEvaluation ( scriptRecord )\n  public EvaluateScript(\n    ctx: ExecutionContext,\n  ): $Any {\n    const scriptRecord = this;\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    const stack = realm.stack;\n\n    // 1. Let globalEnv be scriptRecord.[[Realm]].[[GlobalEnv]].\n    const globalEnv = scriptRecord.realm['[[GlobalEnv]]'];\n\n    // 2. Let scriptCxt be a new ECMAScript code execution context.\n    const scriptCxt = new ExecutionContext(realm);\n\n    // 3. Set the Function of scriptCxt to null.\n    // 4. Set the Realm of scriptCxt to scriptRecord.[[Realm]].\n    // 5. Set the ScriptOrModule of scriptCxt to scriptRecord.\n    scriptCxt.ScriptOrModule = scriptRecord;\n\n    // 6. Set the VariableEnvironment of scriptCxt to globalEnv.\n    scriptCxt.VariableEnvironment = globalEnv;\n\n    // 7. Set the LexicalEnvironment of scriptCxt to globalEnv.\n    scriptCxt.LexicalEnvironment = globalEnv;\n\n    // 8. Suspend the currently running execution context.\n    ctx.suspend();\n\n    // 9. Push scriptCxt on to the execution context stack; scriptCxt is now the running execution context.\n    stack.push(scriptCxt);\n\n    // 10. Let scriptBody be scriptRecord.[[ECMAScriptCode]].\n    const scriptBody = scriptRecord;\n\n    // 11. Let result be GlobalDeclarationInstantiation(scriptBody, globalEnv).\n    let result = scriptBody.InstantiateGlobalDeclaration(scriptCxt, globalEnv) as $Any;\n\n    // 12. If result.[[Type]] is normal, then\n    if (result['[[Type]]'] === CompletionType.normal) {\n      // 12. a. Set result to the result of evaluating scriptBody.\n      const $statements = scriptBody.$statements;\n      let $statement: $$ESStatementListItem;\n      let sl: $Any = (void 0)!;\n      for (let i = 0, ii = $statements.length; i < ii; ++i) {\n        $statement = $statements[i];\n\n        switch ($statement.$kind) {\n          case SyntaxKind.VariableStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.FunctionDeclaration:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.ClassDeclaration:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.Block:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.EmptyStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.ExpressionStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.IfStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.DoStatement:\n            sl = $statement.EvaluateLabelled(scriptCxt, new $StringSet());\n            break;\n          case SyntaxKind.WhileStatement:\n            sl = $statement.EvaluateLabelled(scriptCxt, new $StringSet());\n            break;\n          case SyntaxKind.ForStatement:\n            sl = $statement.EvaluateLabelled(scriptCxt);\n            break;\n          case SyntaxKind.ForInStatement:\n            sl = $statement.EvaluateLabelled(scriptCxt);\n            break;\n          case SyntaxKind.ForOfStatement:\n            sl = $statement.EvaluateLabelled(scriptCxt);\n            break;\n          case SyntaxKind.ContinueStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.BreakStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.ReturnStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.WithStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.SwitchStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.LabeledStatement:\n            sl = $statement.EvaluateLabelled(scriptCxt);\n            break;\n          case SyntaxKind.ThrowStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.TryStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          case SyntaxKind.DebuggerStatement:\n            sl = $statement.Evaluate(scriptCxt);\n            break;\n          default:\n            throw new Error(`Unexpected syntax node: ${SyntaxKind[$statement.$kind]}.`);\n        }\n\n        if (sl.isAbrupt) {\n          sl.enrichWith(ctx, this);\n          break;\n        }\n      }\n\n      result = sl;\n    }\n\n    // 13. If result.[[Type]] is normal and result.[[Value]] is empty, then\n    if (result['[[Type]]'] === CompletionType.normal && result.isEmpty) {\n      // 13. a. Set result to NormalCompletion(undefined).\n      result = new $Undefined(realm);\n    }\n\n    // 14. Suspend scriptCxt and remove it from the execution context stack.\n    scriptCxt.suspend();\n    stack.pop();\n\n    // 15. Assert: The execution context stack is not empty.\n    // 16. Resume the context that is now on the top of the execution context stack as the running execution context.\n    ctx.resume();\n\n    // 17. Return Completion(result).\n    return result;\n  }\n}\n\nexport type ModuleStatus = 'uninstantiated' | 'instantiating' | 'instantiated' | 'evaluating' | 'evaluated';\n\n// http://www.ecma-international.org/ecma-262/#sec-abstract-module-records\n// http://www.ecma-international.org/ecma-262/#sec-cyclic-module-records\n// http://www.ecma-international.org/ecma-262/#sec-source-text-module-records\nexport class $ESModule implements I$Node, IModule {\n  public readonly '<IModule>': unknown;\n\n  public disposed: boolean = false;\n\n  public '[[Environment]]': $ModuleEnvRec | $Undefined;\n  public '[[Namespace]]': $NamespaceExoticObject | $Undefined;\n  public '[[HostDefined]]': any;\n\n  public get isAbrupt(): false { return false; }\n\n  public get $kind(): SyntaxKind.SourceFile { return SyntaxKind.SourceFile; }\n\n  public readonly path: string;\n\n  public readonly mos: $ESModule = this;\n  public readonly parent: $ESModule = this;\n  public readonly ctx: Context = Context.None;\n  public readonly depth: number = 0;\n\n  public readonly $statements: readonly $$TSModuleItem[];\n\n  public readonly DirectivePrologue: DirectivePrologue;\n\n  public ExecutionResult: $Any; // Temporary property for testing purposes\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-exportedbindings\n  // 15.2.1.5 Static Semantics: ExportedBindings\n  public readonly ExportedBindings: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-exportednames\n  // 15.2.1.6 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-exportentries\n  // 15.2.1.7 Static Semantics: ExportEntries\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-importentries\n  // 15.2.1.8 Static Semantics: ImportEntries\n  public readonly ImportEntries: readonly ImportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-importedlocalnames\n  // 15.2.1.9 Static Semantics: ImportedLocalNames ( importEntries )\n  public readonly ImportedLocalNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-modulerequests\n  // 15.2.1.10 Static Semantics: ModuleRequests\n  public readonly ModuleRequests: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-lexicallyscopeddeclarations\n  // 15.2.1.12 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-static-semantics-varscopeddeclarations\n  // 15.2.1.14 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public Status: ModuleStatus;\n  public DFSIndex: number | undefined;\n  public DFSAncestorIndex: number | undefined;\n  public RequestedModules: $String[];\n\n  public readonly LocalExportEntries: readonly ExportEntryRecord[];\n  public readonly IndirectExportEntries: readonly ExportEntryRecord[];\n  public readonly StarExportEntries: readonly ExportEntryRecord[];\n\n  public get isNull(): false { return false; }\n  public get isScript(): false { return false; }\n  public get isModule(): true { return true; }\n\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly $file: IFile,\n    public readonly node: SourceFile,\n    public readonly realm: Realm,\n    public readonly pkg: NPMPackage | null,\n    public readonly moduleResolver: IModuleResolver,\n    public readonly compilerOptions: $CompilerOptions,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.ExecutionResult = intrinsics.empty;\n\n    this['[[Environment]]'] = intrinsics.undefined;\n    this['[[Namespace]]'] = intrinsics.undefined;\n\n    this.path = `ESModule<(...)${$file.rootlessPath}>`;\n    this.logger = logger.root;\n\n    let ctx = Context.None;\n    this.DirectivePrologue = GetDirectivePrologue(node.statements);\n    if (this.DirectivePrologue.ContainsUseStrict) {\n      ctx |= Context.InStrictMode;\n    }\n\n    const ExportedBindings = this.ExportedBindings = [] as $String[];\n    const ExportedNames = this.ExportedNames = [] as $String[];\n    const ExportEntries = this.ExportEntries = [] as ExportEntryRecord[];\n    const ImportEntries = this.ImportEntries = [] as ImportEntryRecord[];\n    const ImportedLocalNames = this.ImportedLocalNames = [] as $String[];\n    const ModuleRequests = this.ModuleRequests = [] as $String[];\n    const LexicallyScopedDeclarations = this.LexicallyScopedDeclarations = [] as $$ESDeclaration[];\n    const VarScopedDeclarations = this.VarScopedDeclarations = [] as $$ESVarDeclaration[];\n\n    const $statements = this.$statements = [] as $$TSModuleItem[];\n    const statements = node.statements as readonly $StatementNode[];\n    let stmt: $StatementNode;\n    let $stmt: $$TSModuleItem;\n    let s = 0;\n    for (let i = 0, ii = statements.length; i < ii; ++i) {\n      stmt = statements[i];\n\n      switch (stmt.kind) {\n        case SyntaxKind.ModuleDeclaration:\n          $stmt = $statements[s] = new $ModuleDeclaration(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.NamespaceExportDeclaration:\n          $stmt = $statements[s] = new $NamespaceExportDeclaration(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ImportEqualsDeclaration:\n          $stmt = $statements[s] = new $ImportEqualsDeclaration(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ImportDeclaration:\n          $stmt = $statements[s] = new $ImportDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          ImportEntries.push(...$stmt.ImportEntries);\n          ImportedLocalNames.push(...$stmt.ImportEntries.map(getLocalName));\n\n          ModuleRequests.push(...$stmt.ModuleRequests);\n          break;\n        case SyntaxKind.ExportAssignment:\n          $stmt = $statements[s] = new $ExportAssignment(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ExportDeclaration:\n          $stmt = $statements[s] = new $ExportDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          ExportedBindings.push(...$stmt.ExportedBindings);\n          ExportedNames.push(...$stmt.ExportedNames);\n          ExportEntries.push(...$stmt.ExportEntries);\n\n          ModuleRequests.push(...$stmt.ModuleRequests);\n\n          LexicallyScopedDeclarations.push(...$stmt.LexicallyScopedDeclarations);\n          break;\n        case SyntaxKind.VariableStatement:\n          $stmt = $statements[s] = new $VariableStatement(stmt, this, ctx, s);\n          ++s;\n\n          if ($stmt.isLexical) {\n            LexicallyScopedDeclarations.push($stmt);\n          } else {\n            VarScopedDeclarations.push($stmt);\n          }\n\n          if (hasBit($stmt.modifierFlags, ModifierFlags.Export)) {\n            ExportedBindings.push(...$stmt.ExportedBindings);\n            ExportedNames.push(...$stmt.ExportedNames);\n            ExportEntries.push(...$stmt.ExportEntries);\n          }\n\n          break;\n        case SyntaxKind.FunctionDeclaration:\n          // Skip overload signature\n          if (stmt.body === void 0) {\n            continue;\n          }\n          $stmt = $statements[s] = new $FunctionDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          if (hasBit($stmt.modifierFlags, ModifierFlags.Export)) {\n            ExportedBindings.push(...$stmt.ExportedBindings);\n            ExportedNames.push(...$stmt.ExportedNames);\n            ExportEntries.push(...$stmt.ExportEntries);\n          }\n\n          LexicallyScopedDeclarations.push($stmt);\n          break;\n        case SyntaxKind.ClassDeclaration:\n          $stmt = $statements[s] = new $ClassDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          if (hasBit($stmt.modifierFlags, ModifierFlags.Export)) {\n            ExportedBindings.push(...$stmt.ExportedBindings);\n            ExportedNames.push(...$stmt.ExportedNames);\n            ExportEntries.push(...$stmt.ExportEntries);\n          }\n\n          LexicallyScopedDeclarations.push($stmt);\n          break;\n        case SyntaxKind.InterfaceDeclaration:\n          $stmt = $statements[s] = new $InterfaceDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          if (hasBit($stmt.modifierFlags, ModifierFlags.Export)) {\n            ExportedBindings.push(...$stmt.ExportedBindings);\n            ExportedNames.push(...$stmt.ExportedNames);\n            ExportEntries.push(...$stmt.ExportEntries);\n          }\n          break;\n        case SyntaxKind.TypeAliasDeclaration:\n          $stmt = $statements[s] = new $TypeAliasDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          if (hasBit($stmt.modifierFlags, ModifierFlags.Export)) {\n            ExportedBindings.push(...$stmt.ExportedBindings);\n            ExportedNames.push(...$stmt.ExportedNames);\n            ExportEntries.push(...$stmt.ExportEntries);\n          }\n          break;\n        case SyntaxKind.EnumDeclaration:\n          $stmt = $statements[s] = new $EnumDeclaration(stmt, this, ctx, s);\n          ++s;\n\n          if (hasBit($stmt.modifierFlags, ModifierFlags.Export)) {\n            ExportedBindings.push(...$stmt.ExportedBindings);\n            ExportedNames.push(...$stmt.ExportedNames);\n            ExportEntries.push(...$stmt.ExportEntries);\n          }\n          break;\n        case SyntaxKind.Block:\n          $stmt = $statements[s] = new $Block(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.EmptyStatement:\n          $stmt = $statements[s] = new $EmptyStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ExpressionStatement:\n          $stmt = $statements[s] = new $ExpressionStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.IfStatement:\n          $stmt = $statements[s] = new $IfStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.DoStatement:\n          $stmt = $statements[s] = new $DoStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.WhileStatement:\n          $stmt = $statements[s] = new $WhileStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ForStatement:\n          $stmt = $statements[s] = new $ForStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ForInStatement:\n          $stmt = $statements[s] = new $ForInStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ForOfStatement:\n          $stmt = $statements[s] = new $ForOfStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ContinueStatement:\n          $stmt = $statements[s] = new $ContinueStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.BreakStatement:\n          $stmt = $statements[s] = new $BreakStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.ReturnStatement:\n          $stmt = $statements[s] = new $ReturnStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.WithStatement:\n          $stmt = $statements[s] = new $WithStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.SwitchStatement:\n          $stmt = $statements[s] = new $SwitchStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.LabeledStatement:\n          $stmt = $statements[s] = new $LabeledStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.ThrowStatement:\n          $stmt = $statements[s] = new $ThrowStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        case SyntaxKind.TryStatement:\n          $stmt = $statements[s] = new $TryStatement(stmt, this, ctx, s);\n          ++s;\n\n          VarScopedDeclarations.push(...$stmt.VarScopedDeclarations);\n          break;\n        case SyntaxKind.DebuggerStatement:\n          $stmt = $statements[s] = new $DebuggerStatement(stmt, this, ctx, s);\n          ++s;\n          break;\n        default:\n          throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as Node).kind]}.`);\n      }\n    }\n\n    // http://www.ecma-international.org/ecma-262/#sec-parsemodule\n    // 15.2.1.17.1 ParseModule ( sourceText , realm , hostDefined )\n\n    // 1. Assert: sourceText is an ECMAScript source text (see clause 10).\n    // 2. Parse sourceText using Module as the goal symbol and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let body be the resulting parse tree. Otherwise, let body be a List of one or more SyntaxError or ReferenceError objects representing the parsing errors and/or early errors. Parsing and early error detection may be interweaved in an implementation-dependent manner. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.\n    // 3. If body is a List of errors, return body.\n    // 4. Let requestedModules be the ModuleRequests of body.\n    const requestedModules = ModuleRequests;\n\n    // 5. Let importEntries be ImportEntries of body.\n    const importEntries = ImportEntries;\n\n    // 6. Let importedBoundNames be ImportedLocalNames(importEntries).\n    const importedBoundNames = ImportedLocalNames;\n\n    // 7. Let indirectExportEntries be a new empty List.\n    const indirectExportEntries: ExportEntryRecord[] = [];\n\n    // 8. Let localExportEntries be a new empty List.\n    const localExportEntries: ExportEntryRecord[] = [];\n\n    // 9. Let starExportEntries be a new empty List.\n    const starExportEntries: ExportEntryRecord[] = [];\n\n    // 10. Let exportEntries be ExportEntries of body.\n    const exportEntries = ExportEntries;\n    let ee: ExportEntryRecord;\n\n    // 11. For each ExportEntry Record ee in exportEntries, do\n    for (let i = 0, ii = exportEntries.length; i < ii; ++i) {\n      ee = exportEntries[i];\n\n      // 11. a. If ee.[[ModuleRequest]] is null, then\n      if (ee.ModuleRequest.isNull) {\n        // 11. a. i. If ee.[[LocalName]] is not an element of importedBoundNames, then\n        if (!importedBoundNames.some(x => x.is(ee.LocalName))) {\n          // 11. a. i. 1. Append ee to localExportEntries.\n          localExportEntries.push(ee);\n        }\n        // 11. a. ii. Else,\n        else {\n          // 11. a. ii. 1. Let ie be the element of importEntries whose [[LocalName]] is the same as ee.[[LocalName]].\n          const ie = importEntries.find(x => x.LocalName.is(ee.LocalName))!;\n          // 11. a. ii. 2. If ie.[[ImportName]] is \"*\", then\n          if (ie.ImportName['[[Value]]'] === '*') {\n            // 11. a. ii. 2. a. Assert: This is a re-export of an imported module namespace object.\n            // 11. a. ii. 2. b. Append ee to localExportEntries.\n            localExportEntries.push(ee);\n          }\n          // 11. a. ii. 3. Else this is a re-export of a single name,\n          else {\n            // 11. a. ii. 3. a. Append the ExportEntry Record { [[ModuleRequest]]: ie.[[ModuleRequest]], [[ImportName]]: ie.[[ImportName]], [[LocalName]]: null, [[ExportName]]: ee.[[ExportName]] } to indirectExportEntries.\n            indirectExportEntries.push(new ExportEntryRecord(\n              /* source */this,\n              /* ExportName */ee.ExportName,\n              /* ModuleRequest */ie.ModuleRequest,\n              /* ImportName */ie.ImportName,\n              /* LocalName */intrinsics.null,\n            ));\n          }\n        }\n      }\n      // 11. b. Else if ee.[[ImportName]] is \"*\", then\n      else if (ee.ImportName['[[Value]]'] === '*') {\n        // 11. b. i. Append ee to starExportEntries.\n        starExportEntries.push(ee);\n      }\n      // 11. c. Else,\n      else {\n        // 11. c. i. Append ee to indirectExportEntries.\n        indirectExportEntries.push(ee);\n      }\n    }\n\n    // 12. Return Source Text Module Record { [[Realm]]: Realm, [[Environment]]: undefined, [[Namespace]]: undefined, [[Status]]: \"uninstantiated\", [[EvaluationError]]: undefined, [[HostDefined]]: hostDefined, [[ECMAScriptCode]]: body, [[RequestedModules]]: requestedModules, [[ImportEntries]]: importEntries, [[LocalExportEntries]]: localExportEntries, [[IndirectExportEntries]]: indirectExportEntries, [[StarExportEntries]]: starExportEntries, [[DFSIndex]]: undefined, [[DFSAncestorIndex]]: undefined }.\n    this.Status = 'uninstantiated';\n    this.DFSIndex = void 0;\n    this.DFSAncestorIndex = void 0;\n\n    this.RequestedModules = requestedModules;\n\n    this.IndirectExportEntries = indirectExportEntries;\n    this.LocalExportEntries = localExportEntries;\n    this.StarExportEntries = starExportEntries;\n\n    this.logger.trace(`RequestedModules: `, requestedModules);\n\n    this.logger.trace(`ImportEntries: `, importEntries);\n\n    this.logger.trace(`IndirectExportEntries: `, indirectExportEntries);\n    this.logger.trace(`LocalExportEntries: `, localExportEntries);\n    this.logger.trace(`StarExportEntries: `, starExportEntries);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-moduledeclarationinstantiation\n  // 15.2.1.16.1 Instantiate ( ) Concrete Method\n  public Instantiate(\n    ctx: ExecutionContext,\n  ): $Undefined | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const start = Date.now();\n    this.logger.debug(`${this.path}.[Instantiate] starting`);\n\n    // TODO: this is temporary. Should be done by RunJobs\n    if (realm.stack.top.ScriptOrModule.isNull) {\n      realm.stack.top.ScriptOrModule = this;\n    }\n\n    // 1. Let module be this Cyclic Module Record.\n    // 2. Assert: module.[[Status]] is not \"instantiating\" or \"evaluating\".\n    // 3. Let stack be a new empty List.\n    const stack = [] as $ESModule[];\n\n    // 4. Let result be InnerModuleInstantiation(module, stack, 0).\n    const result = this._InnerModuleInstantiation(ctx, stack, new $Number(realm, 0));\n\n    // 5. If result is an abrupt completion, then\n    if (result.isAbrupt) {\n      // 5. a. For each module m in stack, do\n      for (const m of stack) {\n        // 5. a. i. Assert: m.[[Status]] is \"instantiating\".\n        // 5. a. ii. Set m.[[Status]] to \"uninstantiated\".\n        m.Status = 'uninstantiated';\n\n        // 5. a. iii. Set m.[[Environment]] to undefined.\n        m['[[Environment]]'] = intrinsics.undefined;\n\n        // 5. a. iv. Set m.[[DFSIndex]] to undefined.\n        m.DFSIndex = void 0;\n\n        // 5. a. v. Set m.[[DFSAncestorIndex]] to undefined.\n        m.DFSAncestorIndex = void 0;\n      }\n\n      // 5. b. Assert: module.[[Status]] is \"uninstantiated\".\n      // 5. c. Return result.\n      return result;\n    }\n\n    // 6. Assert: module.[[Status]] is \"instantiated\" or \"evaluated\".\n    // 7. Assert: stack is empty.\n    // 8. Return undefined.\n\n    const end = Date.now();\n    this.logger.debug(`${this.path}.[Instantiate] done in ${Math.round(end - start)}ms`);\n\n    return new $Undefined(realm);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-innermoduleinstantiation\n  // 15.2.1.16.1.1 InnerModuleInstantiation ( module , stack , idx )\n  /** @internal */\n  public _InnerModuleInstantiation(\n    ctx: ExecutionContext,\n    stack: $ESModule[],\n    idx: $Number,\n  ): $Number | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}._InnerModuleInstantiation(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If module is not a Cyclic Module Record, then\n      // 1. a. Perform ? module.Evaluate(ctx).\n      // 1. b. Return idx.\n\n    // We only deal with cyclic module records for now\n\n    // 2. If module.[[Status]] is \"instantiating\", \"instantiated\", or \"evaluated\", then\n    if (this.Status === 'instantiating' || this.Status === 'instantiated' || this.Status === 'evaluated') {\n      // 2. Return idx.\n      return idx;\n    }\n\n    // 3. Assert: module.[[Status]] is \"uninstantiated\".\n    // 4. Set module.[[Status]] to \"instantiating\".\n    this.Status = 'instantiating';\n\n    // 5. Set module.[[DFSIndex]] to idx.\n    this.DFSIndex = idx['[[Value]]'];\n\n    // 6. Set module.[[DFSAncestorIndex]] to idx.\n    this.DFSAncestorIndex = idx['[[Value]]'];\n\n    // 7. Increase idx by 1.\n    idx = new $Number(realm, idx['[[Value]]'] + 1);\n\n    // 8. Append module to stack.\n    stack.push(this);\n\n    // 9. For each String required that is an element of module.[[RequestedModules]], do\n    for (const required of this.RequestedModules) {\n      // 9. a. Let requiredModule be ? HostResolveImportedModule(module, required).\n      const requiredModule = this.moduleResolver.ResolveImportedModule(ctx, this, required);\n      if (requiredModule.isAbrupt) { return requiredModule.enrichWith(ctx, this); }\n\n      // 9. b. Set idx to ? InnerModuleInstantiation(requiredModule, stack, idx).\n      const $idx = requiredModule._InnerModuleInstantiation(ctx, stack, idx);\n      if ($idx.isAbrupt) { return $idx.enrichWith(ctx, this); }\n      idx = $idx;\n\n      // 9. c. Assert: requiredModule.[[Status]] is either \"instantiating\", \"instantiated\", or \"evaluated\".\n      // 9. d. Assert: requiredModule.[[Status]] is \"instantiating\" if and only if requiredModule is in stack.\n      // 9. e. If requiredModule.[[Status]] is \"instantiating\", then\n      if (requiredModule instanceof $ESModule && requiredModule.Status === 'instantiating') {\n        // 9. e. i. Assert: requiredModule is a Cyclic Module Record.\n        this.logger.warn(`[_InnerModuleInstantiation] ${requiredModule.$file.name} is a cyclic module record`);\n\n        // 9. e. ii. Set module.[[DFSAncestorIndex]] to min(module.[[DFSAncestorIndex]], requiredModule.[[DFSAncestorIndex]]).\n        this.DFSAncestorIndex = Math.min(this.DFSAncestorIndex, requiredModule.DFSAncestorIndex!);\n      }\n    }\n\n    // 10. Perform ? module.InitializeEnvironment().\n    const $InitializeEnvironmentResult = this.InitializeEnvironment(ctx);\n    if ($InitializeEnvironmentResult.isAbrupt) { return $InitializeEnvironmentResult.enrichWith(ctx, this); }\n\n    // 11. Assert: module occurs exactly once in stack.\n    // 12. Assert: module.[[DFSAncestorIndex]] is less than or equal to module.[[DFSIndex]].\n    // 13. If module.[[DFSAncestorIndex]] equals module.[[DFSIndex]], then\n    if (this.DFSAncestorIndex === this.DFSIndex) {\n      // 13. a. Let done be false.\n      let done = false;\n\n      // 13. b. Repeat, while done is false,\n      while (!done) {\n        // 13. b. i. Let requiredModule be the last element in stack.\n        // 13. b. ii. Remove the last element of stack.\n        const requiredModule = stack.pop()!;\n\n        // 13. b. iii. Set requiredModule.[[Status]] to \"instantiated\".\n        requiredModule.Status = 'instantiated';\n        // 13. b. iv. If requiredModule and module are the same Module Record, set done to true.\n        if (requiredModule === this) {\n          done = true;\n        }\n      }\n    }\n\n    // 14. Return idx.\n    return idx;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-source-text-module-record-initialize-environment\n  // 15.2.1.17.4 InitializeEnvironment ( ) Concrete Method\n  public InitializeEnvironment(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeEnvironment(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let module be this Source Text Module Record.\n    // 2. For each ExportEntry Record e in module.[[IndirectExportEntries]], do\n    for (const e of this.IndirectExportEntries) {\n      // 2. a. Let resolution be ? module.ResolveExport(e.[[ExportName]], « »).\n      const resolution = this.ResolveExport(ctx, e.ExportName as $String, new ResolveSet());\n      if (resolution.isAbrupt) { return resolution.enrichWith(ctx, this); }\n\n      // 2. b. If resolution is null or \"ambiguous\", throw a SyntaxError exception.\n      if (resolution.isNull || resolution.isAmbiguous) {\n        return new $SyntaxError(realm, `ResolveExport(${e.ExportName}) returned ${resolution}`);\n      }\n\n      // 2. c. Assert: resolution is a ResolvedBinding Record.\n    }\n\n    // 3. Assert: All named exports from module are resolvable.\n    // 4. Let realm be module.[[Realm]].\n\n    // 5. Assert: Realm is not undefined.\n    // 6. Let env be NewModuleEnvironment(realm.[[GlobalEnv]]).\n    const envRec = new $ModuleEnvRec(this.logger, realm, realm['[[GlobalEnv]]']);\n\n    // 7. Set module.[[Environment]] to env.\n    this['[[Environment]]'] = envRec;\n\n    // 8. Let envRec be env's EnvironmentRecord.\n    // 9. For each ImportEntry Record in in module.[[ImportEntries]], do\n    for (const ie of this.ImportEntries) {\n      // 9. a. Let importedModule be ! HostResolveImportedModule(module, in.[[ModuleRequest]]).\n      const importedModule = this.moduleResolver.ResolveImportedModule(ctx, this, ie.ModuleRequest) as IModule;\n\n      // 9. b. NOTE: The above call cannot fail because imported module requests are a subset of module.[[RequestedModules]], and these have been resolved earlier in this algorithm.\n      // 9. c. If in.[[ImportName]] is \"*\", then\n      if (ie.ImportName['[[Value]]'] === '*') {\n        // 9. c. i. Let namespace be ? GetModuleNamespace(importedModule).\n        const namespace = (function (mod) {\n          // http://www.ecma-international.org/ecma-262/#sec-getmodulenamespace\n          // 15.2.1.19 Runtime Semantics: GetModuleNamespace ( module )\n\n          // 1. Assert: module is an instance of a concrete subclass of Module Record.\n          // 2. Assert: module.[[Status]] is not \"uninstantiated\".\n          // 3. Let namespace be module.[[Namespace]].\n          let namespace = mod['[[Namespace]]'];\n\n          // 4. If namespace is undefined, then\n          if (namespace.isUndefined) {\n            // 4. a. Let exportedNames be ? module.GetExportedNames(« »).\n            const exportedNames = mod.GetExportedNames(ctx, new Set());\n            if (exportedNames.isAbrupt) { return exportedNames.enrichWith(ctx, mod as unknown as I$Node); }\n\n            // 4. b. Let unambiguousNames be a new empty List.\n            const unambiguousNames = new $List<$String>();\n\n            // 4. c. For each name that is an element of exportedNames, do\n            for (const name of exportedNames) {\n              // 4. c. i. Let resolution be ? module.ResolveExport(name, « »).\n              const resolution = mod.ResolveExport(ctx, name, new ResolveSet());\n              if (resolution.isAbrupt) { return resolution.enrichWith(ctx, mod as unknown as I$Node); }\n\n              // 4. c. ii. If resolution is a ResolvedBinding Record, append name to unambiguousNames.\n              if (resolution instanceof ResolvedBindingRecord) {\n                unambiguousNames.push(name);\n              }\n            }\n\n            // 4. d. Set namespace to ModuleNamespaceCreate(module, unambiguousNames).\n            namespace = new $NamespaceExoticObject(realm, mod, unambiguousNames);\n          }\n\n          // 5. Return namespace.\n          return namespace;\n        })(importedModule);\n\n        // 9. c. ii. Perform ! envRec.CreateImmutableBinding(in.[[LocalName]], true).\n        envRec.CreateImmutableBinding(ctx, ie.LocalName, intrinsics.true);\n\n        // 9. c. iii. Call envRec.InitializeBinding(in.[[LocalName]], namespace).\n        if (namespace.isAbrupt) { return namespace.enrichWith(ctx, this); } // TODO: sure about this? Spec doesn't say it\n        envRec.InitializeBinding(ctx, ie.LocalName, namespace);\n      }\n      // 9. d. Else,\n      else {\n        // 9. d. i. Let resolution be ? importedModule.ResolveExport(in.[[ImportName]], « »).\n        const resolution = importedModule.ResolveExport(ctx, ie.ImportName, new ResolveSet());\n        if (resolution.isAbrupt) { return resolution.enrichWith(ctx, this); }\n\n        // 9. d. ii. If resolution is null or \"ambiguous\", throw a SyntaxError exception.\n        if (resolution.isNull || resolution.isAmbiguous) {\n          return new $SyntaxError(realm, `ResolveExport(${ie.ImportName}) returned ${resolution}`);\n        }\n\n        // 9. d. iii. Call envRec.CreateImportBinding(in.[[LocalName]], resolution.[[Module]], resolution.[[BindingName]]).\n        envRec.CreateImportBinding(ctx, ie.LocalName, resolution.Module, resolution.BindingName);\n      }\n    }\n\n    // 10. Let code be module.[[ECMAScriptCode]].\n    // 11. Let varDeclarations be the VarScopedDeclarations of code.\n    const varDeclarations = this.VarScopedDeclarations;\n\n    // 12. Let declaredVarNames be a new empty List.\n    const declaredVarNames = new $List<$String>();\n\n    // 13. For each element d in varDeclarations, do\n    for (const d of varDeclarations) {\n      // 13. a. For each element dn of the BoundNames of d, do\n      for (const dn of d.BoundNames) {\n        // 13. a. i. If dn is not an element of declaredVarNames, then\n        if (!declaredVarNames.$contains(dn)) {\n          // 13. a. i. 1. Perform ! envRec.CreateMutableBinding(dn, false).\n          envRec.CreateMutableBinding(ctx, dn, intrinsics.false);\n\n          // 13. a. i. 2. Call envRec.InitializeBinding(dn, undefined).\n          envRec.InitializeBinding(ctx, dn, intrinsics.undefined);\n\n          // 13. a. i. 3. Append dn to declaredVarNames.\n          declaredVarNames.push(dn);\n        }\n      }\n    }\n\n    // 14. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n    const lexDeclarations = this.LexicallyScopedDeclarations;\n\n    // 15. For each element d in lexDeclarations, do\n    for (const d of lexDeclarations) {\n      // 15. a. For each element dn of the BoundNames of d, do\n      for (const dn of d.BoundNames) {\n        // 15. a. i. If IsConstantDeclaration of d is true, then\n        if (d.IsConstantDeclaration) {\n          // 15. a. i. 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n          envRec.CreateImmutableBinding(ctx, dn, intrinsics.true);\n        }\n        // 15. a. ii. Else,\n        else {\n          // 15. a. ii. 1. Perform ! envRec.CreateMutableBinding(dn, false).\n          envRec.CreateMutableBinding(ctx, dn, intrinsics.false);\n\n          // 15. a. iii. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then\n          if (d.$kind === SyntaxKind.FunctionDeclaration) {\n            // 15. a. iii. 1. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n            const fo = d.InstantiateFunctionObject(ctx, envRec);\n            if (fo.isAbrupt) { return fo.enrichWith(ctx, this); }\n\n            // 15. a. iii. 2. Call envRec.InitializeBinding(dn, fo).\n            envRec.InitializeBinding(ctx, dn, fo);\n          }\n        }\n      }\n    }\n\n    // 16. Return NormalCompletion(empty).\n    return new $Empty(realm);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getexportednames\n  // 15.2.1.17.2 GetExportedNames ( exportStarSet ) Concrete Method\n  public GetExportedNames(\n    ctx: ExecutionContext,\n    exportStarSet: Set<IModule>,\n  ): $List<$String> | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let module be this Source Text Module Record.\n    const mod = this;\n\n    // 2. If exportStarSet contains module, then\n    if (exportStarSet.has(mod)) {\n      // 2. a. Assert: We've reached the starting point of an import * circularity.\n      // 2. b. Return a new empty List.\n      return new $List();\n    }\n\n    // 3. Append module to exportStarSet.\n    exportStarSet.add(mod);\n\n    // 4. Let exportedNames be a new empty List.\n    const exportedNames = new $List<$String>();\n\n    // 5. For each ExportEntry Record e in module.[[LocalExportEntries]], do\n    for (const e of mod.LocalExportEntries) {\n      // 5. a. Assert: module provides the direct binding for this export.\n      // 5. b. Append e.[[ExportName]] to exportedNames.\n      exportedNames.push(e.ExportName as $String);\n    }\n\n    // 6. For each ExportEntry Record e in module.[[IndirectExportEntries]], do\n    for (const e of mod.IndirectExportEntries) {\n      // 6. a. Assert: module imports a specific binding for this export.\n      // 6. b. Append e.[[ExportName]] to exportedNames.\n      exportedNames.push(e.ExportName as $String);\n    }\n\n    // 7. For each ExportEntry Record e in module.[[StarExportEntries]], do\n    for (const e of mod.StarExportEntries) {\n      // 7. a. Let requestedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).\n      const requestedModule = this.moduleResolver.ResolveImportedModule(ctx, mod, e.ModuleRequest as $String);\n      if (requestedModule.isAbrupt) { return requestedModule.enrichWith(ctx, this); }\n\n      // 7. b. Let starNames be ? requestedModule.GetExportedNames(exportStarSet).\n      const starNames = requestedModule.GetExportedNames(ctx, exportStarSet);\n      if (starNames.isAbrupt) { return starNames.enrichWith(ctx, this); }\n\n      // 7. c. For each element n of starNames, do\n      for (const n of starNames) {\n        // 7. c. i. If SameValue(n, \"default\") is false, then\n        if (n['[[Value]]'] !== 'default') {\n          // 7. c. i. 1. If n is not an element of exportedNames, then\n          if (!exportedNames.$contains(n)) {\n            // 7. c. i. 1. a. Append n to exportedNames.\n            exportedNames.push(n);\n          }\n        }\n      }\n    }\n\n    // 8. Return exportedNames.\n    return exportedNames;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-resolveexport\n  // 15.2.1.17.3 ResolveExport ( exportName , resolveSet ) Concrete Method\n  public ResolveExport(\n    ctx: ExecutionContext,\n    exportName: $String,\n    resolveSet: ResolveSet,\n  ): ResolvedBindingRecord | $Null | $String<'ambiguous'> | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let module be this Source Text Module Record.\n    // 2. For each Record { [[Module]], [[ExportName]] } r in resolveSet, do\n    // 2. a. If module and r.[[Module]] are the same Module Record and SameValue(exportName, r.[[ExportName]]) is true, then\n    if (resolveSet.has(this, exportName)) {\n      // 2. a. i. Assert: This is a circular import request.\n      // 2. a. ii. Return null.\n      this.logger.warn(`[ResolveExport] Circular import: ${exportName}`);\n      return new $Null(realm);\n    }\n\n    // 3. Append the Record { [[Module]]: module, [[ExportName]]: exportName } to resolveSet.\n    resolveSet.add(this, exportName);\n\n    // 4. For each ExportEntry Record e in module.[[LocalExportEntries]], do\n    for (const e of this.LocalExportEntries) {\n      // 4. a. If SameValue(exportName, e.[[ExportName]]) is true, then\n      if (exportName.is(e.ExportName)) {\n        // 4. a. i. Assert: module provides the direct binding for this export.\n        this.logger.debug(`${this.path}.[ResolveExport] found direct binding for ${exportName['[[Value]]']}`);\n\n        // 4. a. ii. Return ResolvedBinding Record { [[Module]]: module, [[BindingName]]: e.[[LocalName]] }.\n        return new ResolvedBindingRecord(this, e.LocalName as $String);\n      }\n    }\n\n    // 5. For each ExportEntry Record e in module.[[IndirectExportEntries]], do\n    for (const e of this.IndirectExportEntries) {\n      // 5. a. If SameValue(exportName, e.[[ExportName]]) is true, then\n      if (exportName.is(e.ExportName)) {\n        // 5. a. i. Assert: module imports a specific binding for this export.\n        this.logger.debug(`${this.path}.[ResolveExport] found specific imported binding for ${exportName['[[Value]]']}`);\n\n        // 5. a. ii. Let importedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).\n        const importedModule = this.moduleResolver.ResolveImportedModule(ctx, this, e.ModuleRequest as $String);\n        if (importedModule.isAbrupt) { return importedModule.enrichWith(ctx, this); }\n\n        // 5. a. iii. Return importedModule.ResolveExport(e.[[ImportName]], resolveSet).\n        return importedModule.ResolveExport(ctx, e.ImportName as $String, resolveSet);\n      }\n    }\n\n    // 6. If SameValue(exportName, \"default\") is true, then\n    if (exportName['[[Value]]'] === 'default') {\n      // 6. a. Assert: A default export was not explicitly defined by this module.\n      // 6. b. Return null.\n      this.logger.warn(`[ResolveExport] No default export defined`);\n\n      return new $Null(realm);\n      // 6. c. NOTE: A default export cannot be provided by an export *.\n    }\n\n    // 7. Let starResolution be null.\n    let starResolution: ResolvedBindingRecord | $Null = new $Null(realm);\n\n    // 8. For each ExportEntry Record e in module.[[StarExportEntries]], do\n    for (const e of this.StarExportEntries) {\n      // 8. a. Let importedModule be ? HostResolveImportedModule(module, e.[[ModuleRequest]]).\n      const importedModule = this.moduleResolver.ResolveImportedModule(ctx, this, e.ModuleRequest as $String);\n      if (importedModule.isAbrupt) { return importedModule.enrichWith(ctx, this); }\n\n      // 8. b. Let resolution be ? importedModule.ResolveExport(exportName, resolveSet).\n      const resolution = importedModule.ResolveExport(ctx, exportName, resolveSet);\n      if (resolution.isAbrupt) { return resolution.enrichWith(ctx, this); }\n\n      // 8. c. If resolution is \"ambiguous\", return \"ambiguous\".\n      if (resolution.isAmbiguous) {\n        this.logger.warn(`[ResolveExport] ambiguous resolution for ${exportName['[[Value]]']}`);\n\n        return resolution;\n      }\n\n      // 8. d. If resolution is not null, then\n      if (!resolution.isNull) {\n        // 8. d. i. Assert: resolution is a ResolvedBinding Record.\n        // 8. d. ii. If starResolution is null, set starResolution to resolution.\n        if (starResolution.isNull) {\n          starResolution = resolution;\n        }\n        // 8. d. iii. Else,\n        else {\n          // 8. d. iii. 1. Assert: There is more than one * import that includes the requested name.\n          // 8. d. iii. 2. If resolution.[[Module]] and starResolution.[[Module]] are not the same Module Record or SameValue(resolution.[[BindingName]], starResolution.[[BindingName]]) is false, return \"ambiguous\".\n          if (!(resolution.Module === starResolution.Module && resolution.BindingName.is(starResolution.BindingName))) {\n            this.logger.warn(`[ResolveExport] ambiguous resolution for ${exportName['[[Value]]']}`);\n\n            return new $String(realm, 'ambiguous');\n          }\n        }\n      }\n    }\n\n    if (starResolution.isNull) {\n      this.logger.warn(`[ResolveExport] starResolution is null for ${exportName['[[Value]]']}`);\n    }\n\n    // 9. Return starResolution.\n    return starResolution;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-moduleevaluation\n  // 15.2.1.16.2 Evaluate ( ) Concrete Method\n  public EvaluateModule(\n    ctx: ExecutionContext,\n  ): $Any {\n    this.logger.debug(`${this.path}.EvaluateModule()`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let module be this Cyclic Module Record.\n    // 2. Assert: module.[[Status]] is \"instantiated\" or \"evaluated\".\n    // 3. Let stack be a new empty List.\n    const stack: $ESModule[] = [];\n\n    // 4. Let result be InnerModuleEvaluation(module, stack, 0).\n    const result = this.EvaluateModuleInner(ctx, stack, 0);\n\n    // 5. If result is an abrupt completion, then\n    if (result.isAbrupt) {\n      // 5. a. For each module m in stack, do\n      for (const m of stack) {\n        // 5. a. i. Assert: m.[[Status]] is \"evaluating\".\n        // 5. a. ii. Set m.[[Status]] to \"evaluated\".\n        m.Status = 'evaluated';\n\n        // 5. a. iii. Set m.[[EvaluationError]] to result.\n        // TODO\n      }\n\n      // 5. b. Assert: module.[[Status]] is \"evaluated\" and module.[[EvaluationError]] is result.\n      // 5. c. Return result.\n      return result;\n    }\n\n    // 6. Assert: module.[[Status]] is \"evaluated\" and module.[[EvaluationError]] is undefined.\n    // 7. Assert: stack is empty.\n    // 8. Return undefined.\n    return new $Undefined(realm, CompletionType.normal, intrinsics.empty, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-innermoduleevaluation\n  // 15.2.1.16.2.1 InnerModuleEvaluation ( module , stack , idx )\n  public EvaluateModuleInner(\n    ctx: ExecutionContext,\n    stack: $ESModule[],\n    idx: number,\n  ): $Number | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.EvaluateModuleInner(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If module is not a Cyclic Module Record, then\n    // 1. a. Perform ? module.Evaluate(ctx).\n    // 1. b. Return idx.\n    // 2. If module.[[Status]] is \"evaluated\", then\n    if (this.Status === 'evaluated') {\n      // 2. a. If module.[[EvaluationError]] is undefined, return idx.\n      return new $Number(realm, idx); // TODO\n\n      // 2. b. Otherwise return module.[[EvaluationError]].\n    }\n\n    // 3. If module.[[Status]] is \"evaluating\", return idx.\n    if (this.Status === 'evaluating') {\n      return new $Number(realm, idx);\n    }\n\n    // 4. Assert: module.[[Status]] is \"instantiated\".\n    // 5. Set module.[[Status]] to \"evaluating\".\n    this.Status = 'evaluating';\n\n    // 6. Set module.[[DFSIndex]] to idx.\n    this.DFSIndex = idx;\n\n    // 7. Set module.[[DFSAncestorIndex]] to idx.\n    this.DFSAncestorIndex = idx;\n\n    // 8. Increase idx by 1.\n    ++idx;\n\n    // 9. Append module to stack.\n    stack.push(this);\n\n    // 10. For each String required that is an element of module.[[RequestedModules]], do\n    for (const required of this.RequestedModules) {\n      // 10. a. Let requiredModule be ! HostResolveImportedModule(module, required).\n      const requiredModule = this.moduleResolver.ResolveImportedModule(ctx, this, required) as $ESModule; // TODO\n\n      // 10. b. NOTE: Instantiate must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.\n      // 10. c. Set idx to ? InnerModuleEvaluation(requiredModule, stack, idx).\n      const $EvaluateModuleInnerResult = requiredModule.EvaluateModuleInner(ctx, stack, idx);\n      if ($EvaluateModuleInnerResult.isAbrupt) { return $EvaluateModuleInnerResult.enrichWith(ctx, this); }\n\n      idx = $EvaluateModuleInnerResult['[[Value]]'];\n\n      // 10. d. Assert: requiredModule.[[Status]] is either \"evaluating\" or \"evaluated\".\n      // 10. e. Assert: requiredModule.[[Status]] is \"evaluating\" if and only if requiredModule is in stack.\n      // 10. f. If requiredModule.[[Status]] is \"evaluating\", then\n      if (requiredModule.Status === 'evaluating') {\n        // 10. f. i. Assert: requiredModule is a Cyclic Module Record.\n        // 10. f. ii. Set module.[[DFSAncestorIndex]] to min(module.[[DFSAncestorIndex]], requiredModule.[[DFSAncestorIndex]]).\n        this.DFSAncestorIndex = Math.min(this.DFSAncestorIndex, requiredModule.DFSAncestorIndex!);\n      }\n    }\n\n    // 11. Perform ? module.ExecuteModule().\n    const $ExecuteModuleResult = this.ExecutionResult = this.ExecuteModule(ctx);\n    if ($ExecuteModuleResult.isAbrupt) { return $ExecuteModuleResult.enrichWith(ctx, this); }\n\n    // 12. Assert: module occurs exactly once in stack.\n    // 13. Assert: module.[[DFSAncestorIndex]] is less than or equal to module.[[DFSIndex]].\n    // 14. If module.[[DFSAncestorIndex]] equals module.[[DFSIndex]], then\n    if (this.DFSAncestorIndex === this.DFSIndex) {\n      // 14. a. Let done be false.\n      let done = false;\n      // 14. b. Repeat, while done is false,\n      while (!done) {\n        // 14. b. i. Let requiredModule be the last element in stack.\n        // 14. b. ii. Remove the last element of stack.\n        const requiredModule = stack.pop()!;\n\n        // 14. b. iii. Set requiredModule.[[Status]] to \"evaluated\".\n        requiredModule.Status = 'evaluated';\n\n        // 14. b. iv. If requiredModule and module are the same Module Record, set done to true.\n        if (requiredModule === this) {\n          done = true;\n        }\n      }\n    }\n\n    // 15. Return idx.\n    return new $Number(realm, idx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-source-text-module-record-execute-module\n  // 15.2.1.17.5 ExecuteModule ( ) Concrete Method\n  public ExecuteModule(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.ExecuteModule(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let module be this Source Text Module Record.\n    // 2. Let moduleCxt be a new ECMAScript code execution context.\n    const moduleCxt = new ExecutionContext(this.realm);\n\n    // 3. Set the Function of moduleCxt to null.\n    moduleCxt.Function = intrinsics.null;\n\n    // 4. Assert: module.[[Realm]] is not undefined.\n\n    // 5. Set the Realm of moduleCxt to module.[[Realm]].\n\n    // 6. Set the ScriptOrModule of moduleCxt to module.\n    moduleCxt.ScriptOrModule = this;\n\n    // 7. Assert: module has been linked and declarations in its module environment have been instantiated.\n    // 8. Set the VariableEnvironment of moduleCxt to module.[[Environment]].\n    moduleCxt.VariableEnvironment = this['[[Environment]]'] as ($ModuleEnvRec | $FunctionEnvRec);\n\n    // 9. Set the LexicalEnvironment of moduleCxt to module.[[Environment]].\n    moduleCxt.LexicalEnvironment = this['[[Environment]]'] as $EnvRec;\n\n    // 10. Suspend the currently running execution context.\n    const stack = realm.stack;\n    ctx.suspend();\n\n    // 11. Push moduleCxt on to the execution context stack; moduleCxt is now the running execution context.\n    stack.push(moduleCxt);\n\n    // 12. Let result be the result of evaluating module.[[ECMAScriptCode]].\n    const result = this.Evaluate(moduleCxt);\n\n    // 13. Suspend moduleCxt and remove it from the execution context stack.\n    moduleCxt.suspend();\n    stack.pop();\n\n    // 14. Resume the context that is now on the top of the execution context stack as the running execution context.\n    ctx.resume();\n\n    // 15. Return Completion(result).\n    return result;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-module-semantics-runtime-semantics-evaluation\n  // 15.2.1.21 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    const $statements = this.$statements;\n\n    // Module : [empty]\n\n    // 1. Return NormalCompletion(undefined).\n\n    // ModuleBody : ModuleItemList\n\n    // 1. Let result be the result of evaluating ModuleItemList.\n    // 2. If result.[[Type]] is normal and result.[[Value]] is empty, then\n    // 2. a. Return NormalCompletion(undefined).\n    // 3. Return Completion(result).\n\n    // ModuleItemList : ModuleItemList ModuleItem\n\n    // 1. Let sl be the result of evaluating ModuleItemList.\n    // 2. ReturnIfAbrufpt(sl).\n    // 3. Let s be the result of evaluating ModuleItem.\n    // 4. Return Completion(UpdateEmpty(s, sl)).\n\n    // ModuleItem : ImportDeclaration\n\n    // 1. Return NormalCompletion(empty).\n\n    let $statement: $$TSModuleItem;\n    let sl: $Any = (void 0)!;\n    for (let i = 0, ii = $statements.length; i < ii; ++i) {\n      $statement = $statements[i];\n\n      switch ($statement.$kind) {\n        case SyntaxKind.ModuleDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.NamespaceExportDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ImportEqualsDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ImportDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ExportAssignment:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ExportDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.VariableStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.FunctionDeclaration:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ClassDeclaration:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.InterfaceDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.TypeAliasDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.EnumDeclaration:\n          // sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.Block:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.EmptyStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ExpressionStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.IfStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.DoStatement:\n          sl = $statement.EvaluateLabelled(ctx, new $StringSet());\n          break;\n        case SyntaxKind.WhileStatement:\n          sl = $statement.EvaluateLabelled(ctx, new $StringSet());\n          break;\n        case SyntaxKind.ForStatement:\n          sl = $statement.EvaluateLabelled(ctx);\n          break;\n        case SyntaxKind.ForInStatement:\n          sl = $statement.EvaluateLabelled(ctx);\n          break;\n        case SyntaxKind.ForOfStatement:\n          sl = $statement.EvaluateLabelled(ctx);\n          break;\n        case SyntaxKind.ContinueStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.BreakStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.ReturnStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.WithStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.SwitchStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.LabeledStatement:\n          sl = $statement.EvaluateLabelled(ctx);\n          break;\n        case SyntaxKind.ThrowStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.TryStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        case SyntaxKind.DebuggerStatement:\n          sl = $statement.Evaluate(ctx);\n          break;\n        default:\n          throw new Error(`Unexpected syntax node: ${SyntaxKind[$statement.$kind]}.`);\n      }\n\n      if (sl.isAbrupt) { return sl.enrichWith(ctx, this); }\n    }\n\n    return sl;\n  }\n\n  public dispose(this: Writable<Partial<$ESModule>>): void {\n    if (this.disposed) {\n      return;\n    }\n\n    this.disposed = true;\n\n    this['[[Environment]]'] = void 0;\n    this['[[Namespace]]'] = void 0;\n\n    this.mos = void 0;\n    this.parent = void 0;\n\n    this.$statements = void 0;\n    this.DirectivePrologue = void 0;\n    this.ExecutionResult = void 0;\n\n    this.ExportedBindings = void 0;\n    this.ExportedNames = void 0;\n    this.ExportEntries = void 0;\n    this.ImportEntries = void 0;\n    this.ImportedLocalNames = void 0;\n    this.ModuleRequests = void 0;\n    this.LexicallyScopedDeclarations = void 0;\n    this.VarScopedDeclarations = void 0;\n    this.TypeDeclarations = void 0;\n    this.RequestedModules = void 0;\n    this.LocalExportEntries = void 0;\n    this.IndirectExportEntries = void 0;\n    this.StarExportEntries = void 0;\n\n    this.logger = void 0;\n    this.$file = void 0;\n    this.node = void 0;\n    this.realm = void 0;\n    this.pkg = void 0;\n    this.moduleResolver = void 0;\n    this.compilerOptions = void 0;\n  }\n}\n\nexport class $DocumentFragment implements I$Node, IModule {\n  public readonly '<IModule>': unknown;\n\n  public readonly documentFragment: $DocumentFragment = this;\n  public readonly parent: $DocumentFragment = this;\n  public readonly ctx: Context = Context.None;\n  public readonly depth: number = 0;\n\n  public readonly path: string;\n\n  public '[[Environment]]': $ModuleEnvRec | $Undefined;\n  public '[[Namespace]]': $NamespaceExoticObject | $Undefined;\n  public '[[HostDefined]]': any;\n\n  public get isNull(): false { return false; }\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    public readonly logger: ILogger,\n    public readonly $file: IFile,\n    public readonly node: DocumentFragment,\n    public readonly realm: Realm,\n    public readonly pkg: NPMPackage | null,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    this['[[Environment]]'] = intrinsics.undefined;\n    this['[[Namespace]]'] = intrinsics.undefined;\n\n    this.logger = logger.root;\n\n    this.path = `DocumentFragment<(...)${$file.rootlessPath}>`;\n  }\n\n  public ResolveExport(\n    ctx: ExecutionContext,\n    exportName: $String,\n    resolveSet: ResolveSet,\n  ): ResolvedBindingRecord | $Null | $String<'ambiguous'> {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.[ResolveExport] returning content as '${exportName['[[Value]]']}'`);\n\n    return new ResolvedBindingRecord(this, exportName);\n  }\n\n  public GetExportedNames(\n    ctx: ExecutionContext,\n    exportStarSet: Set<IModule>,\n  ): $List<$String> | $Error {\n    ctx.checkTimeout();\n\n    return new $List<$String>();\n  }\n\n  public Instantiate(\n    ctx: ExecutionContext,\n  ): $Undefined | $Error {\n    ctx.checkTimeout();\n\n    return ctx.Realm['[[Intrinsics]]'].undefined;\n  }\n\n  /** @internal */\n  public _InnerModuleInstantiation(\n    ctx: ExecutionContext,\n    stack: IModule[],\n    idx: $Number,\n  ): $Number | $Error {\n    ctx.checkTimeout();\n\n    return idx;\n  }\n\n  public dispose(): void {\n    throw new Error('Method not implemented.');\n  }\n}\n\nexport type $$ModuleBody = (\n  $ModuleBlock |\n  $ModuleDeclaration\n);\n\nexport type $$ModuleName = (\n  $Identifier |\n  $StringLiteral\n);\n\nexport class $ModuleDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.ModuleDeclaration { return SyntaxKind.ModuleDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $$ModuleName;\n  public readonly $body: $Identifier | $ModuleBlock | $ModuleDeclaration | undefined;\n\n  public constructor(\n    public readonly node: ModuleDeclaration,\n    public readonly parent: $ESModule | $$ModuleBody,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ModuleDeclaration`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (node.name.kind === SyntaxKind.Identifier) {\n      this.$name = new $Identifier(node.name, this, ctx, -1);\n    } else {\n      this.$name = new $StringLiteral(node.name, this, ctx, -1);\n    }\n\n    if (node.body === void 0) {\n      this.$body = void 0;\n    } else {\n      switch (node.body.kind) {\n        case SyntaxKind.Identifier:\n          this.$body = new $Identifier(node.body, this, ctx, -1);\n          break;\n        case SyntaxKind.ModuleBlock:\n          this.$body = new $ModuleBlock(node.body, this, ctx);\n          break;\n        case SyntaxKind.ModuleDeclaration:\n          this.$body = new $ModuleDeclaration(node.body, this, ctx, -1);\n          break;\n        default:\n          throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as Node).kind]}.`);\n      }\n    }\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#importentry-record\n/**\n * | Import Statement Form          | MR        | IN          | LN        |\n * |:-------------------------------|:----------|:------------|:----------|\n * | `import v from \"mod\";`         | `\"mod\"`   | `\"default\"` | `\"v\"`     |\n * | `import * as ns from \"mod\";`   | `\"mod\"`   | `\"*\"`       | `\"ns\"`    |\n * | `import {x} from \"mod\";`       | `\"mod\"`   | `\"x\"`       | `\"x\"`     |\n * | `import {x as v} from \"mod\";`  | `\"mod\"`   | `\"x\"`       | `\"v\"`     |\n * | `import \"mod\";`                | N/A       | N/A         | N/A       |\n */\nexport class ImportEntryRecord {\n  public constructor(\n    public readonly source: $ImportClause | $NamespaceImport | $ImportSpecifier,\n    public readonly ModuleRequest: $String,\n    public readonly ImportName: $String,\n    public readonly LocalName: $String,\n  ) { }\n}\n\nexport type $$ModuleReference = (\n  $$EntityName |\n  $ExternalModuleReference\n);\n\n/**\n * One of:\n * - import x = require(\"mod\");\n * - import x = M.x;\n */\nexport class $ImportEqualsDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.ImportEqualsDeclaration { return SyntaxKind.ImportEqualsDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $Identifier;\n  public readonly $moduleReference: $$ModuleReference;\n\n  public constructor(\n    public readonly node: ImportEqualsDeclaration,\n    public readonly parent: $ESModule | $ModuleBlock,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ImportEqualsDeclaration`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$name = $identifier(node.name, this, ctx, -1);\n    switch (node.moduleReference.kind) {\n      case SyntaxKind.Identifier:\n        this.$moduleReference = new $Identifier(node.moduleReference, this, ctx, -1);\n        break;\n      case SyntaxKind.QualifiedName:\n        this.$moduleReference = new $QualifiedName(node.moduleReference, this, ctx);\n        break;\n      case SyntaxKind.ExternalModuleReference:\n        this.$moduleReference = new $ExternalModuleReference(node.moduleReference, this, ctx);\n        break;\n      default:\n        throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as Node).kind]}.`);\n    }\n  }\n}\n\n// In case of:\n// import \"mod\"  => importClause = undefined, moduleSpecifier = \"mod\"\n// In rest of the cases, module specifier is string literal corresponding to module\n// ImportClause information is shown at its declaration below.\nexport class $ImportDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.ImportDeclaration { return SyntaxKind.ImportDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $importClause: $ImportClause | $Undefined;\n  public readonly $moduleSpecifier: $StringLiteral;\n\n  public readonly moduleSpecifier: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-boundnames\n  // 15.2.2.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-importentries\n  // 15.2.2.3 Static Semantics: ImportEntries\n  public readonly ImportEntries: readonly ImportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-modulerequests\n  // 15.2.2.5 Static Semantics: ModuleRequests\n  public readonly ModuleRequests: readonly $String[];\n\n  public constructor(\n    public readonly node: ImportDeclaration,\n    public readonly parent: $ESModule | $ModuleBlock,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ImportDeclaration`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    const $moduleSpecifier = this.$moduleSpecifier = new $StringLiteral(node.moduleSpecifier as StringLiteral, this, ctx, -1);\n\n    const moduleSpecifier = this.moduleSpecifier = $moduleSpecifier.StringValue;\n\n    if (node.importClause === void 0) {\n      this.$importClause = new $Undefined(realm, void 0, void 0, this);\n\n      this.BoundNames = emptyArray;\n      this.ImportEntries = emptyArray;\n    } else {\n      const $importClause = this.$importClause = new $ImportClause(node.importClause, this, ctx);\n\n      this.BoundNames = $importClause.BoundNames;\n      this.ImportEntries = $importClause.ImportEntriesForModule;\n    }\n\n    this.ModuleRequests = [moduleSpecifier];\n  }\n}\n\n// In case of:\n// import d from \"mod\" => name = d, namedBinding = undefined\n// import * as ns from \"mod\" => name = undefined, namedBinding: NamespaceImport = { name: ns }\n// import d, * as ns from \"mod\" => name = d, namedBinding: NamespaceImport = { name: ns }\n// import { a, b as x } from \"mod\" => name = undefined, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}\n// import d, { a, b as x } from \"mod\" => name = d, namedBinding: NamedImports = { elements: [{ name: a }, { name: x, propertyName: b}]}\nexport class $ImportClause implements I$Node {\n  public get $kind(): SyntaxKind.ImportClause { return SyntaxKind.ImportClause; }\n\n  public readonly $name: $Identifier | $Undefined;\n  public readonly $namedBindings: $NamespaceImport | $NamedImports | undefined;\n\n  public readonly moduleSpecifier: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-boundnames\n  // 15.2.2.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-importentriesformodule\n  // 15.2.2.4 Static Semantics: ImportEntriesForModule\n  public readonly ImportEntriesForModule: readonly ImportEntryRecord[];\n\n  public constructor(\n    public readonly node: ImportClause,\n    public readonly parent: $ImportDeclaration,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.ImportClause`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const moduleSpecifier = this.moduleSpecifier = parent.moduleSpecifier;\n\n    const BoundNames = this.BoundNames = [] as $String[];\n    const ImportEntriesForModule = this.ImportEntriesForModule = [] as ImportEntryRecord[];\n\n    if (node.name === void 0) {\n      this.$name = new $Undefined(realm, void 0, void 0, this);\n    } else {\n      const $name = this.$name = new $Identifier(node.name, this, ctx, -1);\n\n      const [localName] = $name.BoundNames;\n      BoundNames.push(localName);\n      ImportEntriesForModule.push(\n        new ImportEntryRecord(\n          /* source */this,\n          /* ModuleRequest */moduleSpecifier,\n          /* ImportName */intrinsics.default,\n          /* LocalName */localName,\n        ),\n      );\n    }\n\n    if (node.namedBindings === void 0) {\n      this.$namedBindings = void 0;\n    } else {\n      if (node.namedBindings.kind === SyntaxKind.NamespaceImport) {\n        const $namedBindings = this.$namedBindings = new $NamespaceImport(node.namedBindings, this, ctx);\n        BoundNames.push(...$namedBindings.BoundNames);\n        ImportEntriesForModule.push(...$namedBindings.ImportEntriesForModule);\n      } else {\n        const $namedBindings = this.$namedBindings = new $NamedImports(node.namedBindings, this, ctx);\n        BoundNames.push(...$namedBindings.BoundNames);\n        ImportEntriesForModule.push(...$namedBindings.ImportEntriesForModule);\n      }\n    }\n  }\n}\n\nexport class $NamedImports implements I$Node {\n  public get $kind(): SyntaxKind.NamedImports { return SyntaxKind.NamedImports; }\n\n  public readonly $elements: readonly $ImportSpecifier[];\n\n  public readonly moduleSpecifier: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-boundnames\n  // 15.2.2.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-importentriesformodule\n  // 15.2.2.4 Static Semantics: ImportEntriesForModule\n  public readonly ImportEntriesForModule: readonly ImportEntryRecord[];\n\n  public constructor(\n    public readonly node: NamedImports,\n    public readonly parent: $ImportClause,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.NamedImports`,\n  ) {\n    this.moduleSpecifier = parent.moduleSpecifier;\n\n    const $elements = this.$elements = node.elements.map(x => new $ImportSpecifier(x, this, ctx));\n\n    this.BoundNames = $elements.flatMap(getBoundNames);\n    this.ImportEntriesForModule = $elements.flatMap(getImportEntriesForModule);\n  }\n}\n\nexport class $ImportSpecifier implements I$Node {\n  public get $kind(): SyntaxKind.ImportSpecifier { return SyntaxKind.ImportSpecifier; }\n\n  public readonly $propertyName: $Identifier | $Undefined;\n  public readonly $name: $Identifier;\n\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-boundnames\n  // 15.2.2.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly [$String];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-importentriesformodule\n  // 15.2.2.4 Static Semantics: ImportEntriesForModule\n  public readonly ImportEntriesForModule: readonly [ImportEntryRecord];\n\n  public constructor(\n    public readonly node: ImportSpecifier,\n    public readonly parent: $NamedImports,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.ImportSpecifier`,\n  ) {\n    let $propertyName: $Identifier | $Undefined;\n    if (node.propertyName === void 0) {\n      $propertyName = this.$propertyName = new $Undefined(realm, void 0, void 0, this);\n    } else {\n      $propertyName = this.$propertyName = new $Identifier(node.propertyName, this, ctx, -1);\n    }\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n\n    const BoundNames = this.BoundNames = this.$name.BoundNames;\n\n    const moduleSpecifier = parent.moduleSpecifier;\n\n    if ($propertyName.isUndefined) {\n      const [localName] = BoundNames;\n      this.ImportEntriesForModule = [\n        new ImportEntryRecord(\n          /* source */this,\n          /* ModuleRequest */moduleSpecifier,\n          /* ImportName */localName,\n          /* LocalName */localName,\n        ),\n      ];\n    } else {\n      const importName = $propertyName.StringValue;\n      const localName = $name.StringValue;\n      this.ImportEntriesForModule = [\n        new ImportEntryRecord(\n          /* source */this,\n          /* ModuleRequest */moduleSpecifier,\n          /* ImportName */importName,\n          /* LocalName */localName,\n        ),\n      ];\n    }\n  }\n}\n\nexport class $NamespaceImport implements I$Node {\n  public get $kind(): SyntaxKind.NamespaceImport { return SyntaxKind.NamespaceImport; }\n\n  public readonly $name: $Identifier;\n\n  // http://www.ecma-international.org/ecma-262/#sec-imports-static-semantics-boundnames\n  // 15.2.2.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-importentriesformodule\n  // 15.2.2.4 Static Semantics: ImportEntriesForModule\n  public readonly ImportEntriesForModule: readonly [ImportEntryRecord];\n\n  public constructor(\n    public readonly node: NamespaceImport,\n    public readonly parent: $ImportClause,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.NamespaceImport`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const $name = this.$name = new $Identifier(node.name, this, ctx, -1);\n\n    this.BoundNames = $name.BoundNames;\n\n    const moduleSpecifier = parent.moduleSpecifier;\n\n    const localName = $name.StringValue;\n    this.ImportEntriesForModule = [\n      new ImportEntryRecord(\n        /* source */this,\n        /* ModuleRequest */moduleSpecifier,\n        /* ImportName */intrinsics['*'],\n        /* LocalName */localName,\n      ),\n    ];\n  }\n}\n\n/**\n * | Export Statement Form           | EN           | MR            | IN         | LN            |\n * |:--------------------------------|:-------------|:--------------|:-----------|:--------------|\n * | `export var v;`                 | `\"v\"`        | `null`        | `null`     | `\"v\"`         |\n * | `export default function f(){}` | `\"default\"`  | `null`        | `null`     | `\"f\"`         |\n * | `export default function(){}`   | `\"default\"`  | `null`        | `null`     | `\"*default*\"` |\n * | `export default 42;`            | `\"default\"`  | `null`        | `null`     | `\"*default*\"` |\n * | `export {x};`                   | `\"x\"`        | `null`        | `null`     | `\"x\"`         |\n * | `export {v as x};`              | `\"x\"`        | `null`        | `null`     | `\"v\"`         |\n * | `export {x} from \"mod\";`        | `\"x\"`        | `\"mod\"`       | `\"x\"`      | `null`        |\n * | `export {v as x} from \"mod\";`   | `\"x\"`        | `\"mod\"`       | `\"v\"`      | `null`        |\n * | `export * from \"mod\";`          | `null`       | `\"mod\"`       | `\"*\"`      | `null`        |\n */\nexport class ExportEntryRecord {\n  public constructor(\n    public readonly source: $FunctionDeclaration | $ClassDeclaration | $VariableStatement | $ExportDeclaration | $ExportSpecifier | $ESModule | $TypeAliasDeclaration | $InterfaceDeclaration | $EnumDeclaration,\n    public readonly ExportName: $String | $Null,\n    public readonly ModuleRequest: $String | $Null,\n    public readonly ImportName: $String | $Null,\n    public readonly LocalName: $String | $Null,\n  ) { }\n}\n\nexport class $ExportAssignment implements I$Node {\n  public get $kind(): SyntaxKind.ExportAssignment { return SyntaxKind.ExportAssignment; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public readonly BoundNames: readonly [$String<'*default*'>];\n\n  public constructor(\n    public readonly node: ExportAssignment,\n    public readonly parent: $ESModule,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ExportAssignment`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.BoundNames = [intrinsics['*default*']];\n  }\n}\n\nexport class $ExportDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.ExportDeclaration { return SyntaxKind.ExportDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $exportClause: $NamedExports | undefined;\n  public readonly $moduleSpecifier: $StringLiteral | undefined;\n\n  public readonly moduleSpecifier: $String | $Null;\n\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-boundnames\n  // 15.2.3.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportedbindings\n  // 15.2.3.3 Static Semantics: ExportedBindings\n  public readonly ExportedBindings: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportednames\n  // 15.2.3.4 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportentries\n  // 15.2.3.5 Static Semantics: ExportEntries\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-isconstantdeclaration\n  // 15.2.3.7 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-lexicallyscopeddeclarations\n  // 15.2.3.8 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-modulerequests\n  // 15.2.3.9 Static Semantics: ModuleRequests\n  public readonly ModuleRequests: readonly $String[];\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public constructor(\n    public readonly node: ExportDeclaration,\n    public readonly parent: $ESModule | $ModuleBlock,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ExportDeclaration`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    let moduleSpecifier: $String | $Null;\n    if (node.moduleSpecifier === void 0) {\n      this.$moduleSpecifier = void 0;\n      moduleSpecifier = this.moduleSpecifier = intrinsics.null;\n\n      this.ModuleRequests = emptyArray;\n    } else {\n      const $moduleSpecifier = this.$moduleSpecifier = new $StringLiteral(node.moduleSpecifier as StringLiteral, this, ctx, -1);\n      moduleSpecifier = this.moduleSpecifier = $moduleSpecifier!.StringValue;\n\n      this.ModuleRequests = [moduleSpecifier];\n    }\n\n    if (node.exportClause === void 0) {\n      this.$exportClause = void 0;\n\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = [\n        new ExportEntryRecord(\n          /* source */this,\n          /* ExportName */intrinsics.null,\n          /* ModuleRequest */moduleSpecifier,\n          /* ImportName */intrinsics['*'],\n          /* LocalName */intrinsics.null,\n        ),\n      ];\n    } else {\n      // @ts-ignore - TODO(fkleuver): update AOT to use new TS 3.8 ast\n      const $exportClause = this.$exportClause = new $NamedExports(node.exportClause, this, ctx);\n\n      this.ExportedNames = $exportClause.ExportedNames;\n      this.ExportEntries = $exportClause.ExportEntriesForModule;\n    }\n  }\n}\n\nexport class $NamedExports implements I$Node {\n  public get $kind(): SyntaxKind.NamedExports { return SyntaxKind.NamedExports; }\n\n  public readonly $elements: readonly $ExportSpecifier[];\n\n  public readonly moduleSpecifier: $String | $Null;\n\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportednames\n  // 15.2.3.4 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-exportentriesformodule\n  // 15.2.3.6 Static Semantics: ExportEntriesForModule\n  public readonly ExportEntriesForModule: readonly ExportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-referencedbindings\n  // 15.2.3.10 Static Semantics: ReferencedBindings\n  public readonly ReferencedBindings: readonly $String[];\n\n  public constructor(\n    public readonly node: NamedExports,\n    public readonly parent: $ExportDeclaration,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.NamedExports`,\n  ) {\n    this.moduleSpecifier = parent.moduleSpecifier;\n\n    const $elements = this.$elements = node.elements.map(x => new $ExportSpecifier(x, this, ctx));\n\n    this.ExportedNames = $elements.flatMap(getExportedNames);\n    this.ExportEntriesForModule = $elements.flatMap(getExportEntriesForModule);\n    this.ReferencedBindings = $elements.flatMap(getReferencedBindings);\n  }\n}\n\nexport class $ExportSpecifier implements I$Node {\n  public get $kind(): SyntaxKind.ExportSpecifier { return SyntaxKind.ExportSpecifier; }\n\n  public readonly $propertyName: $Identifier | $Undefined;\n  public readonly $name: $Identifier;\n\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportednames\n  // 15.2.3.4 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly [$String];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-exportentriesformodule\n  // 15.2.3.6 Static Semantics: ExportEntriesForModule\n  public readonly ExportEntriesForModule: readonly [ExportEntryRecord];\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-referencedbindings\n  // 15.2.3.10 Static Semantics: ReferencedBindings\n  public readonly ReferencedBindings: readonly [$String];\n\n  public constructor(\n    public readonly node: ExportSpecifier,\n    public readonly parent: $NamedExports,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.ExportSpecifier`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    let $propertyName: $Identifier | $Undefined;\n    if (node.propertyName === void 0) {\n      $propertyName = this.$propertyName = new $Undefined(realm, void 0, void 0, this);\n    } else {\n      $propertyName = this.$propertyName = new $Identifier(node.propertyName, this, ctx, -1);\n    }\n    const $name = this.$name = new $Identifier(node.name, this, ctx, -1);\n\n    const moduleSpecifier = parent.moduleSpecifier;\n\n    if ($propertyName.isUndefined) {\n      const sourceName = $name.StringValue;\n\n      this.ReferencedBindings = [sourceName];\n      this.ExportedNames = [sourceName];\n\n      if (moduleSpecifier.isNull) {\n        this.ExportEntriesForModule = [\n          new ExportEntryRecord(\n            /* source */this,\n            /* ExportName */sourceName,\n            /* ModuleRequest */moduleSpecifier,\n            /* ImportName */intrinsics.null,\n            /* LocalName */sourceName,\n          ),\n        ];\n      } else {\n        this.ExportEntriesForModule = [\n          new ExportEntryRecord(\n            /* source */this,\n            /* ExportName */sourceName,\n            /* ModuleRequest */moduleSpecifier,\n            /* ImportName */sourceName,\n            /* LocalName */intrinsics.null,\n          ),\n        ];\n      }\n    } else {\n      const exportName = $name.StringValue;\n      const sourceName = $propertyName.StringValue;\n      this.ReferencedBindings = [sourceName];\n\n      this.ExportedNames = [exportName];\n\n      if (moduleSpecifier.isNull) {\n        this.ExportEntriesForModule = [\n          new ExportEntryRecord(\n            /* source */this,\n            /* ExportName */exportName,\n            /* ModuleRequest */moduleSpecifier,\n            /* ImportName */intrinsics.null,\n            /* LocalName */sourceName,\n          ),\n        ];\n      } else {\n        this.ExportEntriesForModule = [\n          new ExportEntryRecord(\n            /* source */this,\n            /* ExportName */exportName,\n            /* ModuleRequest */moduleSpecifier,\n            /* ImportName */sourceName,\n            /* LocalName */intrinsics.null,\n          ),\n        ];\n      }\n    }\n  }\n}\n\nexport class $NamespaceExportDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.NamespaceExportDeclaration { return SyntaxKind.NamespaceExportDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $Identifier;\n\n  public constructor(\n    public readonly node: NamespaceExportDeclaration,\n    public readonly parent: $$ModuleDeclarationParent,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.NamespaceExportDeclaration`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$name = $identifier(node.name, this, ctx, -1);\n  }\n}\n\nexport class $ModuleBlock implements I$Node {\n  public get $kind(): SyntaxKind.ModuleBlock { return SyntaxKind.ModuleBlock; }\n\n  // TODO: ModuleBlock shares a lot in common with SourceFile, so we implement this last to try to maximize code reuse / reduce refactoring overhead and/or see if the two can be consolidated.\n  public readonly $statements: readonly $$TSModuleItem[] = emptyArray;\n\n  public constructor(\n    public readonly node: ModuleBlock,\n    public readonly parent: $ModuleDeclaration,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.ModuleBlock`,\n  ) {}\n}\n\nexport class $ExternalModuleReference implements I$Node {\n  public get $kind(): SyntaxKind.ExternalModuleReference { return SyntaxKind.ExternalModuleReference; }\n\n  public readonly $expression: $StringLiteral;\n\n  public constructor(\n    public readonly node: ExternalModuleReference,\n    public readonly parent: $ImportEqualsDeclaration,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.ExternalModuleReference`,\n  ) {\n    this.$expression = new $StringLiteral(node.expression as StringLiteral, this, ctx, -1);\n  }\n}\n\nexport type $$NodeWithQualifiedName = (\n  $ImportEqualsDeclaration |\n  $QualifiedName\n);\n\nexport type $$EntityName = (\n  $Identifier |\n  $QualifiedName\n);\n\nexport class $QualifiedName implements I$Node {\n  public get $kind(): SyntaxKind.QualifiedName { return SyntaxKind.QualifiedName; }\n\n  public readonly $left: $$EntityName;\n  public readonly $right: $Identifier;\n\n  public constructor(\n    public readonly node: QualifiedName,\n    public readonly parent: $$NodeWithQualifiedName,\n    public readonly ctx: Context,\n    public readonly mos: $ESModule = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.QualifiedName`,\n  ) {\n    if (node.left.kind === SyntaxKind.Identifier) {\n      this.$left = new $Identifier(node.left, this, ctx, -1);\n    } else {\n      this.$left = new $QualifiedName(node.left, this, ctx);\n    }\n\n    this.$right = new $Identifier(node.right, this, ctx, -1);\n  }\n}\n","import {\n  Block,\n  BreakStatement,\n  CaseBlock,\n  CaseClause,\n  CatchClause,\n  ContinueStatement,\n  DebuggerStatement,\n  DefaultClause,\n  DoStatement,\n  EmptyStatement,\n  ExpressionStatement,\n  ForInStatement,\n  ForOfStatement,\n  ForStatement,\n  IfStatement,\n  LabeledStatement,\n  ModifierFlags,\n  NodeArray,\n  NodeFlags,\n  ReturnStatement,\n  StringLiteral,\n  SwitchStatement,\n  SyntaxKind,\n  ThrowStatement,\n  TryStatement,\n  VariableDeclaration,\n  VariableDeclarationList,\n  VariableStatement,\n  WhileStatement,\n  WithStatement,\n  Expression,\n  CaseOrDefaultClause,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $DeclarativeEnvRec,\n} from '../types/environment-record.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Any,\n  CompletionType,\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  I$Node,\n  Context,\n  $$ESDeclaration,\n  $NodeWithStatements,\n  clearBit,\n  modifiersToModifierFlags,\n  hasBit,\n  $identifier,\n  $$AssignmentExpressionOrHigher,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$TSDeclaration,\n  $$BindingName,\n  $$bindingName,\n  getBoundNames,\n  getVarDeclaredNames,\n  getVarScopedDeclarations,\n  $$TSStatementListItem,\n  $$tsStatementList,\n  $StatementNode,\n  BlockDeclarationInstantiation,\n  evaluateStatementList,\n  evaluateStatement,\n  $$ESLabelledItem,\n  $$esLabelledItem,\n  getLexicallyDeclaredNames,\n  getLexicallyScopedDeclarations,\n  $i,\n  $$ESVarDeclaration,\n} from './_shared.js';\nimport {\n  ExportEntryRecord,\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Identifier,\n} from './expressions.js';\nimport {\n  $ObjectBindingPattern,\n} from './bindings.js';\nimport {\n  $StringSet,\n} from '../globals/string.js';\nimport {\n  $LoopContinues,\n} from '../operations.js';\n\nexport class $VariableStatement implements I$Node {\n  public get $kind(): SyntaxKind.VariableStatement { return SyntaxKind.VariableStatement; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $declarationList: $VariableDeclarationList;\n\n  public readonly isLexical: boolean;\n\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-boundnames\n  // 13.3.2.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-vardeclarednames\n  // 13.3.2.2 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-varscopeddeclarations\n  // 13.3.2.3 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportedbindings\n  // 15.2.3.3 Static Semantics: ExportedBindings\n  public readonly ExportedBindings: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportednames\n  // 15.2.3.4 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportentries\n  // 15.2.3.5 Static Semantics: ExportEntries\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-isconstantdeclaration\n  // 15.2.3.7 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: boolean;\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-lexicallyscopeddeclarations\n  // 15.2.3.8 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-modulerequests\n  // 15.2.3.9 Static Semantics: ModuleRequests\n  public readonly ModuleRequests: readonly $String[];\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public constructor(\n    public readonly node: VariableStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.VariableStatement`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    ctx |= Context.InVariableStatement;\n\n    if (hasBit(this.modifierFlags, ModifierFlags.Export)) {\n      ctx |= Context.InExport;\n    }\n\n    const $declarationList = this.$declarationList = new $VariableDeclarationList(\n      node.declarationList,\n      this,\n      ctx,\n    );\n\n    const isLexical = this.isLexical = $declarationList.isLexical;\n    this.IsConstantDeclaration = $declarationList.IsConstantDeclaration;\n\n    const BoundNames = this.BoundNames = $declarationList.BoundNames;\n    this.VarDeclaredNames = $declarationList.VarDeclaredNames;\n    this.VarScopedDeclarations = $declarationList.VarScopedDeclarations;\n\n    if (hasBit(ctx, Context.InExport)) {\n      this.ExportedBindings = BoundNames;\n      this.ExportedNames = BoundNames;\n      this.ExportEntries = BoundNames.map(name =>\n        new ExportEntryRecord(\n          /* source */this,\n          /* ExportName */name,\n          /* ModuleRequest */intrinsics.null,\n          /* ImportName */intrinsics.null,\n          /* LocalName */name,\n        )\n      );\n\n      if (isLexical) {\n        this.LexicallyScopedDeclarations = [this];\n      } else {\n        this.LexicallyScopedDeclarations = emptyArray;\n      }\n    } else {\n      this.ExportedBindings = emptyArray;\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = emptyArray;\n\n      this.LexicallyScopedDeclarations = emptyArray;\n    }\n\n    this.ModuleRequests = emptyArray;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-runtime-semantics-evaluation\n  // 13.3.1.4 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-runtime-semantics-evaluation\n  // 13.3.2.4 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-runtime-semantics-evaluation\n    // 13.3.1.4 Runtime Semantics: Evaluation\n\n    // LexicalDeclaration : LetOrConst BindingList ;\n\n    // 1. Let next be the result of evaluating BindingList.\n    // 2. ReturnIfAbrupt(next).\n    // 3. Return NormalCompletion(empty).\n\n    // BindingList : BindingList , LexicalBinding\n\n    // 1. Let next be the result of evaluating BindingList.\n    // 2. ReturnIfAbrupt(next).\n    // 3. Return the result of evaluating LexicalBinding.\n\n    // LexicalBinding : BindingIdentifier\n\n    // 1. Let lhs be ResolveBinding(StringValue of BindingIdentifier).\n    // 2. Return InitializeReferencedBinding(lhs, undefined).\n\n    // LexicalBinding : BindingIdentifier Initializer\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    // 2. Let lhs be ResolveBinding(bindingId).\n    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then\n    // 3. a. Let value be the result of performing NamedEvaluation for Initializer with argument bindingId.\n    // 4. Else,\n    // 4. a. Let rhs be the result of evaluating Initializer.\n    // 4. b. Let value be ? GetValue(rhs).\n    // 5. Return InitializeReferencedBinding(lhs, value).\n\n    // LexicalBinding : BindingPattern Initializer\n\n    // 1. Let rhs be the result of evaluating Initializer.\n    // 2. Let value be ? GetValue(rhs).\n    // 3. Let env be the running execution context's LexicalEnvironment.\n    // 4. Return the result of performing BindingInitialization for BindingPattern using value and env as the arguments.\n\n    // http://www.ecma-international.org/ecma-262/#sec-variable-statement-runtime-semantics-evaluation\n    // 13.3.2.4 Runtime Semantics: Evaluation\n\n    // VariableStatement : var VariableDeclarationList ;\n\n    // 1. Let next be the result of evaluating VariableDeclarationList.\n    // 2. ReturnIfAbrupt(next).\n    // 3. Return NormalCompletion(empty).\n\n    // VariableDeclarationList : VariableDeclarationList , VariableDeclaration\n\n    // 1. Let next be the result of evaluating VariableDeclarationList.\n    // 2. ReturnIfAbrupt(next).\n    // 3. Return the result of evaluating VariableDeclaration.\n\n    // VariableDeclaration : BindingIdentifier\n\n    // 1. Return NormalCompletion(empty).\n\n    // VariableDeclaration : BindingIdentifier Initializer\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    // 2. Let lhs be ? ResolveBinding(bindingId).\n    // 3. If IsAnonymousFunctionDefinition(Initializer) is true, then\n    // 3. a. Let value be the result of performing NamedEvaluation for Initializer with argument bindingId.\n    // 4. Else,\n    // 4. a. Let rhs be the result of evaluating Initializer.\n    // 4. b. Let value be ? GetValue(rhs).\n    // 5. Return ? PutValue(lhs, value).\n\n    // VariableDeclaration : BindingPattern Initializer\n\n    // 1. Let rhs be the result of evaluating Initializer.\n    // 2. Let rval be ? GetValue(rhs).\n    // 3. Return the result of performing BindingInitialization for BindingPattern passing rval and undefined as arguments.\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $VariableDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.VariableDeclaration { return SyntaxKind.VariableDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n  public readonly combinedModifierFlags: ModifierFlags;\n\n  public readonly $name: $$BindingName;\n  public readonly $initializer: $$AssignmentExpressionOrHigher | undefined;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-boundnames\n  // 13.3.2.1 Static Semantics: BoundNames\n  // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-static-semantics-boundnames\n  // 13.3.1.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-vardeclarednames\n  // 13.3.2.2 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-varscopeddeclarations\n  // 13.3.2.3 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-static-semantics-isconstantdeclaration\n  // 13.3.1.3 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: boolean;\n\n  public constructor(\n    public readonly node: VariableDeclaration,\n    public readonly parent: $VariableDeclarationList | $CatchClause,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.VariableDeclaration`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (hasBit(ctx, Context.InVariableStatement)) {\n      this.combinedModifierFlags = modifierFlags | (parent as $VariableDeclarationList).combinedModifierFlags;\n    } else {\n      this.combinedModifierFlags = modifierFlags;\n    }\n\n    const $name = this.$name = $$bindingName(node.name, this, ctx, -1);\n\n    // Clear this flag because it's used inside $Identifier to declare locals/exports\n    // and we don't want to do that on the identifiers in types/initializers.\n    ctx = clearBit(ctx, Context.InVariableStatement);\n\n    this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.BoundNames = $name.BoundNames;\n    if (hasBit(ctx, Context.IsVar)) { // TODO: what about parameter and for declarations?\n      this.VarDeclaredNames = this.BoundNames;\n      this.VarScopedDeclarations = [this];\n      this.IsConstantDeclaration = false;\n    } else {\n      this.VarDeclaredNames = emptyArray;\n      this.VarScopedDeclarations = emptyArray;\n      this.IsConstantDeclaration = hasBit(ctx, Context.IsConst);\n    }\n  }\n\n  public InitializeBinding(\n    ctx: ExecutionContext,\n    value: $AnyNonEmpty,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n\n    const bindingName = this.$name;\n    const kind = bindingName.$kind;\n    const boundNames = bindingName.BoundNames;\n    const envRec = ctx.LexicalEnvironment;\n    if ((boundNames?.length ?? 0) > 0) {\n      switch (kind) {\n        // http://www.ecma-international.org/ecma-262/#sec-identifiers-runtime-semantics-bindinginitialization\n        // 12.1.5 Runtime Semantics: BindingInitialization\n        // http://www.ecma-international.org/ecma-262/#sec-initializeboundname\n        // 12.1.5.1 Runtime Semantics: InitializeBoundName ( name , value , environment )\n        case SyntaxKind.Identifier: {\n          const name = boundNames![0]?.GetValue(ctx);\n          // 1. Assert: Type(name) is String.\n          // 2. If environment is not undefined, then\n          if (envRec !== void 0) {\n            // 2. a. Let env be the EnvironmentRecord component of environment.\n            // 2. b. Perform env.InitializeBinding(name, value).\n            envRec.InitializeBinding(ctx, name, value);\n            // 2. c. Return NormalCompletion(undefined).\n            return realm['[[Intrinsics]]'].undefined;\n          } else {\n            // 3. Else,\n            // 3. a. Let lhs be ResolveBinding(name).\n            const lhs = realm.ResolveBinding(name);\n            if (lhs.isAbrupt) { return lhs.enrichWith(ctx, this); } // TODO: is this correct? spec doesn't say it\n\n            // 3. b. Return ? PutValue(lhs, value).\n            return lhs.PutValue(ctx, value).enrichWith(ctx, this);\n          }\n        }\n        case SyntaxKind.ObjectBindingPattern:\n          (bindingName as $ObjectBindingPattern).InitializeBinding(ctx, value, envRec);\n          break;\n\n        case SyntaxKind.ArrayBindingPattern:\n          // TODO\n          break;\n      }\n    }\n\n    return ctx.Realm['[[Intrinsics]]'].empty;\n  }\n}\n\nexport function $variableDeclarationList(\n  nodes: readonly VariableDeclaration[],\n  parent: $VariableDeclarationList,\n  ctx: Context,\n): readonly $VariableDeclaration[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $VariableDeclaration[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $VariableDeclaration(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\nexport class $VariableDeclarationList implements I$Node {\n  public get $kind(): SyntaxKind.VariableDeclarationList { return SyntaxKind.VariableDeclarationList; }\n\n  public readonly combinedModifierFlags: ModifierFlags;\n\n  public readonly $declarations: readonly $VariableDeclaration[];\n\n  public readonly isLexical: boolean;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-boundnames\n  // 13.3.2.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-vardeclarednames\n  // 13.3.2.2 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-variable-statement-static-semantics-varscopeddeclarations\n  // 13.3.2.3 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations-static-semantics-isconstantdeclaration\n  // 13.3.1.3 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: boolean;\n\n  public constructor(\n    public readonly node: VariableDeclarationList,\n    public readonly parent: $VariableStatement | $ForStatement | $ForOfStatement | $ForInStatement,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.VariableDeclarationList`,\n  ) {\n    this.isLexical = (node.flags & (NodeFlags.Const | NodeFlags.Let)) > 0;\n    this.IsConstantDeclaration = (node.flags & NodeFlags.Const) > 0;\n\n    if (hasBit(ctx, Context.InVariableStatement)) {\n      this.combinedModifierFlags = (parent as $VariableStatement).modifierFlags;\n    } else {\n      this.combinedModifierFlags = ModifierFlags.None;\n    }\n\n    if (hasBit(node.flags, NodeFlags.Const)) {\n      ctx |= Context.IsConst;\n    } else if (hasBit(node.flags, NodeFlags.Let)) {\n      ctx |= Context.IsLet;\n    } else {\n      ctx |= Context.IsVar;\n    }\n\n    const $declarations = this.$declarations = $variableDeclarationList(node.declarations, this, ctx);\n\n    this.BoundNames = $declarations.flatMap(getBoundNames);\n    this.VarDeclaredNames = $declarations.flatMap(getVarDeclaredNames);\n    this.VarScopedDeclarations = $declarations.flatMap(getVarScopedDeclarations);\n  }\n}\n\n// #region Statements\n\nexport class $Block implements I$Node {\n  public get $kind(): SyntaxKind.Block { return SyntaxKind.Block; }\n\n  public readonly $statements: readonly $$TSStatementListItem[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-lexicallydeclarednames\n  // 13.2.5 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-lexicallyscopeddeclarations\n  // 13.2.6 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-toplevellexicallydeclarednames\n  // 13.2.7 Static Semantics: TopLevelLexicallyDeclaredNames\n  public readonly TopLevelLexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-toplevellexicallyscopeddeclarations\n  // 13.2.8 Static Semantics: TopLevelLexicallyScopedDeclarations\n  public readonly TopLevelLexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-toplevelvardeclarednames\n  // 13.2.9 Static Semantics: TopLevelVarDeclaredNames\n  public readonly TopLevelVarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-toplevelvarscopeddeclarations\n  // 13.2.10 Static Semantics: TopLevelVarScopedDeclarations\n  public readonly TopLevelVarScopedDeclarations: readonly $$ESVarDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-vardeclarednames\n  // 13.2.11 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-block-static-semantics-varscopeddeclarations\n  // 13.2.12 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public constructor(\n    public readonly node: Block,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.Block`,\n  ) {\n    const $statements = this.$statements = $$tsStatementList(node.statements as NodeArray<$StatementNode>, this, ctx);\n\n    const LexicallyDeclaredNames = this.LexicallyDeclaredNames = [] as $String[];\n    const LexicallyScopedDeclarations = this.LexicallyScopedDeclarations = [] as $$ESDeclaration[];\n    const TopLevelLexicallyDeclaredNames = this.TopLevelLexicallyDeclaredNames = [] as $String[];\n    const TopLevelLexicallyScopedDeclarations = this.TopLevelLexicallyScopedDeclarations = [] as $$ESDeclaration[];\n    const TopLevelVarDeclaredNames = this.TopLevelVarDeclaredNames = [] as $String[];\n    const TopLevelVarScopedDeclarations = this.TopLevelVarScopedDeclarations = [] as $$ESVarDeclaration[];\n    const VarDeclaredNames = this.VarDeclaredNames = [] as $String[];\n    const VarScopedDeclarations = this.VarScopedDeclarations = [] as $$ESVarDeclaration[];\n\n    const len = $statements.length;\n    let $statement: $$TSStatementListItem;\n    for (let i = 0; i < len; ++i) {\n      $statement = $statements[i];\n      switch ($statement.$kind) {\n        case SyntaxKind.FunctionDeclaration:\n          LexicallyDeclaredNames.push(...$statement.BoundNames);\n          LexicallyScopedDeclarations.push($statement);\n\n          TopLevelVarDeclaredNames.push(...$statement.BoundNames);\n          TopLevelVarScopedDeclarations.push($statement);\n          break;\n        case SyntaxKind.ClassDeclaration:\n          LexicallyDeclaredNames.push(...$statement.BoundNames);\n          LexicallyScopedDeclarations.push($statement);\n\n          TopLevelLexicallyDeclaredNames.push(...$statement.BoundNames);\n          TopLevelLexicallyScopedDeclarations.push($statement);\n          break;\n        case SyntaxKind.VariableStatement:\n          if ($statement.isLexical) {\n            LexicallyDeclaredNames.push(...$statement.BoundNames);\n            LexicallyScopedDeclarations.push($statement);\n\n            TopLevelLexicallyDeclaredNames.push(...$statement.BoundNames);\n            TopLevelLexicallyScopedDeclarations.push($statement);\n          } else {\n            TopLevelVarDeclaredNames.push(...$statement.VarDeclaredNames);\n            TopLevelVarScopedDeclarations.push(...$statement.VarScopedDeclarations);\n\n            VarDeclaredNames.push(...$statement.VarDeclaredNames);\n            VarScopedDeclarations.push(...$statement.VarScopedDeclarations);\n          }\n          break;\n        case SyntaxKind.LabeledStatement:\n          LexicallyDeclaredNames.push(...$statement.LexicallyDeclaredNames);\n          LexicallyScopedDeclarations.push(...$statement.LexicallyScopedDeclarations);\n\n          TopLevelVarDeclaredNames.push(...$statement.TopLevelVarDeclaredNames);\n          TopLevelVarScopedDeclarations.push(...$statement.TopLevelVarScopedDeclarations);\n\n          VarDeclaredNames.push(...$statement.VarDeclaredNames);\n          VarScopedDeclarations.push(...$statement.VarScopedDeclarations);\n          break;\n        case SyntaxKind.Block:\n        case SyntaxKind.IfStatement:\n        case SyntaxKind.DoStatement:\n        case SyntaxKind.WhileStatement:\n        case SyntaxKind.ForStatement:\n        case SyntaxKind.ForInStatement:\n        case SyntaxKind.ForOfStatement:\n        case SyntaxKind.WithStatement:\n        case SyntaxKind.SwitchStatement:\n        case SyntaxKind.TryStatement:\n          TopLevelVarDeclaredNames.push(...$statement.VarDeclaredNames);\n          TopLevelVarScopedDeclarations.push(...$statement.VarScopedDeclarations);\n\n          VarDeclaredNames.push(...$statement.VarDeclaredNames);\n          VarScopedDeclarations.push(...$statement.VarScopedDeclarations);\n      }\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-block-runtime-semantics-evaluation\n  // 13.2.13 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    const $statements = this.$statements;\n\n    // Block : { }\n    // 1. Return NormalCompletion(empty).\n    if ($statements.length === 0) {\n      return intrinsics.empty;\n    }\n\n    // Block : { StatementList }\n    // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n    const oldEnv = ctx.LexicalEnvironment;\n    // 2. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n    const blockEnv = ctx.LexicalEnvironment = new $DeclarativeEnvRec(this.logger, realm, oldEnv);\n\n    // 3. Perform BlockDeclarationInstantiation(StatementList, blockEnv).\n    const $BlockDeclarationInstantiationResult = BlockDeclarationInstantiation(ctx, this.LexicallyScopedDeclarations, blockEnv);\n    if ($BlockDeclarationInstantiationResult.isAbrupt) { return $BlockDeclarationInstantiationResult; }\n\n    // 4. Set the running execution context's LexicalEnvironment to blockEnv.\n    realm.stack.push(ctx);\n\n    // 5. Let blockValue be the result of evaluating StatementList.\n    const blockValue = evaluateStatementList(ctx, $statements);\n\n    // 6. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.stack.pop();\n    ctx.LexicalEnvironment = oldEnv;\n\n    // 7. Return blockValue.\n    return blockValue;\n  }\n}\n\nexport class $EmptyStatement implements I$Node {\n  public get $kind(): SyntaxKind.EmptyStatement { return SyntaxKind.EmptyStatement; }\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: EmptyStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.EmptyStatement`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-empty-statement-runtime-semantics-evaluation\n  // 13.4.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // EmptyStatement : ;\n\n    // 1. Return NormalCompletion(empty).\n    return intrinsics.empty;\n  }\n}\n\nexport type ExpressionStatement_T<T extends Expression> = ExpressionStatement & {\n  readonly expression: T;\n};\n\nexport type DirectivePrologue = readonly ExpressionStatement_T<StringLiteral>[] & {\n  readonly ContainsUseStrict?: true;\n};\n\nexport class $ExpressionStatement implements I$Node {\n  public get $kind(): SyntaxKind.ExpressionStatement { return SyntaxKind.ExpressionStatement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: ExpressionStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ExpressionStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-expression-statement-runtime-semantics-evaluation\n  // 13.5.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ExpressionStatement : Expression ;\n\n    // 1. Let exprRef be the result of evaluating Expression.\n    // 2. Return ? GetValue(exprRef).\n\n    return this.$expression.Evaluate(ctx).GetValue(ctx).enrichWith(ctx, this);\n  }\n}\n\nexport class $IfStatement implements I$Node {\n  public get $kind(): SyntaxKind.IfStatement { return SyntaxKind.IfStatement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $thenStatement: $$ESLabelledItem;\n  public readonly $elseStatement: $$ESLabelledItem | undefined;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-if-statement-static-semantics-vardeclarednames\n  // 13.6.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-if-statement-static-semantics-varscopeddeclarations\n  // 13.6.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: IfStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.IfStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    const $thenStatement = this.$thenStatement = $$esLabelledItem(node.thenStatement as $StatementNode, this, ctx, -1);\n\n    if (node.elseStatement === void 0) {\n      this.$elseStatement = void 0;\n\n      this.VarDeclaredNames = $thenStatement.VarDeclaredNames;\n      this.VarScopedDeclarations = $thenStatement.VarScopedDeclarations;\n    } else {\n      const $elseStatement = this.$elseStatement = $$esLabelledItem(node.elseStatement as $StatementNode, this, ctx, -1);\n\n      this.VarDeclaredNames = [\n        ...$thenStatement.VarDeclaredNames,\n        ...$elseStatement.VarDeclaredNames,\n      ];\n      this.VarScopedDeclarations = [\n        ...$thenStatement.VarScopedDeclarations,\n        ...$elseStatement.VarScopedDeclarations,\n      ];\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-if-statement-runtime-semantics-evaluation\n  // 13.6.7 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    const { $expression, $thenStatement, $elseStatement } = this;\n\n    const exprRef = $expression.Evaluate(ctx);\n    const exprValue = exprRef.GetValue(ctx).ToBoolean(ctx);\n\n    if ($elseStatement !== undefined) {\n      // IfStatement : if ( Expression ) Statement else Statement\n\n      // 1. Let exprRef be the result of evaluating Expression.\n      // 2. Let exprValue be ToBoolean(? GetValue(exprRef)).\n\n      let stmtCompletion: $Any;\n      // 3. If exprValue is true, then\n      if (exprValue.is(intrinsics.true)) {\n        // 3. a. Let stmtCompletion be the result of evaluating the first Statement.\n        stmtCompletion = evaluateStatement(ctx, $thenStatement);\n      } else {\n        // 4. Else,\n        // 4. a. Let stmtCompletion be the result of evaluating the second Statement.\n        stmtCompletion = evaluateStatement(ctx, $elseStatement);\n      }\n      // 5. Return Completion(UpdateEmpty(stmtCompletion, undefined)).\n      stmtCompletion.UpdateEmpty(intrinsics.undefined);\n      return stmtCompletion;\n    } else {\n      // IfStatement : if ( Expression ) Statement\n\n      // 1. Let exprRef be the result of evaluating Expression.\n      // 2. Let exprValue be ToBoolean(? GetValue(exprRef)).\n      let stmtCompletion: $Any;\n      // 3. If exprValue is false, then\n      if (exprValue.is(intrinsics.false)) {\n        // 3. a. Return NormalCompletion(undefined).\n        return new $Undefined(realm);\n      } else {\n        // 4. Else,\n        // 4. a. Let stmtCompletion be the result of evaluating Statement.\n        stmtCompletion = evaluateStatement(ctx, $thenStatement);\n        // 4. b. Return Completion(UpdateEmpty(stmtCompletion, undefined)).\n        stmtCompletion.UpdateEmpty(intrinsics.undefined);\n        return stmtCompletion;\n      }\n    }\n  }\n}\n\nexport class $DoStatement implements I$Node {\n  public get $kind(): SyntaxKind.DoStatement { return SyntaxKind.DoStatement; }\n\n  public readonly $statement: $$ESLabelledItem;\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-do-while-statement-static-semantics-vardeclarednames\n  // 13.7.2.4 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-do-while-statement-static-semantics-varscopeddeclarations\n  // 13.7.2.5 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: DoStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.DoStatement`,\n  ) {\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.VarDeclaredNames = $statement.VarDeclaredNames;\n    this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-do-while-statement-runtime-semantics-labelledevaluation\n  // 13.7.2.6 Runtime Semantics: LabelledEvaluation\n  public EvaluateLabelled(\n    ctx: ExecutionContext,\n    labelSet: $StringSet,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);\n    // IterationStatement : do Statement while ( Expression ) ;\n\n    const expr = this.$expression;\n    const stmt = this.$statement;\n\n    // 1. Let V be undefined.\n    let V: $Any = intrinsics.undefined;\n\n    // 2. Repeat,\n    while (true) {\n      // 2. a. Let stmtResult be the result of evaluating Statement.\n      const stmtResult = evaluateStatement(ctx, stmt);\n\n      // 2. b. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).\n      if ($LoopContinues(ctx, stmtResult, labelSet).isFalsey) {\n        return stmtResult.UpdateEmpty(V);\n      }\n\n      // 2. c. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].\n      if (!stmtResult.isEmpty) {\n        V = stmtResult;\n      }\n\n      // 2. d. Let exprRef be the result of evaluating Expression.\n      const exprRef = expr.Evaluate(ctx);\n\n      // 2. e. Let exprValue be ? GetValue(exprRef).\n      const exprValue = exprRef.GetValue(ctx);\n      if (exprValue.isAbrupt) { return exprValue.enrichWith(ctx, this); }\n\n      // 2. f. If ToBoolean(exprValue) is false, return NormalCompletion(V).\n      const bool = exprValue.ToBoolean(ctx);\n      if (bool.isAbrupt) { return bool.enrichWith(ctx, this); }\n      if (bool.isFalsey) {\n        return V.ToCompletion(CompletionType.normal, intrinsics.empty);\n      }\n    }\n  }\n}\n\nexport class $WhileStatement implements I$Node {\n  public get $kind(): SyntaxKind.WhileStatement { return SyntaxKind.WhileStatement; }\n\n  public readonly $statement: $$ESLabelledItem;\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-while-statement-static-semantics-vardeclarednames\n  // 13.7.3.4 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-while-statement-static-semantics-varscopeddeclarations\n  // 13.7.3.5 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: WhileStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.WhileStatement`,\n  ) {\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.VarDeclaredNames = $statement.VarDeclaredNames;\n    this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-while-statement-runtime-semantics-labelledevaluation\n  // 13.7.3.6 Runtime Semantics: LabelledEvaluation\n  public EvaluateLabelled(\n    ctx: ExecutionContext,\n    labelSet: $StringSet,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);\n    // IterationStatement : while ( Expression ) Statement\n\n    const expr = this.$expression;\n    const stmt = this.$statement;\n\n    // 1. Let V be undefined.\n    let V: $Any = intrinsics.undefined;\n\n    // 2. Repeat,\n    while (true) {\n      // 2. a. Let exprRef be the result of evaluating Expression.\n      const exprRef = expr.Evaluate(ctx);\n\n      // 2. b. Let exprValue be ? GetValue(exprRef).\n      const exprValue = exprRef.GetValue(ctx);\n      if (exprValue.isAbrupt) { return exprValue.enrichWith(ctx, this); }\n\n      // 2. c. If ToBoolean(exprValue) is false, return NormalCompletion(V).\n      const bool = exprValue.ToBoolean(ctx);\n      if (bool.isAbrupt) { return bool.enrichWith(ctx, this); }\n      if (bool.isFalsey) {\n        return V.ToCompletion(CompletionType.normal, intrinsics.empty);\n      }\n\n      // 2. d. Let stmtResult be the result of evaluating Statement.\n      const stmtResult = evaluateStatement(ctx, stmt);\n\n      // 2. e. If LoopContinues(stmtResult, labelSet) is false, return Completion(UpdateEmpty(stmtResult, V)).\n      if ($LoopContinues(ctx, stmtResult, labelSet).isFalsey) {\n        return stmtResult.UpdateEmpty(V);\n      }\n\n      // 2. f. If stmtResult.[[Value]] is not empty, set V to stmtResult.[[Value]].\n      if (!stmtResult.isEmpty) {\n        V = stmtResult;\n      }\n    }\n  }\n}\n\nexport type $$Initializer = (\n  $$AssignmentExpressionOrHigher |\n  $VariableDeclarationList\n);\n\nexport class $ForStatement implements I$Node {\n  public get $kind(): SyntaxKind.ForStatement { return SyntaxKind.ForStatement; }\n\n  public readonly $initializer: $$Initializer | undefined;\n  public readonly $condition: $$AssignmentExpressionOrHigher | undefined;\n  public readonly $incrementor: $$AssignmentExpressionOrHigher | undefined;\n  public readonly $statement: $$ESLabelledItem;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-for-statement-static-semantics-vardeclarednames\n  // 13.7.4.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-for-statement-static-semantics-varscopeddeclarations\n  // 13.7.4.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: ForStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ForStatement`,\n  ) {\n    this.$condition = $assignmentExpression(node.condition as $AssignmentExpressionNode, this, ctx, -1);\n    this.$incrementor = $assignmentExpression(node.incrementor as $AssignmentExpressionNode, this, ctx, -1);\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n\n    if (node.initializer === void 0) {\n      this.$initializer = void 0;\n\n      this.VarDeclaredNames = $statement.VarDeclaredNames;\n      this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n    } else {\n      if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {\n        const $initializer = this.$initializer = new $VariableDeclarationList(node.initializer as VariableDeclarationList, this, ctx);\n        if ($initializer.isLexical) {\n          this.VarDeclaredNames = $statement.VarDeclaredNames;\n          this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n        } else {\n          this.VarDeclaredNames = [\n            ...$initializer.VarDeclaredNames,\n            ...$statement.VarDeclaredNames,\n          ];\n          this.VarScopedDeclarations = [\n            ...$initializer.VarScopedDeclarations,\n            ...$statement.VarScopedDeclarations,\n          ];\n        }\n      } else {\n        this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n        this.VarDeclaredNames = $statement.VarDeclaredNames;\n        this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n      }\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-for-statement-runtime-semantics-labelledevaluation\n  // 13.7.4.7 Runtime Semantics: LabelledEvaluation\n  public EvaluateLabelled(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);\n    // IterationStatement : for ( Expression opt ; Expression opt ; Expression opt ) Statement\n\n    // 1. If the first Expression is present, then\n    // 1. a. Let exprRef be the result of evaluating the first Expression.\n    // 1. b. Perform ? GetValue(exprRef).\n    // 2. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet).\n\n    // IterationStatement : for ( var VariableDeclarationList ; Expression opt ; Expression opt ) Statement\n\n    // 1. Let varDcl be the result of evaluating VariableDeclarationList.\n    // 2. ReturnIfAbrupt(varDcl).\n    // 3. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet).\n\n    // IterationStatement : for ( LexicalDeclaration Expression opt ; Expression opt ) Statement\n\n    // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n    // 2. Let loopEnv be NewDeclarativeEnvironment(oldEnv).\n    // 3. Let loopEnvRec be loopEnv's EnvironmentRecord.\n    // 4. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration.\n    // 5. Let boundNames be the BoundNames of LexicalDeclaration.\n    // 6. For each element dn of boundNames, do\n    // 6. a. If isConst is true, then\n    // 6. a. i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true).\n    // 6. b. Else,\n    // 6. b. i. Perform ! loopEnvRec.CreateMutableBinding(dn, false).\n    // 7. Set the running execution context's LexicalEnvironment to loopEnv.\n    // 8. Let forDcl be the result of evaluating LexicalDeclaration.\n    // 9. If forDcl is an abrupt completion, then\n    // 9. a. Set the running execution context's LexicalEnvironment to oldEnv.\n    // 9. b. Return Completion(forDcl).\n    // 10. If isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ».\n    // 11. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet).\n    // 12. Set the running execution context's LexicalEnvironment to oldEnv.\n    // 13. Return Completion(bodyResult).\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $ForInStatement implements I$Node {\n  public get $kind(): SyntaxKind.ForInStatement { return SyntaxKind.ForInStatement; }\n\n  public readonly $initializer: $$Initializer;\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $statement: $$ESLabelledItem;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-static-semantics-vardeclarednames\n  // 13.7.5.7 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations\n  // 13.7.5.8 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: ForInStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ForInStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n\n    if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {\n      const $initializer = this.$initializer = new $VariableDeclarationList(node.initializer as VariableDeclarationList, this, ctx);\n      if ($initializer.isLexical) {\n        this.BoundNames = $initializer.BoundNames;\n        this.VarDeclaredNames = $statement.VarDeclaredNames;\n        this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n      } else {\n        this.BoundNames = emptyArray;\n        this.VarDeclaredNames = [\n          ...$initializer.VarDeclaredNames,\n          ...$statement.VarDeclaredNames,\n        ];\n        this.VarScopedDeclarations = [\n          ...$initializer.VarScopedDeclarations,\n          ...$statement.VarScopedDeclarations,\n        ];\n      }\n    } else {\n      this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n      this.BoundNames = emptyArray;\n      this.VarDeclaredNames = $statement.VarDeclaredNames;\n      this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation\n  // 13.7.5.11 Runtime Semantics: LabelledEvaluation\n  public EvaluateLabelled(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);\n    // IterationStatement : for ( LeftHandSideExpression in Expression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).\n\n    // IterationStatement : for ( var ForBinding in Expression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).\n\n    // IterationStatement : for ( ForDeclaration in Expression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).\n\n    // IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).\n\n    // IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).\n\n    // IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).\n\n    // IterationStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet, async).\n\n    // IterationStatement : for await ( var ForBinding of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet, async).\n\n    // IterationStatement : for await ( ForDeclaration of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, async-iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet, async).\n\n    return intrinsics.empty; // TODO: implement this\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-evaluation\n  // 13.7.5.14 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ForBinding : BindingIdentifier\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    // 2. Return ? ResolveBinding(bindingId).\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $ForOfStatement implements I$Node {\n  public get $kind(): SyntaxKind.ForOfStatement { return SyntaxKind.ForOfStatement; }\n\n  public readonly $initializer: $$Initializer;\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $statement: $$ESLabelledItem;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-static-semantics-vardeclarednames\n  // 13.7.5.7 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations\n  // 13.7.5.8 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: ForOfStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ForOfStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n\n    if (node.initializer.kind === SyntaxKind.VariableDeclarationList) {\n      const $initializer = this.$initializer = new $VariableDeclarationList(node.initializer as VariableDeclarationList, this, ctx);\n      if ($initializer.isLexical) {\n        this.BoundNames = $initializer.BoundNames;\n        this.VarDeclaredNames = $statement.VarDeclaredNames;\n        this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n      } else {\n        this.BoundNames = emptyArray;\n        this.VarDeclaredNames = [\n          ...$initializer.VarDeclaredNames,\n          ...$statement.VarDeclaredNames,\n        ];\n        this.VarScopedDeclarations = [\n          ...$initializer.VarScopedDeclarations,\n          ...$statement.VarScopedDeclarations,\n        ];\n      }\n    } else {\n      this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n      this.BoundNames = emptyArray;\n      this.VarDeclaredNames = $statement.VarDeclaredNames;\n      this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation\n  // 13.7.5.11 Runtime Semantics: LabelledEvaluation\n  public EvaluateLabelled(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);\n    // IterationStatement : for ( LeftHandSideExpression in Expression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, enumerate, assignment, labelSet).\n\n    // IterationStatement : for ( var ForBinding in Expression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », Expression, enumerate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, enumerate, varBinding, labelSet).\n\n    // IterationStatement : for ( ForDeclaration in Expression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, Expression, enumerate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, enumerate, lexicalBinding, labelSet).\n\n    // IterationStatement : for ( LeftHandSideExpression of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet).\n\n    // IterationStatement : for ( var ForBinding of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet).\n\n    // IterationStatement : for ( ForDeclaration of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet).\n\n    // IterationStatement : for await ( LeftHandSideExpression of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(LeftHandSideExpression, Statement, keyResult, iterate, assignment, labelSet, async).\n\n    // IterationStatement : for await ( var ForBinding of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(« », AssignmentExpression, async-iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForBinding, Statement, keyResult, iterate, varBinding, labelSet, async).\n\n    // IterationStatement : for await ( ForDeclaration of AssignmentExpression ) Statement\n\n    // 1. Let keyResult be ? ForIn/OfHeadEvaluation(BoundNames of ForDeclaration, AssignmentExpression, async-iterate).\n    // 2. Return ? ForIn/OfBodyEvaluation(ForDeclaration, Statement, keyResult, iterate, lexicalBinding, labelSet, async).\n\n    return intrinsics.empty; // TODO: implement this\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-for-in-and-for-of-statements-runtime-semantics-evaluation\n  // 13.7.5.14 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $ContinueStatement implements I$Node {\n  public get $kind(): SyntaxKind.ContinueStatement { return SyntaxKind.ContinueStatement; }\n\n  public readonly $label: $Identifier | undefined;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: ContinueStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ContinueStatement`,\n  ) {\n    this.$label = $identifier(node.label, this, ctx | Context.IsLabelReference, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-continue-statement-runtime-semantics-evaluation\n  // 13.8.3 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Empty {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ContinueStatement : continue ;\n\n    // 1. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }.\n    if (this.$label === void 0) {\n      return new $Empty(realm, CompletionType.continue, intrinsics.empty, this);\n    }\n\n    // ContinueStatement : continue LabelIdentifier ;\n\n    // 1. Let label be the StringValue of LabelIdentifier.\n    // 2. Return Completion { [[Type]]: continue, [[Value]]: empty, [[Target]]: label }.\n    return new $Empty(realm, CompletionType.continue, this.$label.StringValue, this);\n  }\n}\n\nexport class $BreakStatement implements I$Node {\n  public get $kind(): SyntaxKind.BreakStatement { return SyntaxKind.BreakStatement; }\n\n  public readonly $label: $Identifier | undefined;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: BreakStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.BreakStatement`,\n  ) {\n    this.$label = $identifier(node.label, this, ctx | Context.IsLabelReference, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-break-statement-runtime-semantics-evaluation\n  // 13.9.3 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // BreakStatement : break ;\n\n    // 1. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.\n    if (this.$label === void 0) {\n      return new $Empty(realm, CompletionType.break, intrinsics.empty, this);\n    }\n\n    // BreakStatement : break LabelIdentifier ;\n\n    // 1. Let label be the StringValue of LabelIdentifier.\n    // 2. Return Completion { [[Type]]: break, [[Value]]: empty, [[Target]]: label }.\n    return new $Empty(realm, CompletionType.break, this.$label.StringValue, this);\n  }\n}\n\nexport class $ReturnStatement implements I$Node {\n  public get $kind(): SyntaxKind.ReturnStatement { return SyntaxKind.ReturnStatement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher | undefined;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: ReturnStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ReturnStatement`,\n  ) {\n    if (node.expression === void 0) {\n      this.$expression = void 0;\n    } else {\n      this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-return-statement\n  // 13.10 The return Statement\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ReturnStatement : return ;\n\n    // 1. Return Completion { [[Type]]: return, [[Value]]: undefined, [[Target]]: empty }.\n    if (this.$expression === void 0) {\n      return new $Undefined(realm, CompletionType.return);\n    }\n\n    // ReturnStatement : return Expression ;\n\n    // 1. Let exprRef be the result of evaluating Expression.\n    const exprRef = this.$expression.Evaluate(ctx);\n\n    // 2. Let exprValue be ? GetValue(exprRef).\n    const exprValue = exprRef.GetValue(ctx);\n    if (exprValue.isAbrupt) { return exprValue.enrichWith(ctx, this); }\n\n    // 3. If ! GetGeneratorKind() is async, set exprValue to ? Await(exprValue). // TODO\n\n    // 4. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.\n    return exprValue.ToCompletion(CompletionType.return, intrinsics.empty);\n  }\n}\n\nexport class $WithStatement implements I$Node {\n  public get $kind(): SyntaxKind.WithStatement { return SyntaxKind.WithStatement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $statement: $$ESLabelledItem;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-with-statement-static-semantics-vardeclarednames\n  // 13.11.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-with-statement-static-semantics-varscopeddeclarations\n  // 13.11.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: WithStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.WithStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n\n    this.VarDeclaredNames = $statement.VarDeclaredNames;\n    this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-with-statement-runtime-semantics-evaluation\n  // 13.11.7 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // WithStatement : with ( Expression ) Statement\n\n    // 1. Let val be the result of evaluating Expression.\n    // 2. Let obj be ? ToObject(? GetValue(val)).\n    // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n    // 4. Let newEnv be NewObjectEnvironment(obj, oldEnv).\n    // 5. Set the withEnvironment flag of newEnv's EnvironmentRecord to true.\n    // 6. Set the running execution context's LexicalEnvironment to newEnv.\n    // 7. Let C be the result of evaluating Statement.\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    // 9. Return Completion(UpdateEmpty(C, undefined)).\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $SwitchStatement implements I$Node {\n  public get $kind(): SyntaxKind.SwitchStatement { return SyntaxKind.SwitchStatement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $caseBlock: $CaseBlock;\n\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallydeclarednames\n  // 13.12.5 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallyscopeddeclarations\n  // 13.12.6 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-vardeclarednames\n  // 13.12.7 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-varscopeddeclarations\n  // 13.12.8 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: SwitchStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.SwitchStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    const $caseBlock = this.$caseBlock = new $CaseBlock(node.caseBlock, this, ctx);\n\n    this.LexicallyDeclaredNames = $caseBlock.LexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $caseBlock.LexicallyScopedDeclarations;\n    this.VarDeclaredNames = $caseBlock.VarDeclaredNames;\n    this.VarScopedDeclarations = $caseBlock.VarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-runtime-semantics-evaluation\n  // 13.12.11 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    const realm = ctx.Realm;\n    // SwitchStatement : switch ( Expression ) CaseBlock\n\n    // 1. Let exprRef be the result of evaluating Expression.\n    // 2. Let switchValue be ? GetValue(exprRef).\n    const switchValue = this.$expression.Evaluate(ctx).GetValue(ctx);\n    if (switchValue.isAbrupt) { return switchValue.enrichWith(ctx, this); }\n\n    // 3. Let oldEnv be the running execution context's LexicalEnvironment.\n    const oldEnv = ctx.LexicalEnvironment;\n\n    // 4. Let blockEnv be NewDeclarativeEnvironment(oldEnv).\n    const blockEnv = ctx.LexicalEnvironment = new $DeclarativeEnvRec(this.logger, realm, oldEnv);\n\n    // 5. Perform BlockDeclarationInstantiation(CaseBlock, blockEnv).\n    const $BlockDeclarationInstantiationResult = BlockDeclarationInstantiation(ctx, this.LexicallyScopedDeclarations, blockEnv);\n    if ($BlockDeclarationInstantiationResult.isAbrupt) { return $BlockDeclarationInstantiationResult; }\n\n    // 6. Set the running execution context's LexicalEnvironment to blockEnv.\n    realm.stack.push(ctx);\n\n    // 7. Let R be the result of performing CaseBlockEvaluation of CaseBlock with argument switchValue.\n    const R = this.EvaluateCaseBlock(ctx, switchValue);\n\n    // 8. Set the running execution context's LexicalEnvironment to oldEnv.\n    realm.stack.pop();\n    ctx.LexicalEnvironment = oldEnv;\n\n    // 9. Return R.\n    return R;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-caseblockevaluation\n  // 13.12.9 Runtime Semantics: CaseBlockEvaluation\n  private EvaluateCaseBlock(\n    ctx: ExecutionContext,\n    switchValue: $Any,\n  ) {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const { $caseBlock: { $clauses: clauses } } = this;\n    const { undefined: $undefined, empty } = realm['[[Intrinsics]]'];\n    // CaseBlock : { }\n    // 1. Return NormalCompletion(undefined).\n    if (clauses.length === 0) {\n      return new $Undefined(realm);\n    }\n\n    let V: $Any = $undefined;\n    const defaultClauseIndex: number = clauses.findIndex((clause) => clause.$kind === SyntaxKind.DefaultClause);\n    class CaseClausesEvaluationResult {\n      public constructor(public result: $Any, public found: boolean, public isAbrupt: boolean) { }\n    }\n    const evaluateCaseClauses = (inclusiveStartIndex: number, exclusiveEndIndex: number, found = false) => {\n      // 1. Let V be undefined.\n      // 2. Let A be the List of CaseClause items in CaseClauses, in source text order.\n      // 3. Let found be false.\n      // 4. For each CaseClause C in A, do\n      for (let i = inclusiveStartIndex; i < exclusiveEndIndex; i++) {\n        const C = clauses[i] as $CaseClause;\n        // 4. a. If found is false, then\n        if (!found) {\n          // 4. a. i. Set found to ? CaseClauseIsSelected(C, input).\n          found = this.IsCaseClauseSelected(ctx, C, switchValue);\n        }\n        // 4. b. If found is true, then\n        if (found) {\n          // 4. b. i. Let R be the result of evaluating C.\n          const R = evaluateStatementList(ctx, C.$statements);\n\n          // 4. b. ii. If R.[[Value]] is not empty, set V to R.[[Value]].\n          if (R.hasValue) {\n            V = R;\n          }\n          // 4. b. iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n          if (R.isAbrupt) {\n            return new CaseClausesEvaluationResult(R.enrichWith(ctx, this).UpdateEmpty(V), found, true);\n          }\n        }\n      }\n      // 5. Return NormalCompletion(V).\n      return new CaseClausesEvaluationResult(\n        V.ToCompletion(CompletionType.normal, intrinsics.empty),\n        found,\n        false,\n      );\n    };\n\n    // CaseBlock : { CaseClauses }\n    if (defaultClauseIndex === -1) {\n      return evaluateCaseClauses(0, clauses.length).result;\n    }\n\n    // CaseBlock : { CaseClauses opt DefaultClause CaseClauses opt }\n    // 1. Let V be undefined.\n    // 2. If the first CaseClauses is present, then\n    // 2. a. Let A be the List of CaseClause items in the first CaseClauses, in source text order.\n    // 3. Else,\n    // 3. a. Let A be « ».\n    // 4. Let found be false.\n    // 5. For each CaseClause C in A, do\n    // 5. a. If found is false, then\n    // 5. a. i. Set found to ? CaseClauseIsSelected(C, input).\n    // 5. b. If found is true, then\n    // 5. b. i. Let R be the result of evaluating C.\n    // 5. b. ii. If R.[[Value]] is not empty, set V to R.[[Value]].\n    // 5. b. iii. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n    let { result, found, isAbrupt } = evaluateCaseClauses(0, defaultClauseIndex);\n    if (isAbrupt) {\n      return result;\n    }\n    // 6. Let foundInB be false.\n    // 7. If the second CaseClauses is present, then\n    // 7. a. Let B be the List of CaseClause items in the second CaseClauses, in source text order.\n    // 8. Else,\n    // 8. a. Let B be « ».\n    // 9. If found is false, then\n    if (!found) {\n      // 9. a. For each CaseClause C in B, do\n      // 9. a. i. If foundInB is false, then\n      // 9. a. i. 1. Set foundInB to ? CaseClauseIsSelected(C, input).\n      // 9. a. ii. If foundInB is true, then\n      // 9. a. ii. 1. Let R be the result of evaluating CaseClause C.\n      // 9. a. ii. 2. If R.[[Value]] is not empty, set V to R.[[Value]].\n      // 9. a. ii. 3. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n      // 10. If foundInB is true, return NormalCompletion(V).\n      ({ result, isAbrupt, found } = evaluateCaseClauses(defaultClauseIndex + 1, clauses.length));\n      if (isAbrupt || found) {\n        return result;\n      }\n    }\n    // 11. Let R be the result of evaluating DefaultClause.\n    // 12. If R.[[Value]] is not empty, set V to R.[[Value]].\n    // 13. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n    ({ result, isAbrupt } = evaluateCaseClauses(defaultClauseIndex, defaultClauseIndex + 1, true));\n    if (isAbrupt) {\n      return result;\n    }\n    // 14. For each CaseClause C in B (NOTE: this is another complete iteration of the second CaseClauses), do\n    // 14. a. Let R be the result of evaluating CaseClause C.\n    // 14. b. If R.[[Value]] is not empty, set V to R.[[Value]].\n    // 14. c. If R is an abrupt completion, return Completion(UpdateEmpty(R, V)).\n    // 15. Return NormalCompletion(V).\n    return evaluateCaseClauses(defaultClauseIndex + 1, clauses.length, true).result;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-caseclauseisselected\n  // 13.12.10 Runtime Semantics: CaseClauseIsSelected ( C , input )\n  private IsCaseClauseSelected(\n    ctx: ExecutionContext,\n    clause: $CaseClause,\n    switchValue: $Any,\n  ): boolean {\n    ctx.checkTimeout();\n\n    // 1. Assert: C is an instance of the production CaseClause:caseExpression:StatementListopt .\n    // 2. Let exprRef be the result of evaluating the Expression of C.\n    // 3. Let clauseSelector be ? GetValue(exprRef).\n    // 4. Return the result of performing Strict Equality Comparison input === clauseSelector.\n    return clause.$expression.Evaluate(ctx).GetValue(ctx)['[[Value]]'] === switchValue['[[Value]]'];\n  }\n}\n\nexport class $LabeledStatement implements I$Node {\n  public get $kind(): SyntaxKind.LabeledStatement { return SyntaxKind.LabeledStatement; }\n\n  public readonly $label: $Identifier;\n  public readonly $statement: $$ESLabelledItem;\n\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-lexicallydeclarednames\n  // 13.13.6 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-lexicallyscopeddeclarations\n  // 13.13.7 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-toplevellexicallydeclarednames\n  // 13.13.8 Static Semantics: TopLevelLexicallyDeclaredNames\n  public readonly TopLevelLexicallyDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations\n  // 13.13.9 Static Semantics: TopLevelLexicallyScopedDeclarations\n  public readonly TopLevelLexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-toplevelvardeclarednames\n  // 13.13.10 Static Semantics: TopLevelVarDeclaredNames\n  public readonly TopLevelVarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations\n  // 13.13.11 Static Semantics: TopLevelVarScopedDeclarations\n  public readonly TopLevelVarScopedDeclarations: readonly $$ESVarDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-vardeclarednames\n  // 13.13.12 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-static-semantics-varscopeddeclarations\n  // 13.13.13 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public constructor(\n    public readonly node: LabeledStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.LabeledStatement`,\n  ) {\n    this.$label = $identifier(node.label, this, ctx | Context.IsLabel, -1);\n    const $statement = this.$statement = $$esLabelledItem(node.statement as $StatementNode, this, ctx, -1);\n\n    if ($statement.$kind === SyntaxKind.FunctionDeclaration) {\n      this.LexicallyDeclaredNames = $statement.BoundNames;\n      this.LexicallyScopedDeclarations = [$statement];\n      this.TopLevelVarDeclaredNames = $statement.BoundNames;\n      this.TopLevelVarScopedDeclarations = [$statement];\n      this.VarDeclaredNames = emptyArray;\n      this.VarScopedDeclarations = emptyArray;\n    } else {\n      this.LexicallyDeclaredNames = emptyArray;\n      this.LexicallyScopedDeclarations = emptyArray;\n      if ($statement.$kind === SyntaxKind.LabeledStatement) {\n        this.TopLevelVarDeclaredNames = $statement.TopLevelVarDeclaredNames;\n        this.TopLevelVarScopedDeclarations = $statement.TopLevelVarScopedDeclarations;\n      } else {\n        this.TopLevelVarDeclaredNames = $statement.VarDeclaredNames;\n        this.TopLevelVarScopedDeclarations = $statement.VarScopedDeclarations;\n      }\n      this.VarDeclaredNames = $statement.VarDeclaredNames;\n      this.VarScopedDeclarations = $statement.VarScopedDeclarations;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-runtime-semantics-labelledevaluation\n  // 13.13.14 Runtime Semantics: LabelledEvaluation\n  public EvaluateLabelled(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.EvaluateLabelled(#${ctx.id})`);\n    // LabelledStatement : LabelIdentifier : LabelledItem\n\n    // 1. Let label be the StringValue of LabelIdentifier.\n    // 2. Append label as an element of labelSet.\n    // 3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.\n    // 4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then\n    // 4. a. Set stmtResult to NormalCompletion(stmtResult.[[Value]]).\n    // 5. Return Completion(stmtResult).\n\n    // LabelledItem : Statement\n\n    // 1. If Statement is either a LabelledStatement or a BreakableStatement, then\n    // 1. a. Return LabelledEvaluation of Statement with argument labelSet.\n    // 2. Else,\n    // 2. a. Return the result of evaluating Statement.\n\n    // LabelledItem : FunctionDeclaration\n\n    // 1. Return the result of evaluating FunctionDeclaration.\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-labelled-statements-runtime-semantics-evaluation\n  // 13.13.15 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // LabelledStatement : LabelIdentifier : LabelledItem\n\n    // 1. Let newLabelSet be a new empty List.\n    // 2. Return LabelledEvaluation of this LabelledStatement with argument newLabelSet.\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $ThrowStatement implements I$Node {\n  public get $kind(): SyntaxKind.ThrowStatement { return SyntaxKind.ThrowStatement; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: ThrowStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ThrowStatement`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-throw-statement-runtime-semantics-evaluation\n  // 13.14.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ThrowStatement : throw Expression ;\n\n    // 1. Let exprRef be the result of evaluating Expression.\n    const exprRef = this.$expression.Evaluate(ctx);\n\n    // 2. Let exprValue be ? GetValue(exprRef).\n    const exprValue = exprRef.GetValue(ctx);\n    if (exprValue.isAbrupt) { return exprValue.enrichWith(ctx, this); }\n\n    // 3. Return ThrowCompletion(exprValue).\n    return exprValue.ToCompletion(CompletionType.throw, intrinsics.empty);\n  }\n}\n\nexport class $TryStatement implements I$Node {\n  public get $kind(): SyntaxKind.TryStatement { return SyntaxKind.TryStatement; }\n\n  public readonly $tryBlock: $Block;\n  public readonly $catchClause: $CatchClause | undefined;\n  public readonly $finallyBlock: $Block | undefined;\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-try-statement-static-semantics-vardeclarednames\n  // 13.15.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-try-statement-static-semantics-varscopeddeclarations\n  // 13.15.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public constructor(\n    public readonly node: TryStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TryStatement`,\n  ) {\n    const $tryBlock = this.$tryBlock = new $Block(node.tryBlock, this, ctx, -1);\n    if (node.catchClause === void 0) {\n      // finallyBlock must be defined\n      this.$catchClause = void 0;\n      const $finallyBlock = this.$finallyBlock = new $Block(node.finallyBlock!, this, ctx, -1);\n\n      this.VarDeclaredNames = [\n        ...$tryBlock.VarDeclaredNames,\n        ...$finallyBlock.VarDeclaredNames,\n      ];\n      this.VarScopedDeclarations = [\n        ...$tryBlock.VarScopedDeclarations,\n        ...$finallyBlock.VarScopedDeclarations,\n      ];\n    } else if (node.finallyBlock === void 0) {\n      // catchClause must be defined\n      const $catchClause = this.$catchClause = new $CatchClause(node.catchClause!, this, ctx);\n      this.$finallyBlock = void 0;\n\n      this.VarDeclaredNames = [\n        ...$tryBlock.VarDeclaredNames,\n        ...$catchClause.VarDeclaredNames,\n      ];\n      this.VarScopedDeclarations = [\n        ...$tryBlock.VarScopedDeclarations,\n        ...$catchClause.VarScopedDeclarations,\n      ];\n    } else {\n      const $catchClause = this.$catchClause = new $CatchClause(node.catchClause!, this, ctx);\n      const $finallyBlock = this.$finallyBlock = new $Block(node.finallyBlock!, this, ctx, -1);\n\n      this.VarDeclaredNames = [\n        ...$tryBlock.VarDeclaredNames,\n        ...$catchClause.VarDeclaredNames,\n        ...$finallyBlock.VarDeclaredNames,\n      ];\n      this.VarScopedDeclarations = [\n        ...$tryBlock.VarScopedDeclarations,\n        ...$catchClause.VarScopedDeclarations,\n        ...$finallyBlock.VarScopedDeclarations,\n      ];\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-try-statement-runtime-semantics-evaluation\n  // 13.15.8 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    const realm = ctx.Realm;\n    // TryStatement : try Block Catch\n\n    // 1. Let B be the result of evaluating Block.\n    // 2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].\n    // 3. Else, let C be B.\n    // 4. Return Completion(UpdateEmpty(C, undefined)).\n\n    // TryStatement : try Block Finally\n\n    // 1. Let B be the result of evaluating Block.\n    // 2. Let F be the result of evaluating Finally.\n    // 3. If F.[[Type]] is normal, set F to B.\n    // 4. Return Completion(UpdateEmpty(F, undefined)).\n\n    // TryStatement : try Block Catch Finally\n\n    // 1. Let B be the result of evaluating Block.\n    // 2. If B.[[Type]] is throw, let C be CatchClauseEvaluation of Catch with argument B.[[Value]].\n    // 3. Else, let C be B.\n    // 4. Let F be the result of evaluating Finally.\n    // 5. If F.[[Type]] is normal, set F to C.\n    // 6. Return Completion(UpdateEmpty(F, undefined)).\n\n    let result = this.$tryBlock.Evaluate(ctx);\n\n    if (this.$catchClause !== void 0) {\n      result = result['[[Type]]'] === CompletionType.throw ? this.EvaluateCatchClause(ctx, result.GetValue(ctx) as $AnyNonEmpty) : result; // TODO: fix types\n    }\n    const $finallyBlock = this.$finallyBlock;\n    if ($finallyBlock !== void 0) {\n      const F = $finallyBlock.Evaluate(ctx);\n      result = F['[[Type]]'] !== CompletionType.normal ? F : result;\n    }\n    result.UpdateEmpty(realm['[[Intrinsics]]'].undefined);\n\n    return result as $AnyNonEmpty;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-catchclauseevaluation\n  // 13.15.7 Runtime Semantics: CatchClauseEvaluation\n  private EvaluateCatchClause(\n    ctx: ExecutionContext,\n    thrownValue: $AnyNonEmpty,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const catchClause = this.$catchClause;\n    const varDeclarations = catchClause?.$variableDeclaration;\n    const hasCatchParamteres = varDeclarations !== void 0;\n\n    // Catch : catch Block\n\n    // 1. Return the result of evaluating Block.\n\n    // Catch : catch ( CatchParameter ) Block\n\n    // 1. Let oldEnv be the running execution context's LexicalEnvironment.\n    const oldEnv = ctx.LexicalEnvironment;\n\n    if (hasCatchParamteres) {\n      // 2. Let catchEnv be NewDeclarativeEnvironment(oldEnv).\n      // 3. Let catchEnvRec be catchEnv's EnvironmentRecord.\n      ctx.LexicalEnvironment = new $DeclarativeEnvRec(this.logger, realm, oldEnv);\n\n      // 4. For each element argName of the BoundNames of CatchParameter, do\n      // 4. a. Perform ! catchEnvRec.CreateMutableBinding(argName, false).\n      catchClause?.CreateBinding(ctx, realm);\n\n      // 5. Set the running execution context's LexicalEnvironment to catchEnv.\n      realm.stack.push(ctx);\n\n      // 6. Let status be the result of performing BindingInitialization for CatchParameter passing thrownValue and catchEnv as arguments.\n      const status = varDeclarations?.InitializeBinding(ctx, thrownValue);\n\n      // 7. If status is an abrupt completion, then\n      if (status?.isAbrupt) {\n        // 7. a. Set the running execution context's LexicalEnvironment to oldEnv.\n        realm.stack.pop();\n        ctx.LexicalEnvironment = oldEnv;\n\n        // 7. b. Return Completion(status).\n        return status;\n      }\n    }\n    // 8. Let B be the result of evaluating Block.\n    const B = catchClause?.$block.Evaluate(ctx);\n\n    // 9. Set the running execution context's LexicalEnvironment to oldEnv.\n    if (hasCatchParamteres) {\n      realm.stack.pop();\n      ctx.LexicalEnvironment = oldEnv;\n    }\n\n    // 10. Return Completion(B).\n    return B as $AnyNonEmpty; // TODO fix typings\n  }\n}\n\nexport class $DebuggerStatement implements I$Node {\n  public get $kind(): SyntaxKind.DebuggerStatement { return SyntaxKind.DebuggerStatement; }\n\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-vardeclarednames\n  // 13.1.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-statement-semantics-static-semantics-varscopeddeclarations\n  // 13.1.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public constructor(\n    public readonly node: DebuggerStatement,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.DebuggerStatement`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-debugger-statement-runtime-semantics-evaluation\n  // 13.16.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // DebuggerStatement : debugger ;\n\n    // 1. If an implementation-defined debugging facility is available and enabled, then\n    // 1. a. Perform an implementation-defined debugging action.\n    // 1. b. Let result be an implementation-defined Completion value.\n    // 2. Else,\n    // 2. a. Let result be NormalCompletion(empty).\n    // 3. Return result.\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\n// #endregion\n\n// #region Statement members\n\nexport type $$CaseOrDefaultClause = $CaseClause | $DefaultClause;\n\nexport function $$clauseList(\n  nodes: readonly CaseOrDefaultClause[],\n  parent: $CaseBlock,\n  ctx: Context,\n): readonly $$CaseOrDefaultClause[] {\n  const len = nodes.length;\n  let node: CaseOrDefaultClause;\n  const $nodes: $$CaseOrDefaultClause[] = [];\n\n  for (let i = 0; i < len; ++i) {\n    node = nodes[i];\n    switch (node.kind) {\n      case SyntaxKind.CaseClause:\n        $nodes[i] = new $CaseClause(node, parent, ctx, i);\n        break;\n      case SyntaxKind.DefaultClause:\n        $nodes[i] = new $DefaultClause(node, parent, ctx, i);\n        break;\n    }\n  }\n  return $nodes;\n}\n\nexport class $CaseBlock implements I$Node {\n  public get $kind(): SyntaxKind.CaseBlock { return SyntaxKind.CaseBlock; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallydeclarednames\n  // 13.12.5 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallyscopeddeclarations\n  // 13.12.6 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-vardeclarednames\n  // 13.12.7 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-varscopeddeclarations\n  // 13.12.8 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly $clauses: readonly $$CaseOrDefaultClause[];\n\n  public constructor(\n    public readonly node: CaseBlock,\n    public readonly parent: $SwitchStatement,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.CaseBlock`,\n  ) {\n    const $clauses = this.$clauses = $$clauseList(node.clauses, this, ctx);\n\n    this.LexicallyDeclaredNames = $clauses.flatMap(getLexicallyDeclaredNames);\n    this.LexicallyScopedDeclarations = $clauses.flatMap(getLexicallyScopedDeclarations);\n    this.VarDeclaredNames = $clauses.flatMap(getVarDeclaredNames);\n    this.VarScopedDeclarations = $clauses.flatMap(getVarScopedDeclarations);\n  }\n}\n\nexport class $CaseClause implements I$Node {\n  public get $kind(): SyntaxKind.CaseClause { return SyntaxKind.CaseClause; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallydeclarednames\n  // 13.12.5 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallyscopeddeclarations\n  // 13.12.6 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-vardeclarednames\n  // 13.12.7 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-varscopeddeclarations\n  // 13.12.8 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n  public readonly $statements: readonly $$TSStatementListItem[];\n\n  public constructor(\n    public readonly node: CaseClause,\n    public readonly parent: $CaseBlock,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.CaseClause`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n    const $statements = this.$statements = $$tsStatementList(node.statements as NodeArray<$StatementNode>, this, ctx);\n\n    this.LexicallyDeclaredNames = $statements.flatMap(getLexicallyDeclaredNames);\n    this.LexicallyScopedDeclarations = $statements.flatMap(getLexicallyScopedDeclarations);\n    this.VarDeclaredNames = $statements.flatMap(getVarDeclaredNames);\n    this.VarScopedDeclarations = $statements.flatMap(getVarScopedDeclarations);\n  }\n}\n\nexport class $DefaultClause implements I$Node {\n  public get $kind(): SyntaxKind.DefaultClause { return SyntaxKind.DefaultClause; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallydeclarednames\n  // 13.12.5 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-lexicallyscopeddeclarations\n  // 13.12.6 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-vardeclarednames\n  // 13.12.7 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-switch-statement-static-semantics-varscopeddeclarations\n  // 13.12.8 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly $statements: readonly $$TSStatementListItem[];\n\n  public constructor(\n    public readonly node: DefaultClause,\n    public readonly parent: $CaseBlock,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.DefaultClause`,\n  ) {\n    const $statements = this.$statements = $$tsStatementList(node.statements as NodeArray<$StatementNode>, this, ctx);\n\n    this.LexicallyDeclaredNames = $statements.flatMap(getLexicallyDeclaredNames);\n    this.LexicallyScopedDeclarations = $statements.flatMap(getLexicallyScopedDeclarations);\n    this.VarDeclaredNames = $statements.flatMap(getVarDeclaredNames);\n    this.VarScopedDeclarations = $statements.flatMap(getVarScopedDeclarations);\n  }\n}\n\nexport class $CatchClause implements I$Node {\n  public get $kind(): SyntaxKind.CatchClause { return SyntaxKind.CatchClause; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-try-statement-static-semantics-vardeclarednames\n  // 13.15.5 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-try-statement-static-semantics-varscopeddeclarations\n  // 13.15.6 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly $variableDeclaration: $VariableDeclaration | undefined;\n  public readonly $block: $Block;\n\n  public constructor(\n    public readonly node: CatchClause,\n    public readonly parent: $TryStatement,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.CatchClause`,\n  ) {\n    ctx |= Context.InCatchClause;\n\n    if (node.variableDeclaration === void 0) {\n      this.$variableDeclaration = void 0;\n    } else {\n      this.$variableDeclaration = new $VariableDeclaration(node.variableDeclaration, this, ctx, -1);\n    }\n    const $block = this.$block = new $Block(node.block, this, ctx, -1);\n\n    this.VarDeclaredNames = $block.VarDeclaredNames;\n    this.VarScopedDeclarations = $block.VarScopedDeclarations;\n  }\n  public CreateBinding(ctx: ExecutionContext, realm: Realm) {\n    ctx.checkTimeout();\n\n    for (const argName of this.$variableDeclaration?.BoundNames ?? []) {\n      ctx.LexicalEnvironment.CreateMutableBinding(ctx, argName, realm['[[Intrinsics]]'].false);\n    }\n  }\n}\n\n// #endregion\n","import {\n  GetAccessorDeclaration,\n  MethodDeclaration,\n  ModifierFlags,\n  SetAccessorDeclaration,\n  SyntaxKind,\n} from 'typescript';\nimport {\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $DefinePropertyOrThrow,\n} from '../operations.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  $Error,\n} from '../types/error.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  I$Node,\n  Context,\n  modifiersToModifierFlags,\n  hasBit,\n  $$PropertyName,\n  $$propertyName,\n  $decoratorList,\n  $$ESDeclaration,\n  $i,\n  $$ESVarDeclaration,\n  FunctionKind,\n} from './_shared.js';\nimport {\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Decorator,\n  $ObjectLiteralExpression,\n} from './expressions.js';\nimport {\n  $ClassDeclaration,\n  $ClassExpression,\n} from './classes.js';\nimport {\n  MethodDefinitionRecord,\n  $FormalParameterList,\n  $FunctionDeclaration\n} from './functions.js';\nimport {\n  $Block,\n} from './statements.js';\nimport {\n  $FunctionEnvRec,\n} from '../types/environment-record.js';\nimport {\n  $Any,\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  $List,\n} from '../types/list.js';\n\nexport class $MethodDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.MethodDeclaration { return SyntaxKind.MethodDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $$PropertyName;\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-isstatic\n  // 14.6.9 Static Semantics: IsStatic\n  public readonly IsStatic: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-static-semantics-propname\n  // 14.3.5 Static Semantics: PropName\n  public readonly PropName: $String | $Empty;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.1.14 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.1.15 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-vardeclarednames\n  // 14.1.16 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-varscopeddeclarations\n  // 14.1.17 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly functionKind: FunctionKind;\n\n  public constructor(\n    public readonly node: MethodDeclaration,\n    public readonly parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.MethodDeclaration`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    const $name = this.$name = $$propertyName(node.name, this, ctx | Context.IsMemberName, -1);\n    this.$parameters = new $FormalParameterList(node.parameters, this, ctx);\n    const $body = this.$body = new $Block(node.body!, this, ctx, -1);\n\n    this.PropName = $name.PropName;\n    this.IsStatic = hasBit(modifierFlags, ModifierFlags.Static);\n\n    this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;\n    this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;\n    this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;\n\n    if (!hasBit(modifierFlags, ModifierFlags.Async)) {\n      if (node.asteriskToken === void 0) {\n        this.functionKind = FunctionKind.normal;\n      } else {\n        this.functionKind = FunctionKind.generator;\n      }\n    } else if (node.asteriskToken === void 0) {\n      this.functionKind = FunctionKind.async;\n    } else {\n      this.functionKind = FunctionKind.asyncGenerator;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-definemethod\n  // 14.3.7 Runtime Semantics: DefineMethod\n  public DefineMethod(\n    ctx: ExecutionContext,\n    object: $Object,\n  ): MethodDefinitionRecord | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    // NOTE: this logic and signature is adapted to the fact that this is never a constructor method (that's what $ConstructorDeclaration is for)\n\n    // MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }\n\n    // 1. Let propKey be the result of evaluating PropertyName.\n    const propKey = this.$name.EvaluatePropName(ctx);\n\n    // 2. ReturnIfAbrupt(propKey).\n    if (propKey.isAbrupt) { return propKey.enrichWith(ctx, this); }\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = intrinsics.true; // TODO: use static semantics\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 5. If functionPrototype is present as a parameter, then\n      // 5. a. Let kind be Normal.\n      // 5. b. Let prototype be functionPrototype.\n    // 6. Else,\n      // 6. a. Let kind be Method.\n      // 6. b. Let prototype be the intrinsic object %FunctionPrototype%.\n\n    const functionPrototype = intrinsics['%FunctionPrototype%'];\n\n    // 7. Let closure be FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype).\n    const closure = $Function.FunctionCreate(ctx, 'method', this, scope, strict, functionPrototype);\n\n    // 8. Perform MakeMethod(closure, object).\n    closure['[[HomeObject]]'] = object;\n\n    // 9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 10. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.\n    return new MethodDefinitionRecord(propKey, closure);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation\n  // 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation\n  public EvaluatePropertyDefinition(\n    ctx: ExecutionContext,\n    object: $Object,\n    enumerable: $Boolean,\n  ): $Boolean | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }\n\n    // 1. Let methodDef be DefineMethod of MethodDefinition with argument object.\n    const methodDef = this.DefineMethod(ctx, object);\n\n    // 2. ReturnIfAbrupt(methodDef).\n    if (methodDef.isAbrupt) { return methodDef.enrichWith(ctx, this); }\n\n    // 3. Perform SetFunctionName(methodDef.[[Closure]], methodDef.[[Key]]).\n    methodDef['[[Closure]]'].SetFunctionName(ctx, methodDef['[[Key]]']);\n\n    // 4. Let desc be the PropertyDescriptor { [[Value]]: methodDef.[[Closure]], [[Writable]]: true, [[Enumerable]]: enumerable, [[Configurable]]: true }.\n    const desc = new $PropertyDescriptor(\n      realm,\n      methodDef['[[Key]]'],\n      {\n        '[[Value]]': methodDef['[[Closure]]'],\n        '[[Writable]]': intrinsics.true,\n        '[[Enumerable]]': enumerable,\n        '[[Configurable]]': intrinsics.true,\n      },\n    );\n\n    // 5. Return ? DefinePropertyOrThrow(object, methodDef.[[Key]], desc).\n    return $DefinePropertyOrThrow(ctx, object, methodDef['[[Key]]'], desc).enrichWith(ctx, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    ctx.checkTimeout();\n\n    return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);\n  }\n}\n\nexport class $GetAccessorDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.GetAccessor { return SyntaxKind.GetAccessor; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $$PropertyName;\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-isstatic\n  // 14.6.9 Static Semantics: IsStatic\n  public readonly IsStatic: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-static-semantics-propname\n  // 14.3.5 Static Semantics: PropName\n  public readonly PropName: $String | $Empty;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.1.14 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.1.15 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-vardeclarednames\n  // 14.1.16 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-varscopeddeclarations\n  // 14.1.17 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly functionKind: FunctionKind.normal = FunctionKind.normal;\n\n  public constructor(\n    public readonly node: GetAccessorDeclaration,\n    public readonly parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.GetAccessorDeclaration`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    const $name = this.$name = $$propertyName(node.name, this, ctx | Context.IsMemberName, -1);\n    this.$parameters = new $FormalParameterList(node.parameters, this, ctx);\n    const $body = this.$body = new $Block(node.body!, this, ctx, -1);\n\n    this.PropName = $name.PropName;\n    this.IsStatic = hasBit(modifierFlags, ModifierFlags.Static);\n\n    this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;\n    this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;\n    this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation\n  // 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation\n  public EvaluatePropertyDefinition(\n    ctx: ExecutionContext,\n    object: $Object,\n    enumerable: $Boolean,\n  ): $Boolean | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // MethodDefinition : get PropertyName ( ) { FunctionBody }\n\n    // 1. Let propKey be the result of evaluating PropertyName.\n    const propKey = this.$name.EvaluatePropName(ctx);\n\n    // 2. ReturnIfAbrupt(propKey).\n    if (propKey.isAbrupt) { return propKey.enrichWith(ctx, this); }\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = intrinsics.true; // TODO: use static semantics\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 5. Let formalParameterList be an instance of the production FormalParameters:[empty] .\n    // 6. Let closure be FunctionCreate(Method, formalParameterList, FunctionBody, scope, strict).\n    const closure = $Function.FunctionCreate(ctx, 'method', this, scope, strict);\n\n    // 7. Perform MakeMethod(closure, object).\n    closure['[[HomeObject]]'] = object;\n\n    // 8. Perform SetFunctionName(closure, propKey, \"get\").\n    closure.SetFunctionName(ctx, propKey, intrinsics.$get);\n\n    // 9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 10. Let desc be the PropertyDescriptor { [[Get]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.\n    const desc = new $PropertyDescriptor(\n      realm,\n      propKey,\n      {\n        '[[Get]]': closure,\n        '[[Enumerable]]': enumerable,\n        '[[Configurable]]': intrinsics.true,\n      },\n    );\n\n    // 11. Return ? DefinePropertyOrThrow(object, propKey, desc).\n    return $DefinePropertyOrThrow(ctx, object, propKey, desc).enrichWith(ctx, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    ctx.checkTimeout();\n\n    return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);\n  }\n}\n\nexport class $SetAccessorDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.SetAccessor { return SyntaxKind.SetAccessor; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $$PropertyName;\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-isstatic\n  // 14.6.9 Static Semantics: IsStatic\n  public readonly IsStatic: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-static-semantics-propname\n  // 14.3.5 Static Semantics: PropName\n  public readonly PropName: $String | $Empty;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.1.14 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.1.15 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-vardeclarednames\n  // 14.1.16 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-varscopeddeclarations\n  // 14.1.17 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly functionKind: FunctionKind.normal = FunctionKind.normal;\n\n  public constructor(\n    public readonly node: SetAccessorDeclaration,\n    public readonly parent: $ClassDeclaration | $ClassExpression | $ObjectLiteralExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.SetAccessorDeclaration`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    const $name = this.$name = $$propertyName(node.name, this, ctx | Context.IsMemberName, -1);\n    this.$parameters = new $FormalParameterList(node.parameters, this, ctx);\n    const $body = this.$body = new $Block(node.body!, this, ctx, -1);\n\n    this.PropName = $name.PropName;\n    this.IsStatic = hasBit(modifierFlags, ModifierFlags.Static);\n\n    this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;\n    this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;\n    this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation\n  // 14.3.8 Runtime Semantics: PropertyDefinitionEvaluation\n  public EvaluatePropertyDefinition(\n    ctx: ExecutionContext,\n    object: $Object,\n    enumerable: $Boolean,\n  ): $Boolean | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // MethodDefinition : set PropertyName ( PropertySetParameterList ) { FunctionBody }\n\n    // 1. Let propKey be the result of evaluating PropertyName.\n    const propKey = this.$name.EvaluatePropName(ctx);\n\n    // 2. ReturnIfAbrupt(propKey).\n    if (propKey.isAbrupt) { return propKey.enrichWith(ctx, this); }\n\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = intrinsics.true; // TODO: use static semantics\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 5. Let closure be FunctionCreate(Method, PropertySetParameterList, FunctionBody, scope, strict).\n    const closure = $Function.FunctionCreate(ctx, 'method', this, scope, strict);\n\n    // 6. Perform MakeMethod(closure, object).\n    closure['[[HomeObject]]'] = object;\n\n    // 7. Perform SetFunctionName(closure, propKey, \"set\").\n    closure.SetFunctionName(ctx, propKey, intrinsics.$set);\n\n    // 8. Set closure.[[SourceText]] to the source text matched by MethodDefinition.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 9. Let desc be the PropertyDescriptor { [[Set]]: closure, [[Enumerable]]: enumerable, [[Configurable]]: true }.\n    const desc = new $PropertyDescriptor(\n      realm,\n      propKey,\n      {\n        '[[Set]]': closure,\n        '[[Enumerable]]': enumerable,\n        '[[Configurable]]': intrinsics.true,\n      },\n    );\n\n    // 10. Return ? DefinePropertyOrThrow(object, propKey, desc).\n    return $DefinePropertyOrThrow(ctx, object, propKey, desc).enrichWith(ctx, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    ctx.checkTimeout();\n\n    return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);\n  }\n}\n","import {\n  ArrayLiteralExpression,\n  AsExpression,\n  AwaitExpression,\n  BinaryExpression,\n  CallExpression,\n  ConditionalExpression,\n  Decorator,\n  DeleteExpression,\n  ElementAccessExpression,\n  Identifier,\n  MetaProperty,\n  ModifierFlags,\n  NewExpression,\n  NodeArray,\n  NonNullExpression,\n  ObjectLiteralElementLike,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PostfixUnaryExpression,\n  PrefixUnaryExpression,\n  PropertyAccessExpression,\n  PropertyAssignment,\n  ShorthandPropertyAssignment,\n  SpreadAssignment,\n  SuperExpression,\n  SyntaxKind,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  TemplateSpan,\n  ThisExpression,\n  TypeAssertion,\n  TypeOfExpression,\n  VoidExpression,\n  YieldExpression,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $EnvRec,\n} from '../types/environment-record.js';\nimport {\n  $AbstractRelationalComparison,\n  $InstanceOfOperator,\n  $AbstractEqualityComparison,\n  $StrictEqualityComparison,\n  $Call,\n  $Construct,\n  $CreateDataProperty,\n  $Set,\n  $CopyDataProperties,\n} from '../operations.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $Any,\n  $AnyNonEmpty,\n  $AnyObject,\n} from '../types/_shared.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Reference,\n} from '../types/reference.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Null,\n} from '../types/null.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $Empty,\n  empty,\n} from '../types/empty.js';\nimport {\n  $IteratorRecord,\n  $IteratorStep,\n  $IteratorValue,\n} from '../globals/iteration.js';\nimport {\n  $TypeError,\n  $Error,\n  $ReferenceError,\n} from '../types/error.js';\nimport {\n  $ArrayExoticObject,\n} from '../exotics/array.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  I$Node,\n  Context,\n  modifiersToModifierFlags,\n  hasBit,\n  $identifier,\n  $$PropertyName,\n  $$AssignmentExpressionOrHigher,\n  $$propertyName,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$LHSExpressionOrHigher,\n  $NodeWithDecorators,\n  $LHSExpression,\n  $LHSExpressionNode,\n  $AnyParentNode,\n  $ArgumentOrArrayLiteralElementNode,\n  IsConstructor,\n  $$UnaryExpressionOrHigher,\n  $unaryExpression,\n  $UnaryExpressionNode,\n  $$BinaryExpressionOrHigher,\n  $BinaryExpressionNode,\n  $$UpdateExpressionOrHigher,\n  $UpdateExpressionNode,\n  $i,\n} from './_shared.js';\nimport {\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $SpreadElement,\n  $OmittedExpression,\n} from './bindings.js';\nimport {\n  $MethodDeclaration,\n  $GetAccessorDeclaration,\n  $SetAccessorDeclaration,\n} from './methods.js';\nimport {\n  $NoSubstitutionTemplateLiteral,\n  $TemplateSpan,\n  $TemplateHead,\n} from './literals.js';\nimport {\n  $FunctionExpression,\n} from './functions.js';\n\nexport class $Decorator implements I$Node {\n  public get $kind(): SyntaxKind.Decorator { return SyntaxKind.Decorator; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n\n  public constructor(\n    public readonly node: Decorator,\n    public readonly parent: $NodeWithDecorators,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.Decorator`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n  }\n}\n\n// #region LHS\n\nexport class $ThisExpression implements I$Node {\n  public get $kind(): SyntaxKind.ThisKeyword { return SyntaxKind.ThisKeyword; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $ThisExpression = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: ThisExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ThisExpression`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-this-keyword-runtime-semantics-evaluation\n  // 12.2.2.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // PrimaryExpression : this\n\n    // 1. Return ? ResolveThisBinding().\n    return realm.ResolveThisBinding().enrichWith(ctx, this);\n  }\n}\n\nexport class $SuperExpression implements I$Node {\n  public get $kind(): SyntaxKind.SuperKeyword { return SyntaxKind.SuperKeyword; }\n\n  public constructor(\n    public readonly node: SuperExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.SuperExpression`,\n  ) {}\n\n  // http://www.ecma-international.org/ecma-262/#sec-super-keyword-runtime-semantics-evaluation\n  // 12.3.5.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // SuperProperty : super [ Expression ]\n\n    // 1. Let env be GetThisEnvironment().\n    // 2. Let actualThis be ? env.GetThisBinding().\n    // 3. Let propertyNameReference be the result of evaluating Expression.\n    // 4. Let propertyNameValue be ? GetValue(propertyNameReference).\n    // 5. Let propertyKey be ? ToPropertyKey(propertyNameValue).\n    // 6. If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be false.\n    // 7. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).\n\n    // SuperProperty : super . IdentifierName\n\n    // 1. Let env be GetThisEnvironment().\n    // 2. Let actualThis be ? env.GetThisBinding().\n    // 3. Let propertyKey be StringValue of IdentifierName.\n    // 4. If the code matched by this SuperProperty is strict mode code, let strict be true, else let strict be false.\n    // 5. Return ? MakeSuperPropertyReference(actualThis, propertyKey, strict).\n\n    // SuperCall : super Arguments\n\n    // 1. Let newTarget be GetNewTarget().\n    // 2. Assert: Type(newTarget) is Object.\n    // 3. Let func be ? GetSuperConstructor().\n    // 4. Let argList be ArgumentListEvaluation of Arguments.\n    // 5. ReturnIfAbrupt(argList).\n    // 6. Let result be ? Construct(func, argList, newTarget).\n    // 7. Let thisER be GetThisEnvironment().\n    // 8. Return ? thisER.BindThisValue(result).\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport type $NodeWithSpreadElements = (\n  $ArrayLiteralExpression |\n  $CallExpression |\n  $NewExpression\n);\n\nexport type $$ArgumentOrArrayLiteralElement = (\n  $$AssignmentExpressionOrHigher |\n  $SpreadElement |\n  $OmittedExpression\n);\n\nexport function $argumentOrArrayLiteralElement(\n  node: $ArgumentOrArrayLiteralElementNode,\n  parent: $NodeWithSpreadElements,\n  ctx: Context,\n  idx: number,\n): $$ArgumentOrArrayLiteralElement {\n  switch (node.kind) {\n    case SyntaxKind.SpreadElement:\n      return new $SpreadElement(node, parent, ctx, idx);\n    case SyntaxKind.OmittedExpression:\n      return new $OmittedExpression(node, parent, ctx, idx);\n    default:\n      return $assignmentExpression(node, parent, ctx, idx);\n  }\n}\n\nexport function $argumentOrArrayLiteralElementList(\n  nodes: readonly $ArgumentOrArrayLiteralElementNode[] | undefined,\n  parent: $NodeWithSpreadElements,\n  ctx: Context,\n): readonly $$ArgumentOrArrayLiteralElement[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $$ArgumentOrArrayLiteralElement[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = $argumentOrArrayLiteralElement(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\nexport class $ArrayLiteralExpression implements I$Node {\n  public get $kind(): SyntaxKind.ArrayLiteralExpression { return SyntaxKind.ArrayLiteralExpression; }\n\n  public readonly $elements: readonly $$ArgumentOrArrayLiteralElement[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $ArrayLiteralExpression = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: ArrayLiteralExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ArrayLiteralExpression`,\n  ) {\n    this.$elements = $argumentOrArrayLiteralElementList(node.elements as NodeArray<$ArgumentOrArrayLiteralElementNode>, this, ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-arrayaccumulation\n  // 12.2.5.2 Runtime Semantics: ArrayAccumulation\n  public AccumulateArray(\n    ctx: ExecutionContext,\n    array: $ArrayExoticObject,\n    nextIndex: $Number,\n  ): $Number | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const elements = this.$elements;\n    let el: $$ArgumentOrArrayLiteralElement;\n    let padding = 0;\n    let postIndex = intrinsics['0'] as $Number;\n\n    for (let i = 0, ii = elements.length; i < ii; ++i) {\n      el = elements[i];\n\n      switch (el.$kind) {\n        case SyntaxKind.OmittedExpression: {\n          ++padding;\n          break;\n        }\n        case SyntaxKind.SpreadElement: {\n          // ElementList : Elision opt SpreadElement\n\n          // 1. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n          // 2. Return the result of performing ArrayAccumulation for SpreadElement with arguments array and nextIndex + padding.\n\n          // ElementList : ElementList , Elision opt SpreadElement\n\n          // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.\n          // 2. ReturnIfAbrupt(postIndex).\n          // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n          // 4. Return the result of performing ArrayAccumulation for SpreadElement with arguments array and postIndex + padding.\n\n          const $postIndex = el.AccumulateArray(ctx, array, new $Number(realm, postIndex['[[Value]]'] + padding));\n          if ($postIndex.isAbrupt) { return $postIndex.enrichWith(ctx, this); }\n          postIndex = $postIndex;\n\n          padding = 0;\n          break;\n        }\n        default: {\n          // ElementList : Elision opt AssignmentExpression\n\n          // 1. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n          // 2. Let initResult be the result of evaluating AssignmentExpression.\n          // 3. Let initValue be ? GetValue(initResult).\n          // 4. Let created be CreateDataProperty(array, ToString(ToUint32(nextIndex + padding)), initValue).\n          // 5. Assert: created is true.\n          // 6. Return nextIndex + padding + 1.\n\n          // ElementList : ElementList , Elision opt AssignmentExpression\n\n          // 1. Let postIndex be the result of performing ArrayAccumulation for ElementList with arguments array and nextIndex.\n          // 2. ReturnIfAbrupt(postIndex).\n          // 3. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n          // 4. Let initResult be the result of evaluating AssignmentExpression.\n          const initResult = el.Evaluate(ctx);\n\n          // 5. Let initValue be ? GetValue(initResult).\n          const initValue = initResult.GetValue(ctx);\n          if (initValue.isAbrupt) { return initValue.enrichWith(ctx, this); }\n\n          // 6. Let created be CreateDataProperty(array, ToString(ToUint32(postIndex + padding)), initValue).\n          const created = $CreateDataProperty(ctx, array, new $Number(realm, postIndex['[[Value]]'] + padding).ToUint32(ctx).ToString(ctx), initValue) as $Boolean;\n\n          // 7. Assert: created is true.\n          // 8. Return postIndex + padding + 1.\n          postIndex = new $Number(realm, postIndex['[[Value]]'] + padding + 1);\n\n          padding = 0;\n          break;\n        }\n      }\n    }\n\n    return postIndex;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-array-initializer-runtime-semantics-evaluation\n  // 12.2.5.3 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $ArrayExoticObject | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // ArrayLiteral : [ Elision opt ]\n\n    // 1. Let array be ! ArrayCreate(0).\n    // 2. Let pad be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n    // 3. Perform Set(array, \"length\", ToUint32(pad), false).\n    // 4. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.\n    // 5. Return array.\n\n    // ArrayLiteral : [ ElementList ]\n\n    // 1. Let array be ! ArrayCreate(0).\n    const array = new $ArrayExoticObject(realm, intrinsics['0']);\n\n    // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.\n    const len = this.AccumulateArray(ctx, array, intrinsics['0']);\n\n    // 3. ReturnIfAbrupt(len).\n    if (len.isAbrupt) { return len.enrichWith(ctx, this); }\n\n    // 4. Perform Set(array, \"length\", ToUint32(len), false).\n    $Set(ctx, array, intrinsics.length, len.ToUint32(ctx), intrinsics.false);\n\n    // 5. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.\n    // 6. Return array.\n    return array;\n\n    // ArrayLiteral : [ ElementList , Elision opt ]\n\n    // 1. Let array be ! ArrayCreate(0).\n    // 2. Let len be the result of performing ArrayAccumulation for ElementList with arguments array and 0.\n    // 3. ReturnIfAbrupt(len).\n    // 4. Let padding be the ElisionWidth of Elision; if Elision is not present, use the numeric value zero.\n    // 5. Perform Set(array, \"length\", ToUint32(padding + len), false).\n    // 6. NOTE: The above Set cannot fail because of the nature of the object returned by ArrayCreate.\n    // 7. Return array.\n  }\n}\n\nexport type $$ObjectLiteralElementLike = (\n  $PropertyAssignment |\n  $ShorthandPropertyAssignment |\n  $SpreadAssignment |\n  $MethodDeclaration |\n  $GetAccessorDeclaration |\n  $SetAccessorDeclaration\n);\n\nexport function $$objectLiteralElementLikeList(\n  nodes: readonly ObjectLiteralElementLike[],\n  parent: $ObjectLiteralExpression,\n  ctx: Context,\n): readonly $$ObjectLiteralElementLike[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $$ObjectLiteralElementLike[] = Array(len);\n  let el: ObjectLiteralElementLike;\n\n  for (let i = 0; i < len; ++i) {\n    el = nodes[i];\n    switch (el.kind) {\n      case SyntaxKind.PropertyAssignment:\n        $nodes[i] = new $PropertyAssignment(el, parent, ctx, i);\n        break;\n      case SyntaxKind.ShorthandPropertyAssignment:\n        $nodes[i] = new $ShorthandPropertyAssignment(el, parent, ctx, i);\n        break;\n      case SyntaxKind.SpreadAssignment:\n        $nodes[i] = new $SpreadAssignment(el, parent, ctx, i);\n        break;\n      case SyntaxKind.MethodDeclaration:\n        $nodes[i] = new $MethodDeclaration(el, parent, ctx, i);\n        break;\n      case SyntaxKind.GetAccessor:\n        $nodes[i] = new $GetAccessorDeclaration(el, parent, ctx, i);\n        break;\n      case SyntaxKind.SetAccessor:\n        $nodes[i] = new $SetAccessorDeclaration(el, parent, ctx, i);\n        break;\n    }\n  }\n  return $nodes;\n}\n\nexport class $ObjectLiteralExpression implements I$Node {\n  public get $kind(): SyntaxKind.ObjectLiteralExpression { return SyntaxKind.ObjectLiteralExpression; }\n\n  public readonly $properties: readonly $$ObjectLiteralElementLike[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $ObjectLiteralExpression = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: ObjectLiteralExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ObjectLiteralExpression`,\n  ) {\n    this.$properties = $$objectLiteralElementLikeList(node.properties, this, ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation\n  // 12.2.6.7 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Object | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // ObjectLiteral : { }\n\n    // 1. Return ObjectCreate(%ObjectPrototype%).\n\n    // ObjectLiteral : { PropertyDefinitionList } { PropertyDefinitionList , }\n\n    // 1. Let obj be ObjectCreate(%ObjectPrototype%).\n    const obj = $Object.ObjectCreate(ctx, 'Object', intrinsics['%ObjectPrototype%']);\n\n    // 2. Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.\n    for (const prop of this.$properties) {\n      const $PropertyDefinitionEvaluationResult = prop.EvaluatePropertyDefinition(ctx, obj, intrinsics.true);\n      if ($PropertyDefinitionEvaluationResult.isAbrupt) { return $PropertyDefinitionEvaluationResult.enrichWith(ctx, this); }\n    }\n\n    // 3. Return obj.\n    return obj;\n  }\n}\n\nexport class $PropertyAssignment implements I$Node {\n  public get $kind(): SyntaxKind.PropertyAssignment { return SyntaxKind.PropertyAssignment; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $$PropertyName;\n  public readonly $initializer: $$AssignmentExpressionOrHigher;\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: $String | $Empty;\n\n  public constructor(\n    public readonly node: PropertyAssignment,\n    public readonly parent: $ObjectLiteralExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.PropertyAssignment`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    const $name = this.$name = $$propertyName(node.name, this, ctx | Context.IsMemberName, -1);\n    this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.PropName = $name.PropName;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation\n  // 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation\n  public EvaluatePropertyDefinition(\n    ctx: ExecutionContext,\n    object: $Object,\n    enumerable: $Boolean,\n  ): $Boolean | $Error {\n    ctx.checkTimeout();\n\n    // PropertyDefinition :\n    //     PropertyName : AssignmentExpression\n\n    // 1. Let propKey be the result of evaluating PropertyName.\n    const propKey = this.$name.EvaluatePropName(ctx);\n\n    // 2. ReturnIfAbrupt(propKey).\n    if (propKey.isAbrupt) { return propKey.enrichWith(ctx, this); }\n\n    let propValue: $AnyNonEmpty;\n\n    // 3. If IsAnonymousFunctionDefinition(AssignmentExpression) is true, then\n    if (this.$initializer instanceof $FunctionExpression && !this.$initializer.HasName) {\n      // 3. a. Let propValue be the result of performing NamedEvaluation for AssignmentExpression with argument propKey.\n      const $propValue = this.$initializer.EvaluateNamed(ctx, propKey);\n      if ($propValue.isAbrupt) { return $propValue.enrichWith(ctx, this); }\n\n      propValue = $propValue;\n    }\n    // 4. Else,\n    else {\n      // 4. a. Let exprValueRef be the result of evaluating AssignmentExpression.\n      const exprValueRef = this.$initializer.Evaluate(ctx);\n\n      // 4. b. Let propValue be ? GetValue(exprValueRef).\n      const $propValue = exprValueRef.GetValue(ctx);\n      if ($propValue.isAbrupt) { return $propValue.enrichWith(ctx, this); }\n\n      propValue = $propValue;\n    }\n\n    // 5. Assert: enumerable is true.\n    // 6. Assert: object is an ordinary, extensible object with no non-configurable properties.\n    // 7. Return ! CreateDataPropertyOrThrow(object, propKey, propValue).\n    return $CreateDataProperty(ctx, object, propKey, propValue);\n  }\n}\n\nexport class $ShorthandPropertyAssignment implements I$Node {\n  public get $kind(): SyntaxKind.ShorthandPropertyAssignment { return SyntaxKind.ShorthandPropertyAssignment; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $Identifier;\n  public readonly $objectAssignmentInitializer: $$AssignmentExpressionOrHigher | undefined;\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: $String;\n\n  public constructor(\n    public readonly node: ShorthandPropertyAssignment,\n    public readonly parent: $ObjectLiteralExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ShorthandPropertyAssignment`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n    this.$objectAssignmentInitializer = $assignmentExpression(node.objectAssignmentInitializer as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.PropName = $name.PropName;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation\n  // 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation\n  public EvaluatePropertyDefinition(\n    ctx: ExecutionContext,\n    object: $Object,\n    enumerable: $Boolean,\n  ): $Boolean | $Error {\n    ctx.checkTimeout();\n\n    // PropertyDefinition :\n    //     IdentifierReference\n\n    // 1. Let propName be StringValue of IdentifierReference.\n    const propName = this.$name.StringValue;\n\n    // 2. Let exprValue be the result of evaluating IdentifierReference.\n    const exprValue = this.$name.Evaluate(ctx);\n\n    // 3. Let propValue be ? GetValue(exprValue).\n    const propValue = exprValue.GetValue(ctx);\n    if (propValue.isAbrupt) { return propValue.enrichWith(ctx, this); }\n\n    // 4. Assert: enumerable is true.\n    // 5. Assert: object is an ordinary, extensible object with no non-configurable properties.\n    // 6. Return ! CreateDataPropertyOrThrow(object, propName, propValue).\n    return $CreateDataProperty(ctx, object, propName, propValue);\n  }\n}\n\nexport class $SpreadAssignment implements I$Node {\n  public get $kind(): SyntaxKind.SpreadAssignment { return SyntaxKind.SpreadAssignment; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: empty = empty;\n\n  public constructor(\n    public readonly node: SpreadAssignment,\n    public readonly parent: $ObjectLiteralExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.SpreadAssignment`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation\n  // 12.2.6.8 Runtime Semantics: PropertyDefinitionEvaluation\n  public EvaluatePropertyDefinition<T extends $AnyObject>(\n    ctx: ExecutionContext,\n    object: T,\n    enumerable: $Boolean,\n  ): T | $Error {\n    ctx.checkTimeout();\n\n    // PropertyDefinition :\n    //     ... AssignmentExpression\n\n    // 1. Let exprValue be the result of evaluating AssignmentExpression.\n    const exprValue = this.$expression.Evaluate(ctx);\n\n    // 2. Let fromValue be ? GetValue(exprValue).\n    const fromValue = exprValue.GetValue(ctx);\n    if (fromValue.isAbrupt) { return fromValue.enrichWith(ctx, this); }\n\n    // 3. Let excludedNames be a new empty List.\n    const excludedNames: $String[] = [];\n\n    // 4. Return ? CopyDataProperties(object, fromValue, excludedNames).\n    return $CopyDataProperties(ctx, object, fromValue, excludedNames);\n  }\n}\n\nexport class $PropertyAccessExpression implements I$Node {\n  public get $kind(): SyntaxKind.PropertyAccessExpression { return SyntaxKind.PropertyAccessExpression; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n  public readonly $name: $Identifier;\n\n  public constructor(\n    public readonly node: PropertyAccessExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.PropertyAccessExpression`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n    // @ts-ignore - TODO(fkleuver): update AOT to use new TS 3.8 ast\n    this.$name = $identifier(node.name, this, ctx | Context.IsPropertyAccessName, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-property-accessors-runtime-semantics-evaluation\n  // 12.3.2.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Reference | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // MemberExpression : MemberExpression . IdentifierName\n\n    // 1. Let baseReference be the result of evaluating MemberExpression.\n    const baseReference = this.$expression.Evaluate(ctx);\n\n    // 2. Let baseValue be ? GetValue(baseReference).\n    const baseValue = baseReference.GetValue(ctx);\n    if (baseValue.isAbrupt) { return baseValue.enrichWith(ctx, this); }\n\n    // 3. baseValue bv be ? RequireObjectCoercible(baseValue).\n    if (baseValue.isNil) { return new $TypeError(realm, `Cannot access property ${this.$name.StringValue['[[Value]]']} on value: ${baseValue['[[Value]]']}`).enrichWith(ctx, this); }\n\n    // 4. Let propertyNameString be StringValue of IdentifierName.\n    const propertyNameString = this.$name.StringValue;\n\n    // 5. If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be false.\n    const strict = intrinsics.true; // TODO: use static semantics\n\n    // 6. Return a value of type Reference whose base value component is bv, whose referenced name component is propertyNameString, and whose strict reference flag is strict.\n    return new $Reference(realm, baseValue, propertyNameString, strict, intrinsics.undefined);\n  }\n}\n\nexport class $ElementAccessExpression implements I$Node {\n  public get $kind(): SyntaxKind.ElementAccessExpression { return SyntaxKind.ElementAccessExpression; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n  public readonly $argumentExpression: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: ElementAccessExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ElementAccessExpression`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n    this.$argumentExpression = $assignmentExpression(node.argumentExpression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-property-accessors-runtime-semantics-evaluation\n  // 12.3.2.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Reference | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // MemberExpression : MemberExpression [ Expression ]\n\n    // 1. Let baseReference be the result of evaluating MemberExpression.\n    const baseReference = this.$expression.Evaluate(ctx);\n\n    // 2. Let baseValue be ? GetValue(baseReference).\n    const baseValue = baseReference.GetValue(ctx);\n    if (baseValue.isAbrupt) { return baseValue.enrichWith(ctx, this); }\n\n    // 3. Let propertyNameReference be the result of evaluating Expression.\n    const propertyNameReference = this.$argumentExpression.Evaluate(ctx);\n\n    // 4. Let propertyNameValue be ? GetValue(propertyNameReference).\n    const propertyNameValue = propertyNameReference.GetValue(ctx);\n    if (propertyNameValue.isAbrupt) { return propertyNameValue.enrichWith(ctx, this); }\n\n    // 5. Let bv be ? RequireObjectCoercible(baseValue).\n    if (baseValue.isNil) { return new $TypeError(realm, `Cannot access computed / indexed property on value: ${baseValue['[[Value]]']}`).enrichWith(ctx, this); }\n\n    // 6. Let propertyKey be ? ToPropertyKey(propertyNameValue).\n    const propertyKey = propertyNameValue.ToPropertyKey(ctx);\n    if (propertyKey.isAbrupt) { return propertyKey.enrichWith(ctx, this); }\n\n    // 7. If the code matched by this MemberExpression is strict mode code, let strict be true, else let strict be false.\n    const strict = intrinsics.true; // TODO: use static semantics\n\n    // 8. Return a value of type Reference whose base value component is bv, whose referenced name component is propertyKey, and whose strict reference flag is strict.\n    return new $Reference(realm, baseValue, propertyKey, strict, intrinsics.undefined);\n  }\n}\n\nexport class $CallExpression implements I$Node {\n  public get $kind(): SyntaxKind.CallExpression { return SyntaxKind.CallExpression; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n  public readonly $arguments: readonly $$ArgumentOrArrayLiteralElement[];\n\n  public constructor(\n    public readonly node: CallExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.CallExpression`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n    this.$arguments = $argumentOrArrayLiteralElementList(node.arguments as NodeArray<$ArgumentOrArrayLiteralElementNode>, this, ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-calls-runtime-semantics-evaluation\n  // 12.3.4.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // CallExpression : CoverCallExpressionAndAsyncArrowHead\n\n    // 1. Let expr be CoveredCallExpression of CoverCallExpressionAndAsyncArrowHead.\n    // 2. Let memberExpr be the MemberExpression of expr.\n    const memberExpr = this.$expression;\n\n    // 3. Let arguments be the Arguments of expr.\n    const $arguments = this.$arguments;\n\n    // 4. Let ref be the result of evaluating memberExpr.\n    const ref = memberExpr.Evaluate(ctx);\n\n    // 5. Let func be ? GetValue(ref).\n    const func = ref.GetValue(ctx);\n    if (func.isAbrupt) { return func.enrichWith(ctx, this); }\n\n    // 6. If Type(ref) is Reference and IsPropertyReference(ref) is false and GetReferencedName(ref) is \"eval\", then\n    if (ref instanceof $Reference && ref.IsPropertyReference().isFalsey && ref.GetReferencedName()['[[Value]]'] === 'eval') {\n      // 6. a. If SameValue(func, %eval%) is true, then\n      if (func.is(intrinsics['%eval%'])) { // TODO\n        // 6. a. i. Let argList be ? ArgumentListEvaluation of arguments.\n\n        // 6. a. ii. If argList has no elements, return undefined.\n        // 6. a. iii. Let evalText be the first element of argList.\n        // 6. a. iv. If the source code matching this CallExpression is strict mode code, let strictCaller be true. Otherwise let strictCaller be false.\n        // 6. a. v. Let evalRealm be the current Realm Record.\n        // 6. a. vi. Perform ? HostEnsureCanCompileStrings(evalRealm, evalRealm).\n        // 6. a. vii. Return ? PerformEval(evalText, evalRealm, strictCaller, true).\n      }\n    }\n\n    // 7. Let thisCall be this CallExpression.\n    const thisCall = this;\n\n    // 8. Let tailCall be IsInTailPosition(thisCall).\n    // TODO\n\n    // 9. Return ? EvaluateCall(func, ref, arguments, tailCall).\n    return $EvaluateCall(ctx, func, ref as $Any, $arguments, intrinsics.false).enrichWith(ctx, this);\n\n    // CallExpression : CallExpression Arguments\n\n    // 1. Let ref be the result of evaluating CallExpression.\n    // 2. Let func be ? GetValue(ref).\n    // 3. Let thisCall be this CallExpression.\n    // 4. Let tailCall be IsInTailPosition(thisCall).\n    // 5. Return ? EvaluateCall(func, ref, Arguments, tailCall).\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-evaluatecall\nexport function $EvaluateCall(\n  ctx: ExecutionContext,\n  func: $AnyNonEmpty,\n  ref: $Any,\n  $arguments: readonly $$ArgumentOrArrayLiteralElement[],\n  tailPosition: $Boolean,\n): $AnyNonEmpty  {\n  ctx.checkTimeout();\n\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  let thisValue: $AnyNonEmpty;\n\n  // 1. If Type(ref) is Reference, then\n  if (ref instanceof $Reference) {\n    // 1. a. If IsPropertyReference(ref) is true, then\n    if (ref.IsPropertyReference().isTruthy) {\n      // 1. a. i. Let thisValue be GetThisValue(ref).\n      thisValue = ref.GetThisValue();\n    }\n    // 1. b. Else the base of ref is an Environment Record,\n    else {\n      // 1. b. i. Let refEnv be GetBase(ref).\n      const refEnv = ref.GetBase() as $EnvRec;\n\n      // 1. b. ii. Let thisValue be refEnv.WithBaseObject().\n      thisValue = refEnv.WithBaseObject(ctx);\n    }\n  }\n  // 2. Else Type(ref) is not Reference,\n  else {\n    // 2. a. Let thisValue be undefined.\n    thisValue = intrinsics.undefined;\n  }\n\n  // 3. Let argList be ArgumentListEvaluation of arguments.\n  const argList = $ArgumentListEvaluation(ctx, $arguments);\n\n  // 4. ReturnIfAbrupt(argList).\n  if (argList.isAbrupt) { return argList; }\n\n  // 5. If Type(func) is not Object, throw a TypeError exception.\n  // 6. If IsCallable(func) is false, throw a TypeError exception.\n  if (!func.isFunction) {\n    return new $TypeError(realm, `${func} is not callable`);\n  }\n\n  // 7. If tailPosition is true, perform PrepareForTailCall().\n  // TODO\n\n  // 8. Let result be Call(func, thisValue, argList).\n  const result = $Call(ctx, func as $Function, thisValue, argList);\n\n  // 9. Assert: If tailPosition is true, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.\n  // 10. Assert: If result is not an abrupt completion, then Type(result) is an ECMAScript language type.\n  // 11. Return result.\n  return result;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-argument-lists-runtime-semantics-argumentlistevaluation\nexport function $ArgumentListEvaluation(\n  ctx: ExecutionContext,\n  args: readonly $$ArgumentOrArrayLiteralElement[],\n): $List<$AnyNonEmpty> | $Error {\n  ctx.checkTimeout();\n\n  // Arguments : ( )\n\n  // 1. Return a new empty List.\n\n  // ArgumentList : AssignmentExpression\n\n  // 1. Let ref be the result of evaluating AssignmentExpression.\n  // 2. Let arg be ? GetValue(ref).\n  // 3. Return a List whose sole item is arg.\n\n  // ArgumentList : ... AssignmentExpression // TODO\n\n  // 1. Let list be a new empty List.\n  // 2. Let spreadRef be the result of evaluating AssignmentExpression.\n  // 3. Let spreadObj be ? GetValue(spreadRef).\n  // 4. Let iteratorRecord be ? GetIterator(spreadObj).\n  // 5. Repeat,\n    // 5. a. Let next be ? IteratorStep(iteratorRecord).\n    // 5. b. If next is false, return list.\n    // 5. c. Let nextArg be ? IteratorValue(next).\n    // 5. d. Append nextArg as the last element of list.\n\n  // ArgumentList : ArgumentList , AssignmentExpression\n\n  // 1. Let precedingArgs be ArgumentListEvaluation of ArgumentList.\n  // 2. ReturnIfAbrupt(precedingArgs).\n  // 3. Let ref be the result of evaluating AssignmentExpression.\n  // 4. Let arg be ? GetValue(ref).\n  // 5. Append arg to the end of precedingArgs.\n  // 6. Return precedingArgs.\n  const list = new $List<$AnyNonEmpty>();\n  for (const arg of args) {\n    const ref = arg.Evaluate(ctx);\n    if (ref.isAbrupt) {\n      return ref;\n    }\n    const value = ref.GetValue(ctx);\n    if (value.isAbrupt) {\n      return value;\n    }\n    if (value.isList) {\n      list.push(...value);\n    } else {\n      list.push(value);\n    }\n  }\n  return list;\n\n  // ArgumentList : ArgumentList , ... AssignmentExpression // TODO\n\n  // 1. Let precedingArgs be ArgumentListEvaluation of ArgumentList.\n  // 2. ReturnIfAbrupt(precedingArgs).\n  // 3. Let spreadRef be the result of evaluating AssignmentExpression.\n  // 4. Let iteratorRecord be ? GetIterator(? GetValue(spreadRef)).\n  // 5. Repeat,\n    // 5. a. Let next be ? IteratorStep(iteratorRecord).\n    // 5. b. If next is false, return precedingArgs.\n    // 5. c. Let nextArg be ? IteratorValue(next).\n    // 5. d. Append nextArg as the last element of precedingArgs.\n\n}\n\nexport class $NewExpression implements I$Node {\n  public get $kind(): SyntaxKind.NewExpression { return SyntaxKind.NewExpression; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n  public readonly $arguments: readonly $$ArgumentOrArrayLiteralElement[];\n\n  public constructor(\n    public readonly node: NewExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.NewExpression`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n    this.$arguments = $argumentOrArrayLiteralElementList(node.arguments as NodeArray<$ArgumentOrArrayLiteralElementNode>, this, ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-new-operator-runtime-semantics-evaluation\n  // 12.3.3.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // NewExpression : new NewExpression\n\n    // 1. Return ? EvaluateNew(NewExpression, empty).\n\n    // MemberExpression : new MemberExpression Arguments\n\n    // 1. Return ? EvaluateNew(MemberExpression, Arguments).\n\n    // http://www.ecma-international.org/ecma-262/#sec-evaluatenew\n    // 12.3.3.1.1 Runtime Semantics: EvaluateNew ( constructExpr , arguments )\n\n    // 1. Assert: constructExpr is either a NewExpression or a MemberExpression.\n    // 2. Assert: arguments is either empty or an Arguments.\n    // 3. Let ref be the result of evaluating constructExpr.\n    const ref = this.$expression.Evaluate(ctx);\n\n    // 4. Let constructor be ? GetValue(ref).\n    const constructor = ref.GetValue(ctx);\n    if (constructor.isAbrupt) { return constructor.enrichWith(ctx, this); }\n\n    const $arguments = this.$arguments;\n    let argList: $List<$AnyNonEmpty>;\n    // 5. If arguments is empty, let argList be a new empty List.\n    if ($arguments.length === 0) {\n      argList = new $List<$AnyNonEmpty>();\n    }\n    // 6. Else,\n    else {\n      // 6. a. Let argList be ArgumentListEvaluation of arguments.\n      const $argList = $ArgumentListEvaluation(ctx, $arguments);\n      // 6. b. ReturnIfAbrupt(argList).\n      if ($argList.isAbrupt) { return $argList.enrichWith(ctx, this); }\n      argList = $argList;\n    }\n    // 7. If IsConstructor(constructor) is false, throw a TypeError exception.\n    if (!IsConstructor(ctx, constructor)) {\n      return new $TypeError(realm, `${constructor} is not a constructor`);\n    }\n    // 8. Return ? Construct(constructor, argList).\n    return $Construct(ctx, constructor, argList, intrinsics.undefined).enrichWith(ctx, this);\n  }\n}\n\nexport type $$TemplateLiteral = (\n  $NoSubstitutionTemplateLiteral |\n  $TemplateExpression\n);\n\nexport class $TaggedTemplateExpression implements I$Node {\n  public get $kind(): SyntaxKind.TaggedTemplateExpression { return SyntaxKind.TaggedTemplateExpression; }\n\n  public readonly $tag: $$LHSExpressionOrHigher;\n  public readonly $template: $$TemplateLiteral;\n\n  public constructor(\n    public readonly node: TaggedTemplateExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TaggedTemplateExpression`,\n  ) {\n    this.$tag = $LHSExpression(node.tag as $LHSExpressionNode, this, ctx, -1);\n\n    if (node.template.kind === SyntaxKind.NoSubstitutionTemplateLiteral) {\n      this.$template = new $NoSubstitutionTemplateLiteral(node.template, this, ctx, -1);\n    } else {\n      this.$template = new $TemplateExpression(node.template, this, ctx, -1);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-tagged-templates-runtime-semantics-evaluation\n  // 12.3.7.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // MemberExpression : MemberExpression TemplateLiteral\n\n    // 1. Let tagRef be the result of evaluating MemberExpression.\n    // 2. Let tagFunc be ? GetValue(tagRef).\n    // 3. Let thisCall be this MemberExpression.\n    // 4. Let tailCall be IsInTailPosition(thisCall).\n    // 5. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).\n\n    // CallExpression : CallExpression TemplateLiteral\n\n    // 1. Let tagRef be the result of evaluating CallExpression.\n    // 2. Let tagFunc be ? GetValue(tagRef).\n    // 3. Let thisCall be this CallExpression.\n    // 4. Let tailCall be IsInTailPosition(thisCall).\n    // 5. Return ? EvaluateCall(tagFunc, tagRef, TemplateLiteral, tailCall).\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport function $$templateSpanList(\n  nodes: readonly TemplateSpan[],\n  parent: $TemplateExpression,\n  ctx: Context,\n): readonly $TemplateSpan[] {\n  if (nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $TemplateSpan[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $TemplateSpan(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\nexport class $TemplateExpression implements I$Node {\n  public get $kind(): SyntaxKind.TemplateExpression { return SyntaxKind.TemplateExpression; }\n\n  public readonly $head: $TemplateHead;\n  public readonly $templateSpans: readonly $TemplateSpan[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $TemplateExpression = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-assignmenttargettype\n  // 12.2.1.5 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'invalid' = 'invalid';\n\n  public constructor(\n    public readonly node: TemplateExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TemplateExpression`,\n  ) {\n    this.$head = new $TemplateHead(node.head, this, ctx);\n    this.$templateSpans = $$templateSpanList(node.templateSpans, this, ctx);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-template-literals-runtime-semantics-evaluation\n  // 12.2.9.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $String {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // SubstitutionTemplate : TemplateHead Expression TemplateSpans\n\n    // 1. Let head be the TV of TemplateHead as defined in 11.8.6.\n    // 2. Let subRef be the result of evaluating Expression.\n    // 3. Let sub be ? GetValue(subRef).\n    // 4. Let middle be ? ToString(sub).\n    // 5. Let tail be the result of evaluating TemplateSpans.\n    // 6. ReturnIfAbrupt(tail).\n    // 7. Return the string-concatenation of head, middle, and tail.\n\n    // TemplateSpans : TemplateTail\n\n    // 1. Let tail be the TV of TemplateTail as defined in 11.8.6.\n    // 2. Return the String value consisting of the code units of tail.\n\n    // TemplateSpans : TemplateMiddleList TemplateTail\n\n    // 1. Let head be the result of evaluating TemplateMiddleList.\n    // 2. ReturnIfAbrupt(head).\n    // 3. Let tail be the TV of TemplateTail as defined in 11.8.6.\n    // 4. Return the string-concatenation of head and tail.\n\n    // TemplateMiddleList : TemplateMiddle Expression\n\n    // 1. Let head be the TV of TemplateMiddle as defined in 11.8.6.\n    // 2. Let subRef be the result of evaluating Expression.\n    // 3. Let sub be ? GetValue(subRef).\n    // 4. Let middle be ? ToString(sub).\n    // 5. Return the sequence of code units consisting of the code units of head followed by the elements of middle.\n\n    // TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression\n\n    // 1. Let rest be the result of evaluating TemplateMiddleList.\n    // 2. ReturnIfAbrupt(rest).\n    // 3. Let middle be the TV of TemplateMiddle as defined in 11.8.6.\n    // 4. Let subRef be the result of evaluating Expression.\n    // 5. Let sub be ? GetValue(subRef).\n    // 6. Let last be ? ToString(sub).\n    // 7. Return the sequence of code units consisting of the elements of rest followed by the code units of middle followed by the elements of last.\n    return intrinsics['']; // TODO: implement this\n  }\n}\n\nexport class $ParenthesizedExpression implements I$Node {\n  public get $kind(): SyntaxKind.ParenthesizedExpression { return SyntaxKind.ParenthesizedExpression; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: ParenthesizedExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ParenthesizedExpression`,\n  ) {\n    const $expression = this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n\n    this.CoveredParenthesizedExpression = $expression;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-grouping-operator-runtime-semantics-evaluation\n  // 12.2.10.5 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty | $Reference | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList\n\n    // 1. Let expr be CoveredParenthesizedExpression of CoverParenthesizedExpressionAndArrowParameterList.\n    // 2. Return the result of evaluating expr.\n\n    // ParenthesizedExpression : ( Expression )\n\n    // 1. Return the result of evaluating Expression. This may be of type Reference.\n    return this.$expression.Evaluate(ctx).enrichWith(ctx, this);\n  }\n}\n\nexport class $NonNullExpression implements I$Node {\n  public get $kind(): SyntaxKind.NonNullExpression { return SyntaxKind.NonNullExpression; }\n\n  public readonly $expression: $$LHSExpressionOrHigher;\n\n  public constructor(\n    public readonly node: NonNullExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.NonNullExpression`,\n  ) {\n    this.$expression = $LHSExpression(node.expression as $LHSExpressionNode, this, ctx, -1);\n  }\n\n  // This is a TS expression that wraps an ordinary expression. Just return the evaluate result.\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty | $Reference | $Error {\n    ctx.checkTimeout();\n\n    return this.$expression.Evaluate(ctx).enrichWith(ctx, this);\n  }\n}\n\nexport class $MetaProperty implements I$Node {\n  public get $kind(): SyntaxKind.MetaProperty { return SyntaxKind.MetaProperty; }\n\n  public readonly $name: $Identifier;\n\n  public constructor(\n    public readonly node: MetaProperty,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.MetaProperty`,\n  ) {\n    this.$name = $identifier(node.name, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-meta-properties-runtime-semantics-evaluation\n  // 12.3.8.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // NewTarget : new . target\n\n    // 1. Return GetNewTarget().\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\n// #endregion\n\n// #region Unary\n\nexport class $DeleteExpression implements I$Node {\n  public get $kind(): SyntaxKind.DeleteExpression { return SyntaxKind.DeleteExpression; }\n\n  public readonly $expression: $$UnaryExpressionOrHigher;\n\n  public constructor(\n    public readonly node: DeleteExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.DeleteExpression`,\n  ) {\n    this.$expression = $unaryExpression(node.expression as $UnaryExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-delete-operator-runtime-semantics-evaluation\n  // 12.5.3.2 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Boolean {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // 1. Let ref be the result of evaluating UnaryExpression.\n    // 2. ReturnIfAbrupt(ref).\n    // 3. If Type(ref) is not Reference, return true.\n    // 4. If IsUnresolvableReference(ref) is true, then\n    // 4. a. Assert: IsStrictReference(ref) is false.\n    // 4. b. Return true.\n    // 5. If IsPropertyReference(ref) is true, then\n    // 5. a. If IsSuperReference(ref) is true, throw a ReferenceError exception.\n    // 5. b. Let baseObj be ! ToObject(GetBase(ref)).\n    // 5. c. Let deleteStatus be ? baseObj.[[Delete]](GetReferencedName(ref)).\n    // 5. d. If deleteStatus is false and IsStrictReference(ref) is true, throw a TypeError exception.\n    // 5. e. Return deleteStatus.\n    // 6. Else ref is a Reference to an Environment Record binding,\n    // 6. a. Let bindings be GetBase(ref).\n    // 6. b. Return ? bindings.DeleteBinding(GetReferencedName(ref)).\n\n    return intrinsics.true; // TODO: implement this\n  }\n}\n\nexport class $TypeOfExpression implements I$Node {\n  public get $kind(): SyntaxKind.TypeOfExpression { return SyntaxKind.TypeOfExpression; }\n\n  public readonly $expression: $$UnaryExpressionOrHigher;\n\n  public constructor(\n    public readonly node: TypeOfExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TypeOfExpression`,\n  ) {\n    this.$expression = $unaryExpression(node.expression as $UnaryExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-typeof-operator-runtime-semantics-evaluation\n  // 12.5.5.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $String | $Undefined | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // UnaryExpression : typeof UnaryExpression\n\n    // 1. Let val be the result of evaluating UnaryExpression.\n    let val = this.$expression.Evaluate(ctx);\n\n    // 2. If Type(val) is Reference, then\n    // 2. a. If IsUnresolvableReference(val) is true, return \"undefined\".\n    if (val instanceof $Reference && val.IsUnresolvableReference()['[[Value]]']) {\n      return new $Undefined(realm);\n    }\n    // 3. Set val to ? GetValue(val).\n    val = val.GetValue(ctx);\n    if (val.isAbrupt) { return val.enrichWith(ctx, this); }\n\n    // 4. Return a String according to Table 35.\n    // Table 35: typeof Operator Results\n    switch (true) {\n      // Type of val   Result\n      // Undefined   \t\"undefined\"\n      case val instanceof $Undefined:\n        return new $String(realm, \"undefined\");\n\n      // Boolean   \t  \"boolean\"\n      case val instanceof $Boolean:\n        return new $String(realm, \"boolean\");\n\n      // Number    \t  \"number\"\n      case val instanceof $Number:\n        return new $String(realm, \"number\");\n\n      // String    \t  \"string\"\n      case val instanceof $String:\n        return new $String(realm, \"string\");\n\n      // Symbol    \t  \"symbol\"\n      // case val instanceof $Symbol:\n      //   return new $String(realm, \"symbol\");\n\n      // Object        (implements [[Call]])\t\"function\"\n      case val instanceof $Function:\n        return new $String(realm, \"function\");\n\n      // Object        (ordinary and does not implement [[Call]])\t\"object\"\n      // Object        (standard exotic and does not implement [[Call]])\t\"object\"\n      // Object        (non-standard exotic and does not implement [[Call]])\tImplementation-defined. Must not be \"undefined\", \"boolean\", \"function\", \"number\", \"symbol\", or \"string\".\n      case val instanceof $Object:\n      // Null    \t    \"object\"\n      case val instanceof $Null:\n      default:\n        return new $String(realm, \"object\");\n    }\n  }\n}\n\nexport class $VoidExpression implements I$Node {\n  public get $kind(): SyntaxKind.VoidExpression { return SyntaxKind.VoidExpression; }\n\n  public readonly $expression: $$UnaryExpressionOrHigher;\n\n  public constructor(\n    public readonly node: VoidExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.VoidExpression`,\n  ) {\n    this.$expression = $unaryExpression(node.expression as $UnaryExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-void-operator\n  // 12.5.4 The void Operator\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // UnaryExpression : void UnaryExpression\n\n    // 1. Let expr be the result of evaluating UnaryExpression.\n    const expr = this.$expression.Evaluate(ctx);\n\n    // 2. Perform ? GetValue(expr).\n    const value = expr.GetValue(ctx);\n    if (value.isAbrupt) { return value.enrichWith(ctx, this); }\n\n    // 3. Return undefined.\n    return intrinsics.undefined;\n  }\n}\n\nexport class $AwaitExpression implements I$Node {\n  public get $kind(): SyntaxKind.AwaitExpression { return SyntaxKind.AwaitExpression; }\n\n  public readonly $expression: $$UnaryExpressionOrHigher;\n\n  public constructor(\n    public readonly node: AwaitExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.AwaitExpression`,\n  ) {\n    this.$expression = $unaryExpression(node.expression as $UnaryExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-runtime-semantics-evaluation\n  // 14.7.14 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // AwaitExpression : await UnaryExpression\n\n    // 1. Let exprRef be the result of evaluating UnaryExpression.\n    // 2. Let value be ? GetValue(exprRef).\n    // 3. Return ? Await(value).\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $PrefixUnaryExpression implements I$Node {\n  public get $kind(): SyntaxKind.PrefixUnaryExpression { return SyntaxKind.PrefixUnaryExpression; }\n\n  public readonly $operand: $$UnaryExpressionOrHigher;\n\n  public constructor(\n    public readonly node: PrefixUnaryExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.PrefixUnaryExpression`,\n  ) {\n    this.$operand = $unaryExpression(node.operand as $UnaryExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-prefix-increment-operator-runtime-semantics-evaluation\n  // 12.4.6.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-prefix-decrement-operator-runtime-semantics-evaluation\n  // 12.4.7.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-unary-plus-operator-runtime-semantics-evaluation\n  // 12.5.6.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-unary-minus-operator-runtime-semantics-evaluation\n  // 12.5.7.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    switch (this.node.operator) {\n      case SyntaxKind.PlusPlusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-prefix-increment-operator-runtime-semantics-evaluation\n        // 12.4.6.1 Runtime Semantics: Evaluation\n\n        // UpdateExpression : ++ UnaryExpression\n\n        // 1. Let expr be the result of evaluating UnaryExpression.\n        const expr = this.$operand.Evaluate(ctx);\n        if (expr.isAbrupt) { return expr.enrichWith(ctx, this); }\n\n        // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n        const $oldValue = expr.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToNumber(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).\n        const newValue = new $Number(realm, oldValue['[[Value]]'] + 1);\n\n        // 4. Perform ? PutValue(expr, newValue).\n        if (!(expr instanceof $Reference)) {\n          return new $ReferenceError(realm, `Value is not assignable: ${expr}`).enrichWith(ctx, this);\n        }\n        const $PutValueResult = expr.PutValue(ctx, newValue);\n        if ($PutValueResult.isAbrupt) { return $PutValueResult.enrichWith(ctx, this); }\n\n        // 5. Return newValue.\n        return newValue;\n      }\n      case SyntaxKind.MinusMinusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-prefix-decrement-operator-runtime-semantics-evaluation\n        // 12.4.7.1 Runtime Semantics: Evaluation\n\n        // UpdateExpression : -- UnaryExpression\n\n        // 1. Let expr be the result of evaluating UnaryExpression.\n        const expr = this.$operand.Evaluate(ctx);\n        if (expr.isAbrupt) { return expr.enrichWith(ctx, this); }\n\n        // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n        const $oldValue = expr.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToNumber(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n        const newValue = new $Number(realm, oldValue['[[Value]]'] - 1);\n\n        // 4. Perform ? PutValue(expr, newValue).\n        if (!(expr instanceof $Reference)) {\n          return new $ReferenceError(realm, `Value is not assignable: ${expr}`).enrichWith(ctx, this);\n        }\n        const $PutValueResult = expr.PutValue(ctx, newValue);\n        if ($PutValueResult.isAbrupt) { return $PutValueResult.enrichWith(ctx, this); }\n\n        // 5. Return newValue.\n        return newValue;\n      }\n      case SyntaxKind.PlusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-unary-plus-operator-runtime-semantics-evaluation\n        // 12.5.6.1 Runtime Semantics: Evaluation\n\n        // UnaryExpression : + UnaryExpression\n\n        // 1. Let expr be the result of evaluating UnaryExpression.\n        const expr = this.$operand.Evaluate(ctx);\n        if (expr.isAbrupt) { return expr.enrichWith(ctx, this); }\n\n        // 2. Return ? ToNumber(? GetValue(expr)).\n        const $value = expr.GetValue(ctx);\n        if ($value.isAbrupt) { return $value.enrichWith(ctx, this); }\n        const value = $value.ToNumber(ctx);\n        if (value.isAbrupt) { return value.enrichWith(ctx, this); }\n        return value;\n      }\n      case SyntaxKind.MinusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-unary-minus-operator-runtime-semantics-evaluation\n        // 12.5.7.1 Runtime Semantics: Evaluation\n\n        // UnaryExpression : - UnaryExpression\n\n        // 1. Let expr be the result of evaluating UnaryExpression.\n        const expr = this.$operand.Evaluate(ctx);\n        if (expr.isAbrupt) { return expr.enrichWith(ctx, this); }\n\n        // 2. Let oldValue be ? ToNumber(? GetValue(expr)).\n        const $oldValue = expr.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToNumber(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. If oldValue is NaN, return NaN.\n        if (oldValue.isNaN) {\n          return oldValue;\n        }\n\n        // 4. Return the result of negating oldValue; that is, compute a Number with the same magnitude but opposite sign.\n        return new $Number(realm, -oldValue['[[Value]]']);\n      }\n      case SyntaxKind.TildeToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-bitwise-not-operator-runtime-semantics-evaluation\n        // 12.5.8.1 Runtime Semantics: Evaluation\n\n        // UnaryExpression : ~ UnaryExpression\n\n        // 1. Let expr be the result of evaluating UnaryExpression.\n        const expr = this.$operand.Evaluate(ctx);\n        if (expr.isAbrupt) { return expr.enrichWith(ctx, this); }\n\n        // 2. Let oldValue be ? ToInt32(? GetValue(expr)).\n        const $oldValue = expr.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToInt32(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. Return the result of applying bitwise complement to oldValue. The result is a signed 32-bit integer.\n        return new $Number(realm, ~oldValue['[[Value]]']);\n      }\n      case SyntaxKind.ExclamationToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-logical-not-operator-runtime-semantics-evaluation\n        // 12.5.9.1 Runtime Semantics: Evaluation\n\n        // UnaryExpression : ! UnaryExpression\n\n        // 1. Let expr be the result of evaluating UnaryExpression.\n        const expr = this.$operand.Evaluate(ctx);\n        if (expr.isAbrupt) { return expr.enrichWith(ctx, this); }\n\n        // 2. Let oldValue be ToBoolean(? GetValue(expr)).\n        const $oldValue = expr.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToBoolean(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. If oldValue is true, return false.\n        if (oldValue.isTruthy) {\n          return intrinsics.false;\n        }\n\n        // 4. Return true.\n        return intrinsics.true;\n      }\n    }\n  }\n}\n\nexport class $PostfixUnaryExpression implements I$Node {\n  public get $kind(): SyntaxKind.PostfixUnaryExpression { return SyntaxKind.PostfixUnaryExpression; }\n\n  public readonly $operand: $$LHSExpressionOrHigher;\n\n  public constructor(\n    public readonly node: PostfixUnaryExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.PostfixUnaryExpression`,\n  ) {\n    this.$operand = $LHSExpression(node.operand as $LHSExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-postfix-increment-operator-runtime-semantics-evaluation\n  // 12.4.4.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-postfix-decrement-operator-runtime-semantics-evaluation\n  // 12.4.5.1 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    switch (this.node.operator) {\n      case SyntaxKind.PlusPlusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-postfix-increment-operator-runtime-semantics-evaluation\n        // 12.4.4.1 Runtime Semantics: Evaluation\n\n        // UpdateExpression : LeftHandSideExpression ++\n\n        // 1. Let lhs be the result of evaluating LeftHandSideExpression.\n        const lhs = this.$operand.Evaluate(ctx);\n\n        // 2. Let oldValue be ? ToNumber(? GetValue(lhs)).\n        const $oldValue = lhs.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToNumber(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. Let newValue be the result of adding the value 1 to oldValue, using the same rules as for the + operator (see 12.8.5).\n        const newValue = new $Number(realm, oldValue['[[Value]]'] + 1);\n\n        // 4. Perform ? PutValue(lhs, newValue).\n        if (!(lhs instanceof $Reference)) {\n          return new $ReferenceError(realm, `Value is not assignable: ${lhs}`).enrichWith(ctx, this);\n        }\n        const $PutValueResult = lhs.PutValue(ctx, newValue);\n        if ($PutValueResult.isAbrupt) { return $PutValueResult.enrichWith(ctx, this); }\n\n        // 5. Return oldValue.\n        return oldValue;\n      }\n      case SyntaxKind.MinusMinusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-postfix-decrement-operator-runtime-semantics-evaluation\n        // 12.4.5.1 Runtime Semantics: Evaluation\n\n        // UpdateExpression : LeftHandSideExpression --\n\n        // 1. Let lhs be the result of evaluating LeftHandSideExpression.\n        const lhs = this.$operand.Evaluate(ctx);\n\n        // 2. Let oldValue be ? ToNumber(? GetValue(lhs)).\n        const $oldValue = lhs.GetValue(ctx);\n        if ($oldValue.isAbrupt) { return $oldValue.enrichWith(ctx, this); }\n        const oldValue = $oldValue.ToNumber(ctx);\n        if (oldValue.isAbrupt) { return oldValue.enrichWith(ctx, this); }\n\n        // 3. Let newValue be the result of subtracting the value 1 from oldValue, using the same rules as for the - operator (see 12.8.5).\n        const newValue = new $Number(realm, oldValue['[[Value]]'] - 1);\n\n        // 4. Perform ? PutValue(lhs, newValue).\n        if (!(lhs instanceof $Reference)) {\n          return new $ReferenceError(realm, `Value is not assignable: ${lhs}`).enrichWith(ctx, this);\n        }\n        const $PutValueResult = lhs.PutValue(ctx, newValue);\n        if ($PutValueResult.isAbrupt) { return $PutValueResult.enrichWith(ctx, this); }\n\n        // 5. Return oldValue.\n        return oldValue;\n      }\n    }\n  }\n}\n\nexport class $TypeAssertion implements I$Node {\n  public get $kind(): SyntaxKind.TypeAssertionExpression { return SyntaxKind.TypeAssertionExpression; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: TypeAssertion,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.TypeAssertion`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // This is a TS expression that wraps an ordinary expression. Just return the evaluate result.\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty | $Reference | $Error {\n    ctx.checkTimeout();\n\n    return this.$expression.Evaluate(ctx);\n  }\n}\n\n// #endregion\n\n// #region Assignment\n\nexport class $BinaryExpression implements I$Node {\n  public get $kind(): SyntaxKind.BinaryExpression { return SyntaxKind.BinaryExpression; }\n\n  public readonly $left: $$BinaryExpressionOrHigher;\n  public readonly $right: $$BinaryExpressionOrHigher;\n\n  public constructor(\n    public readonly node: BinaryExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.BinaryExpression`,\n  ) {\n    this.$left = $assignmentExpression(node.left as $BinaryExpressionNode, this, ctx, -1) as $$BinaryExpressionOrHigher;\n    this.$right = $assignmentExpression(node.right as $BinaryExpressionNode, this, ctx, -1) as $$BinaryExpressionOrHigher;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-exp-operator-runtime-semantics-evaluation\n  // 12.6.3 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation\n  // 12.7.3 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-addition-operator-plus-runtime-semantics-evaluation\n  // 12.8.3.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-subtraction-operator-minus-runtime-semantics-evaluation\n  // 12.8.4.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-signed-right-shift-operator-runtime-semantics-evaluation\n  // 12.9.4.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-unsigned-right-shift-operator-runtime-semantics-evaluation\n  // 12.9.5.1 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-relational-operators-runtime-semantics-evaluation\n  // 12.10.3 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-equality-operators-runtime-semantics-evaluation\n  // 12.11.3 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation\n  // 12.12.3 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-binary-logical-operators-runtime-semantics-evaluation\n  // 12.13.3 Runtime Semantics: Evaluation\n  // http://www.ecma-international.org/ecma-262/#sec-assignment-operators-runtime-semantics-evaluation\n  // 12.15.4 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    switch (this.node.operatorToken.kind) {\n      case SyntaxKind.AsteriskAsteriskToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-exp-operator-runtime-semantics-evaluation\n        // 12.6.3 Runtime Semantics: Evaluation\n\n        // ExponentiationExpression : UpdateExpression ** ExponentiationExpression\n\n        // 1. Let left be the result of evaluating UpdateExpression.\n        const left = this.$left.Evaluate(ctx);\n\n        // 2. Let leftValue be ? GetValue(left).\n        const leftValue = left.GetValue(ctx);\n        if (leftValue.isAbrupt) { return leftValue.enrichWith(ctx, this); }\n\n        // 3. Let right be the result of evaluating ExponentiationExpression.\n        const right = this.$right.Evaluate(ctx);\n\n        // 4. Let rightValue be ? GetValue(right).\n        const rightValue = right.GetValue(ctx);\n        if (rightValue.isAbrupt) { return rightValue.enrichWith(ctx, this); }\n\n        // 5. Let base be ? ToNumber(leftValue).\n        const base = leftValue.ToNumber(ctx);\n        if (base.isAbrupt) { return base.enrichWith(ctx, this); }\n\n        // 6. Let exponent be ? ToNumber(rightValue).\n        const exponent = rightValue.ToNumber(ctx);\n        if (exponent.isAbrupt) { return exponent.enrichWith(ctx, this); }\n\n        // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.6.4.\n        return new $Number(realm, base['[[Value]]'] ** exponent['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.AsteriskToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation\n        // 12.7.3 Runtime Semantics: Evaluation\n\n        // MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression\n\n        // 1. Let left be the result of evaluating MultiplicativeExpression.\n        const left = this.$left.Evaluate(ctx);\n\n        // 2. Let leftValue be ? GetValue(left).\n        const leftValue = left.GetValue(ctx);\n        if (leftValue.isAbrupt) { return leftValue.enrichWith(ctx, this); }\n\n        // 3. Let right be the result of evaluating ExponentiationExpression.\n        const right = this.$right.Evaluate(ctx);\n\n        // 4. Let rightValue be ? GetValue(right).\n        const rightValue = right.GetValue(ctx);\n        if (rightValue.isAbrupt) { return rightValue.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToNumber(leftValue).\n        const lnum = leftValue.ToNumber(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToNumber(rightValue).\n        const rnum = rightValue.ToNumber(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.\n        return new $Number(realm, lnum['[[Value]]'] * rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.SlashToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation\n        // 12.7.3 Runtime Semantics: Evaluation\n\n        // MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression\n\n        // 1. Let left be the result of evaluating MultiplicativeExpression.\n        const left = this.$left.Evaluate(ctx);\n\n        // 2. Let leftValue be ? GetValue(left).\n        const leftValue = left.GetValue(ctx);\n        if (leftValue.isAbrupt) { return leftValue.enrichWith(ctx, this); }\n\n        // 3. Let right be the result of evaluating ExponentiationExpression.\n        const right = this.$right.Evaluate(ctx);\n\n        // 4. Let rightValue be ? GetValue(right).\n        const rightValue = right.GetValue(ctx);\n        if (rightValue.isAbrupt) { return rightValue.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToNumber(leftValue).\n        const lnum = leftValue.ToNumber(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToNumber(rightValue).\n        const rnum = rightValue.ToNumber(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.\n        return new $Number(realm, lnum['[[Value]]'] / rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.PercentToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-multiplicative-operators-runtime-semantics-evaluation\n        // 12.7.3 Runtime Semantics: Evaluation\n\n        // MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression\n\n        // 1. Let left be the result of evaluating MultiplicativeExpression.\n        const left = this.$left.Evaluate(ctx);\n\n        // 2. Let leftValue be ? GetValue(left).\n        const leftValue = left.GetValue(ctx);\n        if (leftValue.isAbrupt) { return leftValue.enrichWith(ctx, this); }\n\n        // 3. Let right be the result of evaluating ExponentiationExpression.\n        const right = this.$right.Evaluate(ctx);\n\n        // 4. Let rightValue be ? GetValue(right).\n        const rightValue = right.GetValue(ctx);\n        if (rightValue.isAbrupt) { return rightValue.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToNumber(leftValue).\n        const lnum = leftValue.ToNumber(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToNumber(rightValue).\n        const rnum = rightValue.ToNumber(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.\n        return new $Number(realm, lnum['[[Value]]'] % rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.PlusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-addition-operator-plus-runtime-semantics-evaluation\n        // 12.8.3.1 Runtime Semantics: Evaluation\n\n        // AdditiveExpression : AdditiveExpression + MultiplicativeExpression\n\n        // 1. Let lref be the result of evaluating AdditiveExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating MultiplicativeExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lprim be ? ToPrimitive(lval).\n        const lprim = lval.ToPrimitive(ctx);\n        if (lprim.isAbrupt) { return lprim.enrichWith(ctx, this); }\n\n        // 6. Let rprim be ? ToPrimitive(rval).\n        const rprim = rval.ToPrimitive(ctx);\n        if (rprim.isAbrupt) { return rprim.enrichWith(ctx, this); }\n\n        // 7. If Type(lprim) is String or Type(rprim) is String, then\n        if (lprim.isString || rprim.isString) {\n          // 7. a. Let lstr be ? ToString(lprim).\n          const lstr = lprim.ToString(ctx);\n          if (lstr.isAbrupt) { return lstr.enrichWith(ctx, this); }\n\n          // 7. b. Let rstr be ? ToString(rprim).\n          const rstr = rprim.ToString(ctx);\n          if (rstr.isAbrupt) { return rstr.enrichWith(ctx, this); }\n\n          // 7. c. Return the string-concatenation of lstr and rstr.\n          return new $String(realm, lstr['[[Value]]'] + rstr['[[Value]]']); // TODO: add temporal state snapshot for tracing\n        }\n\n        // 8. Let lnum be ? ToNumber(lprim).\n        const lnum = lprim.ToNumber(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 9. Let rnum be ? ToNumber(rprim).\n        const rnum = rprim.ToNumber(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 10. Return the result of applying the addition operation to lnum and rnum. See the Note below 12.8.5.\n        return new $Number(realm, lnum['[[Value]]'] + rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.MinusToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-subtraction-operator-minus-runtime-semantics-evaluation\n        // 12.8.4.1 Runtime Semantics: Evaluation\n\n        // AdditiveExpression : AdditiveExpression - MultiplicativeExpression\n\n        // 1. Let lref be the result of evaluating AdditiveExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating MultiplicativeExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToNumber(lval).\n        const lnum = lval.ToNumber(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToNumber(rval).\n        const rnum = rval.ToNumber(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the subtraction operation to lnum and rnum. See the note below 12.8.5.\n        return new $Number(realm, lnum['[[Value]]'] - rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.LessThanLessThanToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-left-shift-operator-runtime-semantics-evaluation\n        // 12.9.3.1 Runtime Semantics: Evaluation\n\n        // ShiftExpression : ShiftExpression << AdditiveExpression\n\n        // 1. Let lref be the result of evaluating ShiftExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating AdditiveExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToInt32(lval).\n        const lnum = lval.ToInt32(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToUint32(rval).\n        const rnum = rval.ToUint32(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\n        const shiftCount = rnum['[[Value]]'] & 0b11111;\n\n        // 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.\n        return new $Number(realm, lnum['[[Value]]'] << shiftCount); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.GreaterThanGreaterThanToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-signed-right-shift-operator-runtime-semantics-evaluation\n        // 12.9.4.1 Runtime Semantics: Evaluation\n\n        // ShiftExpression : ShiftExpression >> AdditiveExpression\n\n        // 1. Let lref be the result of evaluating ShiftExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating AdditiveExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToInt32(lval).\n        const lnum = lval.ToInt32(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToUint32(rval).\n        const rnum = rval.ToUint32(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\n        const shiftCount = rnum['[[Value]]'] & 0b11111;\n\n        // 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.\n        return new $Number(realm, lnum['[[Value]]'] >> shiftCount); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.GreaterThanGreaterThanGreaterThanToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-unsigned-right-shift-operator-runtime-semantics-evaluation\n        // 12.9.5.1 Runtime Semantics: Evaluation\n\n        // ShiftExpression : ShiftExpression >>> AdditiveExpression\n\n        // 1. Let lref be the result of evaluating ShiftExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating AdditiveExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToUint32(lval).\n        const lnum = lval.ToUint32(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToUint32(rval).\n        const rnum = rval.ToUint32(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\n        const shiftCount = rnum['[[Value]]'] & 0b11111;\n\n        // 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.\n        return new $Number(realm, lnum['[[Value]]'] >>> shiftCount); // TODO: add temporal state snapshot for tracing\n      }\n      // http://www.ecma-international.org/ecma-262/#sec-relational-operators-runtime-semantics-evaluation\n      // 12.10.3 Runtime Semantics: Evaluation\n      case SyntaxKind.LessThanToken: {\n        // RelationalExpression : RelationalExpression < ShiftExpression\n\n        // 1. Let lref be the result of evaluating RelationalExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating ShiftExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let r be the result of performing Abstract Relational Comparison lval < rval.\n        const r = $AbstractRelationalComparison(ctx, true, lval, rval);\n\n        // 6. ReturnIfAbrupt(r).\n        if (r.isAbrupt) { return r.enrichWith(ctx, this); }\n\n        // 7. If r is undefined, return false. Otherwise, return r.\n        return r.isUndefined ? intrinsics.false : r;\n      }\n      case SyntaxKind.GreaterThanToken: {\n        // RelationalExpression : RelationalExpression > ShiftExpression\n\n        // 1. Let lref be the result of evaluating RelationalExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating ShiftExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.\n        const r = $AbstractRelationalComparison(ctx, false, rval, lval);\n\n        // 6. ReturnIfAbrupt(r).\n        if (r.isAbrupt) { return r.enrichWith(ctx, this); }\n\n        // 7. If r is undefined, return false. Otherwise, return r.\n        return r.isUndefined ? intrinsics.false : r;\n      }\n      case SyntaxKind.LessThanEqualsToken: {\n        // RelationalExpression : RelationalExpression <= ShiftExpression\n\n        // 1. Let lref be the result of evaluating RelationalExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating ShiftExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let r be the result of performing Abstract Relational Comparison rval < lval with LeftFirst equal to false.\n        const r = $AbstractRelationalComparison(ctx, false, rval, lval);\n\n        // 6. ReturnIfAbrupt(r).\n        if (r.isAbrupt) { return r.enrichWith(ctx, this); }\n\n        // 7. If r is true or undefined, return false. Otherwise, return true.\n        return r.isTruthy || r.isUndefined ? intrinsics.false : intrinsics.true;\n      }\n      case SyntaxKind.GreaterThanEqualsToken: {\n        // RelationalExpression : RelationalExpression >= ShiftExpression\n\n        // 1. Let lref be the result of evaluating RelationalExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating ShiftExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let r be the result of performing Abstract Relational Comparison lval < rval.\n        const r = $AbstractRelationalComparison(ctx, true, lval, rval);\n\n        // 6. ReturnIfAbrupt(r).\n        if (r.isAbrupt) { return r.enrichWith(ctx, this); }\n\n        // 7. If r is true or undefined, return false. Otherwise, return true.\n        return r.isTruthy || r.isUndefined ? intrinsics.false : intrinsics.true;\n      }\n      case SyntaxKind.InstanceOfKeyword: {\n        // RelationalExpression : RelationalExpression instanceof ShiftExpression\n\n        // 1. Let lref be the result of evaluating RelationalExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating ShiftExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Return ? InstanceofOperator(lval, rval).\n        return $InstanceOfOperator(ctx, lval, rval).enrichWith(ctx, this);\n      }\n      case SyntaxKind.InKeyword: {\n        // RelationalExpression : RelationalExpression in ShiftExpression\n\n        // 1. Let lref be the result of evaluating RelationalExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating ShiftExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. If Type(rval) is not Object, throw a TypeError exception.\n        if (!rval.isObject) {\n          return new $TypeError(realm, `Right-hand side of 'in' keyword is not an object: ${rval}`);\n        }\n\n        // 6. Return ? HasProperty(rval, ToPropertyKey(lval)).\n        return rval['[[HasProperty]]'](ctx, lval.ToPropertyKey(ctx) as $String).enrichWith(ctx, this); // TODO: is this cast safe?\n      }\n      // http://www.ecma-international.org/ecma-262/#sec-equality-operators-runtime-semantics-evaluation\n      // 12.11.3 Runtime Semantics: Evaluation\n      case SyntaxKind.EqualsEqualsToken: {\n        // EqualityExpression : EqualityExpression == RelationalExpression\n\n        // 1. Let lref be the result of evaluating EqualityExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating RelationalExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Return the result of performing Abstract Equality Comparison rval == lval.\n        return $AbstractEqualityComparison(ctx, rval, lval).enrichWith(ctx, this);\n      }\n      case SyntaxKind.ExclamationEqualsToken: {\n        // EqualityExpression : EqualityExpression != RelationalExpression\n\n        // 1. Let lref be the result of evaluating EqualityExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating RelationalExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let r be the result of performing Abstract Equality Comparison rval == lval.\n        const r = $AbstractEqualityComparison(ctx, rval, lval);\n        if (r.isAbrupt) { return r.enrichWith(ctx, this); } // TODO: is this correct? spec doesn't say it\n\n        // 6. If r is true, return false. Otherwise, return true.\n        return r.isTruthy ? intrinsics.false : intrinsics.true;\n      }\n      case SyntaxKind.EqualsEqualsEqualsToken: {\n        // EqualityExpression : EqualityExpression === RelationalExpression\n\n        // 1. Let lref be the result of evaluating EqualityExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating RelationalExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Return the result of performing Strict Equality Comparison rval === lval.\n        return $StrictEqualityComparison(ctx, rval, lval).enrichWith(ctx, this);\n      }\n      case SyntaxKind.ExclamationEqualsEqualsToken: {\n        // EqualityExpression : EqualityExpression !== RelationalExpression\n\n        // 1. Let lref be the result of evaluating EqualityExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating RelationalExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let r be the result of performing Strict Equality Comparison rval === lval.\n        const r = $StrictEqualityComparison(ctx, rval, lval);\n        if (r.isAbrupt) { return r.enrichWith(ctx, this); } // TODO: is this correct? spec doesn't say it\n\n        // 6. If r is true, return false. Otherwise, return true.\n        return r.isTruthy ? intrinsics.false : intrinsics.true;\n      }\n      case SyntaxKind.AmpersandToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation\n        // 12.12.3 Runtime Semantics: Evaluation\n\n        // 1. Let lref be the result of evaluating A.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating B.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToInt32(lval).\n        const lnum = lval.ToInt32(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToInt32(rval).\n        const rnum = rval.ToInt32(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.\n        return new $Number(realm, lnum['[[Value]]'] & rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.CaretToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation\n        // 12.12.3 Runtime Semantics: Evaluation\n\n        // 1. Let lref be the result of evaluating A.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating B.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToInt32(lval).\n        const lnum = lval.ToInt32(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToInt32(rval).\n        const rnum = rval.ToInt32(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.\n        return new $Number(realm, lnum['[[Value]]'] ^ rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      case SyntaxKind.BarToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-binary-bitwise-operators-runtime-semantics-evaluation\n        // 12.12.3 Runtime Semantics: Evaluation\n\n        // 1. Let lref be the result of evaluating A.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating B.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let lnum be ? ToInt32(lval).\n        const lnum = lval.ToInt32(ctx);\n        if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n        // 6. Let rnum be ? ToInt32(rval).\n        const rnum = rval.ToInt32(ctx);\n        if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n        // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.\n        return new $Number(realm, lnum['[[Value]]'] | rnum['[[Value]]']); // TODO: add temporal state snapshot for tracing\n      }\n      // http://www.ecma-international.org/ecma-262/#sec-binary-logical-operators-runtime-semantics-evaluation\n      // 12.13.3 Runtime Semantics: Evaluation\n      case SyntaxKind.AmpersandAmpersandToken: {\n\n        // LogicalANDExpression : LogicalANDExpression && BitwiseORExpression\n\n        // 1. Let lref be the result of evaluating LogicalANDExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let lbool be ToBoolean(lval).\n        const lbool = lval.ToBoolean(ctx);\n        if (lbool.isAbrupt) { return lbool.enrichWith(ctx, this); } // TODO: is this correct? spec doesn't say it\n\n        // 4. If lbool is false, return lval.\n        if (lbool.isFalsey) {\n          return lval;\n        }\n\n        // 5. Let rref be the result of evaluating BitwiseORExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 6. Return ? GetValue(rref).\n        return rref.GetValue(ctx);\n      }\n      case SyntaxKind.BarBarToken: {\n        // LogicalORExpression : LogicalORExpression || LogicalANDExpression\n\n        // 1. Let lref be the result of evaluating LogicalORExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let lbool be ToBoolean(lval).\n        const lbool = lval.ToBoolean(ctx);\n        if (lbool.isAbrupt) { return lbool.enrichWith(ctx, this); } // TODO: is this correct? spec doesn't say it\n\n        // 4. If lbool is true, return lval.\n        if (lbool.isTruthy) {\n          return lval;\n        }\n\n        // 5. Let rref be the result of evaluating LogicalANDExpression.\n        const rref = this.$right.Evaluate(ctx);\n\n        // 6. Return ? GetValue(rref).\n        return rref.GetValue(ctx);\n      }\n      case SyntaxKind.EqualsToken: {\n        // http://www.ecma-international.org/ecma-262/#sec-assignment-operators-runtime-semantics-evaluation\n        // 12.15.4 Runtime Semantics: Evaluation\n\n        // AssignmentExpression : LeftHandSideExpression = AssignmentExpression\n\n        const lhs = this.$left;\n        const assign = this.$right;\n\n        // 1. If LeftHandSideExpression is neither an ObjectLiteral nor an ArrayLiteral, then\n        if (!(lhs instanceof $ObjectLiteralExpression || lhs instanceof $ArrayLiteralExpression)) {\n          // 1. a. Let lref be the result of evaluating LeftHandSideExpression.\n          const lref = lhs.Evaluate(ctx);\n\n          // 1. b. ReturnIfAbrupt(lref).\n          if (lref.isAbrupt) { return lref.enrichWith(ctx, this); }\n\n          let rval: $AnyNonEmpty;\n          // 1. c. If IsAnonymousFunctionDefinition(AssignmentExpression) and IsIdentifierRef of LeftHandSideExpression are both true, then\n          if (assign instanceof $FunctionExpression && !assign.HasName && lref instanceof $Identifier) {\n            // 1. c. i. Let rval be the result of performing NamedEvaluation for AssignmentExpression with argument GetReferencedName(lref).\n            rval = (lref as $Reference).GetReferencedName();\n          }\n          // 1. d. Else,\n          else {\n            // 1. d. i. Let rref be the result of evaluating AssignmentExpression.\n            const rref = assign.Evaluate(ctx);\n\n            // 1. d. ii. Let rval be ? GetValue(rref).\n            const $rval = rref.GetValue(ctx);\n            if ($rval.isAbrupt) { return $rval.enrichWith(ctx, this); }\n            rval = $rval;\n          }\n\n          // 1. e. Perform ? PutValue(lref, rval).\n          if (!(lref instanceof $Reference)) {\n            return new $ReferenceError(realm, `Value is not assignable: ${lref}`).enrichWith(ctx, this);\n          }\n          const $PutValueResult = lref.PutValue(ctx, rval);\n          if ($PutValueResult.isAbrupt) { return $PutValueResult.enrichWith(ctx, this); }\n\n          // 1. f. Return rval.\n          return rval;\n        }\n\n        // 2. Let assignmentPattern be the AssignmentPattern that is covered by LeftHandSideExpression.\n        // 3. Let rref be the result of evaluating AssignmentExpression.\n        const rref = assign.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const $rval = rref.GetValue(ctx);\n        if ($rval.isAbrupt) { return $rval.enrichWith(ctx, this); }\n        const rval = $rval;\n\n        // 5. Perform ? DestructuringAssignmentEvaluation of assignmentPattern using rval as the argument.\n        // TODO\n\n        // 6. Return rval.\n        return rval;\n      }\n      case SyntaxKind.CommaToken: {\n        // 1. Let lref be the result of evaluating LeftHandSideExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating AssignmentExpression.\n        const rref = this.$left.Evaluate(ctx);\n\n        // 4. Return ? GetValue(rref)\n        return rref.GetValue(ctx).enrichWith(ctx, this);\n      }\n      case SyntaxKind.QuestionQuestionToken: {\n        const lref = this.$left.Evaluate(ctx);\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        if (lval.isNil) {\n          const rref = this.$right.Evaluate(ctx);\n          return rref.GetValue(ctx).enrichWith(ctx, this);\n        }\n\n        return lval;\n      }\n      case SyntaxKind.AsteriskAsteriskEqualsToken:\n      case SyntaxKind.AsteriskEqualsToken:\n      case SyntaxKind.SlashEqualsToken:\n      case SyntaxKind.PercentEqualsToken:\n      case SyntaxKind.PlusEqualsToken:\n      case SyntaxKind.MinusEqualsToken:\n      case SyntaxKind.LessThanLessThanEqualsToken:\n      case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n      case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n      case SyntaxKind.AmpersandEqualsToken:\n      case SyntaxKind.CaretEqualsToken:\n      case SyntaxKind.BarEqualsToken: {\n        // AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression\n\n        // 1. Let lref be the result of evaluating LeftHandSideExpression.\n        const lref = this.$left.Evaluate(ctx);\n\n        // 2. Let lval be ? GetValue(lref).\n        const lval = lref.GetValue(ctx);\n        if (lval.isAbrupt) { return lval.enrichWith(ctx, this); }\n\n        // 3. Let rref be the result of evaluating AssignmentExpression.\n        const rref = this.$left.Evaluate(ctx);\n\n        // 4. Let rval be ? GetValue(rref).\n        const rval = rref.GetValue(ctx);\n        if (rval.isAbrupt) { return rval.enrichWith(ctx, this); }\n\n        // 5. Let op be the @ where AssignmentOperator is @=.\n\n        // 6. Let r be the result of applying op to lval and rval as if evaluating the expression lval op rval.\n        let r: $AnyNonEmpty;\n        switch (this.node.operatorToken.kind) {\n          case SyntaxKind.AsteriskAsteriskEqualsToken: {\n            // 5. Let base be ? ToNumber(leftValue).\n            const base = lval.ToNumber(ctx);\n            if (base.isAbrupt) { return base.enrichWith(ctx, this); }\n\n            // 6. Let exponent be ? ToNumber(rightValue).\n            const exponent = rval.ToNumber(ctx);\n            if (exponent.isAbrupt) { return exponent.enrichWith(ctx, this); }\n\n            // 7. Return the result of Applying the ** operator with base and exponent as specified in 12.6.4.\n            r = new $Number(realm, base['[[Value]]'] ** exponent['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.AsteriskEqualsToken: {\n            // 5. Let lnum be ? ToNumber(leftValue).\n            const lnum = lval.ToNumber(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToNumber(rightValue).\n            const rnum = rval.ToNumber(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.\n            r = new $Number(realm, lnum['[[Value]]'] * rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.SlashEqualsToken: {\n            // 5. Let lnum be ? ToNumber(leftValue).\n            const lnum = lval.ToNumber(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToNumber(rightValue).\n            const rnum = rval.ToNumber(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.\n            r = new $Number(realm, lnum['[[Value]]'] / rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.PercentEqualsToken: {\n            // 5. Let lnum be ? ToNumber(leftValue).\n            const lnum = lval.ToNumber(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToNumber(rightValue).\n            const rnum = rval.ToNumber(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the MultiplicativeOperator (*, /, or %) to lnum and rnum as specified in 12.7.3.1, 12.7.3.2, or 12.7.3.3.\n            r = new $Number(realm, lnum['[[Value]]'] % rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.PlusEqualsToken: {\n\n            // 5. Let lprim be ? ToPrimitive(lval).\n            const lprim = lval.ToPrimitive(ctx);\n            if (lprim.isAbrupt) { return lprim.enrichWith(ctx, this); }\n\n            // 6. Let rprim be ? ToPrimitive(rval).\n            const rprim = rval.ToPrimitive(ctx);\n            if (rprim.isAbrupt) { return rprim.enrichWith(ctx, this); }\n\n            // 7. If Type(lprim) is String or Type(rprim) is String, then\n            if (lprim.isString || rprim.isString) {\n              // 7. a. Let lstr be ? ToString(lprim).\n              const lstr = lprim.ToString(ctx);\n              if (lstr.isAbrupt) { return lstr.enrichWith(ctx, this); }\n\n              // 7. b. Let rstr be ? ToString(rprim).\n              const rstr = rprim.ToString(ctx);\n              if (rstr.isAbrupt) { return rstr.enrichWith(ctx, this); }\n\n              // 7. c. Return the string-concatenation of lstr and rstr.\n              r = new $String(realm, lstr['[[Value]]'] + rstr['[[Value]]']);\n              break;\n            }\n\n            // 8. Let lnum be ? ToNumber(lprim).\n            const lnum = lprim.ToNumber(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 9. Let rnum be ? ToNumber(rprim).\n            const rnum = rprim.ToNumber(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 10. Return the result of applying the addition operation to lnum and rnum. See the Note below 12.8.5.\n            r = new $Number(realm, lnum['[[Value]]'] + rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.MinusEqualsToken: {\n            // 5. Let lnum be ? ToNumber(lval).\n            const lnum = lval.ToNumber(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToNumber(rval).\n            const rnum = rval.ToNumber(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the subtraction operation to lnum and rnum. See the note below 12.8.5.\n            r = new $Number(realm, lnum['[[Value]]'] - rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.LessThanLessThanEqualsToken: {\n            // 5. Let lnum be ? ToInt32(lval).\n            const lnum = lval.ToInt32(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToUint32(rval).\n            const rnum = rval.ToUint32(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\n            const shiftCount = rnum['[[Value]]'] & 0b11111;\n\n            // 8. Return the result of left shifting lnum by shiftCount bits. The result is a signed 32-bit integer.\n            r = new $Number(realm, lnum['[[Value]]'] << shiftCount);\n            break;\n          }\n          case SyntaxKind.GreaterThanGreaterThanEqualsToken: {\n            // 5. Let lnum be ? ToInt32(lval).\n            const lnum = lval.ToInt32(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToUint32(rval).\n            const rnum = rval.ToUint32(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\n            const shiftCount = rnum['[[Value]]'] & 0b11111;\n\n            // 8. Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.\n            r = new $Number(realm, lnum['[[Value]]'] >> shiftCount);\n            break;\n          }\n          case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken: {\n            // 5. Let lnum be ? ToUint32(lval).\n            const lnum = lval.ToUint32(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToUint32(rval).\n            const rnum = rval.ToUint32(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum & 0x1F.\n            const shiftCount = rnum['[[Value]]'] & 0b11111;\n\n            // 8. Return the result of performing a zero-filling right shift of lnum by shiftCount bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.\n            r = new $Number(realm, lnum['[[Value]]'] >>> shiftCount);\n            break;\n          }\n          case SyntaxKind.AmpersandEqualsToken: {\n            // 5. Let lnum be ? ToInt32(lval).\n            const lnum = lval.ToInt32(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToInt32(rval).\n            const rnum = rval.ToInt32(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.\n            r = new $Number(realm, lnum['[[Value]]'] & rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.CaretEqualsToken: {\n            // 5. Let lnum be ? ToInt32(lval).\n            const lnum = lval.ToInt32(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToInt32(rval).\n            const rnum = rval.ToInt32(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.\n            r = new $Number(realm, lnum['[[Value]]'] ^ rnum['[[Value]]']);\n            break;\n          }\n          case SyntaxKind.BarEqualsToken: {\n            // 5. Let lnum be ? ToInt32(lval).\n            const lnum = lval.ToInt32(ctx);\n            if (lnum.isAbrupt) { return lnum.enrichWith(ctx, this); }\n\n            // 6. Let rnum be ? ToInt32(rval).\n            const rnum = rval.ToInt32(ctx);\n            if (rnum.isAbrupt) { return rnum.enrichWith(ctx, this); }\n\n            // 7. Return the result of applying the bitwise operator @ to lnum and rnum. The result is a signed 32-bit integer.\n            r = new $Number(realm, lnum['[[Value]]'] | rnum['[[Value]]']);\n            break;\n          }\n        }\n\n        // 7. Perform ? PutValue(lref, r).\n        if (!(lref instanceof $Reference)) {\n          return new $ReferenceError(realm, `Value is not assignable: ${lref}`).enrichWith(ctx, this);\n        }\n        const $PutValueResult = lref.PutValue(ctx, r);\n        if ($PutValueResult.isAbrupt) { return $PutValueResult.enrichWith(ctx, this); }\n\n        // 8. Return r.\n        return r;\n      }\n      default:\n        throw new Error(`SyntaxKind ${this.node.operatorToken.kind} not yet implemented`);\n    }\n  }\n}\n\nexport class $ConditionalExpression implements I$Node {\n  public get $kind(): SyntaxKind.ConditionalExpression { return SyntaxKind.ConditionalExpression; }\n\n  public readonly $condition: $$BinaryExpressionOrHigher;\n  public readonly $whenTrue: $$AssignmentExpressionOrHigher;\n  public readonly $whenFalse: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: ConditionalExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ConditionalExpression`,\n  ) {\n    if (node.condition.kind === SyntaxKind.BinaryExpression) {\n      this.$condition = new $BinaryExpression(node.condition as BinaryExpression, this, ctx, -1);\n    } else {\n      this.$condition = $unaryExpression(node.condition as $UnaryExpressionNode, this, ctx, -1);\n    }\n\n    this.$whenTrue = $assignmentExpression(node.whenTrue as $AssignmentExpressionNode, this, ctx, -1);\n    this.$whenFalse = $assignmentExpression(node.whenFalse as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-conditional-operator-runtime-semantics-evaluation\n  // 12.14.3 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression\n\n    // 1. Let lref be the result of evaluating LogicalORExpression.\n    // 2. Let lval be ToBoolean(? GetValue(lref)).\n    // 3. If lval is true, then\n    // 3. a. Let trueRef be the result of evaluating the first AssignmentExpression.\n    // 3. b. Return ? GetValue(trueRef).\n    // 4. Else,\n    // 4. a. Let falseRef be the result of evaluating the second AssignmentExpression.\n    // 4. b. Return ? GetValue(falseRef).\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $YieldExpression implements I$Node {\n  public get $kind(): SyntaxKind.YieldExpression { return SyntaxKind.YieldExpression; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: YieldExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.YieldExpression`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-evaluation\n  // 14.4.14 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // YieldExpression : yield\n\n    // 1. Let generatorKind be ! GetGeneratorKind().\n    // 2. If generatorKind is async, then return ? AsyncGeneratorYield(undefined).\n    // 3. Otherwise, return ? GeneratorYield(CreateIterResultObject(undefined, false)).\n\n    // YieldExpression : yield AssignmentExpression\n\n    // 1. Let generatorKind be ! GetGeneratorKind().\n    // 2. Let exprRef be the result of evaluating AssignmentExpression.\n    // 3. Let value be ? GetValue(exprRef).\n    // 4. If generatorKind is async, then return ? AsyncGeneratorYield(value).\n    // 5. Otherwise, return ? GeneratorYield(CreateIterResultObject(value, false)).\n\n    // YieldExpression : yield * AssignmentExpression\n\n    // 1. Let generatorKind be ! GetGeneratorKind().\n    // 2. Let exprRef be the result of evaluating AssignmentExpression.\n    // 3. Let value be ? GetValue(exprRef).\n    // 4. Let iteratorRecord be ? GetIterator(value, generatorKind).\n    // 5. Let iterator be iteratorRecord.[[Iterator]].\n    // 6. Let received be NormalCompletion(undefined).\n    // 7. Repeat,\n    // 7. a. If received.[[Type]] is normal, then\n    // 7. a. i. Let innerResult be ? Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]], « received.[[Value]] »).\n    // 7. a. ii. If generatorKind is async, then set innerResult to ? Await(innerResult).\n    // 7. a. iii. If Type(innerResult) is not Object, throw a TypeError exception.\n    // 7. a. iv. Let done be ? IteratorComplete(innerResult).\n    // 7. a. v. If done is true, then\n    // 7. a. v. 1. Return ? IteratorValue(innerResult).\n    // 7. a. vi. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).\n    // 7. a. vii. Else, set received to GeneratorYield(innerResult).\n    // 7. b. Else if received.[[Type]] is throw, then\n    // 7. b. i. Let throw be ? GetMethod(iterator, \"throw\").\n    // 7. b. ii. If throw is not undefined, then\n    // 7. b. ii. 1. Let innerResult be ? Call(throw, iterator, « received.[[Value]] »).\n    // 7. b. ii. 2. If generatorKind is async, then set innerResult to ? Await(innerResult).\n    // 7. b. ii. 3. NOTE: Exceptions from the inner iterator throw method are propagated. Normal completions from an inner throw method are processed similarly to an inner next.\n    // 7. b. ii. 4. If Type(innerResult) is not Object, throw a TypeError exception.\n    // 7. b. ii. 5. Let done be ? IteratorComplete(innerResult).\n    // 7. b. ii. 6. If done is true, then\n    // 7. b. ii. 6. a. Return ? IteratorValue(innerResult).\n    // 7. b. ii. 7. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerResult)).\n    // 7. b. ii. 8. Else, set received to GeneratorYield(innerResult).\n    // 7. b. iii. Else,\n    // 7. b. iii. 1. NOTE: If iterator does not have a throw method, this throw is going to terminate the yield* loop. But first we need to give iterator a chance to clean up.\n    // 7. b. iii. 2. Let closeCompletion be Completion { [[Type]]: normal, [[Value]]: empty, [[Target]]: empty }.\n    // 7. b. iii. 3. If generatorKind is async, perform ? AsyncIteratorClose(iteratorRecord, closeCompletion).\n    // 7. b. iii. 4. Else, perform ? IteratorClose(iteratorRecord, closeCompletion).\n    // 7. b. iii. 5. NOTE: The next step throws a TypeError to indicate that there was a yield* protocol violation: iterator does not have a throw method.\n    // 7. b. iii. 6. Throw a TypeError exception.\n    // 7. c. Else,\n    // 7. c. i. Assert: received.[[Type]] is return.\n    // 7. c. ii. Let return be ? GetMethod(iterator, \"return\").\n    // 7. c. iii. If return is undefined, then\n    // 7. c. iii. 1. If generatorKind is async, then set received.[[Value]] to ? Await(received.[[Value]]).\n    // 7. c. iii. 2. Return Completion(received).\n    // 7. c. iv. Let innerReturnResult be ? Call(return, iterator, « received.[[Value]] »).\n    // 7. c. v. If generatorKind is async, then set innerReturnResult to ? Await(innerReturnResult).\n    // 7. c. vi. If Type(innerReturnResult) is not Object, throw a TypeError exception.\n    // 7. c. vii. Let done be ? IteratorComplete(innerReturnResult).\n    // 7. c. viii. If done is true, then\n    // 7. c. viii. 1. Let value be ? IteratorValue(innerReturnResult).\n    // 7. c. viii. 2. Return Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.\n    // 7. c. ix. If generatorKind is async, then set received to AsyncGeneratorYield(? IteratorValue(innerReturnResult)).\n    // 7. c. x. Else, set received to GeneratorYield(innerReturnResult).\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $AsExpression implements I$Node {\n  public get $kind(): SyntaxKind.AsExpression { return SyntaxKind.AsExpression; }\n\n  public readonly $expression: $$UpdateExpressionOrHigher;\n\n  public constructor(\n    public readonly node: AsExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.AsExpression`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $UpdateExpressionNode, this, ctx, -1) as $$UpdateExpressionOrHigher;\n  }\n\n  // This is a TS expression that wraps an ordinary expression. Just return the evaluate result.\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty | $Reference | $Error {\n    ctx.checkTimeout();\n\n    return this.$expression.Evaluate(ctx);\n  }\n}\n\n// #endregion\n\nexport class $Identifier implements I$Node {\n  public get $kind(): SyntaxKind.Identifier { return SyntaxKind.Identifier; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-identifiers-static-semantics-stringvalue\n  // 12.1.4 Static Semantics: StringValue\n  public readonly StringValue: $String;\n  // http://www.ecma-international.org/ecma-262/#sec-object-initializer-static-semantics-propname\n  // 12.2.6.5 Static Semantics: PropName\n  public readonly PropName: $String;\n\n  // http://www.ecma-international.org/ecma-262/#sec-identifiers-static-semantics-boundnames\n  // 12.1.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly [$String];\n  // http://www.ecma-international.org/ecma-262/#sec-identifiers-static-semantics-assignmenttargettype\n  // 12.1.3 Static Semantics: AssignmentTargetType\n  public readonly AssignmentTargetType: 'strict' | 'simple';\n\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredparenthesizedexpression\n  // 12.2.1.1 Static Semantics: CoveredParenthesizedExpression\n  public readonly CoveredParenthesizedExpression: $Identifier = this;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-hasname\n  // 12.2.1.2 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isfunctiondefinition\n  // 12.2.1.3 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-semantics-static-semantics-isidentifierref\n  // 12.2.1.4 Static Semantics: IsIdentifierRef\n  public readonly IsIdentifierRef: true = true;\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression\n  // 13.3.3.2 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer\n  // 13.3.3.3 Static Semantics: HasInitializer\n  public readonly HasInitializer: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist\n  // 13.3.3.4 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: true = true;\n\n  public get isUndefined(): false { return false; }\n  public get isNull(): false { return false; }\n\n  public constructor(\n    public readonly node: Identifier,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.Identifier(${node.text})`,\n  ) {\n    const StringValue = this.StringValue = new $String(realm, node.text, void 0, void 0, this);\n    this.PropName = StringValue;\n    this.BoundNames = [StringValue] as const;\n\n    if (hasBit(ctx, Context.InStrictMode) && (StringValue['[[Value]]'] === 'eval' || StringValue['[[Value]]'] === 'arguments')) {\n      this.AssignmentTargetType = 'strict';\n    } else {\n      this.AssignmentTargetType = 'simple';\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-identifiers-runtime-semantics-evaluation\n  // 12.1.6 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Reference | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // IdentifierReference : Identifier\n\n    // 1. Return ? ResolveBinding(StringValue of Identifier).\n\n    // IdentifierReference : yield\n\n    // 1. Return ? ResolveBinding(\"yield\").\n\n    // IdentifierReference : await\n\n    // 1. Return ? ResolveBinding(\"await\").\n\n    return realm.ResolveBinding(this.StringValue).enrichWith(ctx, this);\n  }\n\n  // based on http://www.ecma-international.org/ecma-262/#sec-object-initializer-runtime-semantics-evaluation\n  public EvaluatePropName(\n    ctx: ExecutionContext,\n  ): $String {\n    ctx.checkTimeout();\n\n    return this.PropName;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization\n  // 13.3.3.6 Runtime Semantics: PropertyBindingInitialization\n  public InitializePropertyBinding(\n    ctx: ExecutionContext,\n    value: $AnyNonEmpty,\n    environment: $EnvRec | undefined,\n  ): $List<$String> | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializePropertyBinding(#${ctx.id})`);\n\n    // BindingProperty : SingleNameBinding\n\n    // 1. Let name be the string that is the only element of BoundNames of SingleNameBinding.\n    const [name] = this.BoundNames;\n\n    // 2. Perform ? KeyedBindingInitialization for SingleNameBinding using value, environment, and name as the arguments.\n    const $InitializeKeyedBindingResult = this.InitializeKeyedBinding(ctx, value, environment, name);\n    if ($InitializeKeyedBindingResult.isAbrupt) { return $InitializeKeyedBindingResult.enrichWith(ctx, this); }\n\n    // 3. Return a new List containing name.\n    return new $List(...this.BoundNames);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization\n  // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization\n  public InitializeIteratorBinding(\n    ctx: ExecutionContext,\n    iteratorRecord: $IteratorRecord,\n    environment: $EnvRec | undefined,\n    initializer?: $$AssignmentExpressionOrHigher,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // SingleNameBinding : BindingIdentifier Initializer opt\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    const bindingId = this.StringValue;\n\n    // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n    const lhs = realm.ResolveBinding(bindingId, environment);\n    if (lhs.isAbrupt) { return lhs.enrichWith(ctx, this); }\n\n    let v: $AnyNonEmpty  = intrinsics.undefined; // TODO: sure about this?\n\n    // 3. If iteratorRecord.[[Done]] is false, then\n    if (iteratorRecord['[[Done]]'].isFalsey) {\n      // 3. a. Let next be IteratorStep(iteratorRecord).\n      const next = $IteratorStep(ctx, iteratorRecord);\n\n      // 3. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n      if (next.isAbrupt) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n        // 3. c. ReturnIfAbrupt(next).\n        return next;\n      }\n\n      // 3. d. If next is false, set iteratorRecord.[[Done]] to true.\n      if (next.isFalsey) {\n        iteratorRecord['[[Done]]'] = intrinsics.true;\n      }\n      // 3. e. Else,\n      else {\n        // 3. e. i. Let v be IteratorValue(next).\n        v = $IteratorValue(ctx, next);\n\n        // 3. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (v.isAbrupt) {\n          iteratorRecord['[[Done]]'] = intrinsics.true;\n          // 3. e. iii. ReturnIfAbrupt(v).\n          return v;\n        }\n      }\n    }\n\n    // 4. If iteratorRecord.[[Done]] is true, let v be undefined.\n    if (iteratorRecord['[[Done]]'].isTruthy) {\n      v = intrinsics.undefined;\n    }\n\n    // 5. If Initializer is present and v is undefined, then\n    if (initializer !== void 0 && v.isUndefined) {\n      // 5. a. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (initializer instanceof $FunctionExpression && !initializer.HasName) {\n        // 5. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.\n        v = initializer.EvaluateNamed(ctx, bindingId);\n      }\n      // 5. b. Else,\n      else {\n        // 5. b. i. Let defaultValue be the result of evaluating Initializer.\n        const defaultValue = initializer.Evaluate(ctx);\n\n        // 5. b. ii. Set v to ? GetValue(defaultValue).\n        const $v = defaultValue.GetValue(ctx);\n        if ($v.isAbrupt) { return $v.enrichWith(ctx, this); }\n\n        v = $v;\n      }\n    }\n\n    // 6. If environment is undefined, return ? PutValue(lhs, v).\n    if (environment === void 0) {\n      return lhs.PutValue(ctx, v as $AnyNonEmpty).enrichWith(ctx, this);\n    }\n\n    // 7. Return InitializeReferencedBinding(lhs, v).\n    return lhs.InitializeReferencedBinding(ctx, v as $AnyNonEmpty).enrichWith(ctx, this);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-keyedbindinginitialization\n  // 13.3.3.9 Runtime Semantics: KeyedBindingInitialization\n  public InitializeKeyedBinding(\n    ctx: ExecutionContext,\n    value: $AnyNonEmpty,\n    environment: $EnvRec | undefined,\n    propertyName: $String,\n    initializer?: $$AssignmentExpressionOrHigher,\n  ): $Any {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeKeyedBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n\n    // SingleNameBinding : BindingIdentifier Initializer opt\n\n    // 1. Let bindingId be StringValue of BindingIdentifier.\n    const bindingId = this.StringValue;\n\n    // 2. Let lhs be ? ResolveBinding(bindingId, environment).\n    const lhs = realm.ResolveBinding(bindingId, environment);\n    if (lhs.isAbrupt) { return lhs.enrichWith(ctx, this); }\n\n    // 3. Let v be ? GetV(value, propertyName).\n    const obj = value.ToObject(ctx);\n    if (obj.isAbrupt) { return obj.enrichWith(ctx, this); }\n    let v = obj['[[Get]]'](ctx, propertyName, obj);\n    if (v.isAbrupt) { return v.enrichWith(ctx, this); }\n\n    // 4. If Initializer is present and v is undefined, then\n    if (initializer !== void 0 && v.isUndefined) {\n      // 4. a. If IsAnonymousFunctionDefinition(Initializer) is true, then\n      if (initializer instanceof $FunctionExpression && !initializer.HasName) {\n        // 4. a. i. Set v to the result of performing NamedEvaluation for Initializer with argument bindingId.\n        v = initializer.EvaluateNamed(ctx, bindingId);\n      }\n      // 4. b. Else,\n      else {\n        // 4. b. i. Let defaultValue be the result of evaluating Initializer.\n        const defaultValue = initializer.Evaluate(ctx);\n\n        // 4. b. ii. Set v to ? GetValue(defaultValue).\n        const $v = defaultValue.GetValue(ctx);\n        if ($v.isAbrupt) { return $v.enrichWith(ctx, this); }\n      }\n    }\n\n    // 5. If environment is undefined, return ? PutValue(lhs, v).\n    if (environment === void 0) {\n      return lhs.PutValue(ctx, v as $AnyNonEmpty).enrichWith(ctx, this);\n    }\n\n    // 6. Return InitializeReferencedBinding(lhs, v).\n    return lhs.InitializeReferencedBinding(ctx, v as $AnyNonEmpty).enrichWith(ctx, this);\n  }\n}\n","import {\n  JsxAttribute,\n  JsxAttributes,\n  JsxChild,\n  JsxClosingElement,\n  JsxClosingFragment,\n  JsxElement,\n  JsxExpression,\n  JsxFragment,\n  JsxOpeningElement,\n  JsxOpeningFragment,\n  JsxSelfClosingElement,\n  JsxSpreadAttribute,\n  JsxTagNameExpression,\n  JsxText,\n  Node,\n  SyntaxKind,\n  JsxAttributeLike,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Any,\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  I$Node,\n  Context,\n  $identifier,\n  $$AssignmentExpressionOrHigher,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$JsxOpeningLikeElement,\n  $i,\n} from './_shared.js';\nimport {\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Identifier,\n  $PropertyAccessExpression,\n  $ThisExpression,\n} from './expressions.js';\nimport {\n  $StringLiteral,\n} from './literals.js';\n\nexport type $$JsxParent = (\n  $JsxElement |\n  $JsxFragment\n);\n\nexport type $$JsxChild = (\n  $JsxText |\n  $JsxExpression |\n  $JsxElement |\n  $JsxSelfClosingElement |\n  $JsxFragment\n);\n\nexport function $$jsxChildList(\n  nodes: readonly JsxChild[],\n  parent: $$JsxParent,\n  ctx: Context,\n): readonly $$JsxChild[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $$JsxChild[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    switch (nodes[i].kind) {\n      case SyntaxKind.JsxText:\n        $nodes[i] = new $JsxText(nodes[i] as JsxText, parent, ctx, i);\n        break;\n      case SyntaxKind.JsxExpression:\n        $nodes[i] = new $JsxExpression(nodes[i] as JsxExpression, parent, ctx, i);\n        break;\n      case SyntaxKind.JsxElement:\n        $nodes[i] = new $JsxElement(nodes[i] as JsxElement, parent, ctx, i);\n        break;\n      case SyntaxKind.JsxSelfClosingElement:\n        $nodes[i] = new $JsxSelfClosingElement(nodes[i] as JsxSelfClosingElement, parent, ctx, i);\n        break;\n      case SyntaxKind.JsxFragment:\n        $nodes[i] = new $JsxFragment(nodes[i] as JsxFragment, parent, ctx, i);\n        break;\n    }\n  }\n  return $nodes;\n}\n\nexport class $JsxElement implements I$Node {\n  public get $kind(): SyntaxKind.JsxElement { return SyntaxKind.JsxElement; }\n\n  public readonly $openingElement: $JsxOpeningElement;\n  public readonly $children: readonly $$JsxChild[];\n  public readonly $closingElement: $JsxClosingElement;\n\n  public constructor(\n    public readonly node: JsxElement,\n    public readonly parent: $$JsxParent,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxElement`,\n  ) {\n    this.$openingElement = new $JsxOpeningElement(node.openingElement, this, ctx);\n    this.$children = $$jsxChildList(node.children, this, ctx);\n    this.$closingElement = new $JsxClosingElement(node.closingElement, this, ctx);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport type $$JsxNamed = (\n  $JsxOpeningElement |\n  $JsxClosingElement |\n  $JsxSelfClosingElement\n);\n\nexport type $$JsxTagNamePropertyAccess = $PropertyAccessExpression & {\n  expression: $$JsxTagNameExpression;\n};\n\nexport type $$JsxTagNameExpression = (\n  $Identifier |\n  $ThisExpression |\n  $$JsxTagNamePropertyAccess\n);\n\nexport function $$jsxTagNameExpression(\n  node: JsxTagNameExpression,\n  parent: $$JsxNamed,\n  ctx: Context,\n  idx: number,\n): $$JsxTagNameExpression {\n  switch (node.kind) {\n    case SyntaxKind.Identifier:\n      return new $Identifier(node, parent, ctx, idx);\n    case SyntaxKind.ThisKeyword:\n      return new $ThisExpression(node, parent, ctx, idx);\n    case SyntaxKind.PropertyAccessExpression:\n      return new $PropertyAccessExpression(node, parent, ctx, idx) as $$JsxTagNamePropertyAccess;\n    default:\n      throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as Node).kind]}.`);\n  }\n}\n\nexport class $JsxSelfClosingElement implements I$Node {\n  public get $kind(): SyntaxKind.JsxSelfClosingElement { return SyntaxKind.JsxSelfClosingElement; }\n\n  public readonly $tagName: $$JsxTagNameExpression;\n  public readonly $attributes: $JsxAttributes;\n\n  public constructor(\n    public readonly node: JsxSelfClosingElement,\n    public readonly parent: $$JsxParent,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxSelfClosingElement`,\n  ) {\n    this.$tagName = $$jsxTagNameExpression(node.tagName, this, ctx, -1);\n    this.$attributes = new $JsxAttributes(node.attributes, this, ctx);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $JsxFragment implements I$Node {\n  public get $kind(): SyntaxKind.JsxFragment { return SyntaxKind.JsxFragment; }\n\n  public readonly $openingFragment: $JsxOpeningFragment;\n  public readonly $children: readonly $$JsxChild[];\n  public readonly $closingFragment: $JsxClosingFragment;\n\n  public constructor(\n    public readonly node: JsxFragment,\n    public readonly parent: $$JsxParent,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxFragment`,\n  ) {\n    this.$openingFragment = new $JsxOpeningFragment(node.openingFragment, this, ctx);\n    this.$children = $$jsxChildList(node.children, this, ctx);\n    this.$closingFragment = new $JsxClosingFragment(node.closingFragment, this, ctx);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class $JsxText implements I$Node {\n  public get $kind(): SyntaxKind.JsxText { return SyntaxKind.JsxText; }\n\n  public constructor(\n    public readonly node: JsxText,\n    public readonly parent: $$JsxParent,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxText`,\n  ) {}\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxOpeningElement implements I$Node {\n  public get $kind(): SyntaxKind.JsxOpeningElement { return SyntaxKind.JsxOpeningElement; }\n\n  public readonly $tagName: $$JsxTagNameExpression;\n  public readonly $attributes: $JsxAttributes;\n\n  public constructor(\n    public readonly node: JsxOpeningElement,\n    public readonly parent: $JsxElement,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.JsxOpeningElement`,\n  ) {\n    this.$tagName = $$jsxTagNameExpression(node.tagName, this, ctx, -1);\n    this.$attributes = new $JsxAttributes(node.attributes, this, ctx);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxClosingElement implements I$Node {\n  public get $kind(): SyntaxKind.JsxClosingElement { return SyntaxKind.JsxClosingElement; }\n\n  public readonly $tagName: $$JsxTagNameExpression;\n\n  public constructor(\n    public readonly node: JsxClosingElement,\n    public readonly parent: $JsxElement,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.JsxClosingElement`,\n  ) {\n    this.$tagName = $$jsxTagNameExpression(node.tagName, this, ctx, -1);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxOpeningFragment implements I$Node {\n  public get $kind(): SyntaxKind.JsxOpeningFragment { return SyntaxKind.JsxOpeningFragment; }\n\n  public constructor(\n    public readonly node: JsxOpeningFragment,\n    public readonly parent: $JsxFragment,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.JsxOpeningFragment`,\n  ) {}\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxClosingFragment implements I$Node {\n  public get $kind(): SyntaxKind.JsxClosingFragment { return SyntaxKind.JsxClosingFragment; }\n\n  public constructor(\n    public readonly node: JsxClosingFragment,\n    public readonly parent: $JsxFragment,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.JsxClosingFragment`,\n  ) {}\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxAttribute implements I$Node {\n  public get $kind(): SyntaxKind.JsxAttribute { return SyntaxKind.JsxAttribute; }\n\n  public readonly $name: $Identifier;\n  public readonly $initializer: $StringLiteral | $JsxExpression | undefined;\n\n  public constructor(\n    public readonly node: JsxAttribute,\n    public readonly parent: $JsxAttributes,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxAttribute`,\n  ) {\n    this.$name = $identifier(node.name, this, ctx, -1);\n    if (node.initializer === void 0) {\n      this.$initializer = void 0;\n    } else {\n      if (node.initializer.kind === SyntaxKind.StringLiteral) {\n        this.$initializer = new $StringLiteral(node.initializer, this, ctx, -1);\n      } else {\n        this.$initializer = new $JsxExpression(node.initializer, this, ctx, -1);\n      }\n    }\n  }\n}\n\nexport type $$JsxAttributeLike = (\n  $JsxAttribute |\n  $JsxSpreadAttribute\n);\n\nexport function $$jsxAttributeLikeList(\n  nodes: readonly JsxAttributeLike[],\n  parent: $JsxAttributes,\n  ctx: Context,\n): readonly $$JsxAttributeLike[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $$JsxAttributeLike[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    switch (nodes[i].kind) {\n      case SyntaxKind.JsxAttribute:\n        $nodes[i] = new $JsxAttribute(nodes[i] as JsxAttribute, parent, ctx, i);\n        break;\n      case SyntaxKind.JsxSpreadAttribute:\n        $nodes[i] = new $JsxSpreadAttribute(nodes[i] as JsxSpreadAttribute, parent, ctx, i);\n        break;\n    }\n  }\n  return $nodes;\n}\n\nexport class $JsxAttributes implements I$Node {\n  public get $kind(): SyntaxKind.JsxAttributes { return SyntaxKind.JsxAttributes; }\n\n  public readonly $properties: readonly $$JsxAttributeLike[];\n\n  public constructor(\n    public readonly node: JsxAttributes,\n    public readonly parent: $$JsxOpeningLikeElement,\n    public readonly ctx: Context,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}.JsxAttributes`,\n  ) {\n    this.$properties = $$jsxAttributeLikeList(node.properties, this, ctx);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxSpreadAttribute implements I$Node {\n  public get $kind(): SyntaxKind.JsxSpreadAttribute { return SyntaxKind.JsxSpreadAttribute; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher;\n\n  public constructor(\n    public readonly node: JsxSpreadAttribute,\n    public readonly parent: $JsxAttributes,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxSpreadAttribute`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n\nexport class $JsxExpression implements I$Node {\n  public get $kind(): SyntaxKind.JsxExpression { return SyntaxKind.JsxExpression; }\n\n  public readonly $expression: $$AssignmentExpressionOrHigher | undefined;\n\n  public constructor(\n    public readonly node: JsxExpression,\n    public readonly parent: $$JsxParent | $$JsxAttributeLike,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.JsxExpression`,\n  ) {\n    this.$expression = $assignmentExpression(node.expression as $AssignmentExpressionNode, this, ctx, -1);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Any {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    return intrinsics.empty; // TODO: implement this\n  }\n}\n","import {\n  ArrayLiteralExpression,\n  ArrowFunction,\n  AsExpression,\n  AwaitExpression,\n  BigIntLiteral,\n  BinaryExpression,\n  BindingName,\n  Block,\n  BooleanLiteral,\n  BreakStatement,\n  CallExpression,\n  ClassDeclaration,\n  ClassExpression,\n  ConditionalExpression,\n  ConstructorDeclaration,\n  ContinueStatement,\n  DebuggerStatement,\n  Decorator,\n  DeleteExpression,\n  DoStatement,\n  ElementAccessExpression,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportAssignment,\n  ExportDeclaration,\n  ExpressionStatement,\n  ForInStatement,\n  ForOfStatement,\n  ForStatement,\n  FunctionDeclaration,\n  FunctionExpression,\n  GetAccessorDeclaration,\n  HeritageClause,\n  Identifier,\n  IfStatement,\n  ImportDeclaration,\n  ImportEqualsDeclaration,\n  InterfaceDeclaration,\n  JsxElement,\n  JsxFragment,\n  JsxSelfClosingElement,\n  LabeledStatement,\n  MetaProperty,\n  MethodDeclaration,\n  Modifier,\n  ModifierFlags,\n  ModuleDeclaration,\n  NamespaceExportDeclaration,\n  NewExpression,\n  Node,\n  NonNullExpression,\n  NoSubstitutionTemplateLiteral,\n  NullLiteral,\n  NumericLiteral,\n  ObjectLiteralExpression,\n  OmittedExpression,\n  ParenthesizedExpression,\n  PostfixUnaryExpression,\n  PrefixUnaryExpression,\n  PropertyAccessExpression,\n  PropertyDeclaration,\n  PropertyName,\n  RegularExpressionLiteral,\n  ReturnStatement,\n  SemicolonClassElement,\n  SetAccessorDeclaration,\n  SpreadElement,\n  StringLiteral,\n  SuperExpression,\n  SwitchStatement,\n  SyntaxKind,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  ThisExpression,\n  ThrowStatement,\n  TryStatement,\n  TypeAliasDeclaration,\n  TypeAssertion,\n  TypeOfExpression,\n  VariableStatement,\n  VoidExpression,\n  WhileStatement,\n  WithStatement,\n  YieldExpression,\n  Statement,\n} from 'typescript';\nimport {\n  emptyArray,\n  IIndexable,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $DeclarativeEnvRec,\n} from '../types/environment-record.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $Any,\n  $AnyNonEmpty,\n} from '../types/_shared.js';\nimport {\n  $$TSModuleItem,\n  $ExportSpecifier,\n  $ExternalModuleReference,\n  $ImportClause,\n  $ImportSpecifier,\n  $ModuleBlock,\n  $NamedImports,\n  $NamespaceImport,\n  $QualifiedName,\n  $ModuleDeclaration,\n  $ExportAssignment,\n  $ExportDeclaration,\n  $ImportDeclaration,\n  $ImportEqualsDeclaration,\n  $ESScript,\n  $ESModule,\n} from './modules.js';\nimport {\n  $ArrayBindingPattern,\n  $BindingElement,\n  $ComputedPropertyName,\n  $ObjectBindingPattern,\n  $SpreadElement,\n  $$NamedDeclaration,\n} from './bindings.js';\nimport {\n  $ArrayLiteralExpression,\n  $AsExpression,\n  $AwaitExpression,\n  $BinaryExpression,\n  $CallExpression,\n  $ConditionalExpression,\n  $Decorator,\n  $DeleteExpression,\n  $ElementAccessExpression,\n  $MetaProperty,\n  $NewExpression,\n  $NonNullExpression,\n  $ObjectLiteralExpression,\n  $ParenthesizedExpression,\n  $PostfixUnaryExpression,\n  $PrefixUnaryExpression,\n  $PropertyAccessExpression,\n  $PropertyAssignment,\n  $ShorthandPropertyAssignment,\n  $SpreadAssignment,\n  $TaggedTemplateExpression,\n  $TemplateExpression,\n  $TypeAssertion,\n  $TypeOfExpression,\n  $VoidExpression,\n  $YieldExpression,\n  $Identifier,\n  $ThisExpression,\n  $SuperExpression,\n} from './expressions.js';\nimport {\n  $ArrowFunction,\n  $ConstructorDeclaration,\n  $FunctionExpression,\n  $ParameterDeclaration,\n  $FunctionDeclaration,\n} from './functions.js';\nimport {\n  $Block,\n  $BreakStatement,\n  $CaseBlock,\n  $CaseClause,\n  $CatchClause,\n  $ContinueStatement,\n  $DefaultClause,\n  $DoStatement,\n  $ExpressionStatement,\n  $ForInStatement,\n  $ForOfStatement,\n  $ForStatement,\n  $IfStatement,\n  $LabeledStatement,\n  $ReturnStatement,\n  $SwitchStatement,\n  $ThrowStatement,\n  $TryStatement,\n  $VariableDeclaration,\n  $VariableDeclarationList,\n  $WhileStatement,\n  $WithStatement,\n  $VariableStatement,\n  $EmptyStatement,\n  $DebuggerStatement,\n  DirectivePrologue,\n  ExpressionStatement_T,\n} from './statements.js';\nimport {\n  $ClassExpression,\n  $ExpressionWithTypeArguments,\n  $HeritageClause,\n  $PropertyDeclaration,\n  $ClassDeclaration,\n  $$NodeWithHeritageClauses,\n  $SemicolonClassElement,\n} from './classes.js';\nimport {\n  $EnumMember,\n  $InterfaceDeclaration,\n  $TypeAliasDeclaration,\n  $EnumDeclaration,\n} from './types.js';\nimport {\n  $GetAccessorDeclaration,\n  $MethodDeclaration,\n  $SetAccessorDeclaration,\n} from './methods.js';\nimport {\n  $JsxAttribute,\n  $JsxAttributes,\n  $JsxClosingElement,\n  $JsxElement,\n  $JsxExpression,\n  $JsxFragment,\n  $JsxOpeningElement,\n  $JsxSelfClosingElement,\n  $JsxSpreadAttribute,\n  $$JsxParent,\n} from './jsx.js';\nimport {\n  $TemplateSpan,\n  $BigIntLiteral,\n  $BooleanLiteral,\n  $NoSubstitutionTemplateLiteral,\n  $NullLiteral,\n  $NumericLiteral,\n  $RegularExpressionLiteral,\n  $StringLiteral,\n} from './literals.js';\nimport {\n  $StringSet,\n} from '../globals/string.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  $Error,\n} from '../types/error.js';\n\n// #region TS AST unions\n\nexport type $PrimaryExpressionNode = (\n  $LiteralNode |\n  ArrayLiteralExpression |\n  ClassExpression |\n  FunctionExpression |\n  Identifier |\n  NewExpression |\n  ObjectLiteralExpression |\n  ParenthesizedExpression |\n  TemplateExpression |\n  ThisExpression |\n  SuperExpression\n);\n\nexport type $MemberExpressionNode = (\n  $PrimaryExpressionNode |\n  ElementAccessExpression |\n  NonNullExpression |\n  PropertyAccessExpression |\n  TaggedTemplateExpression\n);\n\nexport type $CallExpressionNode = (\n  $MemberExpressionNode |\n  CallExpression\n);\n\nexport type $LHSExpressionNode = (\n  $CallExpressionNode |\n  MetaProperty\n);\n\nexport type $UpdateExpressionNode = (\n  $LHSExpressionNode |\n  JsxElement |\n  JsxFragment |\n  JsxSelfClosingElement |\n  PostfixUnaryExpression |\n  PrefixUnaryExpression\n);\n\nexport type $UnaryExpressionNode = (\n  $UpdateExpressionNode |\n  AwaitExpression |\n  DeleteExpression |\n  PrefixUnaryExpression |\n  TypeAssertion |\n  TypeOfExpression |\n  VoidExpression\n);\n\nexport type $BinaryExpressionNode = (\n  $UnaryExpressionNode |\n  AsExpression |\n  BinaryExpression\n);\n\nexport type $AssignmentExpressionNode = (\n  $BinaryExpressionNode |\n  ArrowFunction |\n  ConditionalExpression |\n  YieldExpression\n);\n\nexport type $ArgumentOrArrayLiteralElementNode = (\n  $AssignmentExpressionNode |\n  SpreadElement |\n  OmittedExpression\n);\n\nexport type $LiteralNode = (\n  NumericLiteral |\n  BigIntLiteral |\n  StringLiteral |\n  RegularExpressionLiteral |\n  NoSubstitutionTemplateLiteral |\n  NullLiteral |\n  BooleanLiteral\n);\n\nexport type $ModuleStatementNode = (\n  ModuleDeclaration |\n  NamespaceExportDeclaration |\n  ImportEqualsDeclaration |\n  ImportDeclaration |\n  ExportAssignment |\n  ExportDeclaration\n);\n\nexport type $StatementNode = (\n  $ESStatementListItemNode |\n  InterfaceDeclaration |\n  TypeAliasDeclaration |\n  EnumDeclaration |\n  ModuleDeclaration |\n  NamespaceExportDeclaration |\n  ImportEqualsDeclaration |\n  ImportDeclaration |\n  ExportAssignment |\n  ExportDeclaration\n);\n\nexport type $ESStatementListItemNode = (\n  Block |\n  VariableStatement |\n  EmptyStatement |\n  ExpressionStatement |\n  IfStatement |\n  DoStatement |\n  WhileStatement |\n  ForStatement |\n  ForInStatement |\n  ForOfStatement |\n  ContinueStatement |\n  BreakStatement |\n  ReturnStatement |\n  WithStatement |\n  SwitchStatement |\n  LabeledStatement |\n  ThrowStatement |\n  TryStatement |\n  DebuggerStatement |\n  FunctionDeclaration |\n  ClassDeclaration\n);\n\nexport type $ClassElementNode = (\n  GetAccessorDeclaration |\n  SetAccessorDeclaration |\n  ConstructorDeclaration |\n  MethodDeclaration |\n  SemicolonClassElement |\n  PropertyDeclaration\n);\n\n// #endregion\n\n// #region $Node type unions\n\nexport type $AnyParentNode = (\n  $$TSModuleItem |\n  $ArrayBindingPattern |\n  $ArrayLiteralExpression |\n  $ArrowFunction |\n  $AsExpression |\n  $AwaitExpression |\n  $BinaryExpression |\n  $BindingElement |\n  $Block |\n  $BreakStatement |\n  $CallExpression |\n  $CaseBlock |\n  $CaseClause |\n  $CatchClause |\n  $ClassExpression |\n  $ComputedPropertyName |\n  $ConditionalExpression |\n  $ConstructorDeclaration |\n  $ContinueStatement |\n  $Decorator |\n  $DefaultClause |\n  $DeleteExpression |\n  $DoStatement |\n  $ElementAccessExpression |\n  $EnumMember |\n  $ExportSpecifier |\n  $ExpressionStatement |\n  $ExpressionWithTypeArguments |\n  $ExternalModuleReference |\n  $ForInStatement |\n  $ForOfStatement |\n  $ForStatement |\n  $FunctionExpression |\n  $GetAccessorDeclaration |\n  $HeritageClause |\n  $IfStatement |\n  $ImportClause |\n  $ImportSpecifier |\n  $JsxAttribute |\n  $JsxAttributes |\n  $JsxClosingElement |\n  $JsxElement |\n  $JsxExpression |\n  $JsxFragment |\n  $JsxOpeningElement |\n  $JsxSelfClosingElement |\n  $JsxSpreadAttribute |\n  $LabeledStatement |\n  $MetaProperty |\n  $MethodDeclaration |\n  $ModuleBlock |\n  $NamedImports |\n  $NamespaceImport |\n  $NewExpression |\n  $NonNullExpression |\n  $ObjectBindingPattern |\n  $ObjectLiteralExpression |\n  $ParameterDeclaration |\n  $ParenthesizedExpression |\n  $PostfixUnaryExpression |\n  $PrefixUnaryExpression |\n  $PropertyAccessExpression |\n  $PropertyAssignment |\n  $PropertyDeclaration |\n  $QualifiedName |\n  $ReturnStatement |\n  $SetAccessorDeclaration |\n  $ShorthandPropertyAssignment |\n  $ESModule |\n  $SpreadAssignment |\n  $SpreadElement |\n  $SwitchStatement |\n  $TaggedTemplateExpression |\n  $TemplateExpression |\n  $TemplateSpan |\n  $ThrowStatement |\n  $TryStatement |\n  $TypeAssertion |\n  $TypeOfExpression |\n  $VariableDeclaration |\n  $VariableDeclarationList |\n  $VoidExpression |\n  $WhileStatement |\n  $WithStatement |\n  $YieldExpression\n);\n\nexport type $$JsxOpeningLikeElement = (\n  $JsxSelfClosingElement |\n  $JsxOpeningElement\n);\n\n// #endregion\n\n// #region Builders\n\nexport type $$BinaryExpression = (\n  $AsExpression |\n  $BinaryExpression\n);\n\nexport type $$BinaryExpressionOrHigher = (\n  $$UnaryExpressionOrHigher |\n  $$BinaryExpression\n);\n\nexport type $$AssignmentExpression = (\n  $ArrowFunction |\n  $ConditionalExpression |\n  $YieldExpression\n);\n\nexport type $$AssignmentExpressionOrHigher = (\n  $$BinaryExpressionOrHigher |\n  $$AssignmentExpression\n);\n\nexport function $assignmentExpression(\n  node: undefined,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): undefined;\nexport function $assignmentExpression(\n  node: $AssignmentExpressionNode,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $$AssignmentExpressionOrHigher;\nexport function $assignmentExpression(\n  node: $AssignmentExpressionNode | undefined,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $$AssignmentExpressionOrHigher | undefined;\nexport function $assignmentExpression(\n  node: $AssignmentExpressionNode | undefined,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $$AssignmentExpressionOrHigher | undefined {\n  if (node === void 0) {\n    return void 0;\n  }\n\n  switch (node.kind) {\n    case SyntaxKind.AsExpression:\n      return new $AsExpression(node, parent, ctx, idx);\n    case SyntaxKind.BinaryExpression:\n      return new $BinaryExpression(node, parent, ctx, idx);\n    case SyntaxKind.ArrowFunction:\n      return new $ArrowFunction(node, parent, ctx, idx);\n    case SyntaxKind.ConditionalExpression:\n      return new $ConditionalExpression(node, parent, ctx, idx);\n    case SyntaxKind.YieldExpression:\n      return new $YieldExpression(node, parent, ctx, idx);\n    default:\n      return $unaryExpression(node, parent, ctx, idx);\n  }\n}\n\nexport type $$UpdateExpression = (\n  $JsxElement |\n  $JsxFragment |\n  $JsxSelfClosingElement |\n  $PostfixUnaryExpression |\n  $PrefixUnaryExpression\n);\n\nexport type $$UpdateExpressionOrHigher = (\n  $$LHSExpressionOrHigher |\n  $$UpdateExpression\n);\n\nexport type $$UnaryExpression = (\n  $AwaitExpression |\n  $DeleteExpression |\n  $PrefixUnaryExpression |\n  $TypeAssertion |\n  $TypeOfExpression |\n  $VoidExpression\n);\n\nexport type $$UnaryExpressionOrHigher = (\n  $$UpdateExpressionOrHigher |\n  $$UnaryExpression\n);\n\nexport function $unaryExpression(\n  node: $UnaryExpressionNode,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $$UnaryExpressionOrHigher {\n  switch (node.kind) {\n    case SyntaxKind.JsxElement:\n      return new $JsxElement(node, parent as $$JsxParent, ctx, idx);\n    case SyntaxKind.JsxFragment:\n      return new $JsxFragment(node, parent as $$JsxParent, ctx, idx);\n    case SyntaxKind.JsxSelfClosingElement:\n      return new $JsxSelfClosingElement(node, parent as $$JsxParent, ctx, idx);\n    case SyntaxKind.PostfixUnaryExpression:\n      return new $PostfixUnaryExpression(node, parent, ctx, idx);\n    case SyntaxKind.PrefixUnaryExpression:\n      return new $PrefixUnaryExpression(node, parent, ctx, idx);\n    case SyntaxKind.AwaitExpression:\n      return new $AwaitExpression(node, parent, ctx, idx);\n    case SyntaxKind.DeleteExpression:\n      return new $DeleteExpression(node, parent, ctx, idx);\n    case SyntaxKind.TypeAssertionExpression:\n      return new $TypeAssertion(node, parent, ctx, idx);\n    case SyntaxKind.TypeOfExpression:\n      return new $TypeOfExpression(node, parent, ctx, idx);\n    case SyntaxKind.VoidExpression:\n      return new $VoidExpression(node, parent, ctx, idx);\n    default:\n      return $LHSExpression(node, parent, ctx, idx);\n  }\n}\n\nexport type $$Literal = (\n  $BigIntLiteral |\n  $BooleanLiteral |\n  $NoSubstitutionTemplateLiteral |\n  $NullLiteral |\n  $NumericLiteral |\n  $RegularExpressionLiteral |\n  $StringLiteral\n);\n\nexport type $$PrimaryExpression = (\n  $ArrayLiteralExpression |\n  $ClassExpression |\n  $FunctionExpression |\n  $Identifier |\n  $NewExpression |\n  $ObjectLiteralExpression |\n  $ParenthesizedExpression |\n  $TemplateExpression |\n  $ThisExpression |\n  $SuperExpression\n);\n\nexport type $$PrimaryExpressionOrHigher = (\n  $$Literal |\n  $$PrimaryExpression\n);\n\nexport type $$MemberExpression = (\n  $ElementAccessExpression |\n  $NonNullExpression |\n  $PropertyAccessExpression |\n  $TaggedTemplateExpression\n);\n\nexport type $$MemberExpressionOrHigher = (\n  $$PrimaryExpressionOrHigher |\n  $$MemberExpression\n);\n\nexport type $$CallExpressionOrHigher = (\n  $$MemberExpressionOrHigher |\n  $CallExpression\n);\n\nexport type $$LHSExpression = (\n  $MetaProperty\n);\n\nexport type $$LHSExpressionOrHigher = (\n  $$CallExpressionOrHigher |\n  $$LHSExpression\n);\n\nexport function $LHSExpression(\n  node: $LHSExpressionNode,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $$LHSExpressionOrHigher {\n  switch (node.kind) {\n    case SyntaxKind.ArrayLiteralExpression:\n      return new $ArrayLiteralExpression(node, parent, ctx, idx);\n    case SyntaxKind.ClassExpression:\n      return new $ClassExpression(node, parent, ctx, idx);\n    case SyntaxKind.FunctionExpression:\n      return new $FunctionExpression(node, parent, ctx, idx);\n    case SyntaxKind.Identifier:\n      return new $Identifier(node, parent, ctx, idx);\n    case SyntaxKind.NewExpression:\n      return new $NewExpression(node, parent, ctx, idx);\n    case SyntaxKind.ObjectLiteralExpression:\n      return new $ObjectLiteralExpression(node, parent, ctx, idx);\n    case SyntaxKind.ParenthesizedExpression:\n      return new $ParenthesizedExpression(node, parent, ctx, idx);\n    case SyntaxKind.TemplateExpression:\n      return new $TemplateExpression(node, parent, ctx, idx);\n    case SyntaxKind.ElementAccessExpression:\n      return new $ElementAccessExpression(node, parent, ctx, idx);\n    case SyntaxKind.NonNullExpression:\n      return new $NonNullExpression(node, parent, ctx, idx);\n    case SyntaxKind.PropertyAccessExpression:\n      return new $PropertyAccessExpression(node, parent, ctx, idx);\n    case SyntaxKind.TaggedTemplateExpression:\n      return new $TaggedTemplateExpression(node, parent, ctx, idx);\n    case SyntaxKind.CallExpression:\n      return new $CallExpression(node, parent, ctx, idx);\n    case SyntaxKind.MetaProperty:\n      return new $MetaProperty(node, parent, ctx, idx);\n    case SyntaxKind.ThisKeyword:\n      return new $ThisExpression(node, parent, ctx, idx);\n    case SyntaxKind.SuperKeyword:\n      return new $SuperExpression(node, parent, ctx, idx);\n    case SyntaxKind.NumericLiteral:\n      return new $NumericLiteral(node, parent, ctx, idx);\n    case SyntaxKind.BigIntLiteral:\n      return new $BigIntLiteral(node, parent, ctx, idx);\n    case SyntaxKind.StringLiteral:\n      return new $StringLiteral(node, parent, ctx, idx);\n    case SyntaxKind.RegularExpressionLiteral:\n      return new $RegularExpressionLiteral(node, parent, ctx, idx);\n    case SyntaxKind.NoSubstitutionTemplateLiteral:\n      return new $NoSubstitutionTemplateLiteral(node, parent, ctx, idx);\n    case SyntaxKind.NullKeyword:\n      return new $NullLiteral(node, parent, ctx, idx);\n    case SyntaxKind.TrueKeyword:\n    case SyntaxKind.FalseKeyword:\n      return new $BooleanLiteral(node, parent, ctx, idx);\n    default:\n      throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as any).kind]}.`);\n  }\n}\n\nexport function $identifier(\n  node: undefined,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): undefined;\nexport function $identifier(\n  node: Identifier,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $Identifier;\nexport function $identifier(\n  node: Identifier | undefined,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $Identifier | undefined;\nexport function $identifier(\n  node: Identifier | undefined,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n): $Identifier | undefined {\n  if (node === void 0) {\n    return void 0;\n  }\n  return new $Identifier(node, parent, ctx, idx);\n}\n\nexport type $$PropertyName = (\n  $ComputedPropertyName |\n  $Identifier |\n  $NumericLiteral |\n  $StringLiteral\n);\n\nexport function $$propertyName(\n  node: PropertyName,\n  parent: $AnyParentNode,\n  ctx: Context,\n  idx: number,\n  // @ts-ignore - TODO(fkleuver): update AOT to use new TS 3.8 ast\n): $$PropertyName {\n  switch (node.kind) {\n    case SyntaxKind.Identifier:\n      return new $Identifier(node, parent, ctx, idx);\n    case SyntaxKind.StringLiteral:\n      return new $StringLiteral(node, parent, ctx, idx);\n    case SyntaxKind.NumericLiteral:\n      return new $NumericLiteral(node, parent, ctx, idx);\n    case SyntaxKind.ComputedPropertyName:\n      return new $ComputedPropertyName(node, parent as $$NamedDeclaration, ctx, idx);\n  }\n}\n\nexport type $$DestructurableBinding = (\n  $VariableDeclaration |\n  $ParameterDeclaration |\n  $BindingElement\n);\n\nexport type $$BindingName = (\n  $ArrayBindingPattern |\n  $Identifier |\n  $ObjectBindingPattern\n);\n\nexport function $$bindingName(\n  node: BindingName,\n  parent: $$DestructurableBinding,\n  ctx: Context,\n  idx: number,\n): $$BindingName {\n  switch (node.kind) {\n    case SyntaxKind.Identifier:\n      return new $Identifier(node, parent, ctx | Context.IsBindingName, idx);\n    case SyntaxKind.ObjectBindingPattern:\n      return new $ObjectBindingPattern(node, parent, ctx, idx);\n    case SyntaxKind.ArrayBindingPattern:\n      return new $ArrayBindingPattern(node, parent, ctx, idx);\n  }\n}\n\nexport type $NodeWithStatements = (\n  $GetAccessorDeclaration |\n  $SetAccessorDeclaration |\n  $$IterationStatement |\n  $Block |\n  $CaseClause |\n  $CatchClause |\n  $ConstructorDeclaration |\n  $DefaultClause |\n  $FunctionDeclaration |\n  $LabeledStatement |\n  $MethodDeclaration |\n  $ModuleBlock |\n  $ESModule |\n  $ESScript |\n  $TryStatement |\n  $WithStatement |\n  $FunctionExpression |\n  $ArrowFunction |\n  $IfStatement\n);\n\nexport type $$IterationStatement = (\n  $DoStatement |\n  $ForInStatement |\n  $ForOfStatement |\n  $ForStatement |\n  $WhileStatement\n);\n\nexport type $$BreakableStatement = (\n  $$IterationStatement |\n  $SwitchStatement\n);\n\nexport type $$ModuleDeclarationParent = (\n  $ESModule |\n  $ModuleBlock |\n  $ModuleDeclaration\n);\n\n// http://www.ecma-international.org/ecma-262/#prod-Statement\nexport type $$ESStatement = (\n  $Block |\n  $VariableStatement | // Note, technically only \"var declaration\" belongs here but TS clumps them up\n  $EmptyStatement |\n  $ExpressionStatement |\n  $IfStatement |\n  $$BreakableStatement |\n  $ContinueStatement |\n  $BreakStatement |\n  $ReturnStatement |\n  $WithStatement |\n  $LabeledStatement |\n  $ThrowStatement |\n  $TryStatement |\n  $DebuggerStatement\n);\n\nexport function $$esStatement(\n  node: $StatementNode,\n  parent: $NodeWithStatements,\n  ctx: Context,\n  idx: number,\n): $$ESStatement {\n  switch (node.kind) {\n    case SyntaxKind.Block:\n      return new $Block(node, parent, ctx, idx);\n    case SyntaxKind.EmptyStatement:\n      return new $EmptyStatement(node, parent, ctx, idx);\n    case SyntaxKind.ExpressionStatement:\n      return new $ExpressionStatement(node, parent, ctx, idx);\n    case SyntaxKind.IfStatement:\n      return new $IfStatement(node, parent, ctx, idx);\n    case SyntaxKind.DoStatement:\n      return new $DoStatement(node, parent, ctx, idx);\n    case SyntaxKind.WhileStatement:\n      return new $WhileStatement(node, parent, ctx, idx);\n    case SyntaxKind.ForStatement:\n      return new $ForStatement(node, parent, ctx, idx);\n    case SyntaxKind.ForInStatement:\n      return new $ForInStatement(node, parent, ctx, idx);\n    case SyntaxKind.ForOfStatement:\n      return new $ForOfStatement(node, parent, ctx, idx);\n    case SyntaxKind.ContinueStatement:\n      return new $ContinueStatement(node, parent, ctx, idx);\n    case SyntaxKind.BreakStatement:\n      return new $BreakStatement(node, parent, ctx, idx);\n    case SyntaxKind.ReturnStatement:\n      return new $ReturnStatement(node, parent, ctx, idx);\n    case SyntaxKind.WithStatement:\n      return new $WithStatement(node, parent, ctx, idx);\n    case SyntaxKind.SwitchStatement:\n      return new $SwitchStatement(node, parent, ctx, idx);\n    case SyntaxKind.LabeledStatement:\n      return new $LabeledStatement(node, parent, ctx, idx);\n    case SyntaxKind.ThrowStatement:\n      return new $ThrowStatement(node, parent, ctx, idx);\n    case SyntaxKind.TryStatement:\n      return new $TryStatement(node, parent, ctx, idx);\n    case SyntaxKind.DebuggerStatement:\n      return new $DebuggerStatement(node, parent, ctx, idx);\n    default:\n      throw new Error(`Unexpected syntax node: ${SyntaxKind[(node as Node).kind]}.`);\n  }\n}\n\nexport type $$ESVarDeclaration = (\n  $FunctionDeclaration |\n  $VariableStatement |\n  $VariableDeclaration\n);\n\nexport type $$ESDeclaration = (\n  $$ESVarDeclaration |\n  $ClassDeclaration\n);\n\nexport type $$TSDeclaration = (\n  $InterfaceDeclaration |\n  $TypeAliasDeclaration |\n  $EnumDeclaration\n);\n\nexport type $$ESStatementListItem = (\n  $$ESStatement |\n  $$ESDeclaration\n);\n\nexport type $$TSStatementListItem = (\n  $$ESStatementListItem |\n  $$TSDeclaration\n);\n\nexport function $$tsStatementListItem(\n  node: $StatementNode,\n  parent: $NodeWithStatements,\n  ctx: Context,\n  idx: number,\n): $$TSStatementListItem {\n  switch (node.kind) {\n    case SyntaxKind.VariableStatement:\n      return new $VariableStatement(node, parent, ctx, idx);\n    case SyntaxKind.FunctionDeclaration:\n      return new $FunctionDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.ClassDeclaration:\n      return new $ClassDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.InterfaceDeclaration:\n      return new $InterfaceDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.TypeAliasDeclaration:\n      return new $TypeAliasDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.EnumDeclaration:\n      return new $EnumDeclaration(node, parent, ctx, idx);\n    default:\n      return $$esStatement(node, parent, ctx, idx);\n  }\n}\n\nexport function $$tsStatementList(\n  nodes: readonly $StatementNode[],\n  parent: $NodeWithStatements,\n  ctx: Context,\n): readonly $$TSStatementListItem[] {\n  const len = nodes.length;\n  let node: $StatementNode;\n  const $nodes: $$TSStatementListItem[] = [];\n\n  let x = 0;\n  for (let i = 0; i < len; ++i) {\n    node = nodes[i];\n    if (node.kind === SyntaxKind.FunctionDeclaration && node.body === void 0) {\n      continue;\n    }\n    $nodes[x] = $$tsStatementListItem(node, parent, ctx, x);\n    ++x;\n  }\n  return $nodes;\n}\n\nexport type $$ESLabelledItem = (\n  $$ESStatement |\n  $FunctionDeclaration\n);\n\nexport function $$esLabelledItem(\n  node: $StatementNode,\n  parent: $NodeWithStatements,\n  ctx: Context,\n  idx: number,\n): $$ESLabelledItem {\n  switch (node.kind) {\n    case SyntaxKind.VariableStatement:\n      return new $VariableStatement(node, parent, ctx, idx);\n    case SyntaxKind.FunctionDeclaration:\n      return new $FunctionDeclaration(node, parent, ctx, idx);\n    default:\n      return $$esStatement(node, parent, ctx, idx);\n  }\n}\n\n// #endregion\n\n// #region AST helpers\n\nexport function GetDirectivePrologue(statements: readonly Statement[]): DirectivePrologue {\n  let directivePrologue: ExpressionStatement_T<StringLiteral>[] = emptyArray;\n\n  let statement: ExpressionStatement_T<StringLiteral>;\n  const len = statements.length;\n  for (let i = 0; i < len; ++i) {\n    statement = statements[i] as ExpressionStatement_T<StringLiteral>;\n    if (\n      statement.kind === SyntaxKind.ExpressionStatement\n      && statement.expression.kind === SyntaxKind.StringLiteral\n    ) {\n      if (directivePrologue === emptyArray) {\n        directivePrologue = [statement];\n      } else {\n        directivePrologue.push(statement);\n      }\n      if (statement.expression.text === 'use strict') {\n        (directivePrologue as Writable<DirectivePrologue>).ContainsUseStrict = true;\n      }\n    } else {\n      break;\n    }\n  }\n\n  return directivePrologue;\n}\n\nexport function GetExpectedArgumentCount(params: readonly $ParameterDeclaration[]): number {\n  for (let i = 0, ii = params.length; i < ii; ++i) {\n    if (params[i].HasInitializer) {\n      return i;\n    }\n  }\n\n  return params.length;\n}\n\nexport function evaluateStatement(\n  ctx: ExecutionContext,\n  statement: $$ESLabelledItem,\n): $Any {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  let stmtCompletion: $Any = intrinsics.empty;\n  switch (statement.$kind) {\n    case SyntaxKind.Block:\n    case SyntaxKind.VariableStatement:\n    case SyntaxKind.EmptyStatement:\n    case SyntaxKind.ExpressionStatement:\n    case SyntaxKind.IfStatement:\n    case SyntaxKind.SwitchStatement:\n    case SyntaxKind.ContinueStatement:\n    case SyntaxKind.BreakStatement:\n    case SyntaxKind.ReturnStatement:\n    case SyntaxKind.WithStatement:\n    case SyntaxKind.LabeledStatement:\n    case SyntaxKind.ThrowStatement:\n    case SyntaxKind.TryStatement:\n    case SyntaxKind.DebuggerStatement:\n    case SyntaxKind.FunctionDeclaration:\n      stmtCompletion = statement.Evaluate(ctx);\n      break;\n    case SyntaxKind.DoStatement:\n    case SyntaxKind.WhileStatement:\n    case SyntaxKind.ForStatement:\n    case SyntaxKind.ForInStatement:\n    case SyntaxKind.ForOfStatement:\n      stmtCompletion = statement.EvaluateLabelled(ctx, new $StringSet());\n      break;\n    // Note that no default case is needed here as the cases above are exhausetive $$ESStatement (http://www.ecma-international.org/ecma-262/#prod-Statement)\n  }\n  return stmtCompletion;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-block-runtime-semantics-evaluation\n// StatementList : StatementList StatementListItem\nexport function evaluateStatementList(\n  ctx: ExecutionContext,\n  statements: readonly $$TSStatementListItem[],\n): $Any {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let sl be the result of evaluating StatementList.\n  // 2. ReturnIfAbrupt(sl).\n  // 3. Let s be the result of evaluating StatementListItem.\n  // 4. Return Completion(UpdateEmpty(s, sl)).\n  let sl: $Any = intrinsics.empty;\n  for (const statement of statements) {\n    const s = evaluateStatement(ctx, statement as $$ESStatement); // TODO handle the declarations.\n    if (s.isAbrupt) {\n      return s;\n    }\n    sl = sl.UpdateEmpty(s);\n  }\n\n  return sl;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-blockdeclarationinstantiation\nexport function BlockDeclarationInstantiation(\n  ctx: ExecutionContext,\n  lexicallyScopedDeclarations: readonly $$ESDeclaration[],\n  envRec: $DeclarativeEnvRec,\n): $Empty | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let envRec be env's EnvironmentRecord.\n  // 2. Assert: envRec is a declarative Environment Record.\n  // 3. Let declarations be the LexicallyScopedDeclarations of code.\n\n  // 4. For each element d in declarations, do\n  for (const d of lexicallyScopedDeclarations) {\n\n    // 4. a. For each element dn of the BoundNames of d, do\n    for (const dn of d.BoundNames) {\n      // 4. a. i. If IsConstantDeclaration of d is true, then\n      if (d.IsConstantDeclaration) {\n        // 4. a. i. 1. Perform ! envRec.CreateImmutableBinding(dn, true).\n        envRec.CreateImmutableBinding(ctx, dn, intrinsics.true);\n      } else {\n        // 4. a. ii. Else,\n        // 4. a. ii. 1. Perform ! envRec.CreateMutableBinding(dn, false).\n        envRec.CreateImmutableBinding(ctx, dn, intrinsics.false);\n      }\n    }\n\n    const dkind = d.$kind;\n    // 4. b. If d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then\n    if (dkind === SyntaxKind.FunctionDeclaration /* || dkind === SyntaxKind.GeneratorDeclaration || dkind === SyntaxKind.AsyncFunctionDeclaration || dkind === SyntaxKind.AsyncGeneratorDeclaration */) {\n      // 4. b. i. Let fn be the sole element of the BoundNames of d.\n      const fn = d.BoundNames[0];\n\n      // 4. b. ii. Let fo be the result of performing InstantiateFunctionObject for d with argument env.\n      const fo = (d as $FunctionDeclaration).InstantiateFunctionObject(ctx, envRec);\n      if (fo.isAbrupt) { return fo; }\n\n      // 4. b. iii. Perform envRec.InitializeBinding(fn, fo).\n      envRec.InitializeBinding(ctx, fn, fo);\n    }\n  }\n\n  return ctx.Realm['[[Intrinsics]]'].empty;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-isconstructor\nexport function IsConstructor(ctx: ExecutionContext, argument: $AnyNonEmpty): argument is $Function {\n  const intrinsics = ctx.Realm['[[Intrinsics]]'];\n  // 1. If Type(argument) is not Object, return false.\n  if (!argument.isObject) { return intrinsics.false.GetValue(ctx)['[[Value]]']; }\n\n  // 2. If argument has a [[Construct]] internal method, return true.\n  if (argument instanceof $Function && argument['[[Construct]]'] !== void 0) { return intrinsics.true.GetValue(ctx)['[[Value]]']; }\n\n  // 3. Return false.\n  return intrinsics.false.GetValue(ctx)['[[Value]]'];\n}\n\n// #endregion\n\n// #region AST\n\n// #region Declaration statements\nexport type $NodeWithDecorators = (\n  $GetAccessorDeclaration |\n  $SetAccessorDeclaration |\n  $ClassDeclaration |\n  $ConstructorDeclaration |\n  $EnumDeclaration |\n  $ExportAssignment |\n  $ExportDeclaration |\n  $FunctionDeclaration |\n  $ImportDeclaration |\n  $ImportEqualsDeclaration |\n  $InterfaceDeclaration |\n  $MethodDeclaration |\n  $ModuleDeclaration |\n  $ParameterDeclaration |\n  $PropertyDeclaration |\n  $TypeAliasDeclaration\n);\n\nexport function $decoratorList(\n  nodes: readonly Decorator[] | undefined,\n  parent: $NodeWithDecorators,\n  ctx: Context,\n): readonly $Decorator[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  if (nodes.length === 1) {\n    return [new $Decorator(nodes[0], parent, ctx, 0)];\n  }\n\n  const len = nodes.length;\n  const $nodes: $Decorator[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $Decorator(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\n// Simple property accessors used for some map/flatMap/some/every operations,\n// to avoid allocating a new arrow function for each of those calls.\nexport function getContainsExpression<T>(obj: { ContainsExpression: T }): T { return obj.ContainsExpression; }\nexport function getHasInitializer<T>(obj: { HasInitializer: T }): T { return obj.HasInitializer; }\nexport function getIsSimpleParameterList<T>(obj: { IsSimpleParameterList: T }): T { return obj.IsSimpleParameterList; }\nexport function getBoundNames<T>(obj: { BoundNames: T }): T { return obj.BoundNames; }\nexport function getLexicallyDeclaredNames<T>(obj: { LexicallyDeclaredNames: T }): T { return obj.LexicallyDeclaredNames; }\nexport function getLexicallyScopedDeclarations<T>(obj: { LexicallyScopedDeclarations: T }): T { return obj.LexicallyScopedDeclarations; }\nexport function getVarDeclaredNames<T>(obj: { VarDeclaredNames: T }): T { return obj.VarDeclaredNames; }\nexport function getVarScopedDeclarations<T>(obj: { VarScopedDeclarations: T }): T { return obj.VarScopedDeclarations; }\nexport function getLocalName<T>(obj: { LocalName: T }): T { return obj.LocalName; }\nexport function getImportEntriesForModule<T>(obj: { ImportEntriesForModule: T }): T { return obj.ImportEntriesForModule; }\nexport function getExportedNames<T>(obj: { ExportedNames: T }): T { return obj.ExportedNames; }\nexport function getExportEntriesForModule<T>(obj: { ExportEntriesForModule: T }): T { return obj.ExportEntriesForModule; }\nexport function getReferencedBindings<T>(obj: { ReferencedBindings: T }): T { return obj.ReferencedBindings; }\n\nexport function $heritageClauseList(\n  nodes: readonly HeritageClause[] | undefined,\n  parent: $$NodeWithHeritageClauses,\n  ctx: Context,\n): readonly $HeritageClause[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $HeritageClause[] = Array(len);\n  for (let i = 0; i < len; ++i) {\n    $nodes[i] = new $HeritageClause(nodes[i], parent, ctx, i);\n  }\n  return $nodes;\n}\n\nexport function $$classElementList(\n  nodes: readonly $ClassElementNode[] | undefined,\n  parent: $ClassDeclaration | $ClassExpression,\n  ctx: Context,\n): readonly $$ClassElement[] {\n  if (nodes === void 0 || nodes.length === 0) {\n    return emptyArray;\n  }\n\n  const len = nodes.length;\n  const $nodes: $$ClassElement[] = [];\n  let $node: $$ClassElement | undefined;\n  let node: $ClassElementNode;\n  for (let i = 0; i < len; ++i) {\n    node = nodes[i];\n    if ((node as { body?: Block }).body !== void 0) {\n      $node = $$classElement(nodes[i], parent, ctx, i);\n      if ($node !== void 0) {\n        $nodes.push($node);\n      }\n    }\n  }\n  return $nodes;\n}\n\nexport type $$ClassElement = (\n  $GetAccessorDeclaration |\n  $SetAccessorDeclaration |\n  $ConstructorDeclaration |\n  $MethodDeclaration |\n  $SemicolonClassElement |\n  $PropertyDeclaration\n);\n\nexport function $$classElement(\n  node: $ClassElementNode,\n  parent: $ClassDeclaration | $ClassExpression,\n  ctx: Context,\n  idx: number,\n): $$ClassElement | undefined {\n  switch (node.kind) {\n    case SyntaxKind.PropertyDeclaration:\n      return new $PropertyDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.SemicolonClassElement:\n      return new $SemicolonClassElement(node, parent, ctx, idx);\n    case SyntaxKind.MethodDeclaration:\n      return new $MethodDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.Constructor:\n      return new $ConstructorDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.GetAccessor:\n      return new $GetAccessorDeclaration(node, parent, ctx, idx);\n    case SyntaxKind.SetAccessor:\n      return new $SetAccessorDeclaration(node, parent, ctx, idx);\n    default:\n      return void 0;\n  }\n}\n\nexport type $$MethodDefinition = (\n  $MethodDeclaration |\n  $GetAccessorDeclaration |\n  $SetAccessorDeclaration\n);\n\n// #endregion\n\nexport function hasBit(flag: number, bit: number): boolean {\n  return (flag & bit) > 0;\n}\n\nexport function hasAllBits(flag: number, bit: number): boolean {\n  return (flag & bit) === bit;\n}\n\nexport function clearBit(flag: number, bit: number): number {\n  return (flag | bit) ^ bit;\n}\n\nexport const enum Context {\n  None                      = 0b00000000000000000,\n  Dynamic                   = 0b00000000000000010,\n  InVariableStatement       = 0b00000000000000100,\n  IsBindingName             = 0b00000000000001000,\n  InParameterDeclaration    = 0b00000000000010000,\n  InCatchClause             = 0b00000000000100000,\n  InBindingPattern          = 0b00000000001000000,\n  InTypeElement             = 0b00000000010000000,\n  IsPropertyAccessName      = 0b00000000100000000,\n  IsMemberName              = 0b00000001000000000,\n  IsLabel                   = 0b00000010000000000,\n  IsLabelReference          = 0b00000100000000000,\n  InExport                  = 0b00001000000000000,\n  IsConst                   = 0b00010000000000000,\n  IsLet                     = 0b00100000000000000,\n  IsBlockScoped             = 0b00110000000000000,\n  IsVar                     = 0b01000000000000000,\n  IsFunctionScoped          = 0b01000000000000000,\n  InStrictMode              = 0b10000000000000000,\n}\n\nexport const modifiersToModifierFlags = (function () {\n  const lookup = Object.assign(Object.create(null) as {}, {\n    [SyntaxKind.ConstKeyword]: ModifierFlags.Const,\n    [SyntaxKind.DefaultKeyword]: ModifierFlags.Default,\n    [SyntaxKind.ExportKeyword]: ModifierFlags.Export,\n    [SyntaxKind.AsyncKeyword]: ModifierFlags.Async,\n    [SyntaxKind.PrivateKeyword]: ModifierFlags.Private,\n    [SyntaxKind.ProtectedKeyword]: ModifierFlags.Protected,\n    [SyntaxKind.PublicKeyword]: ModifierFlags.Public,\n    [SyntaxKind.StaticKeyword]: ModifierFlags.Static,\n    [SyntaxKind.AbstractKeyword]: ModifierFlags.Abstract,\n    [SyntaxKind.DeclareKeyword]: ModifierFlags.Ambient,\n    [SyntaxKind.ReadonlyKeyword]: ModifierFlags.Readonly,\n  } as const);\n\n  return function (mods: readonly Modifier[] | undefined): ModifierFlags {\n    if (mods === void 0) {\n      return ModifierFlags.None;\n    }\n    const len = mods.length;\n    if (len === 1) {\n      // todo(fred): bigopon added these cast, as it causes issues to the build\n      //             it's from existing working code, though the cast is really weird when the lookup only has a few keys\n      return (lookup as IIndexable)[mods[0].kind] as ModifierFlags;\n    } else if (len === 2) {\n      return (lookup as IIndexable)[mods[0].kind] as ModifierFlags + ((lookup as IIndexable)[mods[1].kind] as ModifierFlags);\n    } else if (len === 3) {\n      return ((lookup as IIndexable)[mods[0].kind] as ModifierFlags)\n        + ((lookup as IIndexable)[mods[1].kind] as ModifierFlags)\n        + ((lookup as IIndexable)[mods[2].kind] as ModifierFlags);\n    } else {\n      // More than 4 modifiers is not possible\n      return ((lookup as IIndexable)[mods[0].kind] as ModifierFlags)\n        + ((lookup as IIndexable)[mods[1].kind] as ModifierFlags)\n        + ((lookup as IIndexable)[mods[2].kind] as ModifierFlags)\n        + ((lookup as IIndexable)[mods[3].kind] as ModifierFlags);\n    }\n  };\n})();\n\nexport const enum FunctionKind {\n  normal           = 0b0000,\n  nonConstructor   = 0b0001,\n  classConstructor = 0b0010,\n  generator        = 0b0100,\n  async            = 0b1000,\n  asyncGenerator   = 0b1100,\n}\n\n/**\n * Returns the indexed string representation, or an empty string if the number is -1.\n */\nexport function $i(idx: number): string {\n  return idx === -1 ? '' : `[${idx}]`;\n}\n\nexport interface I$Node<\n  TNode extends object = object,\n> {\n  readonly depth: number;\n  readonly realm: Realm;\n  readonly parent: I$Node;\n  readonly node: TNode;\n  readonly ctx: Context;\n  readonly path: string;\n}\n","import {\n  $Object,\n} from '../types/object.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $Function,\n  $BuiltinFunction,\n} from '../types/function.js';\n\nimport {\n  $PropertyKey,\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  $AnyObject,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $EnvRec,\n} from '../types/environment-record.js';\nimport {\n  $CreateDataProperty,\n  $DefinePropertyOrThrow,\n  $HasOwnProperty,\n  $Set,\n} from '../operations.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $PropertyDescriptor,\n  $IsDataDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $Error,\n} from '../types/error.js';\nimport {\n  $ParameterDeclaration,\n} from '../ast/functions.js';\nimport {\n  getBoundNames,\n} from '../ast/_shared.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects\nexport class $ArgumentsExoticObject extends $Object<'ArgumentsExoticObject'> {\n  public readonly '[[ParameterMap]]': $AnyObject;\n\n  // http://www.ecma-international.org/ecma-262/#sec-createmappedargumentsobject\n  // 9.4.4.7 CreateMappedArgumentsObject ( func , formals , argumentsList , env )\n  public constructor(\n    realm: Realm,\n    func: $Function,\n    formals: readonly $ParameterDeclaration[],\n    argumentsList: readonly $AnyNonEmpty [],\n    env: $EnvRec,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'ArgumentsExoticObject', intrinsics['%ObjectPrototype%'], CompletionType.normal, intrinsics.empty);\n\n    const ctx = realm.stack.top;\n\n    // 1. Assert: formals does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.\n    // 2. Let len be the number of elements in argumentsList.\n    const len = argumentsList.length;\n\n    // 3. Let obj be a newly created arguments exotic object with a [[ParameterMap]] internal slot.\n    // 4. Set obj.[[GetOwnProperty]] as specified in 9.4.4.1.\n    // 5. Set obj.[[DefineOwnProperty]] as specified in 9.4.4.2.\n    // 6. Set obj.[[Get]] as specified in 9.4.4.3.\n    // 7. Set obj.[[Set]] as specified in 9.4.4.4.\n    // 8. Set obj.[[Delete]] as specified in 9.4.4.5.\n    // 9. Set the remainder of obj's essential internal methods to the default ordinary object definitions specified in 9.1.\n    // 10. Set obj.[[Prototype]] to %ObjectPrototype%.\n    // 11. Set obj.[[Extensible]] to true.\n    // 12. Let map be ObjectCreate(null).\n    const map = new $Object(realm, '[[ParameterMap]]', intrinsics.null, CompletionType.normal, intrinsics.empty);\n\n    // 13. Set obj.[[ParameterMap]] to map.\n    this['[[ParameterMap]]'] = map;\n\n    // 14. Let parameterNames be the BoundNames of formals.\n    const parameterNames = formals.flatMap(getBoundNames);\n\n    // 15. Let numberOfParameters be the number of elements in parameterNames.\n    const numberOfParameters = parameterNames.length;\n\n    // 16. Let index be 0.\n    let index = 0;\n\n    // 17. Repeat, while index < len,\n    while (index < len) {\n      // 17. a. Let val be argumentsList[index].\n      const val = argumentsList[index];\n\n      // 17. b. Perform CreateDataProperty(obj, ! ToString(index), val).\n      $CreateDataProperty(ctx, this, new $String(realm, index.toString()), val);\n\n      // 17. c. Increase index by 1.\n      ++index;\n    }\n\n    // 18. Perform DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).\n    const desc = new $PropertyDescriptor(realm, intrinsics.length);\n    desc['[[Value]]'] = new $Number(realm, len);\n\n    // 19. Let mappedNames be a new empty List.\n    const mappedNames = [] as $String[];\n\n    // 20. Let index be numberOfParameters - 1.\n    index = numberOfParameters - 1;\n\n    // 21. Repeat, while index ≥ 0,\n    while (index >= 0) {\n      // 21. a. Let name be parameterNames[index].\n      const name = parameterNames[index];\n\n      // 21. b. If name is not an element of mappedNames, then\n      if (!mappedNames.some(x => x.is(name))) {\n        // 21. b. i. Add name as an element of the list mappedNames.\n        mappedNames.push(name);\n\n        // 21. b. ii. If index < len, then\n        if (index < len) {\n          // 21. b. ii. 1. Let g be MakeArgGetter(name, env).\n          const g = new $ArgGetter(realm, name, env);\n\n          // 21. b. ii. 2. Let p be MakeArgSetter(name, env).\n          const p = new $ArgSetter(realm, name, env);\n\n          // 21. b. ii. 3. Perform map.[[DefineOwnProperty]](! ToString(index), PropertyDescriptor { [[Set]]: p, [[Get]]: g, [[Enumerable]]: false, [[Configurable]]: true }).\n          const desc = new $PropertyDescriptor(\n            realm,\n            new $String(realm, index.toString()),\n            {\n              '[[Set]]': p,\n              '[[Get]]': g,\n              '[[Enumerable]]': intrinsics.false,\n              '[[Configurable]]': intrinsics.true,\n            },\n          );\n          map['[[DefineOwnProperty]]'](ctx, desc.name, desc);\n        }\n      }\n\n      // 21. c. Decrease index by 1.\n      --index;\n    }\n\n    // 22. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).\n    const iteratorDesc = new $PropertyDescriptor(\n      realm,\n      intrinsics['@@iterator'],\n      {\n        '[[Value]]': intrinsics['%ArrayProto_values%'],\n        '[[Writable]]': intrinsics.true,\n        '[[Enumerable]]': intrinsics.false,\n        '[[Configurable]]': intrinsics.true,\n      },\n    );\n    $DefinePropertyOrThrow(ctx, this, iteratorDesc.name, iteratorDesc);\n\n    // 23. Perform ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor { [[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).\n    const calleeDesc = new $PropertyDescriptor(\n      realm,\n      intrinsics.$callee,\n      {\n        '[[Value]]': func,\n        '[[Writable]]': intrinsics.true,\n        '[[Enumerable]]': intrinsics.false,\n        '[[Configurable]]': intrinsics.true,\n      },\n    );\n    $DefinePropertyOrThrow(ctx, this, calleeDesc.name, calleeDesc);\n\n    // 24. Return obj.\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-getownproperty-p\n  // 9.4.4.1 [[GetOwnProperty]] ( P )\n  public '[[GetOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $PropertyDescriptor | $Undefined {\n    // 1. Let args be the arguments object.\n    // 2. Let desc be OrdinaryGetOwnProperty(args, P).\n    const desc = super['[[GetOwnProperty]]'](ctx, P) as $PropertyDescriptor | $Undefined;\n\n    // 3. If desc is undefined, return desc.\n    if (desc.isUndefined) {\n      return desc;\n    }\n\n    // 4. Let map be args.[[ParameterMap]].\n    const map = this['[[ParameterMap]]'];\n\n    // 5. Let isMapped be ! HasOwnProperty(map, P).\n    const isMapped = ($HasOwnProperty(ctx, map, P) as $Boolean).isTruthy;\n\n    // 6. If isMapped is true, then\n    if (isMapped) {\n      // 6. a. Set desc.[[Value]] to Get(map, P).\n      desc['[[Value]]'] = map['[[Get]]'](ctx, P, map) as $AnyNonEmpty;\n    }\n\n    // 7. Return desc.\n    return desc;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-defineownproperty-p-desc\n  // 9.4.4.2 [[DefineOwnProperty]] ( P , Desc )\n  public '[[DefineOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Desc: $PropertyDescriptor,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let args be the arguments object.\n    // 2. Let map be args.[[ParameterMap]].\n    const map = this['[[ParameterMap]]'];\n\n    // 3. Let isMapped be HasOwnProperty(map, P).\n    const isMapped = ($HasOwnProperty(ctx, map, P) as $Boolean).isTruthy;\n\n    // 4. Let newArgDesc be Desc.\n    let newArgDesc = Desc;\n\n    // 5. If isMapped is true and IsDataDescriptor(Desc) is true, then\n    if (isMapped && $IsDataDescriptor(Desc)) {\n      // 5. a. If Desc.[[Value]] is not present and Desc.[[Writable]] is present and its value is false, then\n      if (Desc['[[Value]]'].isEmpty && Desc['[[Writable]]'].hasValue && Desc['[[Writable]]'].isFalsey) {\n        // 5. a. i. Set newArgDesc to a copy of Desc.\n        newArgDesc = new $PropertyDescriptor(\n          Desc.realm,\n          Desc.name,\n          {\n            // 5. a. ii. Set newArgDesc.[[Value]] to Get(map, P).\n            '[[Value]]': map['[[Get]]'](ctx, P, map) as $AnyNonEmpty,\n            '[[Writable]]': Desc['[[Writable]]'],\n            '[[Enumerable]]': Desc['[[Enumerable]]'],\n            '[[Configurable]]': Desc['[[Configurable]]'],\n          },\n        );\n      }\n    }\n\n    // 6. Let allowed be ? OrdinaryDefineOwnProperty(args, P, newArgDesc).\n    const allowed = super['[[DefineOwnProperty]]'](ctx, P, newArgDesc);\n    if (allowed.isAbrupt) { return allowed; }\n\n    // 7. If allowed is false, return false.\n    if (allowed.isFalsey) {\n      return allowed;\n    }\n\n    // 8. If isMapped is true, then\n    if (isMapped) {\n      // 8. a. If IsAccessorDescriptor(Desc) is true, then\n      if (Desc.isAccessorDescriptor) {\n        // 8. a. i. Call map.[[Delete]](P).\n        map['[[Delete]]'](ctx, P);\n      }\n    }\n    // 8. b. Else,\n    else {\n      // 8. b. i. If Desc.[[Value]] is present, then\n      if (Desc['[[Value]]'].hasValue) {\n        // 8. b. i. 1. Let setStatus be Set(map, P, Desc.[[Value]], false).\n        const setStatus = $Set(ctx, map, P, Desc['[[Value]]'], intrinsics.false);\n\n        // 8. b. i. 2. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n        // 8. b. ii. If Desc.[[Writable]] is present and its value is false, then\n        if (Desc['[[Writable]]'].hasValue && Desc['[[Writable]]'].isFalsey) {\n          // 8. b. ii. 1. Call map.[[Delete]](P).\n          map['[[Delete]]'](ctx, P);\n        }\n      }\n    }\n\n    // 9. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-get-p-receiver\n  // 9.4.4.3 [[Get]] ( P , Receiver )\n  public '[[Get]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Receiver: $AnyObject,\n  ): $AnyNonEmpty  {\n    // 1. Let args be the arguments object.\n    // 2. Let map be args.[[ParameterMap]].\n    const map = this['[[ParameterMap]]'];\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    const isMapped = ($HasOwnProperty(ctx, map, P) as $Boolean).isTruthy;\n\n    // 4. If isMapped is false, then\n    if (!isMapped) {\n      // 4. a. Return ? OrdinaryGet(args, P, Receiver).\n      return super['[[Get]]'](ctx, P, Receiver);\n    }\n    // 5. Else map contains a formal parameter mapping for P,\n    else {\n      // 5. a. Return Get(map, P).\n      return map['[[Get]]'](ctx, P, map);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-set-p-v-receiver\n  // 9.4.4.4 [[Set]] ( P , V , Receiver )\n  public '[[Set]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    V: $AnyNonEmpty ,\n    Receiver: $AnyObject,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let args be the arguments object.\n    // 2. If SameValue(args, Receiver) is false, then\n    // 2. a. Let isMapped be false.\n    // 3. Else,\n    // 3. a. Let map be args.[[ParameterMap]].\n    // 3. b. Let isMapped be ! HasOwnProperty(map, P).\n    // 4. If isMapped is true, then\n    // 4. a. Let setStatus be Set(map, P, V, false).\n    // 4. b. Assert: setStatus is true because formal parameters mapped by argument objects are always writable.\n    // 5. Return ? OrdinarySet(args, P, V, Receiver).\n    if (this.is(Receiver)) {\n      const map = this['[[ParameterMap]]'];\n\n      const isMapped = ($HasOwnProperty(ctx, map, P) as $Boolean).isTruthy;\n      if (isMapped) {\n        const setStatus = $Set(ctx, map, P, V, intrinsics.false);\n      }\n    }\n\n    return super['[[Set]]'](ctx, P, V, Receiver);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arguments-exotic-objects-delete-p\n  // 9.4.4.5 [[Delete]] ( P )\n  public '[[Delete]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    // 1. Let args be the arguments object.\n    // 2. Let map be args.[[ParameterMap]].\n    const map = this['[[ParameterMap]]'];\n\n    // 3. Let isMapped be ! HasOwnProperty(map, P).\n    const isMapped = ($HasOwnProperty(ctx, map, P) as $Boolean).isTruthy;\n\n    // 4. Let result be ? OrdinaryDelete(args, P).\n    const result = super['[[Delete]]'](ctx, P);\n    if (result.isAbrupt) { return result; }\n\n    // 5. If result is true and isMapped is true, then\n    if (result.isTruthy && isMapped) {\n      // 5. a. Call map.[[Delete]](P).\n      map['[[Delete]]'](ctx, P);\n    }\n\n    // 6. Return result.\n    return result;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-makearggetter\nexport class $ArgGetter extends $BuiltinFunction {\n  public readonly '[[Name]]': $String;\n  public readonly '[[Env]]': $EnvRec;\n\n  public constructor(\n    realm: Realm,\n    name: $String,\n    env: $EnvRec,\n  ) {\n    super(realm, 'ArgGetter', realm['[[Intrinsics]]']['%FunctionPrototype%']);\n\n    // 3. Set getter.[[Name]] to name.\n    this['[[Name]]'] = name;\n    // 4. Set getter.[[Env]] to env.\n    this['[[Env]]'] = env;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let f be the active function object.\n    // 2. Let name be f.[[Name]].\n    const name = this['[[Name]]'];\n\n    // 3. Let env be f.[[Env]].\n    const env = this['[[Env]]'];\n\n    // 4. Return env.GetBindingValue(name, false).\n    return env.GetBindingValue(ctx, name, intrinsics.false);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-makeargsetter\nexport class $ArgSetter extends $BuiltinFunction {\n  public readonly '[[Name]]': $String;\n  public readonly '[[Env]]': $EnvRec;\n\n  public constructor(\n    realm: Realm,\n    name: $String,\n    env: $EnvRec,\n  ) {\n    super(realm, 'ArgSetter', realm['[[Intrinsics]]']['%FunctionPrototype%']);\n\n    // 3. Set getter.[[Name]] to name.\n    this['[[Name]]'] = name;\n    // 4. Set getter.[[Env]] to env.\n    this['[[Env]]'] = env;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let f be the active function object.\n    // 2. Let name be f.[[Name]].\n    const name = this['[[Name]]'];\n\n    // 3. Let env be f.[[Env]].\n    const env = this['[[Env]]'];\n\n    // 4. Return env.SetMutableBinding(name, value, false).\n    return env.SetMutableBinding(ctx, name, value, intrinsics.false) as $AnyNonEmpty; // TODO: we probably need to change the signature of performSteps to return $Any but that may open a new can of worms, so leave it for now and revisit when we're further down the road and implemented more natives\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createunmappedargumentsobject\nexport function $CreateUnmappedArgumentsObject(\n  ctx: ExecutionContext,\n  argumentsList: readonly $AnyNonEmpty [],\n): $AnyObject {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let len be the number of elements in argumentsList.\n  const len = argumentsList.length;\n\n  // 2. Let obj be ObjectCreate(%ObjectPrototype%, « [[ParameterMap]] »).\n  const obj = $Object.ObjectCreate(\n    ctx,\n    'UnmappedArgumentsObject',\n    intrinsics['%ObjectPrototype%'],\n    {\n      '[[ParameterMap]]': intrinsics.undefined,\n    },\n  );\n\n  // 3. Set obj.[[ParameterMap]] to undefined.\n  // 4. Perform DefinePropertyOrThrow(obj, \"length\", PropertyDescriptor { [[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).\n  $DefinePropertyOrThrow(\n    ctx,\n    obj,\n    intrinsics.length,\n    new $PropertyDescriptor(\n      realm,\n      intrinsics.length,\n      {\n        '[[Value]]': new $Number(realm, len),\n        '[[Writable]]': intrinsics.true,\n        '[[Enumerable]]': intrinsics.false,\n        '[[Configurable]]': intrinsics.true,\n      },\n    ),\n  );\n\n  // 5. Let index be 0.\n  let index = 0;\n\n  // 6. Repeat, while index < len,\n  while (index < len) {\n    // 6. a. Let val be argumentsList[index].\n    const val = argumentsList[index];\n\n    // 6. b. Perform CreateDataProperty(obj, ! ToString(index), val).\n    $CreateDataProperty(ctx, obj, new $String(realm, index.toString()), val);\n\n    // 6. c. Increase index by 1.\n    ++index;\n  }\n\n  // 7. Perform ! DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor { [[Value]]: %ArrayProto_values%, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }).\n  $DefinePropertyOrThrow(\n    ctx,\n    obj,\n    intrinsics['@@iterator'],\n    new $PropertyDescriptor(\n      realm,\n      intrinsics['@@iterator'],\n      {\n        '[[Value]]': intrinsics['%ArrayProto_values%'],\n        '[[Writable]]': intrinsics.true,\n        '[[Enumerable]]': intrinsics.false,\n        '[[Configurable]]': intrinsics.true,\n      },\n    ),\n  );\n\n  // 8. Perform ! DefinePropertyOrThrow(obj, \"callee\", PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false }).\n  $DefinePropertyOrThrow(\n    ctx,\n    obj,\n    intrinsics.$callee,\n    new $PropertyDescriptor(\n      realm,\n      intrinsics.$callee,\n      {\n        '[[Get]]': intrinsics['%ThrowTypeError%'],\n        '[[Set]]': intrinsics['%ThrowTypeError%'],\n        '[[Enumerable]]': intrinsics.false,\n        '[[Configurable]]': intrinsics.false,\n      },\n    ),\n  );\n\n  // 9. Return obj.\n  return obj;\n}\n","import {\n  ArrowFunction,\n  Block,\n  ConstructorDeclaration,\n  FunctionDeclaration,\n  FunctionExpression,\n  ModifierFlags,\n  ParameterDeclaration,\n  SyntaxKind,\n} from 'typescript';\nimport {\n  emptyArray,\n  ILogger,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $EnvRec,\n  $DeclarativeEnvRec,\n  $FunctionEnvRec,\n} from '../types/environment-record.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $Any,\n  CompletionType,\n  $AnyNonEmpty,\n  $PropertyKey,\n} from '../types/_shared.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Empty,\n} from '../types/empty.js';\nimport {\n  $CreateUnmappedArgumentsObject,\n  $ArgumentsExoticObject,\n} from '../exotics/arguments.js';\nimport {\n  $CreateListIteratorRecord,\n  $IteratorRecord,\n  $IteratorStep,\n  $IteratorValue,\n} from '../globals/iteration.js';\nimport {\n  $Error,\n} from '../types/error.js';\nimport {\n  I$Node,\n  Context,\n  $$ESDeclaration,\n  $NodeWithStatements,\n  modifiersToModifierFlags,\n  hasBit,\n  $identifier,\n  $$AssignmentExpressionOrHigher,\n  $assignmentExpression,\n  $AssignmentExpressionNode,\n  $$TSDeclaration,\n  $$BindingName,\n  $$bindingName,\n  $AnyParentNode,\n  GetDirectivePrologue,\n  $decoratorList,\n  $i,\n  $$ESVarDeclaration,\n  FunctionKind,\n} from './_shared.js';\nimport {\n  ExportEntryRecord,\n  $$ESModuleOrScript,\n} from './modules.js';\nimport {\n  $Identifier,\n  $Decorator,\n} from './expressions.js';\nimport {\n  $ClassDeclaration,\n  $ClassExpression,\n} from './classes.js';\nimport {\n  $Block,\n  DirectivePrologue,\n} from './statements.js';\nimport {\n  $MethodDeclaration,\n  $SetAccessorDeclaration,\n  $GetAccessorDeclaration,\n} from './methods.js';\nimport {\n  $DefinePropertyOrThrow,\n} from '../operations.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $List,\n} from '../types/list.js';\n\nexport type $$Function = (\n  $FunctionDeclaration |\n  $FunctionExpression |\n  $MethodDeclaration |\n  $ConstructorDeclaration |\n  $SetAccessorDeclaration |\n  $GetAccessorDeclaration |\n  $ArrowFunction\n);\n\nexport class $FormalParameterList extends Array<$ParameterDeclaration> {\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames\n  // 13.3.3.1 Static Semantics: BoundNames\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-boundnames\n  // 14.1.3 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-containsexpression\n  // 14.1.5 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: boolean = false;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-expectedargumentcount\n  // 14.1.7 Static Semantics: ExpectedArgumentCount\n  public readonly ExpectedArgumentCount: number = 0;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-hasinitializer\n  // 14.1.8 Static Semantics: HasInitializer\n  public readonly HasInitializer: boolean = false;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-issimpleparameterlist\n  // 14.1.13 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: boolean = true;\n  public readonly hasDuplicates: boolean = false;\n\n  public constructor(\n    nodes: readonly ParameterDeclaration[] | undefined,\n    parent: $$Function,\n    ctx: Context,\n  ) {\n    super();\n\n    if (nodes === void 0) {\n      this.BoundNames = emptyArray;\n    } else {\n      const BoundNames = this.BoundNames = [] as $String[];\n\n      const seenNames = new Set<string>();\n      let boundNamesLen = 0;\n\n      let cur: $ParameterDeclaration;\n      let curBoundNames: readonly $String[];\n      let curBoundName: $String;\n      for (let i = 0, ii = nodes.length; i < ii; ++i) {\n        cur = super[i] = new $ParameterDeclaration(nodes[i], parent, ctx, i);\n\n        curBoundNames = cur.BoundNames;\n        for (let j = 0, jj = curBoundNames.length; j < jj; ++j) {\n          curBoundName = curBoundNames[j];\n          if (seenNames.has(curBoundName['[[Value]]'])) {\n            this.hasDuplicates = true;\n          } else {\n            seenNames.add(curBoundName['[[Value]]']);\n          }\n\n          BoundNames[boundNamesLen++] = curBoundName;\n        }\n\n        if (cur.ContainsExpression && !this.ContainsExpression) {\n          this.ContainsExpression = true;\n        }\n\n        if (cur.HasInitializer && !this.HasInitializer) {\n          this.HasInitializer = true;\n          this.ExpectedArgumentCount = i;\n        }\n\n        if (!cur.IsSimpleParameterList && this.IsSimpleParameterList) {\n          this.IsSimpleParameterList = false;\n        }\n      }\n\n      if (!this.HasInitializer) {\n        this.ExpectedArgumentCount = nodes.length;\n      }\n    }\n  }\n}\n\nexport class $FunctionExpression implements I$Node {\n  public get $kind(): SyntaxKind.FunctionExpression { return SyntaxKind.FunctionExpression; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $name: $Identifier | undefined;\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-boundnames\n  // 14.1.3 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-containsusestrict\n  // 14.1.6 Static Semantics: ContainsUseStrict\n  public readonly ContainsUseStrict: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-hasname\n  // 14.1.9 Static Semantics: HasName\n  public readonly HasName: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isconstantdeclaration\n  // 14.1.11 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isfunctiondefinition\n  // 14.1.12 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: true = true;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.1.14 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.1.15 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-vardeclarednames\n  // 14.1.16 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-varscopeddeclarations\n  // 14.1.17 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly DirectivePrologue: DirectivePrologue;\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public readonly functionKind: FunctionKind.normal | FunctionKind.generator | FunctionKind.async | FunctionKind.asyncGenerator;\n\n  public constructor(\n    public readonly node: FunctionExpression,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.FunctionExpression`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    const DirectivePrologue = this.DirectivePrologue = GetDirectivePrologue(node.body!.statements);\n    if (DirectivePrologue.ContainsUseStrict) {\n      ctx |= Context.InStrictMode;\n    }\n\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n    this.$parameters = new $FormalParameterList(node.parameters, this, ctx);\n    const $body = this.$body = new $Block(node.body, this, ctx, -1);\n\n    this.BoundNames = emptyArray;\n    this.ContainsUseStrict = DirectivePrologue.ContainsUseStrict === true;\n    this.HasName = $name !== void 0;\n\n    this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;\n    this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;\n    this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;\n\n    if (!hasBit(modifierFlags, ModifierFlags.Async)) {\n      if (node.asteriskToken === void 0) {\n        this.functionKind = FunctionKind.normal;\n      } else {\n        this.functionKind = FunctionKind.generator;\n      }\n    } else if (node.asteriskToken === void 0) {\n      this.functionKind = FunctionKind.async;\n    } else {\n      this.functionKind = FunctionKind.asyncGenerator;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    return EvaluateBody(this, ctx, functionObject, argumentsList);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    switch (this.functionKind) {\n      case FunctionKind.normal:\n        return this.$Evaluate(ctx);\n      case FunctionKind.generator:\n        return this.$EvaluateGenerator(ctx);\n      case FunctionKind.asyncGenerator:\n        return this.$EvaluateAsyncGenerator(ctx);\n      case FunctionKind.async:\n        return this.$EvaluateAsync(ctx);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluation\n  // 14.1.22 Runtime Semantics: Evaluation\n  private $Evaluate(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.$Evaluate(#${ctx.id})`);\n    // FunctionExpression :\n    //     function ( FormalParameters ) { FunctionBody }\n\n    // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    // 2. Let scope be the LexicalEnvironment of the running execution context.\n    // 3. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).\n    // 4. Perform MakeConstructor(closure).\n    // 5. Set closure.[[SourceText]] to the source text matched by FunctionExpression.\n    // 6. Return closure.\n\n    // FunctionExpression :\n    //     function BindingIdentifier ( FormalParameters ) { FunctionBody }\n\n    // 1. If the function code for FunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n    const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);\n\n    // 4. Let envRec be funcEnv's EnvironmentRecord.\n\n    // 5. Let name be StringValue of BindingIdentifier.\n    const name = this.$name?.StringValue ?? void 0;\n    if (name !== void 0) {\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false);\n    }\n\n    // 7. Let closure be FunctionCreate(Normal, FormalParameters, FunctionBody, funcEnv, strict).\n    const closure = $Function.FunctionCreate(ctx, 'normal', this, funcEnv, strict);\n\n    // 8. Perform MakeConstructor(closure).\n    closure.MakeConstructor(ctx);\n\n    if (name !== void 0) {\n      // 9. Perform SetFunctionName(closure, name).\n      closure.SetFunctionName(ctx, name);\n    }\n\n    // 10. Set closure.[[SourceText]] to the source text matched by FunctionExpression.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    if (name !== void 0) {\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      funcEnv.InitializeBinding(ctx, name, closure);\n    }\n\n    // 12. Return closure.\n    return closure;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-evaluation\n  // 14.4.14 Runtime Semantics: Evaluation\n  private $EvaluateGenerator(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.$EvaluateGenerator(#${ctx.id})`);\n\n    // GeneratorExpression :\n    //     function * ( FormalParameters ) { GeneratorBody }\n\n    // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    // 2. Let scope be the LexicalEnvironment of the running execution context.\n    // 3. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).\n    // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).\n    // 5. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    // 6. Set closure.[[SourceText]] to the source text matched by GeneratorExpression.\n    // 7. Return closure.\n\n    // GeneratorExpression :\n    //     function * BindingIdentifier ( FormalParameters ) { GeneratorBody }\n\n    // 1. If the function code for this GeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 3. Let funcEnv be NewDeclarativeEnvironment(scope).\n    const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);\n\n    // 4. Let envRec be funcEnv's EnvironmentRecord.\n    // 5. Let name be StringValue of BindingIdentifier.\n    const name = this.$name?.StringValue ?? void 0;\n    if (name !== void 0) {\n\n      // 6. Perform envRec.CreateImmutableBinding(name, false).\n      funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false);\n    }\n\n    // 7. Let closure be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, funcEnv, strict).\n    const closure = $Function.GeneratorFunctionCreate(ctx, 'normal', this, funcEnv, strict);\n\n    // 8. Let prototype be ObjectCreate(%GeneratorPrototype%).\n    const prototype = $Object.ObjectCreate(ctx, 'Generator', intrinsics['%GeneratorPrototype%']);\n\n    // 9. Perform DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(\n      ctx,\n      closure,\n      intrinsics.$prototype,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$prototype,\n        {\n          '[[Value]]': prototype,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n    if ($DefinePropertyOrThrowResult.isAbrupt) { return $DefinePropertyOrThrowResult.enrichWith(ctx, this); }\n\n    if (name !== void 0) {\n      // 10. Perform SetFunctionName(closure, name).\n      closure.SetFunctionName(ctx, name);\n\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      funcEnv.InitializeBinding(ctx, name, closure);\n    }\n\n    // 12. Set closure.[[SourceText]] to the source text matched by GeneratorExpression.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 13. Return closure.\n    return closure;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-definitions-evaluation\n  // 14.5.14 Runtime Semantics: Evaluation\n  private $EvaluateAsyncGenerator(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.$EvaluateAsyncGenerator(#${ctx.id})`);\n\n    // AsyncGeneratorExpression :\n    //     async function * ( FormalParameters ) { AsyncGeneratorBody }\n\n    // 1. If the function code for this AsyncGeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    // 2. Let scope be the LexicalEnvironment of the running execution context.\n    // 3. Let closure be ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict).\n    // 4. Let prototype be ! ObjectCreate(%AsyncGeneratorPrototype%).\n    // 5. Perform ! DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    // 6. Set closure.[[SourceText]] to the source text matched by AsyncGeneratorExpression.\n    // 7. Return closure.\n\n    // AsyncGeneratorExpression :\n    //     async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }\n\n    // 1. If the function code for this AsyncGeneratorExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 3. Let funcEnv be ! NewDeclarativeEnvironment(scope).\n    const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);\n\n    // 4. Let envRec be funcEnv's EnvironmentRecord.\n    // 5. Let name be StringValue of BindingIdentifier.\n    const name = this.$name?.StringValue ?? void 0;\n    if (name !== void 0) {\n\n      // 6. Perform ! envRec.CreateImmutableBinding(name).\n      funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false); // TODO: we sure about this?\n    }\n\n    // 7. Let closure be ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, funcEnv, strict).\n    const closure = $Function.AsyncGeneratorFunctionCreate(ctx, 'normal', this, funcEnv, strict);\n\n    // 8. Let prototype be ! ObjectCreate(%AsyncGeneratorPrototype%).\n    const prototype = $Object.ObjectCreate(ctx, 'AsyncGenerator', intrinsics['%AsyncGeneratorPrototype%']);\n\n    // 9. Perform ! DefinePropertyOrThrow(closure, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(\n      ctx,\n      closure,\n      intrinsics.$prototype,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$prototype,\n        {\n          '[[Value]]': prototype,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n    if ($DefinePropertyOrThrowResult.isAbrupt) { return $DefinePropertyOrThrowResult.enrichWith(ctx, this); }\n\n    if (name !== void 0) {\n      // 10. Perform SetFunctionName(closure, name).\n      closure.SetFunctionName(ctx, name);\n\n      // 11. Perform envRec.InitializeBinding(name, closure).\n      funcEnv.InitializeBinding(ctx, name, closure);\n    }\n\n    // 12. Set closure.[[SourceText]] to the source text matched by AsyncGeneratorExpression.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 13. Return closure.\n    return closure;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-runtime-semantics-evaluation\n  // 14.7.14 Runtime Semantics: Evaluation\n  private $EvaluateAsync(\n    ctx: ExecutionContext,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.$EvaluateAsync(#${ctx.id})`);\n\n    // AsyncFunctionExpression :\n    //     async function ( FormalParameters ) { AsyncFunctionBody }\n\n    // 1. If the function code for AsyncFunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    // 2. Let scope be the LexicalEnvironment of the running execution context.\n    // 3. Let closure be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).\n    // 4. Set closure.[[SourceText]] to the source text matched by AsyncFunctionExpression.\n    // 5. Return closure.\n\n    // AsyncFunctionExpression :\n    //     async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }\n\n    // 1. If the function code for AsyncFunctionExpression is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let scope be the LexicalEnvironment of the running execution context.\n    const scope = ctx.LexicalEnvironment;\n\n    // 3. Let funcEnv be ! NewDeclarativeEnvironment(scope).\n    const funcEnv = new $DeclarativeEnvRec(this.logger, realm, scope);\n\n    // 4. Let envRec be funcEnv's EnvironmentRecord.\n    // 5. Let name be StringValue of BindingIdentifier.\n    const name = this.$name?.StringValue ?? void 0;\n    if (name !== void 0) {\n\n      // 6. Perform ! envRec.CreateImmutableBinding(name).\n      funcEnv.CreateImmutableBinding(ctx, name, intrinsics.false); // TODO: we sure about this?\n    }\n\n    // 7. Let closure be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, funcEnv, strict).\n    const closure = $Function.AsyncFunctionCreate(ctx, 'normal', this, funcEnv, strict);\n\n    if (name !== void 0) {\n      // 8. Perform ! SetFunctionName(closure, name).\n      closure.SetFunctionName(ctx, name);\n\n      // 9. Perform ! envRec.InitializeBinding(name, closure).\n      funcEnv.InitializeBinding(ctx, name, closure);\n    }\n\n    // 10. Set closure.[[SourceText]] to the source text matched by AsyncFunctionExpression.\n    closure['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 11. Return closure.\n    return closure;\n  }\n\n  public EvaluateNamed(\n    ctx: ExecutionContext,\n    name: $String,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-namedevaluation\n    // 14.1.21 Runtime Semantics: NamedEvaluation\n    // FunctionExpression :\n    //     function ( FormalParameters ) { FunctionBody }\n\n    // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-namedevaluation\n    // 14.4.13 Runtime Semantics: NamedEvaluation\n    // GeneratorExpression :\n    //     function * ( FormalParameters ) { GeneratorBody }\n\n    // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-definitions-namedevaluation\n    // 14.5.13 Runtime Semantics: NamedEvaluation\n    // AsyncGeneratorExpression :\n    //     async function * ( FormalParameters ) { AsyncGeneratorBody }\n\n    // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-runtime-semantics-namedevaluation\n    // 14.7.13 Runtime Semantics: NamedEvaluation\n    // AsyncFunctionExpression :\n    //     async function ( FormalParameters ) { AsyncFunctionBody }\n\n    // FunctionExpression : function ( FormalParameters ) { FunctionBody }\n\n    // 1. Let closure be the result of evaluating this FunctionExpression.\n    // 1. Let closure be the result of evaluating this GeneratorExpression.\n    // 1. Let closure be the result of evaluating this AsyncGeneratorExpression.\n    // 1. Let closure be the result of evaluating this AsyncFunctionExpression.\n    const closure = this.Evaluate(ctx);\n    if (closure.isAbrupt) { return closure.enrichWith(ctx, this); }\n\n    // 2. Perform SetFunctionName(closure, name).\n    closure.SetFunctionName(ctx, name);\n\n    // 3. Return closure.\n    return closure;\n  }\n}\n\nexport class $FunctionDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.FunctionDeclaration { return SyntaxKind.FunctionDeclaration; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $Identifier | undefined;\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-boundnames\n  // 14.1.3 Static Semantics: BoundNames\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-boundnames\n  // 14.4.2 Static Semantics: BoundNames\n  // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-boundnames\n  // 14.5.2 Static Semantics: BoundNames\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-BoundNames\n  // 14.7.2 Static Semantics: BoundNames\n  public readonly BoundNames: readonly [$String | $String<'*default*'>] | readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-containsusestrict\n  // 14.1.6 Static Semantics: ContainsUseStrict\n  public readonly ContainsUseStrict: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-hasname\n  // 14.1.9 Static Semantics: HasName\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-hasname\n  // 14.4.6 Static Semantics: HasName\n  // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-hasname\n  // 14.5.6 Static Semantics: HasName\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-HasName\n  // 14.7.6 Static Semantics: HasName\n  public readonly HasName: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isconstantdeclaration\n  // 14.1.11 Static Semantics: IsConstantDeclaration\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-isconstantdeclaration\n  // 14.4.7 Static Semantics: IsConstantDeclaration\n  // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-isconstantdeclaration\n  // 14.5.7 Static Semantics: IsConstantDeclaration\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-IsConstantDeclaration\n  // 14.7.7 Static Semantics: IsConstantDeclaration\n  public readonly IsConstantDeclaration: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-isfunctiondefinition\n  // 14.1.12 Static Semantics: IsFunctionDefinition\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-isfunctiondefinition\n  // 14.4.8 Static Semantics: IsFunctionDefinition\n  // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-isfunctiondefinition\n  // 14.5.8 Static Semantics: IsFunctionDefinition\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-IsFunctionDefinition\n  // 14.7.8 Static Semantics: IsFunctionDefinition\n  public readonly IsFunctionDefinition: true = true;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.1.14 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.1.15 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-vardeclarednames\n  // 14.1.16 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-varscopeddeclarations\n  // 14.1.17 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-static-semantics-propname\n  // 14.4.9 Static Semantics: PropName\n  // http://www.ecma-international.org/ecma-262/#sec-async-generator-function-definitions-static-semantics-propname\n  // 14.5.9 Static Semantics: PropName\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-static-semantics-PropName\n  // 14.7.9 Static Semantics: PropName\n  public readonly PropName: $String | $Undefined;\n\n  public readonly DirectivePrologue: DirectivePrologue;\n\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportedbindings\n  // 15.2.3.3 Static Semantics: ExportedBindings\n  public readonly ExportedBindings: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportednames\n  // 15.2.3.4 Static Semantics: ExportedNames\n  public readonly ExportedNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-exportentries\n  // 15.2.3.5 Static Semantics: ExportEntries\n  public readonly ExportEntries: readonly ExportEntryRecord[];\n  // http://www.ecma-international.org/ecma-262/#sec-exports-static-semantics-modulerequests\n  // 15.2.3.9 Static Semantics: ModuleRequests\n  public readonly ModuleRequests: readonly $String[] = emptyArray;\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public readonly functionKind: FunctionKind.normal | FunctionKind.generator | FunctionKind.async | FunctionKind.asyncGenerator;\n\n  public constructor(\n    public readonly node: FunctionDeclaration,\n    public readonly parent: $NodeWithStatements,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.FunctionDeclaration`,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (hasBit(modifierFlags, ModifierFlags.Export)) {\n      ctx |= Context.InExport;\n    }\n\n    const DirectivePrologue = this.DirectivePrologue = GetDirectivePrologue(node.body!.statements);\n    if (this.DirectivePrologue.ContainsUseStrict) {\n      ctx |= Context.InStrictMode;\n    }\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    const $name = this.$name = $identifier(node.name, this, ctx, -1);\n    this.$parameters = new $FormalParameterList(node.parameters, this, ctx);\n    const $body = this.$body = new $Block(node.body!, this, ctx, -1);\n\n    this.ContainsUseStrict = DirectivePrologue.ContainsUseStrict === true;\n    const HasName = this.HasName = $name !== void 0;\n\n    this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;\n    this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;\n    this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;\n\n    if ($name === void 0) {\n      this.PropName = new $Undefined(realm);\n    } else {\n      this.PropName = $name.PropName;\n    }\n\n    if (hasBit(ctx, Context.InExport)) {\n      if (hasBit(this.modifierFlags, ModifierFlags.Default)) {\n        if (HasName) {\n          const [localName] = $name!.BoundNames;\n          const BoundNames = this.BoundNames = [localName, intrinsics['*default*']];\n\n          this.ExportedBindings = BoundNames;\n          this.ExportedNames = [intrinsics['default']];\n          this.ExportEntries = [\n            new ExportEntryRecord(\n              /* source */this,\n              /* ExportName */intrinsics['default'],\n              /* ModuleRequest */intrinsics.null,\n              /* ImportName */intrinsics.null,\n              /* LocalName */localName,\n            ),\n          ];\n        } else {\n          const BoundNames = this.BoundNames = [intrinsics['*default*']];\n\n          this.ExportedBindings = BoundNames;\n          this.ExportedNames = [intrinsics['default']];\n          this.ExportEntries = [\n            new ExportEntryRecord(\n              /* source */this,\n              /* ExportName */intrinsics['default'],\n              /* ModuleRequest */intrinsics.null,\n              /* ImportName */intrinsics.null,\n              /* LocalName */intrinsics['*default*'],\n            ),\n          ];\n        }\n      } else {\n        // Must have a name, so we assume it does\n        const BoundNames = this.BoundNames = $name!.BoundNames;\n        const [localName] = BoundNames;\n\n        this.ExportedBindings = BoundNames;\n        this.ExportedNames = BoundNames;\n        this.ExportEntries = [\n          new ExportEntryRecord(\n            /* source */this,\n            /* ExportName */localName,\n            /* ModuleRequest */intrinsics.null,\n            /* ImportName */intrinsics.null,\n            /* LocalName */localName,\n          ),\n        ];\n      }\n    } else {\n      // Must have a name, so we assume it does\n      this.BoundNames = $name!.BoundNames;\n\n      this.ExportedBindings = emptyArray;\n      this.ExportedNames = emptyArray;\n      this.ExportEntries = emptyArray;\n    }\n\n    if (!hasBit(modifierFlags, ModifierFlags.Async)) {\n      if (node.asteriskToken === void 0) {\n        this.functionKind = FunctionKind.normal;\n      } else {\n        this.functionKind = FunctionKind.generator;\n      }\n    } else if (node.asteriskToken === void 0) {\n      this.functionKind = FunctionKind.async;\n    } else {\n      this.functionKind = FunctionKind.asyncGenerator;\n    }\n  }\n\n  public InstantiateFunctionObject(\n    ctx: ExecutionContext,\n    Scope: $EnvRec,\n  ): $Function | $Error {\n    switch (this.functionKind) {\n      case FunctionKind.normal:\n        return this.$InstantiateFunctionObject(ctx, Scope);\n      case FunctionKind.generator:\n        return this.$InstantiateGeneratorFunctionObject(ctx, Scope);\n      case FunctionKind.asyncGenerator:\n        return this.$InstantiateAsyncGeneratorFunctionObject(ctx, Scope);\n      case FunctionKind.async:\n        return this.$InstantiateAsyncFunctionObject(ctx, Scope);\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-instantiatefunctionobject\n  // 14.1.20 Runtime Semantics: InstantiateFunctionObject\n  private $InstantiateFunctionObject(\n    ctx: ExecutionContext,\n    Scope: $EnvRec,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // FunctionDeclaration :\n    //     function ( FormalParameters ) { FunctionBody }\n    // 1. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, true).\n    // 2. Perform MakeConstructor(F).\n    // 3. Perform SetFunctionName(F, \"default\").\n    // 4. Set F.[[SourceText]] to the source text matched by FunctionDeclaration.\n    // 5. Return F.\n\n    // FunctionDeclaration :\n    //     function BindingIdentifier ( FormalParameters ) { FunctionBody }\n\n    // 1. If the function code for FunctionDeclaration is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let name be StringValue of BindingIdentifier.\n    const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;\n\n    // 3. Let F be FunctionCreate(Normal, FormalParameters, FunctionBody, scope, strict).\n    const F = $Function.FunctionCreate(ctx, 'normal', this, Scope, strict);\n\n    // 4. Perform MakeConstructor(F).\n    F.MakeConstructor(ctx);\n\n    // 5. Perform SetFunctionName(F, name).\n    F.SetFunctionName(ctx, name);\n\n    // 6. Set F.[[SourceText]] to the source text matched by FunctionDeclaration.\n    F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 7. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject\n  // 14.4.11 Runtime Semantics: InstantiateFunctionObject\n  private $InstantiateGeneratorFunctionObject(\n    ctx: ExecutionContext,\n    Scope: $EnvRec,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // GeneratorDeclaration :\n    //     function * ( FormalParameters ) { GeneratorBody }\n    // 1. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, true).\n    // 2. Let prototype be ObjectCreate(%GeneratorPrototype%).\n    // 3. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    // 4. Perform SetFunctionName(F, \"default\").\n    // 5. Set F.[[SourceText]] to the source text matched by GeneratorDeclaration.\n    // 6. Return F.\n\n    // GeneratorDeclaration :\n    //     function * BindingIdentifier ( FormalParameters ) { GeneratorBody }\n\n    // 1. If the function code for GeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let name be StringValue of BindingIdentifier.\n    const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;\n\n    // 3. Let F be GeneratorFunctionCreate(Normal, FormalParameters, GeneratorBody, scope, strict).\n    const F = $Function.GeneratorFunctionCreate(ctx, 'normal', this, Scope, strict);\n\n    // 4. Let prototype be ObjectCreate(%GeneratorPrototype%).\n    const prototype = $Object.ObjectCreate(ctx, 'Generator', intrinsics['%GeneratorPrototype%']);\n\n    // 5. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(\n      ctx,\n      F,\n      intrinsics.$prototype,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$prototype,\n        {\n          '[[Value]]': prototype,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n    if ($DefinePropertyOrThrowResult.isAbrupt) { return $DefinePropertyOrThrowResult.enrichWith(ctx, this); }\n\n    // 6. Perform SetFunctionName(F, name).\n    F.SetFunctionName(ctx, name);\n\n    // 7. Set F.[[SourceText]] to the source text matched by GeneratorDeclaration.\n    F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 8. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-definitions-instantiatefunctionobject\n  // 14.5.11 Runtime Semantics: InstantiateFunctionObject\n  private $InstantiateAsyncGeneratorFunctionObject(\n    ctx: ExecutionContext,\n    Scope: $EnvRec,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // AsyncGeneratorDeclaration :\n    //     async function * ( FormalParameters ) { AsyncGeneratorBody }\n    // 1. If the function code for AsyncGeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.\n    // 2. Let F be AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict).\n    // 3. Let prototype be ObjectCreate(%AsyncGeneratorPrototype%).\n    // 4. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    // 5. Perform SetFunctionName(F, \"default\").\n    // 6. Set F.[[SourceText]] to the source text matched by AsyncGeneratorDeclaration.\n    // 7. Return F.\n\n    // AsyncGeneratorDeclaration :\n    //     async function * BindingIdentifier ( FormalParameters ) { AsyncGeneratorBody }\n\n    // 1. If the function code for AsyncGeneratorDeclaration is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let name be StringValue of BindingIdentifier.\n    const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;\n\n    // 3. Let F be ! AsyncGeneratorFunctionCreate(Normal, FormalParameters, AsyncGeneratorBody, scope, strict).\n    const F = $Function.GeneratorFunctionCreate(ctx, 'normal', this, Scope, strict);\n\n    // 4. Let prototype be ! ObjectCreate(%AsyncGeneratorPrototype%).\n    const prototype = $Object.ObjectCreate(ctx, 'AsyncGenerator', intrinsics['%AsyncGeneratorPrototype%']);\n\n    // 5. Perform ! DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    const $DefinePropertyOrThrowResult = $DefinePropertyOrThrow(\n      ctx,\n      F,\n      intrinsics.$prototype,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$prototype,\n        {\n          '[[Value]]': prototype,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n    if ($DefinePropertyOrThrowResult.isAbrupt) { return $DefinePropertyOrThrowResult.enrichWith(ctx, this); }\n\n    // 6. Perform ! SetFunctionName(F, name).\n    F.SetFunctionName(ctx, name);\n\n    // 7. Set F.[[SourceText]] to the source text matched by AsyncGeneratorDeclaration.\n    F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 8. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-definitions-InstantiateFunctionObject\n  // 14.7.10 Runtime Semantics: InstantiateFunctionObject\n  private $InstantiateAsyncFunctionObject(\n    ctx: ExecutionContext,\n    Scope: $EnvRec,\n  ): $Function | $Error {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.$InstantiateFunctionObject(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // AsyncFunctionDeclaration :\n    //     async function ( FormalParameters ) { AsyncFunctionBody }\n    // 1. If the function code for AsyncFunctionDeclaration is strict mode code, let strict be true. Otherwise, let strict be false.\n    // 2. Let F be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).\n    // 3. Perform ! SetFunctionName(F, \"default\").\n    // 4. Set F.[[SourceText]] to the source text matched by AsyncFunctionDeclaration.\n    // 5. Return F.\n\n    // AsyncFunctionDeclaration :\n    //     async function BindingIdentifier ( FormalParameters ) { AsyncFunctionBody }\n\n    // 1. If the function code for AsyncFunctionDeclaration is strict mode code, let strict be true. Otherwise, let strict be false.\n    const strict = new $Boolean(realm, this.DirectivePrologue.ContainsUseStrict === true);\n\n    // 2. Let name be StringValue of BindingIdentifier.\n    const name = this.$name === void 0 ? intrinsics.default : this.$name.StringValue;\n\n    // 3. Let F be ! AsyncFunctionCreate(Normal, FormalParameters, AsyncFunctionBody, scope, strict).\n    const F = $Function.GeneratorFunctionCreate(ctx, 'normal', this, Scope, strict);\n\n    // 4. Perform ! SetFunctionName(F, name).\n    F.SetFunctionName(ctx, name);\n\n    // 5. Set F.[[SourceText]] to the source text matched by AsyncFunctionDeclaration.\n    F['[[SourceText]]'] = new $String(realm, this.node.getText(this.mos.node));\n\n    // 6. Return F.\n    return F;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    return EvaluateBody(this, ctx, functionObject, argumentsList);\n  }\n\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $Empty {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluation\n    // 14.1.22 Runtime Semantics: Evaluation\n    // FunctionDeclaration :\n    //     function BindingIdentifier ( FormalParameters ) { FunctionBody }\n    // 1. Return NormalCompletion(empty).\n    // FunctionDeclaration :\n    //     function ( FormalParameters ) { FunctionBody }\n    // 1. Return NormalCompletion(empty).\n\n    return new $Empty(realm, CompletionType.normal, intrinsics.empty, this);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n// 14.1.18 Runtime Semantics: EvaluateBody\nfunction EvaluateBody(\n  fn: $$Function,\n  ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n  functionObject: $Function,\n  argumentsList: $List<$AnyNonEmpty>,\n): $Any {\n  ctx.checkTimeout();\n\n  fn.logger.debug(`${fn.path}.EvaluateBody(#${ctx.id})`);\n\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // FunctionBody : FunctionStatementList\n\n  // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).\n  const fdiResult = $FunctionDeclarationInstantiation(ctx, functionObject, argumentsList);\n  if (fdiResult.isAbrupt) { return fdiResult.enrichWith(ctx, fn); }\n\n  // 2. Return the result of evaluating FunctionStatementList.\n  return (fn.$body as $Block).Evaluate(ctx); // $Block is guaranteed by $ArrowFunction.EvaluateBody\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-functiondeclarationinstantiation\nexport function $FunctionDeclarationInstantiation(\n  ctx: ExecutionContext<$FunctionEnvRec | $DeclarativeEnvRec>,\n  func: $Function,\n  argumentsList: $List<$AnyNonEmpty>,\n): $Empty | $Error {\n  ctx.checkTimeout();\n\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Let calleeContext be the running execution context.\n\n  // 2. Let env be the LexicalEnvironment of calleeContext.\n  // 3. Let envRec be env's EnvironmentRecord.\n  const envRec = ctx.LexicalEnvironment;\n\n  // 4. Let code be func.[[ECMAScriptCode]].\n  const code = func['[[ECMAScriptCode]]'];\n\n  // 5. Let strict be func.[[Strict]].\n  const strict = func['[[Strict]]'];\n\n  // 6. Let formals be func.[[FormalParameters]].\n  const formals = code.$parameters;\n\n  // 7. Let parameterNames be the BoundNames of formals.\n  const parameterNames = formals.BoundNames;\n\n  // 8. If parameterNames has any duplicate entries, let hasDuplicates be true. Otherwise, let hasDuplicates be false.\n  const hasDuplicates = formals.hasDuplicates;\n\n  // 9. Let simpleParameterList be IsSimpleParameterList of formals.\n  const simpleParameterList = formals.IsSimpleParameterList;\n\n  // 10. Let hasParameterExpressions be ContainsExpression of formals.\n  const hasParameterExpressions = formals.ContainsExpression;\n\n  // 11. Let varNames be the VarDeclaredNames of code.\n  const varNames = code.VarDeclaredNames;\n\n  // 12. Let varDeclarations be the VarScopedDeclarations of code.\n  const varDeclarations = code.VarScopedDeclarations;\n\n  // 13. Let lexicalNames be the LexicallyDeclaredNames of code.\n  const lexicalNames = code.LexicallyDeclaredNames;\n\n  // 14. Let functionNames be a new empty List.\n  const functionNames = [] as $String[];\n\n  // 15. Let functionsToInitialize be a new empty List.\n  const functionsToInitialize = [] as ($FunctionDeclaration | $ArrowFunction)[];\n\n  let i = varDeclarations.length;\n  let d: $$ESDeclaration;\n  // 16. For each d in varDeclarations, in reverse list order, do\n  while (--i >= 0) {\n    d = varDeclarations[i];\n\n    // 16. a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then\n    if (d instanceof $FunctionDeclaration) {\n      // 16. a. i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.\n      // 16. a. ii. Let fn be the sole element of the BoundNames of d.\n      const [fn] = d.BoundNames;\n\n      // 16. a. iii. If fn is not an element of functionNames, then\n      if (!functionNames.some(x => x.is(fn))) {\n        // 16. a. iii. 1. Insert fn as the first element of functionNames.\n        functionNames.unshift(fn);\n\n        // 16. a. iii. 2. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n        // 16. a. iii. 3. Insert d as the first element of functionsToInitialize.\n        functionsToInitialize.unshift(d);\n      }\n    }\n  }\n\n  // 17. Let argumentsObjectNeeded be true.\n  let argumentsObjectNeeded = true;\n\n  // 18. If func.[[ThisMode]] is lexical, then\n  if (func['[[ThisMode]]'] === 'lexical') {\n    // 18. a. NOTE: Arrow functions never have an arguments objects.\n    // 18. b. Set argumentsObjectNeeded to false.\n    argumentsObjectNeeded = false;\n  }\n  // 19. Else if \"arguments\" is an element of parameterNames, then\n  else if (parameterNames.some(x => x['[[Value]]'] === 'arguments')) {\n    // 19. a. Set argumentsObjectNeeded to false.\n    argumentsObjectNeeded = false;\n  }\n  // 20. Else if hasParameterExpressions is false, then\n  else if (!hasParameterExpressions) {\n    // 20. a. If \"arguments\" is an element of functionNames or if \"arguments\" is an element of lexicalNames, then\n    if (functionNames.some(x => x['[[Value]]'] === 'arguments') || lexicalNames.some(x => x['[[Value]]'] === 'arguments')) {\n      // 20. a. i. Set argumentsObjectNeeded to false.\n      argumentsObjectNeeded = false;\n    }\n  }\n\n  // 21. For each String paramName in parameterNames, do\n  for (const paramName of parameterNames) {\n    // 21. a. Let alreadyDeclared be envRec.HasBinding(paramName).\n    const alreadyDeclared = envRec.HasBinding(ctx, paramName);\n\n    // 21. b. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n    // 21. c. If alreadyDeclared is false, then\n    if (alreadyDeclared.isFalsey) {\n      // 21. c. i. Perform ! envRec.CreateMutableBinding(paramName, false).\n      envRec.CreateMutableBinding(ctx, paramName, intrinsics.false);\n\n      // 21. c. ii. If hasDuplicates is true, then\n      if (hasDuplicates) {\n        // 21. c. ii. 1. Perform ! envRec.InitializeBinding(paramName, undefined).\n        envRec.InitializeBinding(ctx, paramName, intrinsics.undefined);\n      }\n    }\n  }\n\n  let ao: $Object | $ArgumentsExoticObject;\n  let parameterBindings: readonly $String[];\n\n  // 22. If argumentsObjectNeeded is true, then\n  if (argumentsObjectNeeded) {\n    // 22. a. If strict is true or if simpleParameterList is false, then\n    if (strict.isTruthy || !simpleParameterList) {\n      // 22. a. i. Let ao be CreateUnmappedArgumentsObject(argumentsList).\n      ao = $CreateUnmappedArgumentsObject(ctx, argumentsList);\n    }\n    // 22. b. Else,\n    else {\n      // 22. b. i. NOTE: mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n      // 22. b. ii. Let ao be CreateMappedArgumentsObject(func, formals, argumentsList, envRec).\n      ao = new $ArgumentsExoticObject(realm, func, formals, argumentsList, envRec);\n    }\n\n    // 22. c. If strict is true, then\n    if (strict.isTruthy) {\n      // 22. c. i. Perform ! envRec.CreateImmutableBinding(\"arguments\", false).\n      envRec.CreateImmutableBinding(ctx, intrinsics.$arguments, intrinsics.false);\n    }\n    // 22. d. Else,\n    else {\n      // 22. d. i. Perform ! envRec.CreateMutableBinding(\"arguments\", false).\n      envRec.CreateMutableBinding(ctx, intrinsics.$arguments, intrinsics.false);\n    }\n\n    // 22. e. Call envRec.InitializeBinding(\"arguments\", ao).\n    envRec.InitializeBinding(ctx, intrinsics.$arguments, ao);\n\n    // 22. f. Let parameterBindings be a new List of parameterNames with \"arguments\" appended.\n    parameterBindings = parameterNames.concat(intrinsics.$arguments);\n  }\n  // 23. Else,\n  else {\n    // 23. a. Let parameterBindings be parameterNames.\n    parameterBindings = parameterNames;\n  }\n\n  // 24. Let iteratorRecord be CreateListIteratorRecord(argumentsList).\n  const iteratorRecord = $CreateListIteratorRecord(ctx, argumentsList);\n\n  // 25. If hasDuplicates is true, then\n  if (hasDuplicates) {\n    // 25. a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and undefined as arguments.\n    for (const formal of formals) {\n      const result = formal.InitializeIteratorBinding(ctx, iteratorRecord, void 0);\n      if (result?.isAbrupt) { return result; }\n    }\n  }\n  // 26. Else,\n  else {\n    // 26. a. Perform ? IteratorBindingInitialization for formals with iteratorRecord and env as arguments.\n    for (const formal of formals) {\n      const result = formal.InitializeIteratorBinding(ctx, iteratorRecord, envRec);\n      if (result?.isAbrupt) { return result; }\n    }\n  }\n\n  let varEnvRec: $EnvRec;\n\n  // 27. If hasParameterExpressions is false, then\n  if (!hasParameterExpressions) {\n    // 27. a. NOTE: Only a single lexical environment is needed for the parameters and top-level vars.\n    // 27. b. Let instantiatedVarNames be a copy of the List parameterBindings.\n    const instantiatedVarNames = parameterBindings.slice();\n\n    // 27. c. For each n in varNames, do\n    for (const n of varNames) {\n      // 27. c. i. If n is not an element of instantiatedVarNames, then\n      if (!instantiatedVarNames.some(x => x.is(n))) {\n        // 27. c. i. 1. Append n to instantiatedVarNames.\n        instantiatedVarNames.push(n);\n\n        // 27. c. i. 2. Perform ! envRec.CreateMutableBinding(n, false).\n        envRec.CreateMutableBinding(ctx, n, intrinsics.false);\n\n        // 27. c. i. 3. Call envRec.InitializeBinding(n, undefined).\n        envRec.InitializeBinding(ctx, n, intrinsics.undefined);\n      }\n    }\n\n    // 27. d. Let varEnv be env.\n    // 27. e. Let varEnvRec be envRec.\n    varEnvRec = envRec;\n  }\n  // 28. Else,\n  else {\n    // 28. a. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n    // 28. b. Let varEnv be NewDeclarativeEnvironment(env).\n    // 28. c. Let varEnvRec be varEnv's EnvironmentRecord.\n    varEnvRec = new $DeclarativeEnvRec(code.logger, realm, envRec);\n\n    // 28. d. Set the VariableEnvironment of calleeContext to varEnv.\n    ctx.VariableEnvironment = varEnvRec;\n\n    // 28. e. Let instantiatedVarNames be a new empty List.\n    const instantiatedVarNames = [] as $String[];\n\n    // 28. f. For each n in varNames, do\n    for (const n of varNames) {\n      // 28. f. i. If n is not an element of instantiatedVarNames, then\n      if (!instantiatedVarNames.some(x => x.is(n))) {\n        // 28. f. i. 1. Append n to instantiatedVarNames.\n        instantiatedVarNames.push(n);\n\n        // 28. f. i. 2. Perform ! varEnvRec.CreateMutableBinding(n, false).\n        varEnvRec.CreateMutableBinding(ctx, n, intrinsics.false);\n\n        let initialValue: $Any;\n\n        // 28. f. i. 3. If n is not an element of parameterBindings or if n is an element of functionNames, let initialValue be undefined.\n        if (!parameterBindings.some(x => x.is(n))) {\n          initialValue = intrinsics.undefined;\n        }\n        // 28. f. i. 4. Else,\n        else {\n          // 28. f. i. 4. a. Let initialValue be ! envRec.GetBindingValue(n, false).\n          initialValue = envRec.GetBindingValue(ctx, n, intrinsics.false) as $AnyNonEmpty;\n        }\n\n        // 28. f. i. 5. Call varEnvRec.InitializeBinding(n, initialValue).\n        varEnvRec.InitializeBinding(ctx, n, initialValue);\n\n        // 28. f. i. 6. NOTE: vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.\n      }\n    }\n  }\n\n  // 29. NOTE: Annex B.3.3.1 adds additional steps at this point.\n\n  let lexEnvRec: $EnvRec;\n\n  // 30. If strict is false, then\n  if (strict.isFalsey) {\n    // 30. a. Let lexEnv be NewDeclarativeEnvironment(varEnv).\n    lexEnvRec = new $DeclarativeEnvRec(code.logger, realm, varEnvRec);\n\n    // 30. b. NOTE: Non-strict functions use a separate lexical Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n  }\n  // 31. Else, let lexEnv be varEnv.\n  else {\n    lexEnvRec = varEnvRec;\n  }\n\n  // 32. Let lexEnvRec be lexEnv's EnvironmentRecord.\n  // 33. Set the LexicalEnvironment of calleeContext to lexEnv.\n  ctx.LexicalEnvironment = lexEnvRec;\n\n  // 34. Let lexDeclarations be the LexicallyScopedDeclarations of code.\n  const lexDeclarations = code.LexicallyScopedDeclarations;\n\n  // 35. For each element d in lexDeclarations, do\n  for (const d of lexDeclarations) {\n    // 35. a. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n    // 35. b. For each element dn of the BoundNames of d, do\n    for (const dn of d.BoundNames) {\n      // 35. b. i. If IsConstantDeclaration of d is true, then\n      if (d.IsConstantDeclaration) {\n        // 35. b. i. 1. Perform ! lexEnvRec.CreateImmutableBinding(dn, true).\n        lexEnvRec.CreateImmutableBinding(ctx, dn, intrinsics.true);\n      }\n      // 35. b. ii. Else,\n      else {\n        // 35. b. ii. 1. Perform ! lexEnvRec.CreateMutableBinding(dn, false).\n        lexEnvRec.CreateMutableBinding(ctx, dn, intrinsics.false);\n      }\n    }\n  }\n\n  // 36. For each Parse Node f in functionsToInitialize, do\n  for (const f of functionsToInitialize) {\n    // 36. a. Let fn be the sole element of the BoundNames of f.\n    const [fn] = f.BoundNames;\n\n    // TODO: probably not right\n    if (f instanceof $FunctionDeclaration) {\n      // 36. b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n      const fo = f.InstantiateFunctionObject(ctx, lexEnvRec);\n      if (fo.isAbrupt) { return fo; }\n\n      // 36. c. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n      varEnvRec.SetMutableBinding(ctx, fn, fo, intrinsics.false);\n    }\n  }\n\n  // 37. Return NormalCompletion(empty).\n  return new $Empty(realm, CompletionType.normal, intrinsics.empty);\n}\n\nexport class $ArrowFunction implements I$Node {\n  public get $kind(): SyntaxKind.ArrowFunction { return SyntaxKind.ArrowFunction; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block | $$AssignmentExpressionOrHigher;\n\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-boundnames\n  // 14.2.2 Static Semantics: BoundNames\n  // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-BoundNames\n  // 14.8.3 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-containsusestrict\n  // 14.2.5 Static Semantics: ContainsUseStrict\n  public readonly ContainsUseStrict: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-hasname\n  // 14.2.7 Static Semantics: HasName\n  // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-HasName\n  // 14.8.7 Static Semantics: HasName\n  public readonly HasName: false = false;\n  // http://www.ecma-international.org/ecma-262/#sec-static-semantics-coveredformalslist\n  // 14.2.9 Static Semantics: CoveredFormalsList\n  public readonly CoveredFormalsList: $FormalParameterList;\n\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.2.10 Static Semantics: LexicallyDeclaredNames\n  // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames\n  // 14.8.9 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.2.11 Static Semantics: LexicallyScopedDeclarations\n  // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations\n  // 14.8.10 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-vardeclarednames\n  // 14.2.12 Static Semantics: VarDeclaredNames\n  // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames\n  // 14.8.11 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[] = emptyArray;\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-static-semantics-varscopeddeclarations\n  // 14.2.13 Static Semantics: VarScopedDeclarations\n  // http://www.ecma-international.org/ecma-262/#sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations\n  // 14.8.12 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[] = emptyArray;\n\n  public readonly DirectivePrologue: DirectivePrologue;\n\n  public readonly TypeDeclarations: readonly $$TSDeclaration[] = emptyArray;\n  public readonly IsType: false = false;\n\n  public readonly functionKind: FunctionKind.normal | FunctionKind.async;\n\n  public constructor(\n    public readonly node: ArrowFunction,\n    public readonly parent: $AnyParentNode,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ArrowFunction`,\n  ) {\n    const modifierFlags = this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    if (node.body.kind === SyntaxKind.Block) {\n      const DirectivePrologue = this.DirectivePrologue = GetDirectivePrologue((node.body as Block).statements);\n      if (DirectivePrologue.ContainsUseStrict) {\n        ctx |= Context.InStrictMode;\n        this.ContainsUseStrict = true;\n      } else {\n        this.ContainsUseStrict = false;\n      }\n\n      this.$parameters = this.CoveredFormalsList = new $FormalParameterList(node.parameters, this as $ArrowFunction, ctx);\n      this.$body = new $Block(node.body as Block, this, ctx, -1);\n    } else {\n      this.DirectivePrologue = emptyArray;\n      this.ContainsUseStrict = false;\n\n      this.$parameters = this.CoveredFormalsList = new $FormalParameterList(node.parameters, this, ctx);\n      this.$body = $assignmentExpression(node.body as $AssignmentExpressionNode, this, ctx, -1);\n    }\n\n    this.functionKind = hasBit(modifierFlags, ModifierFlags.Async) ? FunctionKind.async : FunctionKind.normal;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-runtime-semantics-evaluation\n  // 14.2.17 Runtime Semantics: Evaluation\n  public Evaluate(\n    ctx: ExecutionContext,\n  ): $AnyNonEmpty  {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    this.logger.debug(`${this.path}.Evaluate(#${ctx.id})`);\n    // ArrowFunction : ArrowParameters => ConciseBody\n\n    // 1. If the function code for this ArrowFunction is strict mode code, let strict be true. Otherwise let strict be false.\n    // 2. Let scope be the LexicalEnvironment of the running execution context.\n    // 3. Let parameters be CoveredFormalsList of ArrowParameters.\n    // 4. Let closure be FunctionCreate(Arrow, parameters, ConciseBody, scope, strict).\n    // 5. Set closure.[[SourceText]] to the source text matched by ArrowFunction.\n    // 6. Return closure.\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-arrow-function-definitions-runtime-semantics-evaluatebody\n  // 14.2.15 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    ctx.checkTimeout();\n\n    if (this.$body.$kind === SyntaxKind.Block) {\n      return $FunctionDeclaration.prototype.EvaluateBody.call(this, ctx, functionObject, argumentsList);\n    }\n\n    this.logger.debug(`${this.path}.EvaluateBody(#${ctx.id})`);\n\n    // ConciseBody : AssignmentExpression\n\n    // 1. Perform ? FunctionDeclarationInstantiation(functionObject, argumentsList).\n    // 2. Let exprRef be the result of evaluating AssignmentExpression.\n    // 3. Let exprValue be ? GetValue(exprRef).\n    // 4. Return Completion { [[Type]]: return, [[Value]]: exprValue, [[Target]]: empty }.\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    return intrinsics.undefined; // TODO: implement this\n  }\n}\n\nexport class MethodDefinitionRecord {\n  public '[[Key]]': $PropertyKey;\n  public '[[Closure]]': $Function;\n\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    key: $PropertyKey,\n    closure: $Function,\n  ) {\n    this['[[Key]]'] = key;\n    this['[[Closure]]'] = closure;\n  }\n}\n\nexport class $ConstructorDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.Constructor { return SyntaxKind.Constructor; }\n\n  public readonly modifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $parameters: $FormalParameterList;\n  public readonly $body: $Block;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallydeclarednames\n  // 14.1.14 Static Semantics: LexicallyDeclaredNames\n  public readonly LexicallyDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-lexicallyscopeddeclarations\n  // 14.1.15 Static Semantics: LexicallyScopedDeclarations\n  public readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-vardeclarednames\n  // 14.1.16 Static Semantics: VarDeclaredNames\n  public readonly VarDeclaredNames: readonly $String[];\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-static-semantics-varscopeddeclarations\n  // 14.1.17 Static Semantics: VarScopedDeclarations\n  public readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];\n\n  public readonly functionKind: FunctionKind.normal = FunctionKind.normal;\n\n  public constructor(\n    public readonly node: ConstructorDeclaration,\n    public readonly parent: $ClassDeclaration | $ClassExpression,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ConstructorDeclaration`,\n  ) {\n    this.modifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    this.$parameters = new $FormalParameterList(node.parameters, this, ctx);\n\n    const $body = this.$body = new $Block(node.body!, this, ctx, -1);\n\n    this.LexicallyDeclaredNames = $body.TopLevelLexicallyDeclaredNames;\n    this.LexicallyScopedDeclarations = $body.TopLevelLexicallyScopedDeclarations;\n    this.VarDeclaredNames = $body.TopLevelVarDeclaredNames;\n    this.VarScopedDeclarations = $body.TopLevelVarScopedDeclarations;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runtime-semantics-definemethod\n  // 14.3.7 Runtime Semantics: DefineMethod\n  public DefineMethod(\n    ctx: ExecutionContext,\n    object: $Object,\n    functionPrototype: $Object,\n  ): MethodDefinitionRecord {\n    ctx.checkTimeout();\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n    // NOTE: this logic and signature is adapted to the fact that this is always a constructor method\n\n    // MethodDefinition : PropertyName ( UniqueFormalParameters ) { FunctionBody }\n\n    // 1. Let propKey be the result of evaluating PropertyName.\n    const propKey = intrinsics.$constructor;\n\n    // 2. ReturnIfAbrupt(propKey).\n    // 3. If the function code for this MethodDefinition is strict mode code, let strict be true. Otherwise let strict be false.\n    const strict = intrinsics.true; // TODO: use static semantics\n\n    // 4. Let scope be the running execution context's LexicalEnvironment.\n    const scope = ctx.LexicalEnvironment;\n\n    // 5. If functionPrototype is present as a parameter, then\n      // 5. a. Let kind be Normal.\n      // 5. b. Let prototype be functionPrototype.\n    // 6. Else,\n      // 6. a. Let kind be Method.\n      // 6. b. Let prototype be the intrinsic object %FunctionPrototype%.\n\n    // 7. Let closure be FunctionCreate(kind, UniqueFormalParameters, FunctionBody, scope, strict, prototype).\n    const closure = $Function.FunctionCreate(ctx, 'normal', this, scope, strict, functionPrototype);\n\n    // 8. Perform MakeMethod(closure, object).\n    closure['[[HomeObject]]'] = object;\n\n    // 9. Set closure.[[SourceText]] to the source text matched by MethodDefinition.\n    closure['[[SourceText]]'] = new $String(realm, this.parent.node.getText(this.mos.node));\n\n    // 10. Return the Record { [[Key]]: propKey, [[Closure]]: closure }.\n    return new MethodDefinitionRecord(propKey, closure);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-evaluatebody\n  // 14.1.18 Runtime Semantics: EvaluateBody\n  public EvaluateBody(\n    ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>,\n    functionObject: $Function,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $Any {\n    return EvaluateBody(this, ctx, functionObject, argumentsList);\n  }\n}\n\nexport class $ParameterDeclaration implements I$Node {\n  public get $kind(): SyntaxKind.Parameter { return SyntaxKind.Parameter; }\n\n  public readonly modifierFlags: ModifierFlags;\n  public readonly combinedModifierFlags: ModifierFlags;\n\n  public readonly $decorators: readonly $Decorator[];\n  public readonly $name: $$BindingName;\n  public readonly $initializer: $$AssignmentExpressionOrHigher | undefined;\n\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-boundnames\n  // 13.3.3.1 Static Semantics: BoundNames\n  public readonly BoundNames: readonly $String[] | readonly [$String];\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-containsexpression\n  // 13.3.3.2 Static Semantics: ContainsExpression\n  public readonly ContainsExpression: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-hasinitializer\n  // 13.3.3.3 Static Semantics: HasInitializer\n  public readonly HasInitializer: boolean;\n  // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist\n  // 13.3.3.4 Static Semantics: IsSimpleParameterList\n  public readonly IsSimpleParameterList: boolean;\n\n  public constructor(\n    public readonly node: ParameterDeclaration,\n    public readonly parent: $$Function,\n    public readonly ctx: Context,\n    public readonly idx: number,\n    public readonly mos: $$ESModuleOrScript = parent.mos,\n    public readonly realm: Realm = parent.realm,\n    public readonly depth: number = parent.depth + 1,\n    public readonly logger: ILogger = parent.logger,\n    public readonly path: string = `${parent.path}${$i(idx)}.ParameterDeclaration`,\n  ) {\n    this.modifierFlags = this.combinedModifierFlags = modifiersToModifierFlags(node.modifiers);\n\n    ctx |= Context.InParameterDeclaration;\n\n    this.$decorators = $decoratorList(node.decorators, this, ctx);\n    const $name = this.$name = $$bindingName(node.name, this, ctx, -1);\n\n    this.BoundNames = $name.BoundNames;\n    if (node.initializer === void 0) {\n      this.$initializer = void 0;\n      this.ContainsExpression = $name.ContainsExpression;\n      this.HasInitializer = false;\n      this.IsSimpleParameterList = $name.IsSimpleParameterList;\n    } else {\n      this.$initializer = $assignmentExpression(node.initializer as $AssignmentExpressionNode, this, ctx, -1);\n      this.ContainsExpression = true;\n      this.HasInitializer = true;\n      this.IsSimpleParameterList = false;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-definitions-runtime-semantics-iteratorbindinginitialization\n  // 14.1.19 Runtime Semantics: IteratorBindingInitialization\n  public InitializeIteratorBinding(\n    ctx: ExecutionContext,\n    iteratorRecord: $IteratorRecord,\n    environment: $EnvRec | undefined,\n  ) {\n    ctx.checkTimeout();\n\n    this.logger.debug(`${this.path}.InitializeIteratorBinding(#${ctx.id})`);\n\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    const BindingElement = this.$name;\n\n    if (BindingElement.$kind === SyntaxKind.Identifier) {\n      return BindingElement.InitializeIteratorBinding(ctx, iteratorRecord, environment, this.$initializer);\n    }\n\n    // FormalParameter : BindingElement\n    if (!this.ContainsExpression) {\n      // 1. If ContainsExpression of BindingElement is false, return the result of performing IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.\n\n      // http://www.ecma-international.org/ecma-262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization\n      // 13.3.3.8 Runtime Semantics: IteratorBindingInitialization\n      // NOTE: this section is duplicated in BindingElement\n      // BindingElement : BindingPattern Initializer opt\n      let v: $Any = intrinsics.undefined; // TODO: sure about this?\n\n      // 1. If iteratorRecord.[[Done]] is false, then\n      if (iteratorRecord['[[Done]]'].isFalsey) {\n        // 1. a. Let next be IteratorStep(iteratorRecord).\n        const next = $IteratorStep(ctx, iteratorRecord);\n\n        // 1. b. If next is an abrupt completion, set iteratorRecord.[[Done]] to true.\n        if (next.isAbrupt) {\n          iteratorRecord['[[Done]]'] = intrinsics.true;\n\n          // 1. c. ReturnIfAbrupt(next).\n          if (next.isAbrupt) {\n            return next;\n          }\n        }\n\n        // 1. d. If next is false, set iteratorRecord.[[Done]] to true.\n        if (next.isFalsey) {\n          iteratorRecord['[[Done]]'] = intrinsics.true;\n        }\n        // 1. e. Else,\n        else {\n          // 1. e. i. Let v be IteratorValue(next).\n          v = $IteratorValue(ctx, next);\n\n          // 1. e. ii. If v is an abrupt completion, set iteratorRecord.[[Done]] to true.\n          if (v.isAbrupt) {\n            iteratorRecord['[[Done]]'] = intrinsics.true;\n\n            // 1. e. iii. ReturnIfAbrupt(v).\n            if (v.isAbrupt) {\n              return v;\n            }\n          }\n        }\n      }\n\n      // 2. If iteratorRecord.[[Done]] is true, let v be undefined.\n      if (iteratorRecord['[[Done]]'].isTruthy) {\n        v = intrinsics.undefined;\n      }\n\n      const initializer = this.$initializer;\n\n      // 3. If Initializer is present and v is undefined, then\n      if (initializer !== void 0 && v.isUndefined) {\n        // 3. a. Let defaultValue be the result of evaluating Initializer.\n        const defaultValue = initializer.Evaluate(ctx);\n\n        // 3. b. Set v to ? GetValue(defaultValue).\n        const $v = defaultValue.GetValue(ctx);\n        if ($v.isAbrupt) { return $v.enrichWith(ctx, this); }\n      }\n\n      // 4. Return the result of performing BindingInitialization of BindingPattern with v and environment as the arguments.\n      return BindingElement.InitializeBinding(ctx, v as $Object, environment);\n    }\n\n    // TODO: implement the rest of this\n    // 2. Let currentContext be the running execution context.\n    // 3. Let originalEnv be the VariableEnvironment of currentContext.\n    // 4. Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.\n    // 5. Assert: environment and originalEnv are the same.\n    // 6. Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).\n    // 7. Set the VariableEnvironment of currentContext to paramVarEnv.\n    // 8. Set the LexicalEnvironment of currentContext to paramVarEnv.\n    // 9. Let result be the result of performing IteratorBindingInitialization for BindingElement using iteratorRecord and environment as the arguments.\n    // 10. Set the VariableEnvironment of currentContext to originalEnv.\n    // 11. Set the LexicalEnvironment of currentContext to originalEnv.\n    // 12. Return result.\n\n    // FunctionRestParameter : BindingRestElement\n\n    // 1. If ContainsExpression of BindingRestElement is false, return the result of performing IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the arguments.\n    // 2. Let currentContext be the running execution context.\n    // 3. Let originalEnv be the VariableEnvironment of currentContext.\n    // 4. Assert: The VariableEnvironment and LexicalEnvironment of currentContext are the same.\n    // 5. Assert: environment and originalEnv are the same.\n    // 6. Let paramVarEnv be NewDeclarativeEnvironment(originalEnv).\n    // 7. Set the VariableEnvironment of currentContext to paramVarEnv.\n    // 8. Set the LexicalEnvironment of currentContext to paramVarEnv.\n    // 9. Let result be the result of performing IteratorBindingInitialization for BindingRestElement using iteratorRecord and environment as the arguments.\n    // 10. Set the VariableEnvironment of currentContext to originalEnv.\n    // 11. Set the LexicalEnvironment of currentContext to originalEnv.\n    // 12. Return result.\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n  $GetPrototypeFromConstructor,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Error, $TypeError,\n} from '../types/error.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  $Call,\n  $HostEnsureCanCompileStrings,\n  $DefinePropertyOrThrow,\n} from '../operations.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  createSourceFile,\n  ScriptTarget,\n  FunctionDeclaration,\n} from 'typescript';\nimport {\n  $FunctionDeclaration,\n} from '../ast/functions.js';\nimport {\n  $ESModule,\n} from '../ast/modules.js';\nimport {\n  Context,\n  FunctionKind,\n} from '../ast/_shared.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $Number,\n} from '../types/number.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-function-objects\n// 19.2 Function Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-function-constructor\n// 19.2.1 The Function Constructor\nexport class $FunctionConstructor extends $BuiltinFunction<'%Function%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-function.length\n  // 19.2.2.1 Function.length\n  public get length(): $Number<1> {\n    return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'] as $Number<1>;\n  }\n  public set length(value: $Number<1>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].length, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype\n  // 19.2.2.2 Function.prototype\n  public get $prototype(): $FunctionPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $FunctionPrototype;\n  }\n  public set $prototype(value: $FunctionPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Function%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-p1-p2-pn-body\n  // 19.2.1.1 Function ( p1 , p2 , … , pn , body )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // 1. Let C be the active function object.\n    // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].\n    // 3. Return ? CreateDynamicFunction(C, NewTarget, \"normal\", args).\n    return $CreateDynamicFunction(ctx, this, NewTarget, FunctionKind.normal, argumentsList);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-function-prototype-object\n// 19.2.3 Properties of the Function Prototype Object\nexport class $FunctionPrototype extends $Object<'%FunctionPrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.apply\n  // 19.2.3.1 Function.prototype.apply ( thisArg , argArray )\n  public get $apply(): $FunctionPrototype_apply {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$apply)['[[Value]]'] as $FunctionPrototype_apply;\n  }\n  public set $apply(value: $FunctionPrototype_apply) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$apply, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.bind\n  // 19.2.3.2 Function.prototype.bind ( thisArg , ... args )\n  public get $bind(): $FunctionPrototype_bind {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$bind)['[[Value]]'] as $FunctionPrototype_bind;\n  }\n  public set $bind(value: $FunctionPrototype_bind) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$bind, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.call\n  // 19.2.3.3 Function.prototype.call ( thisArg , ... args )\n  public get $call(): $FunctionPrototype_call {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$call)['[[Value]]'] as $FunctionPrototype_call;\n  }\n  public set $call(value: $FunctionPrototype_call) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$call, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.constructor\n  // 19.2.3.4 Function.prototype.constructor\n  public get $constructor(): $FunctionConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $FunctionConstructor;\n  }\n  public set $constructor(value: $FunctionConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.tostring\n  // 19.2.3.5 Function.prototype.toString ( )\n  public get $toString(): $FunctionPrototype_toString {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$toString)['[[Value]]'] as $FunctionPrototype_toString;\n  }\n  public set $toString(value: $FunctionPrototype_toString) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$toString, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype-@@hasinstance\n  // 19.2.3.6 Function.prototype [ @@hasInstance ] ( V )\n  public get '@@hasInstance'(): $FunctionPrototype_hasInstance {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@hasInstance'])['[[Value]]'] as $FunctionPrototype_hasInstance;\n  }\n  public set '@@hasInstance'(value: $FunctionPrototype_hasInstance) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@hasInstance'], value);\n  }\n\n  public constructor(\n    realm: Realm,\n    objectPrototype: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%FunctionPrototype%', objectPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\nexport class $FunctionPrototype_apply extends $BuiltinFunction<'Function.prototype.apply'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Function.prototype.apply', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.apply\n  // 19.2.3.1 Function.prototype.apply ( thisArg , argArray )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [thisArg, argArray]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (thisArg === void 0) {\n      thisArg = intrinsics.undefined;\n    }\n\n    // 1. Let func be the this value.\n    // 2. If IsCallable(func) is false, throw a TypeError exception.\n    // 3. If argArray is undefined or null, then\n      // 3. a. Perform PrepareForTailCall().\n      // 3. b. Return ? Call(func, thisArg).\n    // 4. Let argList be ? CreateListFromArrayLike(argArray).\n    // 5. Perform PrepareForTailCall().\n    // 6. Return ? Call(func, thisArg, argList).\n    throw new Error('Method not implemented.');\n  }\n}\n\nexport class $FunctionPrototype_bind extends $BuiltinFunction<'Function.prototype.bind'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Function.prototype.bind', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.bind\n  // 19.2.3.2 Function.prototype.bind ( thisArg , ... args )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [thisArg, ...args]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (thisArg === void 0) {\n      thisArg = intrinsics.undefined;\n    }\n\n    // 1. Let Target be the this value.\n    // 2. If IsCallable(Target) is false, throw a TypeError exception.\n    // 3. Let args be a new (possibly empty) List consisting of all of the argument values provided after thisArg in order.\n    // 4. Let F be ? BoundFunctionCreate(Target, thisArg, args).\n    // 5. Let targetHasLength be ? HasOwnProperty(Target, \"length\").\n    // 6. If targetHasLength is true, then\n      // 6. a. Let targetLen be ? Get(Target, \"length\").\n      // 6. b. If Type(targetLen) is not Number, let L be 0.\n      // 6. c. Else,\n        // 6. c. i. Set targetLen to ! ToInteger(targetLen).\n        // 6. c. ii. Let L be the larger of 0 and the result of targetLen minus the number of elements of args.\n    // 7. Else, let L be 0.\n    // 8. Perform ! SetFunctionLength(F, L).\n    // 9. Let targetName be ? Get(Target, \"name\").\n    // 10. If Type(targetName) is not String, set targetName to the empty string.\n    // 11. Perform SetFunctionName(F, targetName, \"bound\").\n    // 12. Return F.\n    throw new Error('Method not implemented.');\n  }\n}\n\nexport class $FunctionPrototype_call extends $BuiltinFunction<'Function.prototype.call'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Function.prototype.call', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.call\n  // 19.2.3.3 Function.prototype.call ( thisArg , ... args )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [thisArg, ...args]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (thisArg === void 0) {\n      thisArg = intrinsics.undefined;\n    }\n\n    // 1. Let func be the this value.\n    const func = thisArgument;\n\n    // 2. If IsCallable(func) is false, throw a TypeError exception.\n    if (!func.isFunction) {\n      return new $TypeError(realm, `Function.prototype.call called on ${func}, but expected a callable function`);\n    }\n\n    // 3. Let argList be a new empty List.\n    const argList = new $List<$AnyNonEmpty>();\n\n    // 4. If this method was called with more than one argument, then in left to right order, starting with the second argument, append each argument as the last element of argList.\n    if (args.length > 0) {\n      argList.push(...args);\n    }\n\n    // 5. Perform PrepareForTailCall().\n    ctx.suspend();\n    realm.stack.pop();\n\n    // 6. Return ? Call(func, thisArg, argList).\n    return $Call(realm.stack.top, func as $Function, thisArg as $AnyNonEmptyNonError, argList);\n  }\n}\n\nexport class $FunctionPrototype_toString extends $BuiltinFunction<'Function.prototype.toString'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Function.prototype.toString', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.tostring\n  // 19.2.3.5 Function.prototype.toString ( )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [thisArg, ...args]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (thisArg === void 0) {\n      thisArg = intrinsics.undefined;\n    }\n\n    // 1. Let func be the this value.\n    // 2. If func is a Bound Function exotic object or a built-in function object, then return an implementation-dependent String source code representation of func. The representation must have the syntax of a NativeFunction. Additionally, if func is a Well-known Intrinsic Object and is not identified as an anonymous function, the portion of the returned String that would be matched by PropertyName must be the initial value of the name property of func.\n    // 3. If Type(func) is Object and func has a [[SourceText]] internal slot and Type(func.[[SourceText]]) is String and ! HostHasSourceTextAvailable(func) is true, then return func.[[SourceText]].\n    // 4. If Type(func) is Object and IsCallable(func) is true, then return an implementation-dependent String source code representation of func. The representation must have the syntax of a NativeFunction.\n    // 5. Throw a TypeError exception.\n    throw new Error('Method not implemented.');\n  }\n}\n\nexport class $FunctionPrototype_hasInstance extends $BuiltinFunction<'Function.prototype.hasInstance'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Function.prototype.hasInstance', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype-@@hasinstance\n  // 19.2.3.6 Function.prototype [ @@hasInstance ] ( V )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [V]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let F be the this value.\n    // 2. Return ? OrdinaryHasInstance(F, V).\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-createdynamicfunction\n// 19.2.1.1.1 Runtime Semantics: CreateDynamicFunction ( constructor , newTarget , kind , args )\nexport function $CreateDynamicFunction(\n  ctx: ExecutionContext,\n  constructor: $Function,\n  newTarget: $Function | $Undefined,\n  kind: FunctionKind.normal | FunctionKind.generator | FunctionKind.async | FunctionKind.asyncGenerator,\n  args: $List<$AnyNonEmpty>,\n): $Function | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Assert: The execution context stack has at least two elements.\n  // 2. Let callerContext be the second to top element of the execution context stack.\n  const callerContext = stack[stack.length - 2];\n\n  // 3. Let callerRealm be callerContext's Realm.\n  const callerRealm = callerContext.Realm;\n\n  // 4. Let calleeRealm be the current Realm Record.\n  const calleeRealm = realm;\n\n  // 5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).\n  const $HostEnsureCanCompileStringsResult = $HostEnsureCanCompileStrings(ctx, callerRealm, calleeRealm);\n  if ($HostEnsureCanCompileStringsResult.isAbrupt) { return $HostEnsureCanCompileStringsResult; }\n\n  // 6. If newTarget is undefined, set newTarget to constructor.\n  if (newTarget.isUndefined) {\n    newTarget = constructor;\n  }\n\n  let $yield: boolean;\n  let $await: boolean;\n  let prefix: 'function' | 'function*' | 'async function' | 'async function*';\n  let fallbackProto: '%FunctionPrototype%' | '%Generator%' | '%AsyncFunctionPrototype%' | '%AsyncGenerator%';\n\n  switch (kind) {\n    // 7. If kind is \"normal\", then\n    case FunctionKind.normal:\n      // 7. a. Let goal be the grammar symbol FunctionBody[~Yield, ~Await].\n      // 7. b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, ~Await].\n      prefix = 'function';\n\n      // 7. c. Let fallbackProto be \"%FunctionPrototype%\".\n      fallbackProto = '%FunctionPrototype%';\n      break;\n    // 8. Else if kind is \"generator\", then\n    case FunctionKind.generator:\n      // 8. a. Let goal be the grammar symbol GeneratorBody.\n      // 8. b. Let parameterGoal be the grammar symbol FormalParameters[+Yield, ~Await].\n      prefix = 'function*';\n\n      // 8. c. Let fallbackProto be \"%Generator%\".\n      fallbackProto = '%Generator%';\n      break;\n    // 9. Else if kind is \"async\", then\n    case FunctionKind.async:\n      // 9. a. Let goal be the grammar symbol AsyncFunctionBody.\n      // 9. b. Let parameterGoal be the grammar symbol FormalParameters[~Yield, +Await].\n      prefix = 'async function';\n\n      // 9. c. Let fallbackProto be \"%AsyncFunctionPrototype%\".\n      fallbackProto = '%AsyncFunctionPrototype%';\n      break;\n    // 10. Else,\n    case FunctionKind.asyncGenerator:\n      // 10. a. Assert: kind is \"async generator\".\n      // 10. b. Let goal be the grammar symbol AsyncGeneratorBody.\n      // 10. c. Let parameterGoal be the grammar symbol FormalParameters[+Yield, +Await].\n      prefix = 'async function*';\n\n      // 10. d. Let fallbackProto be \"%AsyncGenerator%\".\n      fallbackProto = '%AsyncGenerator%';\n      break;\n  }\n\n  // 11. Let argCount be the number of elements in args.\n  const argCount = args.length;\n\n  // 12. Let P be the empty String.\n  let P: $String = intrinsics[''];\n\n  let $bodyText: $AnyNonEmpty ;\n  let bodyText: $String;\n\n  // 13. If argCount = 0, let bodyText be the empty String.\n  if (argCount === 0) {\n    $bodyText = intrinsics[''];\n  }\n  // 14. Else if argCount = 1, let bodyText be args[0].\n  else if (argCount === 1) {\n    $bodyText = args[0];\n  }\n  // 15. Else argCount > 1,\n  else {\n    // 15. a. Let firstArg be args[0].\n    const firstArg = args[0];\n\n    // 15. b. Set P to ? ToString(firstArg).\n    const $P = firstArg.ToString(ctx);\n    if ($P.isAbrupt) { return $P; }\n    P = $P;\n\n    // 15. c. Let k be 1.\n    let k = 1;\n\n    // 15. d. Repeat, while k < argCount - 1\n    while (k < argCount - 1) {\n      // 15. d. i. Let nextArg be args[k].\n      const nextArg = args[k];\n\n      // 15. d. ii. Let nextArgString be ? ToString(nextArg).\n      const nextArgString = nextArg.ToString(ctx);\n      if (nextArgString.isAbrupt) { return nextArgString; }\n\n      // 15. d. iii. Set P to the string-concatenation of the previous value of P, \",\" (a comma), and nextArgString.\n      P = new $String(realm, `${P['[[Value]]']},${nextArgString['[[Value]]']}`);\n\n      // 15. d. iv. Increase k by 1.\n      ++k;\n    }\n\n    // 15. e. Let bodyText be args[k].\n    $bodyText = args[k];\n  }\n\n  // 16. Set bodyText to ? ToString(bodyText).\n  $bodyText = $bodyText.ToString(ctx);\n  if ($bodyText.isAbrupt) { return $bodyText; }\n  // eslint-disable-next-line prefer-const\n  bodyText = $bodyText;\n\n  // 41. Let sourceText be the string-concatenation of prefix, \" anonymous(\", P, 0x000A (LINE FEED), \") {\", 0x000A (LINE FEED), bodyText, 0x000A (LINE FEED), and \"}\".\n  // NOTE: we bring this step up here for parsing a proper function with TS (since TS doesn't expose an api for parsing just functions).\n  //    The exact same text is then later set as [[SourceText]]\n  const sourceText = `${prefix} anonymous(${P['[[Value]]']}\\n) {\\n${bodyText['[[Value]]']}\\n}`;\n\n  // 17. Let parameters be the result of parsing P, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using parameterGoal as the goal symbol. Throw a SyntaxError exception if the parse fails.\n  // 18. Let body be the result of parsing bodyText, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, using goal as the goal symbol. Throw a SyntaxError exception if the parse fails.\n  const node = createSourceFile(\n    '',\n    sourceText,\n    ScriptTarget.Latest,\n  ).statements[0] as FunctionDeclaration;\n  const ScriptOrModule = callerContext.ScriptOrModule as $ESModule;\n\n  const $functionDeclaration = new $FunctionDeclaration(\n    node,\n    ScriptOrModule,\n    Context.Dynamic,\n    -1,\n    ScriptOrModule,\n    calleeRealm,\n    1,\n    ScriptOrModule.logger,\n    `${ScriptOrModule.path}[Dynamic].FunctionDeclaration`,\n  );\n\n  // 19. Let strict be ContainsUseStrict of body.\n  const strict = $functionDeclaration.ContainsUseStrict;\n\n  // TODO: revisit whether we need to implement these early errors. See what 262 tests fail, if any, etc.\n\n  // 20. If any static semantics errors are detected for parameters or body, throw a SyntaxError or a ReferenceError exception, depending on the type of the error. If strict is true, the Early Error rules for UniqueFormalParameters:FormalParameters are applied. Parsing and early error detection may be interweaved in an implementation-dependent manner.\n  // 21. If strict is true and IsSimpleParameterList of parameters is false, throw a SyntaxError exception.\n  // 22. If any element of the BoundNames of parameters also occurs in the LexicallyDeclaredNames of body, throw a SyntaxError exception.\n  // 23. If body Contains SuperCall is true, throw a SyntaxError exception.\n  // 24. If parameters Contains SuperCall is true, throw a SyntaxError exception.\n  // 25. If body Contains SuperProperty is true, throw a SyntaxError exception.\n  // 26. If parameters Contains SuperProperty is true, throw a SyntaxError exception.\n  // 27. If kind is \"generator\" or \"async generator\", then\n    // 27. a. If parameters Contains YieldExpression is true, throw a SyntaxError exception.\n  // 28. If kind is \"async\" or \"async generator\", then\n    // 28. a. If parameters Contains AwaitExpression is true, throw a SyntaxError exception.\n  // 29. If strict is true, then\n    // 29. a. If BoundNames of parameters contains any duplicate elements, throw a SyntaxError exception.\n\n  // 30. Let proto be ? GetPrototypeFromConstructor(newTarget, fallbackProto).\n  const proto = $GetPrototypeFromConstructor(ctx, newTarget, fallbackProto);\n  if (proto.isAbrupt) { return proto; }\n\n  // 31. Let F be FunctionAllocate(proto, strict, kind).\n  const F = $Function.FunctionAllocate(ctx, proto, new $Boolean(realm, strict), kind);\n\n  // 32. Let realmF be F.[[Realm]].\n  const realmF = F['[[Realm]]'];\n\n  // 33. Let scope be realmF.[[GlobalEnv]].\n  const scope = realmF['[[GlobalEnv]]'];\n\n  // 34. Perform FunctionInitialize(F, Normal, parameters, body, scope).\n  $Function.FunctionInitialize(ctx, F, 'normal', $functionDeclaration, scope);\n\n  // 35. If kind is \"generator\", then\n  if (kind === FunctionKind.generator) {\n    // 35. a. Let prototype be ObjectCreate(%GeneratorPrototype%).\n    const prototype = new $Object(\n      realm,\n      'anonymous generator',\n      intrinsics['%GeneratorPrototype%'],\n      CompletionType.normal,\n      intrinsics.empty,\n    );\n\n    // 35. b. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    $DefinePropertyOrThrow(\n      ctx,\n      F,\n      intrinsics.$prototype,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$prototype,\n        {\n          '[[Value]]': prototype,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n  }\n  // 36. Else if kind is \"async generator\", then\n  else if (kind === FunctionKind.asyncGenerator) {\n    // 36. a. Let prototype be ObjectCreate(%AsyncGeneratorPrototype%).\n    const prototype = new $Object(\n      realm,\n      'anonymous async generator',\n      intrinsics['%AsyncGeneratorPrototype%'],\n      CompletionType.normal,\n      intrinsics.empty,\n    );\n\n    // 36. b. Perform DefinePropertyOrThrow(F, \"prototype\", PropertyDescriptor { [[Value]]: prototype, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }).\n    $DefinePropertyOrThrow(\n      ctx,\n      F,\n      intrinsics.$prototype,\n      new $PropertyDescriptor(\n        realm,\n        intrinsics.$prototype,\n        {\n          '[[Value]]': prototype,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.false,\n        },\n      ),\n    );\n  }\n  // 37. Else if kind is \"normal\", perform MakeConstructor(F).\n  else if (kind === FunctionKind.normal) {\n    F.MakeConstructor(ctx);\n  }\n\n  // 38. NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a \"prototype\" property.\n  // 39. Perform SetFunctionName(F, \"anonymous\").\n  F.SetFunctionName(ctx, new $String(realm, 'anonymous'));\n\n  // 40. Let prefix be the prefix associated with kind in Table 47.\n  // 41. Let sourceText be the string-concatenation of prefix, \" anonymous(\", P, 0x000A (LINE FEED), \") {\", 0x000A (LINE FEED), bodyText, 0x000A (LINE FEED), and \"}\".\n  // 42. Set F.[[SourceText]] to sourceText.\n  F['[[SourceText]]'] = new $String(realm, sourceText);\n\n  // 43. Return F.\n  return F;\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n  $OrdinaryCreateFromConstructor,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  CompletionType,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-number-constructor\nexport class $NumberConstructor extends $BuiltinFunction<'%Number%'> {\n  public get $prototype(): $NumberPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $NumberPrototype;\n  }\n  public set $prototype(value: $NumberPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Number%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-number-constructor-number-value\n  // 20.1.1.1 Number ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    let n: $Number;\n\n    // 1. If no arguments were passed to this function invocation, let n be +0.\n    if (value === void 0) {\n      n = intrinsics['0'];\n    }\n    // 2. Else, let n be ? ToNumber(value).\n    else {\n      const $n = value.ToNumber(ctx);\n      if ($n.isAbrupt) { return $n; }\n      n = $n;\n    }\n\n    // 3. If NewTarget is undefined, return n.\n    if (NewTarget.isUndefined) {\n      return n;\n    }\n\n    // 4. Let O be ? OrdinaryCreateFromConstructor(NewTarget, \"%NumberPrototype%\", « [[NumberData]] »).\n    // 5. Set O.[[NumberData]] to n.\n    // 6. Return O.\n    return $OrdinaryCreateFromConstructor(ctx, NewTarget, '%NumberPrototype%', { '[[NumberData]]': n });\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-number-prototype-object\nexport class $NumberPrototype extends $Object<'%NumberPrototype%'> {\n  public get $constructor(): $NumberConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $NumberConstructor;\n  }\n  public set $constructor(value: $NumberConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public '[[NumberData]]': $Number;\n\n  public constructor(\n    realm: Realm,\n    objectPrototype: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%NumberPrototype%', objectPrototype, CompletionType.normal, intrinsics.empty);\n\n    this['[[NumberData]]'] = new $Number(realm, 0);\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n  $OrdinaryCreateFromConstructor,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  CompletionType,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-boolean-constructor\nexport class $BooleanConstructor extends $BuiltinFunction<'%Boolean%'> {\n  public get $prototype(): $BooleanPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $BooleanPrototype;\n  }\n  public set $prototype(value: $BooleanPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Boolean%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-boolean-constructor-boolean-value\n  // 19.3.1.1 Boolean ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let b be ToBoolean(value).\n    const b = value?.ToBoolean(ctx) ?? intrinsics.undefined;\n    if (b.isAbrupt) { return b; }\n\n    // 2. If NewTarget is undefined, return b.\n    if (NewTarget.isUndefined) {\n      return b;\n    }\n\n    // 3. Let O be ? OrdinaryCreateFromConstructor(NewTarget, \"%BooleanPrototype%\", « [[BooleanData]] »).\n    // 4. Set O.[[BooleanData]] to b.\n    // 5. Return O.\n    return $OrdinaryCreateFromConstructor(ctx, NewTarget, '%BooleanPrototype%', { '[[BooleanData]]': b });\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-boolean-prototype-object\nexport class $BooleanPrototype extends $Object<'%BooleanPrototype%'> {\n  public get $constructor(): $BooleanConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $BooleanConstructor;\n  }\n  public set $constructor(value: $BooleanConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public '[[BooleanData]]': $Boolean;\n\n  public constructor(\n    realm: Realm,\n    objectPrototype: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%BooleanPrototype%', objectPrototype, CompletionType.normal, intrinsics.empty);\n\n    this['[[BooleanData]]'] = new $Boolean(realm, false);\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  CompletionType,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $Symbol,\n} from '../types/symbol.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-symbol-constructor\nexport class $SymbolConstructor extends $BuiltinFunction<'%Symbol%'> {\n  public get $prototype(): $SymbolPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $SymbolPrototype;\n  }\n  public set $prototype(value: $SymbolPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Symbol%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-symbol-description\n  // 19.4.1.1 Symbol ( [ description ] )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [description]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is not undefined, throw a TypeError exception.\n    if (!NewTarget.isUndefined) {\n      return new $TypeError(realm, `Symbol is not a constructor`);\n    }\n\n    // 2. If description is undefined, let descString be undefined.\n    if (description === void 0 || description.isUndefined) {\n      // 4. Return a new unique Symbol value whose [[Description]] value is descString.\n      return new $Symbol(realm, new $Undefined(realm));\n    }\n    // 3. Else, let descString be ? ToString(description).\n    else {\n      const descString = description.ToString(ctx);\n      if (descString.isAbrupt) { return descString; }\n\n      // 4. Return a new unique Symbol value whose [[Description]] value is descString.\n      return new $Symbol(realm, descString);\n    }\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-symbol-prototype-object\nexport class $SymbolPrototype extends $Object<'%SymbolPrototype%'> {\n  public get $constructor(): $SymbolConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $SymbolConstructor;\n  }\n  public set $constructor(value: $SymbolConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    objectPrototype: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%SymbolPrototype%', objectPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n  $OrdinaryCreateFromConstructor,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  CompletionType,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $DefinePropertyOrThrow,\n} from '../operations.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-error-constructor\nexport class $ErrorConstructor extends $BuiltinFunction<'%Error%'> {\n  public get $prototype(): $ErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $ErrorPrototype;\n  }\n  public set $prototype(value: $ErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Error%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-error-message\n  // 19.5.1.1 Error ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%ErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%ErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-error-prototype-object\nexport class $ErrorPrototype extends $Object<'%ErrorPrototype%'> {\n  public get $constructor(): $ErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $ErrorConstructor;\n  }\n  public set $constructor(value: $ErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public get $toString(): $ErrorPrototype_toString {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $ErrorPrototype_toString;\n  }\n  public set $toString(value: $ErrorPrototype_toString) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    objectPrototype: $ObjectPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%ErrorPrototype%', objectPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-error.prototype.tostring\nexport class $ErrorPrototype_toString extends $BuiltinFunction<'Error.prototype.toString'> {\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let O be the this value.\n    const O = thisArgument;\n\n    // 2. If Type(O) is not Object, throw a TypeError exception.\n    if (!O.isObject) {\n      return new $TypeError(realm, `Error.prototype.toString called on ${O}, but expected an object`);\n    }\n\n    // 3. Let name be ? Get(O, \"name\").\n    let name = O['[[Get]]'](ctx, intrinsics.$name, O);\n    if (name.isAbrupt) { return name; }\n\n    // 4. If name is undefined, set name to \"Error\"; otherwise set name to ? ToString(name).\n    if (name.isUndefined) {\n      name = new $String(realm, 'Error');\n    } else {\n      name = name.ToString(ctx);\n      if (name.isAbrupt) { return name; }\n    }\n\n    // 5. Let msg be ? Get(O, \"message\").\n    let msg = O['[[Get]]'](ctx, intrinsics.message, O);\n    if (msg.isAbrupt) { return msg; }\n\n    // 6. If msg is undefined, set msg to the empty String; otherwise set msg to ? ToString(msg).\n    if (msg.isUndefined) {\n      msg = new $String(realm, '');\n    } else {\n      msg = msg.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n    }\n\n    // 7. If name is the empty String, return msg.\n    if (name['[[Value]]'] === '') {\n      return msg;\n    }\n\n    // 8. If msg is the empty String, return name.\n    if (msg['[[Value]]'] === '') {\n      return name;\n    }\n\n    // 9. Return the string-concatenation of name, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and msg.\n    return new $String(realm, `${name['[[Value]]']}: ${msg['[[Value]]']}`);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors\nexport class $EvalErrorConstructor extends $BuiltinFunction<'%EvalError%'> {\n  public get $prototype(): $EvalErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $EvalErrorPrototype;\n  }\n  public set $prototype(value: $EvalErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorConstructor: $ErrorConstructor,\n  ) {\n    super(realm, '%EvalError%', errorConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-nativeerror\n  // 19.5.6.1.1 NativeError ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%EvalErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%EvalErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects\nexport class $EvalErrorPrototype extends $Object<'%EvalErrorPrototype%'> {\n  public get $constructor(): $EvalErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $EvalErrorConstructor;\n  }\n  public set $constructor(value: $EvalErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorPrototype: $ErrorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%EvalErrorPrototype%', errorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors\nexport class $RangeErrorConstructor extends $BuiltinFunction<'%RangeError%'> {\n  public get $prototype(): $RangeErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $RangeErrorPrototype;\n  }\n  public set $prototype(value: $RangeErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorConstructor: $ErrorConstructor,\n  ) {\n    super(realm, '%RangeError%', errorConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-nativeerror\n  // 19.5.6.1.1 NativeError ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%RangeErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%RangeErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects\nexport class $RangeErrorPrototype extends $Object<'%RangeErrorPrototype%'> {\n  public get $constructor(): $RangeErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $RangeErrorConstructor;\n  }\n  public set $constructor(value: $RangeErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorPrototype: $ErrorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%RangeErrorPrototype%', errorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors\nexport class $ReferenceErrorConstructor extends $BuiltinFunction<'%ReferenceError%'> {\n  public get $prototype(): $ReferenceErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $ReferenceErrorPrototype;\n  }\n  public set $prototype(value: $ReferenceErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorConstructor: $ErrorConstructor,\n  ) {\n    super(realm, '%ReferenceError%', errorConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-nativeerror\n  // 19.5.6.1.1 NativeError ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%ReferenceErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%ReferenceErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects\nexport class $ReferenceErrorPrototype extends $Object<'%ReferenceErrorPrototype%'> {\n  public get $constructor(): $ReferenceErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $ReferenceErrorConstructor;\n  }\n  public set $constructor(value: $ReferenceErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorPrototype: $ErrorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%ReferenceErrorPrototype%', errorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors\nexport class $SyntaxErrorConstructor extends $BuiltinFunction<'%SyntaxError%'> {\n  public get $prototype(): $SyntaxErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $SyntaxErrorPrototype;\n  }\n  public set $prototype(value: $SyntaxErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorConstructor: $ErrorConstructor,\n  ) {\n    super(realm, '%SyntaxError%', errorConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-nativeerror\n  // 19.5.6.1.1 NativeError ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%SyntaxErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%SyntaxErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects\nexport class $SyntaxErrorPrototype extends $Object<'%SyntaxErrorPrototype%'> {\n  public get $constructor(): $SyntaxErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $SyntaxErrorConstructor;\n  }\n  public set $constructor(value: $SyntaxErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorPrototype: $ErrorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%SyntaxErrorPrototype%', errorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors\nexport class $TypeErrorConstructor extends $BuiltinFunction<'%TypeError%'> {\n  public get $prototype(): $TypeErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $TypeErrorPrototype;\n  }\n  public set $prototype(value: $TypeErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorConstructor: $ErrorConstructor,\n  ) {\n    super(realm, '%TypeError%', errorConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-nativeerror\n  // 19.5.6.1.1 NativeError ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%TypeErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%TypeErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects\nexport class $TypeErrorPrototype extends $Object<'%TypeErrorPrototype%'> {\n  public get $constructor(): $TypeErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $TypeErrorConstructor;\n  }\n  public set $constructor(value: $TypeErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorPrototype: $ErrorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%TypeErrorPrototype%', errorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-nativeerror-constructors\nexport class $URIErrorConstructor extends $BuiltinFunction<'%URIError%'> {\n  public get $prototype(): $URIErrorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $URIErrorPrototype;\n  }\n  public set $prototype(value: $URIErrorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorConstructor: $ErrorConstructor,\n  ) {\n    super(realm, '%URIError%', errorConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-nativeerror\n  // 19.5.6.1.1 NativeError ( message )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [message]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. If NewTarget is undefined, let newTarget be the active function object, else let newTarget be NewTarget.\n    const newTarget = NewTarget.isUndefined ? ctx.Function : NewTarget;\n\n    // 2. Let O be ? OrdinaryCreateFromConstructor(newTarget, \"%URIErrorPrototype%\", « [[ErrorData]] »).\n    const O = $OrdinaryCreateFromConstructor(ctx, newTarget as $Function, '%URIErrorPrototype%', { '[[ErrorData]]': void 0 });\n    if (O.isAbrupt) { return O; }\n\n    // 3. If message is not undefined, then\n    if (message !== void 0) {\n      // 3. a. Let msg be ? ToString(message).\n      const msg = message.ToString(ctx);\n      if (msg.isAbrupt) { return msg; }\n\n      // 3. b. Let msgDesc be the PropertyDescriptor { [[Value]]: msg, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.\n      const msgDesc = new $PropertyDescriptor(\n        realm,\n        intrinsics.message,\n        {\n          '[[Value]]': msg,\n          '[[Writable]]': intrinsics.true,\n          '[[Enumerable]]': intrinsics.false,\n          '[[Configurable]]': intrinsics.true,\n        },\n      );\n\n      // 3. c. Perform ! DefinePropertyOrThrow(O, \"message\", msgDesc).\n      $DefinePropertyOrThrow(ctx, O, intrinsics.message, msgDesc);\n    }\n\n    // 4. Return O.\n    return O;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-nativeerror-prototype-objects\nexport class $URIErrorPrototype extends $Object<'%URIErrorPrototype%'> {\n  public get $constructor(): $URIErrorConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $URIErrorConstructor;\n  }\n  public set $constructor(value: $URIErrorConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value);\n  }\n\n  public get message(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].message)['[[Value]]'] as $String;\n  }\n  public set message(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].message, value);\n  }\n\n  public get $name(): $String {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$name)['[[Value]]'] as $String;\n  }\n  public set $name(value: $String) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$name, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    errorPrototype: $ErrorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%URIErrorPrototype%', errorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n","import {\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-%throwtypeerror%\n// 9.2.9.1 %ThrowTypeError% ( )\nexport class $ThrowTypeError extends $BuiltinFunction<'%ThrowTypeError%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-function.prototype.call\n  // 19.2.3.3 Function.prototype.call ( thisArg , ... args )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [thisArg, ...args]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $TypeError {\n    // 1. Throw a TypeError exception.\n    return new $TypeError(ctx.Realm);\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Error, $TypeError,\n} from '../types/error.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  FunctionKind,\n} from '../ast/_shared.js';\nimport {\n  $CreateDynamicFunction,\n  $FunctionPrototype,\n  $FunctionConstructor,\n} from './function.js';\nimport {\n  $IteratorPrototype,\n  $CreateIterResultObject,\n} from './iteration.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Block,\n} from '../ast/statements.js';\nimport {\n  $List\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-objects\n// 25.2 GeneratorFunction Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-constructor\n// #region 25.2.1 The GeneratorFunction Constructor\nexport class $GeneratorFunctionConstructor extends $BuiltinFunction<'%GeneratorFunction%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype\n  // 25.2.2.2 GeneratorFunction.prototype\n  public get $prototype(): $GeneratorFunctionPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $GeneratorFunctionPrototype;\n  }\n  public set $prototype(value: $GeneratorFunctionPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.length\n  // 25.2.2.1 GeneratorFunction.length\n  public get length(): $Number<1> {\n    return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'] as $Number<1>;\n  }\n  public set length(value: $Number<1>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].length, value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionConstructor: $FunctionConstructor,\n  ) {\n    super(realm, '%GeneratorFunction%', functionConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunction\n  // 25.2.1.1 GeneratorFunction ( p1 , p2 , … , pn , body )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // 1. Let C be the active function object.\n    // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].\n    // 3. Return ? CreateDynamicFunction(C, NewTarget, \"generator\", args).\n    return $CreateDynamicFunction(ctx, this, NewTarget, FunctionKind.generator, argumentsList);\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-the-generatorfunction-prototype-object\n// #region 25.2.3 Properties of the GeneratorFunction Prototype Object\nexport class $GeneratorFunctionPrototype extends $Object<'%Generator%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype.constructor\n  // 25.2.3.1 GeneratorFunction.prototype.constructor\n  public get $constructor(): $GeneratorFunctionConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $GeneratorFunctionConstructor;\n  }\n  public set $constructor(value: $GeneratorFunctionConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype.prototype\n  // 25.2.3.2 GeneratorFunction.prototype.prototype\n  public get $prototype(): $GeneratorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $GeneratorPrototype;\n  }\n  public set $prototype(value: $GeneratorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generatorfunction.prototype-@@tostringtag\n  // 25.2.3.3 GeneratorFunction.prototype [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'GeneratorFunction'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'GeneratorFunction'>;\n  }\n  public set '@@toStringTag'(value: $String<'GeneratorFunction'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%Generator%', functionPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances\n// #region 25.2.4 GeneratorFunction Instances\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances-length\n// 25.2.4.1 length\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances-name\n// 25.2.4.2 name\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorfunction-instances-prototype\n// 25.2.4.3 prototype\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-generator-objects\n// 25.4 Generator Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-generator-prototype\n// #region 25.4.1 Properties of the Generator Prototype Object\nexport class $GeneratorPrototype extends $Object<'%GeneratorPrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.constructor\n  // 25.4.1.1 Generator.prototype.constructor\n  public get $constructor(): $GeneratorFunctionPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $GeneratorFunctionPrototype;\n  }\n  public set $constructor(value: $GeneratorFunctionPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.next\n  // 25.4.1.2 Generator.prototype.next ( value )\n  public get next(): $GeneratorPrototype_next {\n    return this.getProperty(this.realm['[[Intrinsics]]'].next)['[[Value]]'] as $GeneratorPrototype_next;\n  }\n  public set next(value: $GeneratorPrototype_next) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].next, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.return\n  // 25.4.1.3 Generator.prototype.return ( value )\n  public get return(): $GeneratorPrototype_return {\n    return this.getProperty(this.realm['[[Intrinsics]]'].return)['[[Value]]'] as $GeneratorPrototype_return;\n  }\n  public set return(value: $GeneratorPrototype_return) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].return, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.throw\n  // 25.4.1.4 Generator.prototype.throw ( exception )\n  public get throw(): $GeneratorPrototype_throw {\n    return this.getProperty(this.realm['[[Intrinsics]]'].throw)['[[Value]]'] as $GeneratorPrototype_throw;\n  }\n  public set throw(value: $GeneratorPrototype_throw) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].throw, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype-@@tostringtag\n  // 25.4.1.5 Generator.prototype [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'Generator'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'Generator'>;\n  }\n  public set '@@toStringTag'(value: $String<'Generator'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    iteratorPrototype: $IteratorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%GeneratorPrototype%', iteratorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\nexport class $GeneratorPrototype_next extends $BuiltinFunction<'Generator.prototype.next'> {\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.next\n  // 25.4.1.2 Generator.prototype.next ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let g be the this value.\n    const g = thisArgument;\n\n    // 2. Return ? GeneratorResume(g, value).\n    return $GeneratorResume(ctx, g, value);\n  }\n}\n\nexport class $GeneratorPrototype_return extends $BuiltinFunction<'Generator.prototype.return'> {\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.return\n  // 25.4.1.3 Generator.prototype.return ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let g be the this value.\n    const g = thisArgument;\n\n    // 2. Let C be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.\n    const C = value.ToCompletion(CompletionType.return, intrinsics.empty);\n\n    // 3. Return ? GeneratorResumeAbrupt(g, C).\n    return $GeneratorResumeAbrupt(ctx, g, C);\n  }\n}\n\nexport class $GeneratorPrototype_throw extends $BuiltinFunction<'Generator.prototype.throw'> {\n  // http://www.ecma-international.org/ecma-262/#sec-generator.prototype.throw\n  // 25.4.1.4 Generator.prototype.throw ( exception )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [exception]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (exception === void 0) {\n      exception = intrinsics.undefined;\n    }\n\n    // 1. Let g be the this value.\n    const g = thisArgument;\n\n    // 2. Let C be ThrowCompletion(exception).\n    const C = exception.ToCompletion(CompletionType.throw, intrinsics.empty);\n\n    // 3. Return ? GeneratorResumeAbrupt(g, C).\n    return $GeneratorResumeAbrupt(ctx, g, C);\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-generator-instances\n// #region 25.4.2 Properties of Generator Instances\nexport const enum GeneratorState {\n  none           = 0,\n  suspendedStart = 1,\n  suspendedYield = 2,\n  executing      = 3,\n  completed      = 4,\n}\n\nexport class $GeneratorInstance extends $Object<'GeneratorInstance'> {\n  public '[[GeneratorState]]': GeneratorState;\n  public '[[GeneratorContext]]': ExecutionContext | undefined;\n\n  public constructor(\n    realm: Realm,\n    proto: $GeneratorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'GeneratorInstance', proto, CompletionType.normal, intrinsics.empty);\n\n    this['[[GeneratorState]]'] = GeneratorState.none;\n    this['[[GeneratorContext]]'] = void 0;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-generator-abstract-operations\n// 25.4.3 Generator Abstract Operations\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorstart\n// 25.4.3.1 GeneratorStart ( generator , generatorBody )\nexport function $GeneratorStart(\n  ctx: ExecutionContext,\n  generator: $GeneratorInstance,\n  generatorBody: $Block,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Assert: The value of generator.[[GeneratorState]] is undefined.\n  // 2. Let genContext be the running execution context.\n  const genContext = ctx;\n\n  // 3. Set the Generator component of genContext to generator.\n  genContext.Generator = generator;\n\n  // 4. Set the code evaluation state of genContext such that when evaluation is resumed for that execution context the following steps will be performed:\n  genContext.onResume = function (resumptionValue: $AnyNonEmpty): $AnyNonEmpty { // TODO: do we need to do something with resumptionValue?\n    // 4. a. Let result be the result of evaluating generatorBody.\n    const result = generatorBody.Evaluate(genContext);\n\n    // 4. b. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n    // 4. c. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    stack.pop();\n\n    // 4. d. Set generator.[[GeneratorState]] to \"completed\".\n    generator['[[GeneratorState]]'] = GeneratorState.completed;\n\n    // 4. e. Once a generator enters the \"completed\" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.\n\n    let resultValue: $AnyNonEmpty;\n    // 4. f. If result.[[Type]] is normal, let resultValue be undefined.\n    if (result['[[Type]]'] === CompletionType.normal) {\n      resultValue = intrinsics.undefined;\n    }\n    // 4. g. Else if result.[[Type]] is return, let resultValue be result.[[Value]].\n    else if (result['[[Type]]'] === CompletionType.return) {\n      resultValue = result;\n    }\n    // 4. h. Else,\n    else {\n      // 4. h. i. Assert: result.[[Type]] is throw.\n      // 4. h. ii. Return Completion(result).\n      return result as $AnyNonEmpty ;\n    }\n\n    // 4. i. Return CreateIterResultObject(resultValue, true).\n    return $CreateIterResultObject(stack.top, resultValue, intrinsics.true);\n  };\n\n  // 5. Set generator.[[GeneratorContext]] to genContext.\n  generator['[[GeneratorContext]]'] = genContext;\n\n  // 6. Set generator.[[GeneratorState]] to \"suspendedStart\".\n  generator['[[GeneratorState]]'] = GeneratorState.suspendedStart;\n\n  // 7. Return NormalCompletion(undefined).\n  return intrinsics.undefined;\n}\n\nexport class $GeneratorState {\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    public readonly value: GeneratorState,\n  ) {}\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorvalidate\n// 25.4.3.2 GeneratorValidate ( generator )\nexport function $GeneratorValidate(\n  ctx: ExecutionContext,\n  generator: $AnyNonEmpty,\n): $GeneratorState | $Error {\n  const realm = ctx.Realm;\n\n  // 1. If Type(generator) is not Object, throw a TypeError exception.\n  // 2. If generator does not have a [[GeneratorState]] internal slot, throw a TypeError exception.\n  // 3. Assert: generator also has a [[GeneratorContext]] internal slot.\n  if (!(generator instanceof $GeneratorInstance)) {\n    return new $TypeError(realm, `Expected generator to be an GeneratorInstance, but got: ${generator}`);\n  }\n\n  // 4. Let state be generator.[[GeneratorState]].\n  const state = generator['[[GeneratorState]]'] as GeneratorState.executing | GeneratorState.suspendedStart | GeneratorState.suspendedYield | GeneratorState.completed;\n\n  // 5. If state is \"executing\", throw a TypeError exception.\n  if (state === GeneratorState.executing) {\n    return new $TypeError(realm, `Generator validation failed: already executing`);\n  }\n\n  // 6. Return state.\n  return new $GeneratorState(state);\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorresume\n// 25.4.3.3 GeneratorResume ( generator , value )\nexport function $GeneratorResume(\n  ctx: ExecutionContext,\n  _generator: $AnyNonEmpty,\n  value: $AnyNonEmpty ,\n): $AnyNonEmpty  {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Let state be ? GeneratorValidate(generator).\n  const $state = $GeneratorValidate(ctx, _generator);\n  if ($state.isAbrupt) { return $state; }\n  const state = $state.value;\n  const generator = _generator as $GeneratorInstance;\n\n  // 2. If state is \"completed\", return CreateIterResultObject(undefined, true).\n  if (state === GeneratorState.completed) {\n    return $CreateIterResultObject(ctx, intrinsics.undefined, intrinsics.true);\n  }\n\n  // 3. Assert: state is either \"suspendedStart\" or \"suspendedYield\".\n  // 4. Let genContext be generator.[[GeneratorContext]].\n  const genContext = generator['[[GeneratorContext]]']!;\n\n  // 5. Let methodContext be the running execution context.\n  const methodContext = ctx;\n\n  // 6. Suspend methodContext.\n  methodContext.suspend();\n\n  // 7. Set generator.[[GeneratorState]] to \"executing\".\n  generator['[[GeneratorState]]'] = GeneratorState.executing;\n\n  // 8. Push genContext onto the execution context stack; genContext is now the running execution context.\n  stack.push(genContext);\n\n  // 9. Resume the suspended evaluation of genContext using NormalCompletion(value) as the result of the operation that suspended it. Let result be the value returned by the resumed computation.\n  genContext.resume();\n  const result = genContext.onResume!(value);\n\n  // 10. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.\n  // 11. Return Completion(result).\n  return result;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-generatorresumeabrupt\n// 25.4.3.4 GeneratorResumeAbrupt ( generator , abruptCompletion )\nexport function $GeneratorResumeAbrupt(\n  ctx: ExecutionContext,\n  _generator: $AnyNonEmpty,\n  abruptCompletion: $AnyNonEmpty ,\n): $AnyNonEmpty  {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Let state be ? GeneratorValidate(generator).\n  const $state = $GeneratorValidate(ctx, _generator);\n  if ($state.isAbrupt) { return $state; }\n  let state = $state.value;\n  const generator = _generator as $GeneratorInstance;\n\n  // 2. If state is \"suspendedStart\", then\n  if (state === GeneratorState.suspendedStart) {\n    // 2. a. Set generator.[[GeneratorState]] to \"completed\".\n    generator['[[GeneratorState]]'] = GeneratorState.completed;\n\n    // 2. b. Once a generator enters the \"completed\" state it never leaves it and its associated execution context is never resumed. Any execution state associated with generator can be discarded at this point.\n    // 2. c. Set state to \"completed\".\n    state = GeneratorState.completed;\n  }\n\n  // 3. If state is \"completed\", then\n  if (state === GeneratorState.completed) {\n    // 3. a. If abruptCompletion.[[Type]] is return, then\n    if (abruptCompletion['[[Type]]'] === CompletionType.return) {\n      // 3. a. i. Return CreateIterResultObject(abruptCompletion.[[Value]], true).\n      return $CreateIterResultObject(ctx, abruptCompletion, intrinsics.true);\n    }\n\n    // 3. b. Return Completion(abruptCompletion).\n    return abruptCompletion;\n  }\n\n  // 4. Assert: state is \"suspendedYield\".\n  // 5. Let genContext be generator.[[GeneratorContext]].\n  const genContext = generator['[[GeneratorContext]]']!;\n\n  // 6. Let methodContext be the running execution context.\n  const methodContext = ctx;\n\n  // 7. Suspend methodContext.\n  methodContext.suspend();\n\n  // 8. Set generator.[[GeneratorState]] to \"executing\".\n  generator['[[GeneratorState]]'] = GeneratorState.executing;\n\n  // 9. Push genContext onto the execution context stack; genContext is now the running execution context.\n  stack.push(genContext);\n\n  // 10. Resume the suspended evaluation of genContext using abruptCompletion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.\n  genContext.resume();\n  const result = genContext.onResume!(abruptCompletion);\n\n  // 11. Assert: When we return here, genContext has already been removed from the execution context stack and methodContext is the currently running execution context.\n  // 12. Return Completion(result).\n  return result;\n}\n\nexport const enum GeneratorKind {\n  none  = 0,\n  async = 1,\n  sync  = 2,\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-getgeneratorkind\n// 25.4.3.5 GetGeneratorKind ( )\nexport function $GetGeneratorKind(\n  ctx: ExecutionContext,\n): GeneratorKind {\n  // 1. Let genContext be the running execution context.\n  const genContext = ctx;\n\n  // 2. If genContext does not have a Generator component, return non-generator.\n  const generator = genContext.Generator;\n  if (generator === void 0) {\n    return GeneratorKind.none;\n  }\n\n  // 3. Let generator be the Generator component of genContext.\n  // 4. If generator has an [[AsyncGeneratorState]] internal slot, return async.\n  if ('[[AsyncGeneratorState]]' in generator) { // TODO: replace with instanceof when the async class is implemented?\n    return GeneratorKind.async;\n  }\n\n  // 5. Else, return sync.\n  return GeneratorKind.sync;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-generatoryield\n// 25.4.3.6 GeneratorYield ( iterNextObj )\nexport function $GeneratorYield(\n  ctx: ExecutionContext,\n  iterNextObj: $Object,\n): any {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Assert: iterNextObj is an Object that implements the IteratorResult interface.\n  // 2. Let genContext be the running execution context.\n  const genContext = ctx;\n\n  // 3. Assert: genContext is the execution context of a generator.\n  // 4. Let generator be the value of the Generator component of genContext.\n  const generator = genContext.Generator as $GeneratorInstance;\n\n  // 5. Assert: GetGeneratorKind() is sync.\n  // 6. Set generator.[[GeneratorState]] to \"suspendedYield\".\n  generator['[[GeneratorState]]'] = GeneratorState.suspendedYield;\n\n  // 7. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  stack.pop();\n\n  // 8. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:\n  genContext.onResume = function (resumptionValue: $AnyNonEmpty): $AnyNonEmpty {\n    // 8. a. Return resumptionValue.\n    return resumptionValue;\n\n    // 8. b. NOTE: This returns to the evaluation of the YieldExpression that originally called this abstract operation.\n  };\n\n  // 9. Return NormalCompletion(iterNextObj).\n  return iterNextObj;\n  // 10. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.\n}\n\n// #endregion\n\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  FunctionKind,\n} from '../ast/_shared.js';\nimport {\n  $CreateDynamicFunction,\n  $FunctionPrototype,\n  $FunctionConstructor,\n} from './function.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Block,\n} from '../ast/statements.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  $PromiseCapability,\n} from './promise.js';\nimport {\n  $Call,\n} from '../operations.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-async-function-objects\n// 25.7 AsyncFunction Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-async-function-constructor\n// 25.7.1 The AsyncFunction Constructor\nexport class $AsyncFunctionConstructor extends $BuiltinFunction<'%AsyncFunction%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-constructor-prototype\n  // 25.7.2.2 AsyncFunction.prototype\n  public get $prototype(): $AsyncFunctionPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $AsyncFunctionPrototype;\n  }\n  public set $prototype(value: $AsyncFunctionPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-constructor-length\n  // 25.7.2.1 AsyncFunction.length\n  public get length(): $Number<1> {\n    return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'] as $Number<1>;\n  }\n  public set length(value: $Number<1>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].length, value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionConstructor: $FunctionConstructor,\n  ) {\n    super(realm, '%AsyncFunction%', functionConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-constructor-arguments\n  // 25.7.1.1 AsyncFunction ( p1 , p2 , … , pn , body )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // 1. Let C be the active function object.\n    // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].\n    // 3. Return CreateDynamicFunction(C, NewTarget, \"async\", args).\n    return $CreateDynamicFunction(ctx, this, NewTarget, FunctionKind.async, argumentsList);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-async-function-prototype-properties\n// 25.7.3 Properties of the AsyncFunction Prototype Object\nexport class $AsyncFunctionPrototype extends $Object<'%AsyncFunctionPrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-prototype-properties-constructor\n  // 25.7.3.1 AsyncFunction.prototype.constructor\n  public get $constructor(): $AsyncFunctionConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $AsyncFunctionConstructor;\n  }\n  public set $constructor(value: $AsyncFunctionConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-async-function-prototype-properties-toStringTag\n  // 25.7.3.2 AsyncFunction.prototype [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'AsyncFunction'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'AsyncFunction'>;\n  }\n  public set '@@toStringTag'(value: $String<'AsyncFunction'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%AsyncFunctionPrototype%', functionPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-async-function-instances\n// 25.7.4 AsyncFunction Instances\n\n// http://www.ecma-international.org/ecma-262/#sec-async-function-instances-length\n// 25.7.4.1 length\n\n// http://www.ecma-international.org/ecma-262/#sec-async-function-instances-name\n// 25.7.4.2 name\n\n// http://www.ecma-international.org/ecma-262/#sec-async-functions-abstract-operations\n// 25.7.5 Async Functions Abstract Operations\n\n// http://www.ecma-international.org/ecma-262/#sec-async-functions-abstract-operations-async-function-start\n// 25.7.5.1 AsyncFunctionStart ( promiseCapability , asyncFunctionBody )\nexport function $AsyncFunctionStart(\n  ctx: ExecutionContext,\n  promiseCapability: $PromiseCapability,\n  asyncFunctionBody: $Block,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Let runningContext be the running execution context.\n  const runningContext = ctx;\n\n  // 2. Let asyncContext be a copy of runningContext.\n  const asyncContext = runningContext.makeCopy();\n\n  // 3. Set the code evaluation state of asyncContext such that when evaluation is resumed for that execution context the following steps will be performed:\n  asyncContext.onResume = function (resumptionValue): $AnyNonEmpty {\n    // 3. a. Let result be the result of evaluating asyncFunctionBody.\n    const result = asyncFunctionBody.Evaluate(asyncContext);\n    if (result.isAbrupt) { return result; }\n\n    // 3. b. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\n    // 3. c. Remove asyncContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    stack.pop();\n\n    // 3. d. If result.[[Type]] is normal, then\n    if (result['[[Type]]'] === CompletionType.normal) {\n      // 3. d. i. Perform ! Call(promiseCapability.[[Resolve]], undefined, « undefined »).\n      $Call(asyncContext, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(intrinsics.undefined));\n    }\n    // 3. e. Else if result.[[Type]] is return, then\n    else if (result['[[Type]]'] === CompletionType.return) {\n      // 3. e. i. Perform ! Call(promiseCapability.[[Resolve]], undefined, « result.[[Value]] »).\n      $Call(asyncContext, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(result));\n    }\n    // 3. f. Else,\n    else {\n      // 3. f. i. Assert: result.[[Type]] is throw.\n      // 3. f. ii. Perform ! Call(promiseCapability.[[Reject]], undefined, « result.[[Value]] »).\n      $Call(asyncContext, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(result as $AnyNonEmpty)); // TODO: is this cast safe?\n    }\n\n    // 3. g. Return.\n    return intrinsics.undefined;\n  };\n\n  // 4. Push asyncContext onto the execution context stack; asyncContext is now the running execution context.\n  stack.push(asyncContext);\n\n  // 5. Resume the suspended evaluation of asyncContext. Let result be the value returned by the resumed computation.\n  asyncContext.resume();\n  const result = asyncContext.onResume!(intrinsics.undefined); // TODO: sure about this?\n\n  // 6. Assert: When we return here, asyncContext has already been removed from the execution context stack and runningContext is the currently running execution context.\n  // 7. Assert: result is a normal completion with a value of undefined. The possible sources of completion values are Await or, if the async function doesn't await anything, the step 3.g above.\n  // 8. Return.\n  return intrinsics.undefined;\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n  $Any,\n} from '../types/_shared.js';\nimport {\n  $Error,\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  FunctionKind,\n} from '../ast/_shared.js';\nimport {\n  $CreateDynamicFunction,\n  $FunctionPrototype,\n  $FunctionConstructor,\n} from './function.js';\nimport {\n  $IteratorPrototype,\n  $CreateIterResultObject,\n} from './iteration.js';\nimport {\n  $Number,\n} from '../types/number.js';\nimport {\n  $Block,\n} from '../ast/statements.js';\nimport {\n  $List,\n} from '../types/list.js';\nimport {\n  $PromiseCapability,\n  $PromiseResolve,\n  $PerformPromiseThen,\n  $NewPromiseCapability,\n  $PromiseInstance,\n} from './promise.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $Call,\n} from '../operations.js';\nimport {\n  $Await,\n} from '../types/await.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-objects\n// 25.3 AsyncGeneratorFunction Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-constructor\n// #region 25.3.1 The AsyncGeneratorFunction Constructor\nexport class $AsyncGeneratorFunctionConstructor extends $BuiltinFunction<'%AsyncGeneratorFunction%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype\n  // 25.3.2.2 AsyncGeneratorFunction.prototype\n  public get $prototype(): $AsyncGeneratorFunctionPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $AsyncGeneratorFunctionPrototype;\n  }\n  public set $prototype(value: $AsyncGeneratorFunctionPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, false);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-length\n  // 25.3.2.1 AsyncGeneratorFunction.length\n  public get length(): $Number<1> {\n    return this.getProperty(this.realm['[[Intrinsics]]'].length)['[[Value]]'] as $Number<1>;\n  }\n  public set length(value: $Number<1>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].length, value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionConstructor: $FunctionConstructor,\n  ) {\n    super(realm, '%AsyncGeneratorFunction%', functionConstructor);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction\n  // 25.3.1.1 AsyncGeneratorFunction ( p1 , p2 , ..., pn , body )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    // 1. Let C be the active function object.\n    // 2. Let args be the argumentsList that was passed to this function by [[Call]] or [[Construct]].\n    // 3. Return ? CreateDynamicFunction(C, NewTarget, \"async generator\", args).\n    return $CreateDynamicFunction(ctx, this, NewTarget, FunctionKind.asyncGenerator, argumentsList);\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-asyncgeneratorfunction-prototype\n// #region 25.3.3 Properties of the AsyncGeneratorFunction Prototype Object\nexport class $AsyncGeneratorFunctionPrototype extends $Object<'%AsyncGenerator%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype-constructor\n  // 25.3.3.1 AsyncGeneratorFunction.prototype.constructor\n  public get $constructor(): $AsyncGeneratorFunctionConstructor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $AsyncGeneratorFunctionConstructor;\n  }\n  public set $constructor(value: $AsyncGeneratorFunctionConstructor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype-prototype\n  // 25.3.3.2 AsyncGeneratorFunction.prototype.prototype\n  public get $prototype(): $AsyncGeneratorPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$prototype)['[[Value]]'] as $AsyncGeneratorPrototype;\n  }\n  public set $prototype(value: $AsyncGeneratorPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$prototype, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-prototype-tostringtag\n  // 25.3.3.3 AsyncGeneratorFunction.prototype [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'AsyncGeneratorFunction'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'AsyncGeneratorFunction'>;\n  }\n  public set '@@toStringTag'(value: $String<'AsyncGeneratorFunction'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%AsyncGenerator%', functionPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instances\n// #region 25.3.4 AsyncGeneratorFunction Instances\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instance-length\n// 25.3.4.1 length\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instance-name\n// 25.3.4.2 name\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorfunction-instance-prototype\n// 25.3.4.3 prototype\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-objects\n// 25.5 AsyncGenerator Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-asyncgenerator-prototype\n// #region 25.5.1 Properties of the AsyncGenerator Prototype Object\nexport class $AsyncGeneratorPrototype extends $Object<'%AsyncGeneratorPrototype%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-constructor\n  // 25.5.1.1 AsyncGenerator.prototype.constructor\n  public get $constructor(): $AsyncGeneratorFunctionPrototype {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$constructor)['[[Value]]'] as $AsyncGeneratorFunctionPrototype;\n  }\n  public set $constructor(value: $AsyncGeneratorFunctionPrototype) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$constructor, value, false, false, true);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-next\n  // 25.5.1.2 AsyncGenerator.prototype.next ( value )\n  public get next(): $AsyncGeneratorPrototype_next {\n    return this.getProperty(this.realm['[[Intrinsics]]'].next)['[[Value]]'] as $AsyncGeneratorPrototype_next;\n  }\n  public set next(value: $AsyncGeneratorPrototype_next) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].next, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-return\n  // 25.5.1.3 AsyncGenerator.prototype.return ( value )\n  public get return(): $AsyncGeneratorPrototype_return {\n    return this.getProperty(this.realm['[[Intrinsics]]'].return)['[[Value]]'] as $AsyncGeneratorPrototype_return;\n  }\n  public set return(value: $AsyncGeneratorPrototype_return) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].return, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-throw\n  // 25.5.1.4 AsyncGenerator.prototype.throw ( exception )\n  public get throw(): $AsyncGeneratorPrototype_throw {\n    return this.getProperty(this.realm['[[Intrinsics]]'].throw)['[[Value]]'] as $AsyncGeneratorPrototype_throw;\n  }\n  public set throw(value: $AsyncGeneratorPrototype_throw) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].throw, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-tostringtag\n  // 25.5.1.5 AsyncGenerator.prototype [ @@toStringTag ]\n  public get '@@toStringTag'(): $String<'AsyncGenerator'> {\n    return this.getProperty(this.realm['[[Intrinsics]]']['@@toStringTag'])['[[Value]]'] as $String<'AsyncGenerator'>;\n  }\n  public set '@@toStringTag'(value: $String<'AsyncGenerator'>) {\n    this.setDataProperty(this.realm['[[Intrinsics]]']['@@toStringTag'], value, false, false, true);\n  }\n\n  public constructor(\n    realm: Realm,\n    iteratorPrototype: $IteratorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, '%AsyncGeneratorPrototype%', iteratorPrototype, CompletionType.normal, intrinsics.empty);\n  }\n}\n\nexport class $AsyncGeneratorPrototype_next extends $BuiltinFunction<'AsyncGenerator.prototype.next'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'AsyncGenerator.prototype.next', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-next\n  // 25.5.1.2 AsyncGenerator.prototype.next ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let generator be the this value.\n    const generator = thisArgument as $AsyncGeneratorInstance;\n\n    // 2. Let completion be NormalCompletion(value).\n    const completion = value;\n\n    // 3. Return ! AsyncGeneratorEnqueue(generator, completion).\n    return $AsyncGeneratorEnqueue(ctx, generator, completion);\n  }\n}\n\nexport class $AsyncGeneratorPrototype_return extends $BuiltinFunction<'AsyncGenerator.prototype.return'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'AsyncGenerator.prototype.return', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-return\n  // 25.5.1.3 AsyncGenerator.prototype.return ( value )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let generator be the this value.\n    const generator = thisArgument as $AsyncGeneratorInstance;\n\n    // 2. Let completion be Completion { [[Type]]: return, [[Value]]: value, [[Target]]: empty }.\n    const completion = value.ToCompletion(CompletionType.return, intrinsics.empty);\n\n    // 3. Return ! AsyncGeneratorEnqueue(generator, completion).\n    return $AsyncGeneratorEnqueue(ctx, generator, completion);\n  }\n}\n\nexport class $AsyncGeneratorPrototype_throw extends $BuiltinFunction<'AsyncGenerator.prototype.throw'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'AsyncGenerator.prototype.throw', proto);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-prototype-throw\n  // 25.5.1.4 AsyncGenerator.prototype.throw ( exception )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [exception]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (exception === void 0) {\n      exception = intrinsics.undefined;\n    }\n\n    // 1. Let generator be the this value.\n    const generator = thisArgument as $AsyncGeneratorInstance;\n\n    // 2. Let completion be ThrowCompletion(exception).\n    const completion = exception.ToCompletion(CompletionType.throw, intrinsics.empty);\n\n    // 3. Return ! AsyncGeneratorEnqueue(generator, completion).\n    return $AsyncGeneratorEnqueue(ctx, generator, completion);\n  }\n}\n\n// #endregion\n\n// http://www.ecma-international.org/ecma-262/#sec-properties-of-asyncgenerator-intances\n// #region 25.5.2 Properties of AsyncGenerator Instances\nexport const enum AsyncGeneratorState {\n  none           = 0,\n  suspendedStart = 1,\n  suspendedYield = 2,\n  executing      = 3,\n  awaitingReturn = 4,\n  completed      = 5,\n}\n\nexport class $AsyncGeneratorInstance extends $Object<'AsyncGeneratorInstance'> {\n  public '[[AsyncGeneratorState]]': AsyncGeneratorState;\n  public '[[AsyncGeneratorContext]]': ExecutionContext | undefined;\n  public '[[AsyncGeneratorQueue]]': $List<$AsyncGeneratorRequest>;\n\n  public constructor(\n    realm: Realm,\n    proto: $AsyncGeneratorPrototype,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'AsyncGeneratorInstance', proto, CompletionType.normal, intrinsics.empty);\n\n    this['[[AsyncGeneratorState]]'] = AsyncGeneratorState.none;\n    this['[[AsyncGeneratorContext]]'] = void 0;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgenerator-abstract-operations\n// 25.5.3 AsyncGenerator Abstract Operations\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorrequest-records\n// 25.5.3.1 AsyncGeneratorRequest Records\nexport class $AsyncGeneratorRequest {\n  public readonly '[[Completion]]': $Any;\n  public readonly '[[Capability]]': $PromiseCapability;\n\n  public constructor(\n    completion: $Any,\n    capability: $PromiseCapability,\n  ) {\n    this['[[Completion]]'] = completion;\n    this['[[Capability]]'] = capability;\n  }\n\n  public is(other: $AsyncGeneratorRequest): boolean {\n    return this === other;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorstart\n// 25.5.3.2 AsyncGeneratorStart ( generator , generatorBody )\nexport function $AsyncGeneratorStart(\n  ctx: ExecutionContext,\n  generator: $AsyncGeneratorInstance,\n  generatorBody: $Block,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Assert: generator is an AsyncGenerator instance.\n  // 2. Assert: generator.[[AsyncGeneratorState]] is undefined.\n  // 3. Let genContext be the running execution context.\n  const genContext = ctx;\n\n  // 4. Set the Generator component of genContext to generator.\n  genContext.Generator = generator;\n\n  // 5. Set the code evaluation state of genContext such that when evaluation is resumed for that execution context the following steps will be performed:\n  genContext.onResume = function (resumptionValue: $AnyNonEmpty): $AnyNonEmpty  { // TODO: do we need to do something with resumptionValue?\n    // 5. a. Let result be the result of evaluating generatorBody.\n    const result = generatorBody.Evaluate(genContext) as $AnyNonEmpty;\n\n    // 5. b. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.\n    // 5. c. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    stack.pop();\n\n    // 5. d. Set generator.[[AsyncGeneratorState]] to \"completed\".\n    generator['[[AsyncGeneratorState]]'] = AsyncGeneratorState.completed;\n\n    let resultValue: $AnyNonEmpty;\n    // 5. e. If result is a normal completion, let resultValue be undefined.\n    if (result['[[Type]]'] === CompletionType.normal) {\n      resultValue = intrinsics.undefined;\n    }\n    // 5. f. Else,\n    else {\n      // 5. f. i. Let resultValue be result.[[Value]].\n      resultValue = result;\n\n      // 5. f. ii. If result.[[Type]] is not return, then\n      if (result['[[Type]]'] !== CompletionType.return) {\n        // 5. f. ii. 1. Return ! AsyncGeneratorReject(generator, resultValue).\n        return $AsyncGeneratorReject(ctx, generator, resultValue as $Error);\n      }\n    }\n\n    // 5. g. Return ! AsyncGeneratorResolve(generator, resultValue, true).\n    return $AsyncGeneratorResolve(ctx, generator, resultValue, intrinsics.true);\n  };\n\n  // 6. Set generator.[[AsyncGeneratorContext]] to genContext.\n  generator['[[AsyncGeneratorContext]]'] = genContext;\n\n  // 7. Set generator.[[AsyncGeneratorState]] to \"suspendedStart\".\n  generator['[[AsyncGeneratorState]]'] = AsyncGeneratorState.suspendedStart;\n\n  // 8. Set generator.[[AsyncGeneratorQueue]] to a new empty List.\n  generator['[[AsyncGeneratorQueue]]'] = new $List();\n\n  // 9. Return undefined.\n  return intrinsics.undefined;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorresolve\n// 25.5.3.3 AsyncGeneratorResolve ( generator , value , done )\nexport function $AsyncGeneratorResolve(\n  ctx: ExecutionContext,\n  generator: $AsyncGeneratorInstance,\n  value: $AnyNonEmpty,\n  done: $Boolean,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: generator is an AsyncGenerator instance.\n  // 2. Let queue be generator.[[AsyncGeneratorQueue]].\n  const queue = generator['[[AsyncGeneratorQueue]]'];\n\n  // 3. Assert: queue is not an empty List.\n  // 4. Remove the first element from queue and let next be the value of that element.\n  const next = queue.shift()!;\n\n  // 5. Let promiseCapability be next.[[Capability]].\n  const promiseCapability = next['[[Capability]]'];\n\n  // 6. Let iteratorResult be ! CreateIterResultObject(value, done).\n  const iteratorResult = $CreateIterResultObject(ctx, value, done);\n\n  // 7. Perform ! Call(promiseCapability.[[Resolve]], undefined, « iteratorResult »).\n  $Call(ctx, promiseCapability['[[Resolve]]'], intrinsics.undefined, new $List(iteratorResult));\n\n  // 8. Perform ! AsyncGeneratorResumeNext(generator).\n  $AsyncGeneratorResumeNext(ctx, generator);\n\n  // 9. Return undefined.\n  return intrinsics.undefined;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorreject\n// 25.5.3.4 AsyncGeneratorReject ( generator , exception )\nexport function $AsyncGeneratorReject(\n  ctx: ExecutionContext,\n  generator: $AsyncGeneratorInstance,\n  exception: $Error,\n): $Undefined {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: generator is an AsyncGenerator instance.\n  // 2. Let queue be generator.[[AsyncGeneratorQueue]].\n  const queue = generator['[[AsyncGeneratorQueue]]'];\n\n  // 3. Assert: queue is not an empty List.\n  // 4. Remove the first element from queue and let next be the value of that element.\n  const next = queue.shift()!;\n\n  // 5. Let promiseCapability be next.[[Capability]].\n  const promiseCapability = next['[[Capability]]'];\n\n  // 6. Perform ! Call(promiseCapability.[[Reject]], undefined, « exception »).\n  $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(exception));\n\n  // 7. Perform ! AsyncGeneratorResumeNext(generator).\n  $AsyncGeneratorResumeNext(ctx, generator);\n\n  // 8. Return undefined.\n  return intrinsics.undefined;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorresumenext\n// 25.5.3.5 AsyncGeneratorResumeNext ( generator )\nexport function $AsyncGeneratorResumeNext(\n  ctx: ExecutionContext,\n  generator: $AsyncGeneratorInstance,\n): $Undefined | $Error {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Assert: generator is an AsyncGenerator instance.\n  // 2. Let state be generator.[[AsyncGeneratorState]].\n  let state = generator['[[AsyncGeneratorState]]'];\n\n  // 3. Assert: state is not \"executing\".\n  // 4. If state is \"awaiting-return\", return undefined.\n  if (state === AsyncGeneratorState.awaitingReturn) {\n    return intrinsics.undefined;\n  }\n\n  // 5. Let queue be generator.[[AsyncGeneratorQueue]].\n  const queue = generator['[[AsyncGeneratorQueue]]'];\n\n  // 6. If queue is an empty List, return undefined.\n  if (queue.length === 0) {\n    return intrinsics.undefined;\n  }\n\n  // 7. Let next be the value of the first element of queue.\n  const next = queue[0];\n\n  // 8. Assert: next is an AsyncGeneratorRequest record.\n  // 9. Let completion be next.[[Completion]].\n  const completion = next['[[Completion]]'] as $AnyNonEmpty; // TODO: is this cast safe?\n\n  // 10. If completion is an abrupt completion, then\n  if (completion.isAbrupt) {\n    // 10. a. If state is \"suspendedStart\", then\n    if (state === AsyncGeneratorState.suspendedStart) {\n      // 10. a. i. Set generator.[[AsyncGeneratorState]] to \"completed\".\n      generator['[[AsyncGeneratorState]]'] = AsyncGeneratorState.completed;\n\n      // 10. a. ii. Set state to \"completed\".\n      state = AsyncGeneratorState.completed;\n    }\n\n    // 10. b. If state is \"completed\", then\n    if (state === AsyncGeneratorState.completed) {\n      // 10. b. i. If completion.[[Type]] is return, then\n      if (\n        // TODO: improve the $Error type / isAbrupt interaction\n        (completion as $AnyNonEmpty)['[[Type]]'] === CompletionType.return\n      ) {\n        // 10. b. i. 1. Set generator.[[AsyncGeneratorState]] to \"awaiting-return\".\n        generator['[[AsyncGeneratorState]]'] = AsyncGeneratorState.awaitingReturn;\n\n        // 10. b. i. 2. Let promise be ? PromiseResolve(%Promise%, « completion.[[Value]] »).\n        const promise = $PromiseResolve(ctx, intrinsics['%Promise%'], new $List(completion) as unknown as $AnyNonEmpty); // TODO: this cast urgently needs to be addressed with corrected typings\n        if (promise.isAbrupt) { return promise; }\n\n        // 10. b. i. 3. Let stepsFulfilled be the algorithm steps defined in AsyncGeneratorResumeNext Return Processor Fulfilled Functions.\n        // 10. b. i. 4. Let onFulfilled be CreateBuiltinFunction(stepsFulfilled, « [[Generator]] »).\n        // 10. b. i. 5. Set onFulfilled.[[Generator]] to generator.\n        const onFulfilled = new $AsyncGeneratorResumeNext_Return_Processor_Fulfilled(realm, generator);\n\n        // 10. b. i. 6. Let stepsRejected be the algorithm steps defined in AsyncGeneratorResumeNext Return Processor Rejected Functions.\n        // 10. b. i. 7. Let onRejected be CreateBuiltinFunction(stepsRejected, « [[Generator]] »).\n        // 10. b. i. 8. Set onRejected.[[Generator]] to generator.\n        const onRejected = new $AsyncGeneratorResumeNext_Return_Processor_Rejected(realm, generator);\n\n        // 10. b. i. 9. Perform ! PerformPromiseThen(promise, onFulfilled, onRejected).\n        $PerformPromiseThen(ctx, promise, onFulfilled, onRejected);\n\n        // 10. b. i. 10. Return undefined.\n        return intrinsics.undefined;\n      }\n      // 10. b. ii. Else,\n      else {\n        // 10. b. ii. 1. Assert: completion.[[Type]] is throw.\n        // 10. b. ii. 2. Perform ! AsyncGeneratorReject(generator, completion.[[Value]]).\n        $AsyncGeneratorReject(ctx, generator, completion);\n\n        // 10. b. ii. 3. Return undefined.\n        return intrinsics.undefined;\n      }\n    }\n  }\n  // 11. Else if state is \"completed\", return ! AsyncGeneratorResolve(generator, undefined, true).\n  else if (state === AsyncGeneratorState.completed) {\n    return $AsyncGeneratorResolve(ctx, generator, intrinsics.undefined, intrinsics.true);\n  }\n\n  // 12. Assert: state is either \"suspendedStart\" or \"suspendedYield\".\n  // 13. Let genContext be generator.[[AsyncGeneratorContext]].\n  const genContext = generator['[[AsyncGeneratorContext]]']!;\n\n  // 14. Let callerContext be the running execution context.\n  const callerContext = ctx;\n\n  // 15. Suspend callerContext.\n  callerContext.suspend();\n\n  // 16. Set generator.[[AsyncGeneratorState]] to \"executing\".\n  generator['[[AsyncGeneratorState]]'] = AsyncGeneratorState.executing;\n\n  // 17. Push genContext onto the execution context stack; genContext is now the running execution context.\n  stack.push(genContext);\n\n  // 18. Resume the suspended evaluation of genContext using completion as the result of the operation that suspended it. Let result be the completion record returned by the resumed computation.\n  genContext.resume();\n  genContext.onResume!(completion);\n\n  // 19. Assert: result is never an abrupt completion.\n  // 20. Assert: When we return here, genContext has already been removed from the execution context stack and callerContext is the currently running execution context.\n  // 21. Return undefined.\n  return intrinsics.undefined;\n}\n\n// http://www.ecma-international.org/ecma-262/#async-generator-resume-next-return-processor-fulfilled\n// 25.5.3.5.1 AsyncGeneratorResumeNext Return Processor Fulfilled Functions\nexport class $AsyncGeneratorResumeNext_Return_Processor_Fulfilled extends $BuiltinFunction<'AsyncGeneratorResumeNext Return Processor Fulfilled'> {\n  public '[[Generator]]': $AsyncGeneratorInstance;\n\n  public constructor(\n    realm: Realm,\n    generator: $AsyncGeneratorInstance,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'AsyncGeneratorResumeNext Return Processor Fulfilled', intrinsics['%FunctionPrototype%']);\n\n    this['[[Generator]]'] = generator;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Set F.[[Generator]].[[AsyncGeneratorState]] to \"completed\".\n    F['[[Generator]]']['[[AsyncGeneratorState]]'] = AsyncGeneratorState.completed;\n\n    // 3. Return ! AsyncGeneratorResolve(F.[[Generator]], value, true).\n    return $AsyncGeneratorResolve(ctx, F['[[Generator]]'], value, intrinsics.true);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#async-generator-resume-next-return-processor-rejected\n// 25.5.3.5.2 AsyncGeneratorResumeNext Return Processor Rejected Functions\nexport class $AsyncGeneratorResumeNext_Return_Processor_Rejected extends $BuiltinFunction<'AsyncGeneratorResumeNext Return Processor Rejected'> {\n  public '[[Generator]]': $AsyncGeneratorInstance;\n\n  public constructor(\n    realm: Realm,\n    generator: $AsyncGeneratorInstance,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'AsyncGeneratorResumeNext Return Processor Rejected', intrinsics['%FunctionPrototype%']);\n\n    this['[[Generator]]'] = generator;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [value]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (value === void 0) {\n      value = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Set F.[[Generator]].[[AsyncGeneratorState]] to \"completed\".\n    F['[[Generator]]']['[[AsyncGeneratorState]]'] = AsyncGeneratorState.completed;\n\n    // 3. Return ! AsyncGeneratorResolve(F.[[Generator]], value, true).\n    return $AsyncGeneratorResolve(ctx, F['[[Generator]]'], value, intrinsics.true);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratorenqueue\n// 25.5.3.6 AsyncGeneratorEnqueue ( generator , completion )\nexport function $AsyncGeneratorEnqueue(\n  ctx: ExecutionContext,\n  generator: $AsyncGeneratorInstance,\n  completion: $Any,\n): $PromiseInstance {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n\n  // 1. Assert: completion is a Completion Record.\n  // 2. Let promiseCapability be ! NewPromiseCapability(%Promise%).\n  const promiseCapability = $NewPromiseCapability(ctx, intrinsics['%Promise%']) as $PromiseCapability;\n\n  // 3. If Type(generator) is not Object, or if generator does not have an [[AsyncGeneratorState]] internal slot, then\n  if (!(generator instanceof $AsyncGeneratorInstance)) {\n    // 3. a. Let badGeneratorError be a newly created TypeError object.\n    const badGeneratorError = new $TypeError(realm, `Expected generator to be AsyncGeneratorInstance, but got: ${generator}`);\n\n    // 3. b. Perform ! Call(promiseCapability.[[Reject]], undefined, « badGeneratorError »).\n    $Call(ctx, promiseCapability['[[Reject]]'], intrinsics.undefined, new $List(badGeneratorError));\n\n    // 3. c. Return promiseCapability.[[Promise]].\n    return promiseCapability['[[Promise]]'] as $PromiseInstance; // TODO: is this cast safe?\n  }\n\n  // 4. Let queue be generator.[[AsyncGeneratorQueue]].\n  const queue = generator['[[AsyncGeneratorQueue]]'];\n\n  // 5. Let request be AsyncGeneratorRequest { [[Completion]]: completion, [[Capability]]: promiseCapability }.\n  const request = new $AsyncGeneratorRequest(completion, promiseCapability);\n\n  // 6. Append request to the end of queue.\n  queue.push(request);\n\n  // 7. Let state be generator.[[AsyncGeneratorState]].\n  const state = generator['[[AsyncGeneratorState]]'];\n\n  // 8. If state is not \"executing\", then\n  if (state !== AsyncGeneratorState.executing) {\n    // 8. a. Perform ! AsyncGeneratorResumeNext(generator).\n    $AsyncGeneratorResumeNext(ctx, generator);\n  }\n\n  // 9. Return promiseCapability.[[Promise]].\n  return promiseCapability['[[Promise]]'] as $PromiseInstance; // TODO: is this cast safe?\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-asyncgeneratoryield\n// 25.5.3.7 AsyncGeneratorYield ( value )\nexport function $AsyncGeneratorYield(\n  ctx: ExecutionContext,\n  value: $Any,\n): $Any {\n  const realm = ctx.Realm;\n  const intrinsics = realm['[[Intrinsics]]'];\n  const stack = realm.stack;\n\n  // 1. Let genContext be the running execution context.\n  const genContext = ctx;\n\n  // 2. Assert: genContext is the execution context of a generator.\n  // 3. Let generator be the value of the Generator component of genContext.\n  const generator = genContext.Generator as $AsyncGeneratorInstance;\n\n  // 4. Assert: GetGeneratorKind() is async.\n  // 5. Set value to ? Await(value).\n  value = $Await(ctx, value); // TODO: something is not quite right here w.r.t. value propagation. Need to revisit\n\n  // 6. Set generator.[[AsyncGeneratorState]] to \"suspendedYield\".\n  generator['[[AsyncGeneratorState]]'] = AsyncGeneratorState.suspendedYield;\n\n  // 7. Remove genContext from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  stack.pop();\n\n  // 8. Set the code evaluation state of genContext such that when evaluation is resumed with a Completion resumptionValue the following steps will be performed:\n  genContext.onResume = function (resumptionValue): $AnyNonEmpty {\n    // 8. a. If resumptionValue.[[Type]] is not return, return Completion(resumptionValue).\n    if (resumptionValue['[[Type]]'] !== CompletionType.return) {\n      return resumptionValue;\n    }\n\n    // 8. b. Let awaited be Await(resumptionValue.[[Value]]).\n    const awaited = $Await(ctx, resumptionValue);\n\n    // 8. c. If awaited.[[Type]] is throw, return Completion(awaited).\n    if (awaited['[[Type]]'] === CompletionType.throw) {\n      return awaited;\n    }\n\n    // 8. d. Assert: awaited.[[Type]] is normal.\n    // 8. e. Return Completion { [[Type]]: return, [[Value]]: awaited.[[Value]], [[Target]]: empty }.\n    return awaited.ToCompletion(CompletionType.return, intrinsics.empty); // TODO: we never return the resumptionValue from $Await so need to revisit this\n\n    // 8. f. NOTE: When one of the above steps returns, it returns to the evaluation of the YieldExpression production that originally called this abstract operation.\n  };\n\n  // 9. Return ! AsyncGeneratorResolve(generator, value, false).\n  return $AsyncGeneratorResolve(ctx, generator, value, intrinsics.false);\n\n  // 10. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of genContext.\n}\n\n// #endregion\n\n","import {\n  $Object,\n} from '../types/object.js';\nimport {\n  $Null,\n} from '../types/null.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $PropertyKey,\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  $AnyObject,\n  CompletionType,\n} from '../types/_shared.js';\nimport {\n  $Call,\n  $ToPropertyDescriptor,\n  $ValidateAndApplyPropertyDescriptor,\n  $FromPropertyDescriptor,\n  $CreateListFromArrayLike,\n  $Construct,\n} from '../operations.js';\nimport {\n  $Boolean,\n} from '../types/boolean.js';\nimport {\n  $PropertyDescriptor,\n} from '../types/property-descriptor.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $String,\n} from '../types/string.js';\nimport {\n  $Symbol,\n} from '../types/symbol.js';\nimport {\n  $Function,\n} from '../types/function.js';\nimport {\n  $CreateArrayFromList,\n} from './array.js';\nimport {\n  $TypeError,\n  $Error,\n} from '../types/error.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots\nexport class $ProxyExoticObject extends $Object<'ProxyExoticObject'> {\n  public '[[ProxyHandler]]': $AnyObject | $Null;\n  public '[[ProxyTarget]]': $AnyObject | $Null;\n\n  public get isProxy(): true { return true; }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxycreate\n  // 9.5.14 ProxyCreate ( target , handler )\n  public constructor(\n    realm: Realm,\n    target: $AnyNonEmpty,\n    handler: $AnyNonEmpty,\n  ) {\n    super(realm, 'ProxyExoticObject', realm['[[Intrinsics]]'].null, CompletionType.normal, realm['[[Intrinsics]]'].empty);\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm) as any; // TODO: move to static method so we can return error completion\n    }\n\n    // 2. If target is a Proxy exotic object and target.[[ProxyHandler]] is null, throw a TypeError exception.\n    if (target.isProxy && (target as $ProxyExoticObject)['[[ProxyHandler]]'].isNull) {\n      return new $TypeError(realm) as any; // TODO: move to static method so we can return error completion\n    }\n\n    // 3. If Type(handler) is not Object, throw a TypeError exception.\n    if (!handler.isObject) {\n      return new $TypeError(realm) as any; // TODO: move to static method so we can return error completion\n    }\n\n    // 4. If handler is a Proxy exotic object and handler.[[ProxyHandler]] is null, throw a TypeError exception.\n    if (handler instanceof $ProxyExoticObject && handler['[[ProxyHandler]]'].isNull) {\n      return new $TypeError(realm) as any; // TODO: move to static method so we can return error completion\n    }\n\n    // 5. Let P be a newly created object.\n    // 6. Set P's essential internal methods (except for [[Call]] and [[Construct]]) to the definitions specified in 9.5.\n    // 7. If IsCallable(target) is true, then\n    // 7. a. Set P.[[Call]] as specified in 9.5.12.\n    // 7. b. If IsConstructor(target) is true, then\n    // 7. b. i. Set P.[[Construct]] as specified in 9.5.13.\n    // 8. Set P.[[ProxyTarget]] to target.\n    this['[[ProxyTarget]]'] = target;\n\n    // 9. Set P.[[ProxyHandler]] to handler.\n    this['[[ProxyHandler]]'] = handler;\n\n    // 10. Return P.\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-getprototypeof\n  // 9.5.1 [[GetPrototypeOf]] ( )\n  public '[[GetPrototypeOf]]'(\n    ctx: ExecutionContext,\n  ): $AnyObject | $Null | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 2. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    // 4. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 5. Let trap be ? GetMethod(handler, \"getPrototypeOf\").\n    const trap = handler.GetMethod(ctx, intrinsics.$getPrototypeOf);\n    if (trap.isAbrupt) { return trap; }\n\n    // 6. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 6. a. Return ? target.[[GetPrototypeOf]]().\n      return target['[[GetPrototypeOf]]'](ctx);\n    }\n\n    // 7. Let handlerProto be ? Call(trap, handler, « target »).\n    const handlerProto = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target));\n    if (handlerProto.isAbrupt) { return handlerProto; }\n\n    // 8. If Type(handlerProto) is neither Object nor Null, throw a TypeError exception.\n    if (!handlerProto.isNull && !handlerProto.isObject) {\n      return new $TypeError(realm, `Proxy handler prototype is ${handlerProto}, but expected Object or Null`);\n    }\n\n    // 9. Let extensibleTarget be ? IsExtensible(target).\n    const extensibleTarget = target['[[IsExtensible]]'](ctx);\n    if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n\n    // 10. If extensibleTarget is true, return handlerProto.\n    if (extensibleTarget.isTruthy) {\n      return handlerProto;\n    }\n\n    // 11. Let targetProto be ? target.[[GetPrototypeOf]]().\n    const targetProto = target['[[GetPrototypeOf]]'](ctx);\n    if (targetProto.isAbrupt) { return targetProto; }\n\n    // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError exception.\n    if (!handlerProto.is(targetProto)) {\n      return new $TypeError(realm, `Expected handler prototype ${handlerProto} to be the same value as target prototype ${targetProto}`);\n    }\n\n    // 13. Return handlerProto.\n    return handlerProto;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v\n  // 9.5.2 [[SetPrototypeOf]] ( V )\n  public '[[SetPrototypeOf]]'(\n    ctx: ExecutionContext,\n    V: $AnyObject | $Null,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: Either Type(V) is Object or Type(V) is Null.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"setPrototypeOf\").\n    const trap = handler.GetMethod(ctx, intrinsics.$setPrototypeOf);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[SetPrototypeOf]](V).\n      return target['[[SetPrototypeOf]]'](ctx, V);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, V »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, V)).ToBoolean(ctx);\n    if (booleanTrapResult.isAbrupt) { return booleanTrapResult; }\n\n    // 9. If booleanTrapResult is false, return false.\n    if (booleanTrapResult.isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 10. Let extensibleTarget be ? IsExtensible(target).\n    const extensibleTarget = target['[[IsExtensible]]'](ctx);\n    if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n    if (extensibleTarget.isTruthy) {\n      // 11. If extensibleTarget is true, return true.\n      return intrinsics.true;\n    }\n\n    // 12. Let targetProto be ? target.[[GetPrototypeOf]]().\n    const targetProto = target['[[GetPrototypeOf]]'](ctx);\n    if (targetProto.isAbrupt) { return targetProto; }\n\n    // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.\n    if (!V.is(targetProto)) {\n      return new $TypeError(realm, `Expected value ${V} to be the same value as target prototype ${targetProto}`);\n    }\n\n    // 14. Return true.\n      return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-isextensible\n  // 9.5.3 [[IsExtensible]] ( )\n  public '[[IsExtensible]]'(\n    ctx: ExecutionContext,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 2. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    // 4. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 5. Let trap be ? GetMethod(handler, \"isExtensible\").\n    const trap = handler.GetMethod(ctx, intrinsics.$isExtensible);\n    if (trap.isAbrupt) { return trap; }\n\n    // 6. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 6. a. Return ? target.[[IsExtensible]]().\n      return target['[[IsExtensible]]'](ctx);\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target)).ToBoolean(ctx);\n\n    // 8. Let targetResult be ? target.[[IsExtensible]]().\n    const targetResult = target['[[IsExtensible]]'](ctx);\n    if (targetResult.isAbrupt) { return targetResult; }\n\n    // 9. If SameValue(booleanTrapResult, targetResult) is false, throw a TypeError exception.\n    if (!booleanTrapResult.is(targetResult)) {\n      return new $TypeError(realm, `Expected booleanTrapResult ${booleanTrapResult} to be the same value as targetResult ${targetResult}`);\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-preventextensions\n  // 9.5.4 [[PreventExtensions]] ( )\n  public '[[PreventExtensions]]'(\n    ctx: ExecutionContext,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 2. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    // 4. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 5. Let trap be ? GetMethod(handler, \"preventExtensions\").\n    const trap = handler.GetMethod(ctx, intrinsics.$preventExtensions);\n    if (trap.isAbrupt) { return trap; }\n\n    // 6. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 6. a. Return ? target.[[PreventExtensions]]().\n      return target['[[PreventExtensions]]'](ctx);\n    }\n\n    // 7. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target)).ToBoolean(ctx);\n    if (booleanTrapResult.isAbrupt) { return booleanTrapResult; }\n\n    // 8. If booleanTrapResult is true, then\n    if (booleanTrapResult.isTruthy) {\n      // 8. a. Let targetIsExtensible be ? target.[[IsExtensible]]().\n      const targetIsExtensible = target['[[IsExtensible]]'](ctx);\n      if (targetIsExtensible.isAbrupt) { return targetIsExtensible; }\n\n      // 8. b. If targetIsExtensible is true, throw a TypeError exception.\n      if (targetIsExtensible.isTruthy) {\n        return new $TypeError(realm, `Target is still extensible`);\n      }\n    }\n\n    // 9. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p\n  // 9.5.5 [[GetOwnProperty]] ( P )\n  public '[[GetOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $PropertyDescriptor | $Undefined | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"getOwnPropertyDescriptor\").\n    const trap = handler.GetMethod(ctx, intrinsics.$getOwnPropertyDescriptor);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[GetOwnProperty]](P).\n      return target['[[GetOwnProperty]]'](ctx, P);\n    }\n\n    // 8. Let trapResultObj be ? Call(trap, handler, « target, P »).\n    const trapResultObj = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, P));\n    if (trapResultObj.isAbrupt) { return trapResultObj; }\n\n    // 9. If Type(trapResultObj) is neither Object nor Undefined, throw a TypeError exception.\n    if (!trapResultObj.isObject && !trapResultObj.isUndefined) {\n      return new $TypeError(realm, `trapResultObj from GetOwnProperty(${P}) is ${trapResultObj}, but expected Object or Undefined`);\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    const targetDesc = target['[[GetOwnProperty]]'](ctx, P);\n    if (targetDesc.isAbrupt) { return targetDesc; }\n\n    // 11. If trapResultObj is undefined, then\n    if (trapResultObj.isUndefined) {\n      // 11. a. If targetDesc is undefined, return undefined.\n      if (targetDesc.isUndefined) {\n        return intrinsics.undefined;\n      }\n\n      // 11. b. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n      if (targetDesc['[[Configurable]]'].isFalsey) {\n        return new $TypeError(realm, `The proxy returned undefined for property descriptor ${P}, but there is a backing property descriptor which is not configurable`);\n      }\n\n      // 11. c. Let extensibleTarget be ? IsExtensible(target).\n      const extensibleTarget = target['[[IsExtensible]]'](ctx);\n      if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n\n      // 11. d. If extensibleTarget is false, throw a TypeError exception.\n      if (extensibleTarget.isFalsey) {\n        return new $TypeError(realm, `The proxy returned undefined for property descriptor ${P}, but there is a backing property descriptor and the backing object is not extensible`);\n      }\n\n      // 11. e. Return undefined.\n      return intrinsics.undefined;\n    }\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    const extensibleTarget = target['[[IsExtensible]]'](ctx);\n    if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n\n    // 13. Let resultDesc be ? ToPropertyDescriptor(trapResultObj).\n    const resultDesc = $ToPropertyDescriptor(ctx, trapResultObj, P);\n    if (resultDesc.isAbrupt) { return resultDesc; }\n\n    // 14. Call CompletePropertyDescriptor(resultDesc).\n    resultDesc.Complete(ctx);\n\n    // 15. Let valid be IsCompatiblePropertyDescriptor(extensibleTarget, resultDesc, targetDesc).\n    const valid = $ValidateAndApplyPropertyDescriptor(\n      ctx,\n      /* O */intrinsics.undefined,\n      /* P */intrinsics.undefined,\n      /* extensible */extensibleTarget,\n      /* Desc */resultDesc,\n      /* current */targetDesc,\n    );\n\n    // 16. If valid is false, throw a TypeError exception.\n    if (valid.isFalsey) {\n      return new $TypeError(realm, `Validation for property descriptor ${P} failed`);\n    }\n\n    // 17. If resultDesc.[[Configurable]] is false, then\n    if (resultDesc['[[Configurable]]'].isFalsey) {\n      // 17. a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, then\n      if (targetDesc.isUndefined || targetDesc['[[Configurable]]'].isTruthy) {\n        // 17. a. i. Throw a TypeError exception.\n        return new $TypeError(realm, `The proxy returned a non-configurable property descriptor for ${P}, but the backing property descriptor is either undefined or configurable`);\n      }\n    }\n\n    // 18. Return resultDesc.\n    return resultDesc;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc\n  // 9.5.6 [[DefineOwnProperty]] ( P , Desc )\n  public '[[DefineOwnProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Desc: $PropertyDescriptor,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"defineProperty\").\n    const trap = handler.GetMethod(ctx, intrinsics.$defineProperty);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[DefineOwnProperty]](P, Desc).\n      return target['[[DefineOwnProperty]]'](ctx, P, Desc);\n    }\n\n    // 8. Let descObj be FromPropertyDescriptor(Desc).\n    const descObj = $FromPropertyDescriptor(ctx, Desc);\n    if (descObj.isAbrupt) { return descObj; } // TODO: spec doesn't say this. maybe we need to fix the types somehow?\n\n    // 9. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, descObj »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, P, descObj)).ToBoolean(ctx);\n    if (booleanTrapResult.isAbrupt) { return booleanTrapResult; }\n\n    // 10. If booleanTrapResult is false, return false.\n    if (booleanTrapResult.isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 11. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    const targetDesc = target['[[GetOwnProperty]]'](ctx, P);\n    if (targetDesc.isAbrupt) { return targetDesc; }\n\n    // 12. Let extensibleTarget be ? IsExtensible(target).\n    const extensibleTarget = target['[[IsExtensible]]'](ctx);\n    if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n\n    let settingConfigFalse: boolean;\n    // 13. If Desc has a [[Configurable]] field and if Desc.[[Configurable]] is false, then\n    if (Desc['[[Configurable]]'].hasValue && Desc['[[Configurable]]'].isFalsey) {\n      // 13. a. Let settingConfigFalse be true.\n      settingConfigFalse = true;\n    }\n    // 14. Else, let settingConfigFalse be false.\n    else {\n      settingConfigFalse = false;\n    }\n\n    // 15. If targetDesc is undefined, then\n    if (targetDesc.isUndefined) {\n      // 15. a. If extensibleTarget is false, throw a TypeError exception.\n      if (extensibleTarget.isFalsey) {\n        return new $TypeError(realm, `Cannot define property ${P} on non-extensible target`);\n      }\n\n      // 15. b. If settingConfigFalse is true, throw a TypeError exception.\n      if (!settingConfigFalse) {\n        return new $TypeError(realm, `Cannot define non-configurable property ${P} on proxy`);\n      }\n    }\n    // 16. Else targetDesc is not undefined,\n    else {\n      // 16. a. If IsCompatiblePropertyDescriptor(extensibleTarget, Desc, targetDesc) is false, throw a TypeError exception.\n      if ($ValidateAndApplyPropertyDescriptor(\n        ctx,\n        /* O */intrinsics.undefined,\n        /* P */intrinsics.undefined,\n        /* extensible */extensibleTarget,\n        /* Desc */Desc,\n        /* current */targetDesc,\n      ).isFalsey) {\n        return new $TypeError(realm, `The provided property descriptor for ${P} is not compatible with the proxy target's existing descriptor`);\n      }\n\n      // 16. b. If settingConfigFalse is true and targetDesc.[[Configurable]] is true, throw a TypeError exception.\n      if (settingConfigFalse && targetDesc['[[Configurable]]'].isTruthy) {\n        return new $TypeError(realm, `The provided property descriptor for ${P} is not configurable but the proxy target's existing descriptor is`);\n      }\n    }\n\n    // 17. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p\n  // 9.5.7 [[HasProperty]] ( P )\n  public '[[HasProperty]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"has\").\n    const trap = handler.GetMethod(ctx, intrinsics.$has);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[HasProperty]](P).\n      return target['[[HasProperty]]'](ctx, P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, P)).ToBoolean(ctx);\n    if (booleanTrapResult.isAbrupt) { return booleanTrapResult; }\n\n    // 9. If booleanTrapResult is false, then\n    if (booleanTrapResult.isFalsey) {\n      // 9. a. Let targetDesc be ? target.[[GetOwnProperty]](P).\n      const targetDesc = target['[[GetOwnProperty]]'](ctx, P);\n      if (targetDesc.isAbrupt) { return targetDesc; }\n\n      // 9. b. If targetDesc is not undefined, then\n      if (!targetDesc.isUndefined) {\n        // 9. b. i. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n        if (targetDesc['[[Configurable]]'].isFalsey) {\n          return new $TypeError(realm, `The proxy returned false for HasProperty for ${P}, but the backing object has a property with that name which is not configurable`);\n        }\n\n        // 9. b. ii. Let extensibleTarget be ? IsExtensible(target).\n        const extensibleTarget = target['[[IsExtensible]]'](ctx);\n        if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n\n        if (extensibleTarget.isFalsey) {\n          // 9. b. iii. If extensibleTarget is false, throw a TypeError exception.\n          return new $TypeError(realm, `The proxy returned false for HasProperty for ${P}, but the backing object has a property with that name and is not extensible`);\n        }\n      }\n    }\n\n    // 10. Return booleanTrapResult.\n    return booleanTrapResult;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver\n  // 9.5.8 [[Get]] ( P , Receiver )\n  public '[[Get]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    Receiver: $AnyNonEmptyNonError,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"get\").\n    const trap = handler.GetMethod(ctx, intrinsics.$get);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[Get]](P, Receiver).\n      return target['[[Get]]'](ctx, P, Receiver);\n    }\n\n    // 8. Let trapResult be ? Call(trap, handler, « target, P, Receiver »).\n    const trapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, P, Receiver));\n    if (trapResult.isAbrupt) { return trapResult; }\n\n    // 9. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    const targetDesc = target['[[GetOwnProperty]]'](ctx, P);\n    if (targetDesc.isAbrupt) { return targetDesc; }\n\n    // 10. If targetDesc is not undefined and targetDesc.[[Configurable]] is false, then\n    if (!targetDesc.isUndefined && targetDesc['[[Configurable]]'].isFalsey) {\n      // 10. a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Writable]] is false, then\n      if (targetDesc.isDataDescriptor && targetDesc['[[Writable]]'].isFalsey) {\n        // 10. a. i. If SameValue(trapResult, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        if (!trapResult.is(targetDesc['[[Value]]'])) {\n          return new $TypeError(realm, `The value returned by the proxy's getter for ${P} (${trapResult}) is different from the backing property's value (${targetDesc}), but the backing descriptor is neither configurable nor writable`);\n        }\n      }\n\n      // 10. b. If IsAccessorDescriptor(targetDesc) is true and targetDesc.[[Get]] is undefined, then\n      if (targetDesc.isAccessorDescriptor && targetDesc['[[Get]]'].isUndefined) {\n        // 10. b. i. If trapResult is not undefined, throw a TypeError exception.\n        if (!trapResult.isUndefined) {\n          return new $TypeError(realm, `The proxy's getter for ${P} returned (${trapResult}), but expected undefined because the backing property's accessor descriptor has no getter and is not configurable`);\n        }\n      }\n    }\n\n    // 11. Return trapResult.\n    return trapResult;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver\n  // 9.5.9 [[Set]] ( P , V , Receiver )\n  public '[[Set]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n    V: $AnyNonEmpty ,\n    Receiver: $AnyObject,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"set\").\n    const trap = handler.GetMethod(ctx, intrinsics.$set);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[Set]](P, V, Receiver).\n      return target['[[Set]]'](ctx, P, V, Receiver);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P, V, Receiver »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, P, V, Receiver)).ToBoolean(ctx);\n    if (booleanTrapResult.isAbrupt) { return booleanTrapResult; }\n\n    // 9. If booleanTrapResult is false, return false.\n    if (booleanTrapResult.isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    const targetDesc = target['[[GetOwnProperty]]'](ctx, P);\n    if (targetDesc.isAbrupt) { return targetDesc; }\n\n    // 11. If targetDesc is not undefined and targetDesc.[[Configurable]] is false, then\n    if (!targetDesc.isUndefined && targetDesc['[[Configurable]]'].isFalsey) {\n\n      // 11. a. If IsDataDescriptor(targetDesc) is true and targetDesc.[[Writable]] is false, then\n      if (targetDesc.isDataDescriptor && targetDesc['[[Writable]]'].isFalsey) {\n\n        // 11. a. i. If SameValue(V, targetDesc.[[Value]]) is false, throw a TypeError exception.\n        if (!V.is(targetDesc['[[Value]]'])) {\n          return new $TypeError(realm, `The value supplied to the proxy's setter for ${P} (${V}) is different from the backing property's value (${targetDesc}), but the backing descriptor is neither configurable nor writable`);\n        }\n      }\n\n      // 11. b. If IsAccessorDescriptor(targetDesc) is true, then\n      if (targetDesc.isAccessorDescriptor) {\n        // 11. b. i. If targetDesc.[[Set]] is undefined, throw a TypeError exception.\n        if (targetDesc['[[Set]]'].isUndefined) {\n          return new $TypeError(realm, `The proxy's setter for ${P} was invoked, but the backing property's accessor descriptor has no setter and is not configurable`);\n        }\n      }\n    }\n\n    // 12. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-delete-p\n  // 9.5.10 [[Delete]] ( P )\n  public '[[Delete]]'(\n    ctx: ExecutionContext,\n    P: $PropertyKey,\n  ): $Boolean | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Assert: IsPropertyKey(P) is true.\n\n    // 2. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 3. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 4. Assert: Type(handler) is Object.\n    // 5. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 6. Let trap be ? GetMethod(handler, \"deleteProperty\").\n    const trap = handler.GetMethod(ctx, intrinsics.$deleteProperty);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? target.[[Delete]](P).\n      return target['[[Delete]]'](ctx, P);\n    }\n\n    // 8. Let booleanTrapResult be ToBoolean(? Call(trap, handler, « target, P »)).\n    const booleanTrapResult = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, P)).ToBoolean(ctx);\n    if (booleanTrapResult.isAbrupt) { return booleanTrapResult; }\n\n    // 9. If booleanTrapResult is false, return false.\n    if (booleanTrapResult.isFalsey) {\n      return intrinsics.false;\n    }\n\n    // 10. Let targetDesc be ? target.[[GetOwnProperty]](P).\n    const targetDesc = target['[[GetOwnProperty]]'](ctx, P);\n    if (targetDesc.isAbrupt) { return targetDesc; }\n\n    // 11. If targetDesc is undefined, return true.\n    if (targetDesc.isUndefined) {\n      return intrinsics.true;\n    }\n\n    // 12. If targetDesc.[[Configurable]] is false, throw a TypeError exception.\n    if (targetDesc['[[Configurable]]'].isFalsey) {\n      return new $TypeError(realm, `The [[Delete]] trap returned true for ${P}, but the backing descriptor is not configurable`);\n    }\n\n    // 13. Return true.\n    return intrinsics.true;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys\n  // 9.5.11 [[OwnPropertyKeys]] ( )\n  public '[[OwnPropertyKeys]]'(\n    ctx: ExecutionContext,\n  ): $List<$PropertyKey> | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 2. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    // 4. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Object;\n\n    // 5. Let trap be ? GetMethod(handler, \"ownKeys\").\n    const trap = handler.GetMethod(ctx, intrinsics.$ownKeys);\n    if (trap.isAbrupt) { return trap; }\n\n    // 6. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 6. a. Return ? target.[[OwnPropertyKeys]]().\n      return target['[[OwnPropertyKeys]]'](ctx);\n    }\n\n    // 7. Let trapResultArray be ? Call(trap, handler, « target »).\n    const trapResultArray = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target));\n    if (trapResultArray.isAbrupt) { return trapResultArray; }\n\n    // 8. Let trapResult be ? CreateListFromArrayLike(trapResultArray, « String, Symbol »).\n    const trapResult = $CreateListFromArrayLike(ctx, trapResultArray, ['String', 'Symbol']) as $List<$String | $Symbol>;\n    if (trapResult.isAbrupt) { return trapResult; }\n\n    // 9. If trapResult contains any duplicate entries, throw a TypeError exception.\n    if (trapResult.filter((x, i) => trapResult.findIndex(y => x.is(y)) === i).length !== trapResult.length) {\n      return new $TypeError(realm, `The [[OwnPropertyKeys]] trap returned more than one of the same property key: ${trapResult.map(x => x['[[Value]]'])}`);\n    }\n\n    // 10. Let extensibleTarget be ? IsExtensible(target).\n    const extensibleTarget = target['[[IsExtensible]]'](ctx);\n    if (extensibleTarget.isAbrupt) { return extensibleTarget; }\n\n    // 11. Let targetKeys be ? target.[[OwnPropertyKeys]]().\n    const targetKeys = target['[[OwnPropertyKeys]]'](ctx);\n    if (targetKeys.isAbrupt) { return targetKeys; }\n\n    // 12. Assert: targetKeys is a List containing only String and Symbol values.\n    // 13. Assert: targetKeys contains no duplicate entries.\n\n    // 14. Let targetConfigurableKeys be a new empty List.\n    const targetConfigurableKeys: $PropertyKey[] = [];\n\n    // 15. Let targetNonconfigurableKeys be a new empty List.\n    const targetNonconfigurableKeys: $PropertyKey[] = [];\n\n    // 16. For each element key of targetKeys, do\n    for (const key of targetKeys) {\n      // 16. a. Let desc be ? target.[[GetOwnProperty]](key).\n      const desc = target['[[GetOwnProperty]]'](ctx, key);\n      if (desc.isAbrupt) { return desc; }\n\n      // 16. b. If desc is not undefined and desc.[[Configurable]] is false, then\n      if (!desc.isUndefined && desc['[[Configurable]]'].isFalsey) {\n        // 16. b. i. Append key as an element of targetNonconfigurableKeys.\n        targetNonconfigurableKeys.push(key);\n      }\n      // 16. c. Else,\n      else {\n        // 16. c. i. Append key as an element of targetConfigurableKeys.\n        targetConfigurableKeys.push(key);\n      }\n    }\n\n    // 17. If extensibleTarget is true and targetNonconfigurableKeys is empty, then\n    if (extensibleTarget.isTruthy && targetConfigurableKeys.length === 0)  {\n      // 17. a. Return trapResult.\n      return trapResult;\n    }\n\n    // 18. Let uncheckedResultKeys be a new List which is a copy of trapResult.\n    const uncheckedResultKeys = trapResult.slice();\n\n    // 19. For each key that is an element of targetNonconfigurableKeys, do\n    for (const key of targetNonconfigurableKeys) {\n      // 19. a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      const idx = uncheckedResultKeys.findIndex(x => x.is(key));\n      if (idx === -1) {\n        return new $TypeError(realm, `The [[OwnPropertyKeys]] trap did not return all non-configurable keys of the backing object: ${key}`);\n      }\n\n      // 19. b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(idx, 1);\n    }\n\n    // 20. If extensibleTarget is true, return trapResult.\n    if (extensibleTarget.isTruthy) {\n      return trapResult;\n    }\n\n    // 21. For each key that is an element of targetConfigurableKeys, do\n    for (const key of targetConfigurableKeys) {\n      // 21. a. If key is not an element of uncheckedResultKeys, throw a TypeError exception.\n      const idx = uncheckedResultKeys.findIndex(x => x.is(key));\n      if (idx === -1) {\n        return new $TypeError(realm, `The [[OwnPropertyKeys]] trap did not return all configurable keys of the backing object: ${key}`);\n      }\n\n      // 21. b. Remove key from uncheckedResultKeys.\n      uncheckedResultKeys.splice(idx, 1);\n    }\n\n    // 22. If uncheckedResultKeys is not empty, throw a TypeError exception.\n    if (uncheckedResultKeys.length > 0) {\n      return new $TypeError(realm, `The [[OwnPropertyKeys]] returned one or more keys that do not exist on the backing object: ${uncheckedResultKeys.map(x => x)}`);\n    }\n\n    // 23. Return trapResult.\n    return trapResult;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist\n  // 9.5.12 [[Call]] ( thisArgument , argumentsList )\n  public '[[Call]]'(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 2. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    // 4. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Function;\n\n    // 5. Let trap be ? GetMethod(handler, \"apply\").\n    const trap = handler.GetMethod(ctx, intrinsics.$apply);\n    if (trap.isAbrupt) { return trap; }\n\n    // 6. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 6. a. Return ? Call(target, thisArgument, argumentsList).\n      return $Call(ctx, target, thisArgument, argumentsList);\n    }\n\n    // 7. Let argArray be CreateArrayFromList(argumentsList).\n    const argArray = $CreateArrayFromList(ctx, argumentsList);\n\n    // 8. Return ? Call(trap, handler, « target, thisArgument, argArray »).\n    return $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, thisArgument, argArray));\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget\n  // 9.5.13 [[Construct]] ( argumentsList , newTarget )\n  public '[[Construct]]'(\n    ctx: ExecutionContext,\n    argumentsList: $List<$AnyNonEmpty>,\n    newTarget: $Function | $Undefined,\n  ): $AnyObject | $Error {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 1. Let handler be O.[[ProxyHandler]].\n    const handler = this['[[ProxyHandler]]'];\n\n    if (handler.isNull) {\n      // 2. If handler is null, throw a TypeError exception.\n      return new $TypeError(realm, `ProxyHandler is null`);\n    }\n\n    // 3. Assert: Type(handler) is Object.\n    // 4. Let target be O.[[ProxyTarget]].\n    const target = this['[[ProxyTarget]]'] as $Function;\n\n    // 5. Assert: IsConstructor(target) is true.\n    // 6. Let trap be ? GetMethod(handler, \"construct\").\n    const trap = handler.GetMethod(ctx, intrinsics.$construct);\n    if (trap.isAbrupt) { return trap; }\n\n    // 7. If trap is undefined, then\n    if (trap.isUndefined) {\n      // 7. a. Return ? Construct(target, argumentsList, newTarget).\n      return $Construct(ctx, target, argumentsList, newTarget);\n    }\n\n    // 8. Let argArray be CreateArrayFromList(argumentsList).\n    const argArray = $CreateArrayFromList(ctx, argumentsList);\n\n    // 9. Let newObj be ? Call(trap, handler, « target, argArray, newTarget »).\n    const newObj = $Call(ctx, trap, handler, new $List<$AnyNonEmpty>(target, argArray, newTarget));\n    if (newObj.isAbrupt) { return newObj; }\n\n    // 10. If Type(newObj) is not Object, throw a TypeError exception.\n    if (!newObj.isObject) {\n      return new $TypeError(realm, `The [[Construct]] trap returned ${newObj}, but expected an object`);\n    }\n\n    // 11. Return newObj.\n    return newObj;\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Error, $TypeError,\n} from '../types/error.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $List\n} from '../types/list.js';\nimport {\n  $ProxyExoticObject,\n} from '../exotics/proxy.js';\nimport {\n  $Null,\n} from '../types/null.js';\nimport {\n  $CreateDataProperty,\n} from '../operations.js';\nimport {\n  $String,\n} from '../types/string.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-proxy-objects\n// 26.2 Proxy Objects\n\n// http://www.ecma-international.org/ecma-262/#sec-proxy-constructor\n// 26.2.1 The Proxy Constructor\nexport class $ProxyConstructor extends $BuiltinFunction<'%Proxy%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-proxy.revocable\n  // 26.2.2.1 Proxy.revocable ( target , handler )\n  public get revocable(): $Proxy_revocable {\n    return this.getProperty(this.realm['[[Intrinsics]]'].revocable)['[[Value]]'] as $Proxy_revocable;\n  }\n  public set revocable(value: $Proxy_revocable) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].revocable, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, '%Proxy%', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-target-handler\n  // 26.2.1.1 Proxy ( target , handler )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [target, handler]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (handler === void 0) {\n      handler = intrinsics.undefined;\n    }\n\n    // 1. If NewTarget is undefined, throw a TypeError exception.\n    if (NewTarget.isUndefined) {\n      return new $TypeError(realm, `Proxy cannot be called as a function`);\n    }\n\n    // 2. Return ? ProxyCreate(target, handler).\n    return new $ProxyExoticObject(realm, target, handler);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-proxy.revocable\n// 26.2.2.1 Proxy.revocable ( target , handler )\nexport class $Proxy_revocable extends $BuiltinFunction<'Proxy.revocable'> {\n  public constructor(\n    realm: Realm,\n    functionPrototype: $FunctionPrototype,\n  ) {\n    super(realm, 'Proxy.revocable', functionPrototype);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-proxy-target-handler\n  // 26.2.1.1 Proxy ( target , handler )\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [target, handler]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (handler === void 0) {\n      handler = intrinsics.undefined;\n    }\n\n    // 1. Let p be ? ProxyCreate(target, handler).\n    const p = new $ProxyExoticObject(realm, target, handler) as $ProxyExoticObject | $Error;\n    if (p.isAbrupt) { return p; }\n\n    // 2. Let steps be the algorithm steps defined in Proxy Revocation Functions.\n    // 3. Let revoker be CreateBuiltinFunction(steps, « [[RevocableProxy]] »).\n    // 4. Set revoker.[[RevocableProxy]] to p.\n    const revoker = new $Proxy_revocation(realm, p);\n\n    // 5. Let result be ObjectCreate(%ObjectPrototype%).\n    const result = $Object.ObjectCreate(ctx, 'Revocable Proxy', intrinsics['%ObjectPrototype%']);\n\n    // 6. Perform CreateDataProperty(result, \"proxy\", p).\n    $CreateDataProperty(ctx, result, new $String(realm, 'proxy'), p);\n\n    // 7. Perform CreateDataProperty(result, \"revoke\", revoker).\n    $CreateDataProperty(ctx, result, new $String(realm, 'revoke'), revoker);\n\n    // 8. Return result.\n    return result;\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-proxy-revocation-functions\n// 26.2.2.1.1 Proxy Revocation Functions\nexport class $Proxy_revocation extends $BuiltinFunction<'Proxy Revocation'> {\n  public '[[RecovableProxy]]': $ProxyExoticObject | $Null;\n\n  public constructor(\n    realm: Realm,\n    revocableProxy: $ProxyExoticObject,\n  ) {\n    const intrinsics = realm['[[Intrinsics]]'];\n    super(realm, 'Proxy Revocation', intrinsics['%FunctionPrototype%']);\n\n    this['[[RecovableProxy]]'] = revocableProxy;\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    [target, handler]: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (handler === void 0) {\n      handler = intrinsics.undefined;\n    }\n\n    // 1. Let F be the active function object.\n    const F = this;\n\n    // 2. Let p be F.[[RevocableProxy]].\n    const p = F['[[RecovableProxy]]'];\n\n    // 3. If p is null, return undefined.\n    if (p.isNull) {\n      return intrinsics.undefined;\n    }\n\n    // 4. Set F.[[RevocableProxy]] to null.\n    F['[[RecovableProxy]]'] = intrinsics.null;\n\n    // 5. Assert: p is a Proxy object.\n    // 6. Set p.[[ProxyTarget]] to null.\n    p['[[ProxyTarget]]'] = intrinsics.null;\n\n    // 7. Set p.[[ProxyHandler]] to null.\n    p['[[ProxyHandler]]'] = intrinsics.null;\n\n    // 8. Return undefined.\n    return intrinsics.undefined;\n  }\n}\n\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n  CompletionType,\n  $AnyObject,\n} from '../types/_shared.js';\nimport {\n  $TypeError,\n} from '../types/error.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $Object,\n} from '../types/object.js';\nimport {\n  $List\n} from '../types/list.js';\nimport {\n  $ToPropertyDescriptor,\n  $CreateListFromArrayLike,\n  $Call,\n  $Construct,\n  $FromPropertyDescriptor,\n} from '../operations.js';\nimport {\n  $ObjectPrototype,\n} from './object.js';\nimport {\n  $CreateArrayFromList,\n} from '../exotics/array.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-reflection\n// 26 Reflection\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect-object\n// 26.1 The Reflect Object\nexport class $Reflect extends $Object<'%Reflect%'> {\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.apply\n  // 26.1.1 Reflect.apply ( target , thisArgument , argumentsList )\n  public get $apply(): $Reflect_apply {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$apply)['[[Value]]'] as $Reflect_apply;\n  }\n  public set $apply(value: $Reflect_apply) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$apply, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.construct\n  // 26.1.2 Reflect.construct ( target , argumentsList [ , newTarget ] )\n  public get $construct(): $Reflect_construct {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$construct)['[[Value]]'] as $Reflect_construct;\n  }\n  public set $construct(value: $Reflect_construct) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$construct, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.defineproperty\n  // 26.1.3 Reflect.defineProperty ( target , propertyKey , attributes )\n  public get $defineProperty(): $Reflect_defineProperty {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$defineProperty)['[[Value]]'] as $Reflect_defineProperty;\n  }\n  public set $defineProperty(value: $Reflect_defineProperty) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$defineProperty, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.deleteproperty\n  // 26.1.4 Reflect.deleteProperty ( target , propertyKey )\n  public get $deleteProperty(): $Reflect_deleteProperty {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$deleteProperty)['[[Value]]'] as $Reflect_deleteProperty;\n  }\n  public set $deleteProperty(value: $Reflect_deleteProperty) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$deleteProperty, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.get\n  // 26.1.5 Reflect.get ( target , propertyKey [ , receiver ] )\n  public get $get(): $Reflect_get {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$get)['[[Value]]'] as $Reflect_get;\n  }\n  public set $get(value: $Reflect_get) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$get, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.getownpropertydescriptor\n  // 26.1.6 Reflect.getOwnPropertyDescriptor ( target , propertyKey )\n  public get $getOwnPropertyDescriptor(): $Reflect_getOwnPropertyDescriptor {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor)['[[Value]]'] as $Reflect_getOwnPropertyDescriptor;\n  }\n  public set $getOwnPropertyDescriptor(value: $Reflect_getOwnPropertyDescriptor) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getOwnPropertyDescriptor, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.getprototypeof\n  // 26.1.7 Reflect.getPrototypeOf ( target )\n  public get $getPrototypeOf(): $Reflect_getPrototypeOf {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf)['[[Value]]'] as $Reflect_getPrototypeOf;\n  }\n  public set $getPrototypeOf(value: $Reflect_getPrototypeOf) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$getPrototypeOf, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.has\n  // 26.1.8 Reflect.has ( target , propertyKey )\n  public get $has(): $Reflect_has {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$has)['[[Value]]'] as $Reflect_has;\n  }\n  public set $has(value: $Reflect_has) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$has, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.isextensible\n  // 26.1.9 Reflect.isExtensible ( target )\n  public get $isExtensible(): $Reflect_isExtensible {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$isExtensible)['[[Value]]'] as $Reflect_isExtensible;\n  }\n  public set $isExtensible(value: $Reflect_isExtensible) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$isExtensible, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.ownkeys\n  // 26.1.10 Reflect.ownKeys ( target )\n  public get $ownKeys(): $Reflect_ownKeys {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$ownKeys)['[[Value]]'] as $Reflect_ownKeys;\n  }\n  public set $ownKeys(value: $Reflect_ownKeys) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$ownKeys, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.preventextensions\n  // 26.1.11 Reflect.preventExtensions ( target )\n  public get $preventExtensions(): $Reflect_preventExtensions {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$preventExtensions)['[[Value]]'] as $Reflect_preventExtensions;\n  }\n  public set $preventExtensions(value: $Reflect_preventExtensions) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$preventExtensions, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.set\n  // 26.1.12 Reflect.set ( target , propertyKey , V [ , receiver ] )\n  public get $set(): $Reflect_set {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$set)['[[Value]]'] as $Reflect_set;\n  }\n  public set $set(value: $Reflect_set) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$set, value);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-reflect.setprototypeof\n  // 26.1.13 Reflect.setPrototypeOf ( target , proto )\n  public get $setPrototypeOf(): $Reflect_setPrototypeOf {\n    return this.getProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf)['[[Value]]'] as $Reflect_setPrototypeOf;\n  }\n  public set $setPrototypeOf(value: $Reflect_setPrototypeOf) {\n    this.setDataProperty(this.realm['[[Intrinsics]]'].$setPrototypeOf, value);\n  }\n\n  public constructor(\n    realm: Realm,\n    proto: $ObjectPrototype,\n  ) {\n    super(realm, '%Reflect%', proto, CompletionType.normal, realm['[[Intrinsics]]'].empty);\n  }\n}\n// http://www.ecma-international.org/ecma-262/#sec-reflect.apply\n// 26.1.1 Reflect.apply ( target , thisArgument , argumentsList )\nexport class $Reflect_apply extends $BuiltinFunction<'Reflect.apply'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.apply', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, thisArgument, argumentsList]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (thisArgument === void 0) {\n      thisArgument = intrinsics.undefined;\n    }\n    if (argumentsList === void 0) {\n      argumentsList = intrinsics.undefined;\n    }\n\n    // 1. If IsCallable(target) is false, throw a TypeError exception.\n    if (!target.isFunction) {\n      return new $TypeError(realm, `Expected target to be a function, but got: ${target}`);\n    }\n\n    // 2. Let args be ? CreateListFromArrayLike(argumentsList).\n    const args = $CreateListFromArrayLike(ctx, argumentsList);\n    if (args.isAbrupt) { return args; }\n\n    // 3. Perform PrepareForTailCall().\n    ctx.suspend();\n    realm.stack.pop();\n\n    // 4. Return ? Call(target, thisArgument, args).\n    return $Call(ctx, target, thisArgument as $AnyNonEmptyNonError, args); // TODO: is this cast safe?\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.construct\n// 26.1.2 Reflect.construct ( target , argumentsList [ , newTarget ] )\nexport class $Reflect_construct extends $BuiltinFunction<'Reflect.construct'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.construct', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, argumentsList, newTarget]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (argumentsList === void 0) {\n      argumentsList = intrinsics.undefined;\n    }\n\n    // 1. If IsConstructor(target) is false, throw a TypeError exception.\n    if (!target.isFunction) {\n      return new $TypeError(realm, `Expected target to be a constructor function, but got: ${target}`);\n    }\n\n    // 2. If newTarget is not present, set newTarget to target.\n    if (newTarget === void 0) {\n      newTarget = target;\n    }\n    // 3. Else if IsConstructor(newTarget) is false, throw a TypeError exception.\n    else if (!newTarget.isFunction) {\n      return new $TypeError(realm, `Expected newTarget to be a constructor function, but got: ${newTarget}`);\n    }\n\n    // 4. Let args be ? CreateListFromArrayLike(argumentsList).\n    const args = $CreateListFromArrayLike(ctx, argumentsList);\n    if (args.isAbrupt) { return args; }\n\n    // 5. Return ? Construct(target, args, newTarget).\n    return $Construct(ctx, target as $Function, args, newTarget as $Function | $Undefined);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.defineproperty\n// 26.1.3 Reflect.defineProperty ( target , propertyKey , attributes )\nexport class $Reflect_defineProperty extends $BuiltinFunction<'Reflect.defineProperty'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.defineProperty', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, propertyKey, attributes]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (propertyKey === void 0) {\n      propertyKey = intrinsics.undefined;\n    }\n    if (attributes === void 0) {\n      attributes = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let key be ? ToPropertyKey(propertyKey).\n    const key = propertyKey.ToPropertyKey(ctx);\n    if (key.isAbrupt) { return key; }\n\n    // 3. Let desc be ? ToPropertyDescriptor(attributes).\n    const desc = $ToPropertyDescriptor(ctx, attributes, key);\n    if (desc.isAbrupt) { return desc; }\n\n    // 4. Return ? target.[[DefineOwnProperty]](key, desc).\n    return target['[[DefineOwnProperty]]'](ctx, key, desc);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.deleteproperty\n// 26.1.4 Reflect.deleteProperty ( target , propertyKey )\nexport class $Reflect_deleteProperty extends $BuiltinFunction<'Reflect.deleteProperty'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.deleteProperty', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, propertyKey]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (propertyKey === void 0) {\n      propertyKey = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let key be ? ToPropertyKey(propertyKey).\n    const key = propertyKey.ToPropertyKey(ctx);\n    if (key.isAbrupt) { return key; }\n\n    // 3. Return ? target.[[Delete]](key).\n    return target['[[Delete]]'](ctx, key);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.get\n// 26.1.5 Reflect.get ( target , propertyKey [ , receiver ] )\nexport class $Reflect_get extends $BuiltinFunction<'Reflect.get'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.get', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, propertyKey, receiver]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (propertyKey === void 0) {\n      propertyKey = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let key be ? ToPropertyKey(propertyKey).\n    const key = propertyKey.ToPropertyKey(ctx);\n    if (key.isAbrupt) { return key; }\n\n    // 3. If receiver is not present, then\n    if (receiver === void 0) {\n      // 3. a. Set receiver to target.\n      receiver = target;\n    }\n\n    // 4. Return ? target.[[Get]](key, receiver).\n    return target['[[Get]]'](ctx, key, receiver as $AnyObject); // TODO: is this cast safe?\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.getownpropertydescriptor\n// 26.1.6 Reflect.getOwnPropertyDescriptor ( target , propertyKey )\nexport class $Reflect_getOwnPropertyDescriptor extends $BuiltinFunction<'Reflect.getOwnPropertyDescriptor'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.getOwnPropertyDescriptor', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, propertyKey]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (propertyKey === void 0) {\n      propertyKey = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let key be ? ToPropertyKey(propertyKey).\n    const key = propertyKey.ToPropertyKey(ctx);\n    if (key.isAbrupt) { return key; }\n\n    // 3. Let desc be ? target.[[GetOwnProperty]](key).\n    const desc = target['[[GetOwnProperty]]'](ctx, key);\n    if (desc.isAbrupt) { return desc; }\n\n    // 4. Return FromPropertyDescriptor(desc).\n    return $FromPropertyDescriptor(ctx, desc);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.getprototypeof\n// 26.1.7 Reflect.getPrototypeOf ( target )\nexport class $Reflect_getPrototypeOf extends $BuiltinFunction<'Reflect.getPrototypeOf'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.getPrototypeOf', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Return ? target.[[GetPrototypeOf]]().\n    return target['[[GetPrototypeOf]]'](ctx);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.has\n// 26.1.8 Reflect.has ( target , propertyKey )\nexport class $Reflect_has extends $BuiltinFunction<'Reflect.has'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.has', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target , propertyKey]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (propertyKey === void 0) {\n      propertyKey = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let key be ? ToPropertyKey(propertyKey).\n    const key = propertyKey.ToPropertyKey(ctx);\n    if (key.isAbrupt) { return key; }\n\n    // 3. Return ? target.[[HasProperty]](key).\n    return target['[[HasProperty]]'](ctx, key);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.isextensible\n// 26.1.9 Reflect.isExtensible ( target )\nexport class $Reflect_isExtensible extends $BuiltinFunction<'Reflect.isExtensible'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.isExtensible', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Return ? target.[[IsExtensible]]().\n    return target['[[IsExtensible]]'](ctx);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.ownkeys\n// 26.1.10 Reflect.ownKeys ( target )\nexport class $Reflect_ownKeys extends $BuiltinFunction<'Reflect.ownKeys'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.ownKeys', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let keys be ? target.[[OwnPropertyKeys]]().\n    const keys = target['[[OwnPropertyKeys]]'](ctx);\n    if (keys.isAbrupt) { return keys; }\n\n    // 3. Return CreateArrayFromList(keys).\n    return $CreateArrayFromList(ctx, keys);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.preventextensions\n// 26.1.11 Reflect.preventExtensions ( target )\nexport class $Reflect_preventExtensions extends $BuiltinFunction<'Reflect.preventExtensions'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.preventExtensions', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Return ? target.[[PreventExtensions]]().\n    return target['[[PreventExtensions]]'](ctx);\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.set\n// 26.1.12 Reflect.set ( target , propertyKey , V [ , receiver ] )\nexport class $Reflect_set extends $BuiltinFunction<'Reflect.set'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.set', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, propertyKey, V, receiver]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (propertyKey === void 0) {\n      propertyKey = intrinsics.undefined;\n    }\n    if (V === void 0) {\n      V = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. Let key be ? ToPropertyKey(propertyKey).\n    const key = propertyKey.ToPropertyKey(ctx);\n    if (key.isAbrupt) { return key; }\n\n    // 3. If receiver is not present, then\n    if (receiver === void 0) {\n      // 3. a. Set receiver to target.\n      receiver = target;\n    }\n\n    // 4. Return ? target.[[Set]](key, V, receiver).\n    return target['[[Set]]'](ctx, key, V, receiver as $AnyObject); // TODO: is this cast safe?\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-reflect.setprototypeof\n// 26.1.13 Reflect.setPrototypeOf ( target , proto )\nexport class $Reflect_setPrototypeOf extends $BuiltinFunction<'Reflect.setPrototypeOf'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, 'Reflect.setPrototypeOf', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    $thisArgument: $AnyNonEmptyNonError,\n    [target, proto]: $List<$AnyNonEmpty>,\n    $NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty  {\n    const realm = ctx.Realm;\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    if (target === void 0) {\n      target = intrinsics.undefined;\n    }\n    if (proto === void 0) {\n      proto = intrinsics.undefined;\n    }\n\n    // 1. If Type(target) is not Object, throw a TypeError exception.\n    if (!target.isObject) {\n      return new $TypeError(realm, `Expected target to be an object, but got: ${target}`);\n    }\n\n    // 2. If Type(proto) is not Object and proto is not null, throw a TypeError exception.\n    if (!proto.isObject && !proto.isNull) {\n      return new $TypeError(realm, `Expected proto to be an object or null, but got: ${proto}`);\n    }\n\n    // 3. Return ? target.[[SetPrototypeOf]](proto).\n    return target['[[SetPrototypeOf]]'](ctx, proto as $AnyObject);\n  }\n}\n\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-eval-x\n// 18.2.1 eval ( x )\nexport class $Eval extends $BuiltinFunction<'%eval%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%eval%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Assert: The execution context stack has at least two elements.\n    // 2. Let callerContext be the second to top element of the execution context stack.\n    // 3. Let callerRealm be callerContext's Realm.\n    // 4. Let calleeRealm be the current Realm Record.\n    // 5. Perform ? HostEnsureCanCompileStrings(callerRealm, calleeRealm).\n    // 6. Return ? PerformEval(x, calleeRealm, false, false).\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-performeval\n// 18.2.1.1 Runtime Semantics: PerformEval ( x , evalRealm , strictCaller , direct )\nexport function $PerformEval(\n  ctx: ExecutionContext,\n  x: any,\n  evalRealm: any,\n  strictCaller: any,\n  direct: any,\n): any {\n  // 1. Assert: If direct is false, then strictCaller is also false.\n  // 2. If Type(x) is not String, return x.\n  // 3. Let thisEnvRec be ! GetThisEnvironment().\n  // 4. If thisEnvRec is a function Environment Record, then\n    // 4. a. Let F be thisEnvRec.[[FunctionObject]].\n    // 4. b. Let inFunction be true.\n    // 4. c. Let inMethod be thisEnvRec.HasSuperBinding().\n    // 4. d. If F.[[ConstructorKind]] is \"derived\", let inDerivedConstructor be true; otherwise, let inDerivedConstructor be false.\n  // 5. Else,\n    // 5. a. Let inFunction be false.\n    // 5. b. Let inMethod be false.\n    // 5. c. Let inDerivedConstructor be false.\n  // 6. Let script be the ECMAScript code that is the result of parsing x, interpreted as UTF-16 encoded Unicode text as described in 6.1.4, for the goal symbol Script. If inFunction is false, additional early error rules from 18.2.1.1.1 are applied. If inMethod is false, additional early error rules from 18.2.1.1.2 are applied. If inDerivedConstructor is false, additional early error rules from 18.2.1.1.3 are applied. If the parse fails, throw a SyntaxError exception. If any early errors are detected, throw a SyntaxError or a ReferenceError exception, depending on the type of the error (but see also clause 16). Parsing and early error detection may be interweaved in an implementation-dependent manner.\n  // 7. If script Contains ScriptBody is false, return undefined.\n  // 8. Let body be the ScriptBody of script.\n  // 9. If strictCaller is true, let strictEval be true.\n  // 10. Else, let strictEval be IsStrict of script.\n  // 11. Let ctx be the running execution context.\n  // 12. NOTE: If direct is true, ctx will be the execution context that performed the direct eval. If direct is false, ctx will be the execution context for the invocation of the eval function.\n  // 13. If direct is true, then\n    // 13. a. Let lexEnv be NewDeclarativeEnvironment(ctx's LexicalEnvironment).\n    // 13. b. Let varEnv be ctx's VariableEnvironment.\n  // 14. Else,\n    // 14. a. Let lexEnv be NewDeclarativeEnvironment(evalRealm.[[GlobalEnv]]).\n    // 14. b. Let varEnv be evalRealm.[[GlobalEnv]].\n  // 15. If strictEval is true, set varEnv to lexEnv.\n  // 16. If ctx is not already suspended, suspend ctx.\n  // 17. Let evalCxt be a new ECMAScript code execution context.\n  // 18. Set the evalCxt's Function to null.\n  // 19. Set the evalCxt's Realm to evalRealm.\n  // 20. Set the evalCxt's ScriptOrModule to ctx's ScriptOrModule.\n  // 21. Set the evalCxt's VariableEnvironment to varEnv.\n  // 22. Set the evalCxt's LexicalEnvironment to lexEnv.\n  // 23. Push evalCxt on to the execution context stack; evalCxt is now the running execution context.\n  // 24. Let result be EvalDeclarationInstantiation(body, varEnv, lexEnv, strictEval).\n  // 25. If result.[[Type]] is normal, then\n    // 25. a. Set result to the result of evaluating body.\n  // 26. If result.[[Type]] is normal and result.[[Value]] is empty, then\n    // 26. a. Set result to NormalCompletion(undefined).\n  // 27. Suspend evalCxt and remove it from the execution context stack.\n  // 28. Resume the context that is now on the top of the execution context stack as the running execution context.\n  // 29. Return Completion(result).\n  throw new Error('Method not implemented.');\n}\n\n  // http://www.ecma-international.org/ecma-262/#sec-performeval-rules-outside-functions\n  // 18.2.1.1.1 Additional Early Error Rules for Eval Outside Functions\n\n  // ScriptBody :\n  //     StatementList\n\n  // http://www.ecma-international.org/ecma-262/#sec-performeval-rules-outside-methods\n  // 18.2.1.1.2 Additional Early Error Rules for Eval Outside Methods\n\n  // ScriptBody :\n  //     StatementList\n\n  // http://www.ecma-international.org/ecma-262/#sec-performeval-rules-outside-constructors\n  // 18.2.1.1.3 Additional Early Error Rules for Eval Outside Constructor Methods\n\n  // ScriptBody :\n  //     StatementList\n\n// http://www.ecma-international.org/ecma-262/#sec-evaldeclarationinstantiation\n// 18.2.1.3 Runtime Semantics: EvalDeclarationInstantiation ( body , varEnv , lexEnv , strict )\nexport function $EvalDeclarationInstantiation(\n  ctx: ExecutionContext,\n  body: any,\n  varEnv: any,\n  lexEnv: any,\n  strict: any,\n): any {\n  // 1. Let varNames be the VarDeclaredNames of body.\n  // 2. Let varDeclarations be the VarScopedDeclarations of body.\n  // 3. Let lexEnvRec be lexEnv's EnvironmentRecord.\n  // 4. Let varEnvRec be varEnv's EnvironmentRecord.\n  // 5. If strict is false, then\n    // 5. a. If varEnvRec is a global Environment Record, then\n      // 5. a. i. For each name in varNames, do\n        // 5. a. i. 1. If varEnvRec.HasLexicalDeclaration(name) is true, throw a SyntaxError exception.\n        // 5. a. i. 2. NOTE: eval will not create a global var declaration that would be shadowed by a global lexical declaration.\n    // 5. b. Let thisLex be lexEnv.\n    // 5. c. Assert: The following loop will terminate.\n    // 5. d. Repeat, while thisLex is not the same as varEnv,\n      // 5. d. i. Let thisEnvRec be thisLex's EnvironmentRecord.\n      // 5. d. ii. If thisEnvRec is not an object Environment Record, then\n        // 5. d. ii. 1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n        // 5. d. ii. 2. For each name in varNames, do\n          // 5. d. ii. 2. a. If thisEnvRec.HasBinding(name) is true, then\n            // 5. d. ii. 2. a. i. Throw a SyntaxError exception.\n            // 5. d. ii. 2. a. ii. NOTE: Annex B.3.5 defines alternate semantics for the above step.\n          // 5. d. ii. 2. b. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n      // 5. d. iii. Set thisLex to thisLex's outer environment reference.\n  // 6. Let functionsToInitialize be a new empty List.\n  // 7. Let declaredFunctionNames be a new empty List.\n  // 8. For each d in varDeclarations, in reverse list order, do\n    // 8. a. If d is neither a VariableDeclaration nor a ForBinding nor a BindingIdentifier, then\n      // 8. a. i. Assert: d is either a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration.\n      // 8. a. ii. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n      // 8. a. iii. Let fn be the sole element of the BoundNames of d.\n      // 8. a. iv. If fn is not an element of declaredFunctionNames, then\n        // 8. a. iv. 1. If varEnvRec is a global Environment Record, then\n          // 8. a. iv. 1. a. Let fnDefinable be ? varEnvRec.CanDeclareGlobalFunction(fn).\n          // 8. a. iv. 1. b. If fnDefinable is false, throw a TypeError exception.\n        // 8. a. iv. 2. Append fn to declaredFunctionNames.\n        // 8. a. iv. 3. Insert d as the first element of functionsToInitialize.\n  // 9. NOTE: Annex B.3.3.3 adds additional steps at this point.\n  // 10. Let declaredVarNames be a new empty List.\n  // 11. For each d in varDeclarations, do\n    // 11. a. If d is a VariableDeclaration, a ForBinding, or a BindingIdentifier, then\n      // 11. a. i. For each String vn in the BoundNames of d, do\n        // 11. a. i. 1. If vn is not an element of declaredFunctionNames, then\n          // 11. a. i. 1. a. If varEnvRec is a global Environment Record, then\n            // 11. a. i. 1. a. i. Let vnDefinable be ? varEnvRec.CanDeclareGlobalVar(vn).\n            // 11. a. i. 1. a. ii. If vnDefinable is false, throw a TypeError exception.\n          // 11. a. i. 1. b. If vn is not an element of declaredVarNames, then\n            // 11. a. i. 1. b. i. Append vn to declaredVarNames.\n  // 12. NOTE: No abnormal terminations occur after this algorithm step unless varEnvRec is a global Environment Record and the global object is a Proxy exotic object.\n  // 13. Let lexDeclarations be the LexicallyScopedDeclarations of body.\n  // 14. For each element d in lexDeclarations, do\n    // 14. a. NOTE: Lexically declared names are only instantiated here but not initialized.\n    // 14. b. For each element dn of the BoundNames of d, do\n      // 14. b. i. If IsConstantDeclaration of d is true, then\n        // 14. b. i. 1. Perform ? lexEnvRec.CreateImmutableBinding(dn, true).\n      // 14. b. ii. Else,\n        // 14. b. ii. 1. Perform ? lexEnvRec.CreateMutableBinding(dn, false).\n  // 15. For each Parse Node f in functionsToInitialize, do\n    // 15. a. Let fn be the sole element of the BoundNames of f.\n    // 15. b. Let fo be the result of performing InstantiateFunctionObject for f with argument lexEnv.\n    // 15. c. If varEnvRec is a global Environment Record, then\n      // 15. c. i. Perform ? varEnvRec.CreateGlobalFunctionBinding(fn, fo, true).\n    // 15. d. Else,\n      // 15. d. i. Let bindingExists be varEnvRec.HasBinding(fn).\n      // 15. d. ii. If bindingExists is false, then\n        // 15. d. ii. 1. Let status be ! varEnvRec.CreateMutableBinding(fn, true).\n        // 15. d. ii. 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n        // 15. d. ii. 3. Perform ! varEnvRec.InitializeBinding(fn, fo).\n      // 15. d. iii. Else,\n        // 15. d. iii. 1. Perform ! varEnvRec.SetMutableBinding(fn, fo, false).\n  // 16. For each String vn in declaredVarNames, in list order, do\n    // 16. a. If varEnvRec is a global Environment Record, then\n      // 16. a. i. Perform ? varEnvRec.CreateGlobalVarBinding(vn, true).\n    // 16. b. Else,\n      // 16. b. i. Let bindingExists be varEnvRec.HasBinding(vn).\n      // 16. b. ii. If bindingExists is false, then\n        // 16. b. ii. 1. Let status be ! varEnvRec.CreateMutableBinding(vn, true).\n        // 16. b. ii. 2. Assert: status is not an abrupt completion because of validation preceding step 12.\n        // 16. b. ii. 3. Perform ! varEnvRec.InitializeBinding(vn, undefined).\n  // 17. Return NormalCompletion(empty).\n  throw new Error('Method not implemented.');\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-isfinite-number\n// 18.2.2 isFinite ( number )\nexport class $IsFinite extends $BuiltinFunction<'%isFinite%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%isFinite%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let num be ? ToNumber(number).\n    // 2. If num is NaN, +∞, or -∞, return false.\n    // 3. Otherwise, return true.\n    throw new Error('Method not implemented.');\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-isnan-number\n// 18.2.3 isNaN ( number )\nexport class $IsNaN extends $BuiltinFunction<'%isNaN%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%isNaN%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let num be ? ToNumber(number).\n    // 2. If num is NaN, return true.\n    // 3. Otherwise, return false.\n    throw new Error('Method not implemented.');\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-parsefloat-string\n// 18.2.4 parseFloat ( string )\nexport class $ParseFloat extends $BuiltinFunction<'%parseFloat%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%parseFloat%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let inputString be ? ToString(string).\n    // 2. Let trimmedString be a substring of inputString consisting of the leftmost code unit that is not a StrWhiteSpaceChar and all code units to the right of that code unit. (In other words, remove leading white space.) If inputString does not contain any such code units, let trimmedString be the empty string.\n    // 3. If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see 7.1.3.1), return NaN.\n    // 4. Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies the syntax of a StrDecimalLiteral.\n    // 5. Let mathFloat be MV of numberString.\n    // 6. If mathFloat = 0, then\n      // 6. a. If the first code unit of trimmedString is the code unit 0x002D (HYPHEN-MINUS), return -0.\n      // 6. b. Return +0.\n    // 7. Return the Number value for mathFloat.\n    throw new Error('Method not implemented.');\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-parseint-string-radix\n// 18.2.5 parseInt ( string , radix )\nexport class $ParseInt extends $BuiltinFunction<'%parseInt%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%parseInt%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let inputString be ? ToString(string).\n    // 2. Let S be a newly created substring of inputString consisting of the first code unit that is not a StrWhiteSpaceChar and all code units following that code unit. (In other words, remove leading white space.) If inputString does not contain any such code unit, let S be the empty string.\n    // 3. Let sign be 1.\n    // 4. If S is not empty and the first code unit of S is the code unit 0x002D (HYPHEN-MINUS), set sign to -1.\n    // 5. If S is not empty and the first code unit of S is the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), remove the first code unit from S.\n    // 6. Let R be ? ToInt32(radix).\n    // 7. Let stripPrefix be true.\n    // 8. If R ≠ 0, then\n      // 8. a. If R < 2 or R > 36, return NaN.\n      // 8. b. If R ≠ 16, set stripPrefix to false.\n    // 9. Else R = 0,\n      // 9. a. Set R to 10.\n    // 10. If stripPrefix is true, then\n      // 10. a. If the length of S is at least 2 and the first two code units of S are either \"0x\" or \"0X\", then\n        // 10. a. i. Remove the first two code units from S.\n        // 10. a. ii. Set R to 16.\n    // 11. If S contains a code unit that is not a radix-R digit, let Z be the substring of S consisting of all code units before the first such code unit; otherwise, let Z be S.\n    // 12. If Z is empty, return NaN.\n    // 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the mathematical integer value that is represented by Z in radix-R notation.)\n    // 14. If mathInt = 0, then\n      // 14. a. If sign = -1, return -0.\n      // 14. b. Return +0.\n    // 15. Let number be the Number value for mathInt.\n    // 16. Return sign × number.\n    throw new Error('Method not implemented.');\n  }\n}\n","import {\n  $BuiltinFunction,\n  $Function,\n} from '../types/function.js';\nimport {\n  Realm,\n  ExecutionContext,\n} from '../realm.js';\nimport {\n  $AnyNonEmpty,\n  $AnyNonEmptyNonError,\n} from '../types/_shared.js';\nimport {\n  $Undefined,\n} from '../types/undefined.js';\nimport {\n  $FunctionPrototype,\n} from './function.js';\nimport {\n  $List,\n} from '../types/list.js';\n\n// http://www.ecma-international.org/ecma-262/#sec-uri-handling-functions\n// 18.2.6 URI Handling Functions\n\n// http://www.ecma-international.org/ecma-262/#sec-uri-syntax-and-semantics\n// 18.2.6.1 URI Syntax and Semantics\n\n// uri :::\n//     uriCharacters opt\n\n// uriCharacters :::\n//     uriCharacter uriCharacters opt\n\n// uriCharacter :::\n//     uriReserved\n//     uriUnescaped\n//     uriEscaped\n\n// uriReserved ::: one of\n//     ; / ? : @ & = + $ ,\n\n// uriUnescaped :::\n//     uriAlpha\n//     DecimalDigit\n//     uriMark\n\n// uriEscaped :::\n//     % HexDigit HexDigit\n\n// uriAlpha ::: one of\n//     a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\n// uriMark ::: one of\n//     - _ . ! ~ * ' ( )\n\n// http://www.ecma-international.org/ecma-262/#sec-encode\n// 18.2.6.1.1 Runtime Semantics: Encode ( string , unescapedSet )\nexport function $Encode(\n  ctx: ExecutionContext,\n  string: any,\n  unescapedSet: any,\n): any {\n  // 1. Let strLen be the number of code units in string.\n  // 2. Let R be the empty String.\n  // 3. Let k be 0.\n  // 4. Repeat,\n    // 4. a. If k equals strLen, return R.\n    // 4. b. Let C be the code unit at index k within string.\n    // 4. c. If C is in unescapedSet, then\n      // 4. c. i. Let S be the String value containing only the code unit C.\n      // 4. c. ii. Set R to the string-concatenation of the previous value of R and S.\n    // 4. d. Else C is not in unescapedSet,\n      // 4. d. i. If C is a trailing surrogate, throw a URIError exception.\n      // 4. d. ii. If C is not a leading surrogate, then\n        // 4. d. ii. 1. Let V be the code point with the same numeric value as code unit C.\n      // 4. d. iii. Else,\n        // 4. d. iii. 1. Increase k by 1.\n        // 4. d. iii. 2. If k equals strLen, throw a URIError exception.\n        // 4. d. iii. 3. Let kChar be the code unit at index k within string.\n        // 4. d. iii. 4. If kChar is not a trailing surrogate, throw a URIError exception.\n        // 4. d. iii. 5. Let V be UTF16Decode(C, kChar).\n      // 4. d. iv. Let Octets be the List of octets resulting by applying the UTF-8 transformation to V.\n      // 4. d. v. For each element octet of Octets in List order, do\n        // 4. d. v. 1. Let S be the string-concatenation of:\"%\"the String representation of octet, formatted as a two-digit uppercase hexadecimal number, padded to the left with a zero if necessary\n        // 4. d. v. 2. Set R to the string-concatenation of the previous value of R and S.\n    // 4. e. Increase k by 1.\n  throw new Error('Method not implemented.');\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-decode\n// 18.2.6.1.2 Runtime Semantics: Decode ( string , reservedSet )\nexport function $Decode(\n  ctx: ExecutionContext,\n  string: any,\n  reservedSet: any,\n): any {\n  // 1. Let strLen be the number of code units in string.\n  // 2. Let R be the empty String.\n  // 3. Let k be 0.\n  // 4. Repeat,\n    // 4. a. If k equals strLen, return R.\n    // 4. b. Let C be the code unit at index k within string.\n    // 4. c. If C is not the code unit 0x0025 (PERCENT SIGN), then\n      // 4. c. i. Let S be the String value containing only the code unit C.\n    // 4. d. Else C is the code unit 0x0025 (PERCENT SIGN),\n      // 4. d. i. Let start be k.\n      // 4. d. ii. If k + 2 is greater than or equal to strLen, throw a URIError exception.\n      // 4. d. iii. If the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a URIError exception.\n      // 4. d. iv. Let B be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).\n      // 4. d. v. Increment k by 2.\n      // 4. d. vi. If the most significant bit in B is 0, then\n        // 4. d. vi. 1. Let C be the code unit whose value is B.\n        // 4. d. vi. 2. If C is not in reservedSet, then\n          // 4. d. vi. 2. a. Let S be the String value containing only the code unit C.\n        // 4. d. vi. 3. Else C is in reservedSet,\n          // 4. d. vi. 3. a. Let S be the substring of string from index start to index k inclusive.\n      // 4. d. vii. Else the most significant bit in B is 1,\n        // 4. d. vii. 1. Let n be the smallest nonnegative integer such that (B << n) & 0x80 is equal to 0.\n        // 4. d. vii. 2. If n equals 1 or n is greater than 4, throw a URIError exception.\n        // 4. d. vii. 3. Let Octets be a List of 8-bit integers of size n.\n        // 4. d. vii. 4. Set Octets[0] to B.\n        // 4. d. vii. 5. If k + (3 × (n - 1)) is greater than or equal to strLen, throw a URIError exception.\n        // 4. d. vii. 6. Let j be 1.\n        // 4. d. vii. 7. Repeat, while j < n\n          // 4. d. vii. 7. a. Increment k by 1.\n          // 4. d. vii. 7. b. If the code unit at index k within string is not the code unit 0x0025 (PERCENT SIGN), throw a URIError exception.\n          // 4. d. vii. 7. c. If the code units at index (k + 1) and (k + 2) within string do not represent hexadecimal digits, throw a URIError exception.\n          // 4. d. vii. 7. d. Let B be the 8-bit value represented by the two hexadecimal digits at index (k + 1) and (k + 2).\n          // 4. d. vii. 7. e. If the two most significant bits in B are not 10, throw a URIError exception.\n          // 4. d. vii. 7. f. Increment k by 2.\n          // 4. d. vii. 7. g. Set Octets[j] to B.\n          // 4. d. vii. 7. h. Increment j by 1.\n        // 4. d. vii. 8. If Octets does not contain a valid UTF-8 encoding of a Unicode code point, throw a URIError exception.\n        // 4. d. vii. 9. Let V be the value obtained by applying the UTF-8 transformation to Octets, that is, from a List of octets into a 21-bit value.\n        // 4. d. vii. 10. Let S be the String value whose code units are, in order, the elements in UTF16Encoding(V).\n    // 4. e. Set R to the string-concatenation of the previous value of R and S.\n    // 4. f. Increase k by 1.\n  throw new Error('Method not implemented.');\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-decodeuri-encodeduri\n// 18.2.6.2 decodeURI ( encodedURI )\nexport class $DecodeURI extends $BuiltinFunction<'%decodeURI%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%decodeURI%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let uriString be ? ToString(encodedURI).\n    // 2. Let reservedURISet be a String containing one instance of each code unit valid in uriReserved plus \"#\".\n    // 3. Return ? Decode(uriString, reservedURISet).\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-decodeuricomponent-encodeduricomponent\n// 18.2.6.3 decodeURIComponent ( encodedURIComponent )\nexport class $DecodeURIComponent extends $BuiltinFunction<'%decodeURIComponent%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%decodeURIComponent%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let componentString be ? ToString(encodedURIComponent).\n    // 2. Let reservedURIComponentSet be the empty String.\n    // 3. Return ? Decode(componentString, reservedURIComponentSet).\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-encodeuri-uri\n// 18.2.6.4 encodeURI ( uri )\nexport class $EncodeURI extends $BuiltinFunction<'%encodeURI%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%encodeURI%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let uriString be ? ToString(uri).\n    // 2. Let unescapedURISet be a String containing one instance of each code unit valid in uriReserved and uriUnescaped plus \"#\".\n    // 3. Return ? Encode(uriString, unescapedURISet).\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-encodeuricomponent-uricomponent\n// 18.2.6.5 encodeURIComponent ( uriComponent )\nexport class $EncodeURIComponent extends $BuiltinFunction<'%encodeURIComponent%'> {\n  public constructor(\n    realm: Realm,\n    proto: $FunctionPrototype,\n  ) {\n    super(realm, '%encodeURIComponent%', proto);\n  }\n\n  public performSteps(\n    ctx: ExecutionContext,\n    thisArgument: $AnyNonEmptyNonError,\n    argumentsList: $List<$AnyNonEmpty>,\n    NewTarget: $Function | $Undefined,\n  ): $AnyNonEmpty {\n    // 1. Let componentString be ? ToString(uriComponent).\n    // 2. Let unescapedURIComponentSet be a String containing one instance of each code unit valid in uriUnescaped.\n    // 3. Return ? Encode(componentString, unescapedURIComponentSet).\n    throw new Error('Method not implemented.');\n  }\n}\n","import {\n  Realm,\n  ExecutionContext,\n} from './realm.js';\nimport {\n  $Boolean,\n} from './types/boolean.js';\nimport {\n  $Empty,\n} from './types/empty.js';\nimport {\n  $Undefined,\n} from './types/undefined.js';\nimport {\n  $Null,\n} from './types/null.js';\nimport {\n  $Number,\n} from './types/number.js';\nimport {\n  $String,\n} from './types/string.js';\nimport {\n  $Symbol,\n} from './types/symbol.js';\nimport {\n  $Object,\n} from './types/object.js';\nimport {\n  $IteratorPrototype,\n  $AsyncIteratorPrototype,\n  $AsyncFromSyncIteratorPrototype,\n  $AsyncFromSyncIteratorPrototype_next,\n  $AsyncFromSyncIteratorPrototype_return,\n  $AsyncFromSyncIteratorPrototype_throw,\n} from './globals/iteration.js';\nimport {\n  $StringConstructor,\n  $StringPrototype,\n} from './globals/string.js';\nimport {\n  $ObjectConstructor,\n  $ObjectPrototype,\n  $ObjProto_toString,\n  $ObjProto_valueOf,\n  $ObjectPrototype_hasOwnProperty,\n  $ObjectPrototype_isPrototypeOf,\n  $ObjectPrototype_propertyIsEnumerable,\n  $ObjectPrototype_toLocaleString,\n  $Object_assign,\n  $Object_create,\n  $Object_defineProperties,\n  $Object_defineProperty,\n  $Object_entries,\n  $Object_freeze,\n  $Object_fromEntries,\n  $Object_getOwnPropertyDescriptor,\n  $Object_getOwnPropertyDescriptors,\n  $Object_getOwnPropertyNames,\n  $Object_getOwnPropertySymbols,\n  $Object_getPrototypeOf,\n  $Object_is,\n  $Object_isExtensible,\n  $Object_isFrozen,\n  $Object_isSealed,\n  $Object_keys,\n  $Object_preventExtensions,\n  $Object_seal,\n  $Object_setPrototypeOf,\n  $Object_values,\n} from './globals/object.js';\nimport {\n  $FunctionPrototype,\n  $FunctionConstructor,\n  $FunctionPrototype_call,\n  $FunctionPrototype_apply,\n  $FunctionPrototype_bind,\n  $FunctionPrototype_toString,\n  $FunctionPrototype_hasInstance,\n} from './globals/function.js';\nimport {\n  CompletionType,\n} from './types/_shared.js';\nimport {\n  $NumberConstructor,\n  $NumberPrototype,\n} from './globals/number.js';\nimport {\n  $BooleanConstructor,\n  $BooleanPrototype,\n} from './globals/boolean.js';\nimport {\n  $SymbolConstructor,\n  $SymbolPrototype,\n} from './globals/symbol.js';\nimport {\n  $ErrorConstructor,\n  $ErrorPrototype,\n  $ErrorPrototype_toString,\n  $EvalErrorConstructor,\n  $EvalErrorPrototype,\n  $RangeErrorConstructor,\n  $RangeErrorPrototype,\n  $ReferenceErrorConstructor,\n  $ReferenceErrorPrototype,\n  $SyntaxErrorConstructor,\n  $SyntaxErrorPrototype,\n  $TypeErrorConstructor,\n  $TypeErrorPrototype,\n  $URIErrorConstructor,\n  $URIErrorPrototype,\n} from './globals/error.js';\nimport {\n  $ThrowTypeError,\n} from './globals/throw-type-error.js';\nimport {\n  IDisposable,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  $GeneratorFunctionPrototype,\n  $GeneratorPrototype,\n  $GeneratorFunctionConstructor,\n  $GeneratorPrototype_next,\n  $GeneratorPrototype_return,\n  $GeneratorPrototype_throw,\n} from './globals/generator-function.js';\nimport {\n  $PromiseConstructor,\n  $PromisePrototype,\n  $Promise_all,\n  $Promise_race,\n  $Promise_resolve,\n  $Promise_reject,\n  $PromiseProto_then,\n  $PromiseProto_catch,\n  $PromiseProto_finally,\n} from './globals/promise.js';\nimport {\n  $GetSpecies,\n} from './globals/_shared.js';\nimport {\n  $AsyncFunctionPrototype,\n  $AsyncFunctionConstructor,\n} from './globals/async-function.js';\nimport {\n  $AsyncGeneratorFunctionPrototype,\n  $AsyncGeneratorFunctionConstructor,\n  $AsyncGeneratorPrototype,\n  $AsyncGeneratorPrototype_next,\n  $AsyncGeneratorPrototype_return,\n  $AsyncGeneratorPrototype_throw,\n} from './globals/async-generator-function.js';\nimport {\n  $ProxyConstructor,\n  $Proxy_revocable,\n} from './globals/proxy.js';\nimport {\n  $Reflect,\n  $Reflect_apply,\n  $Reflect_construct,\n  $Reflect_defineProperty,\n  $Reflect_deleteProperty,\n  $Reflect_get,\n  $Reflect_getOwnPropertyDescriptor,\n  $Reflect_getPrototypeOf,\n  $Reflect_has,\n  $Reflect_isExtensible,\n  $Reflect_ownKeys,\n  $Reflect_preventExtensions,\n  $Reflect_set,\n  $Reflect_setPrototypeOf,\n} from './globals/reflect.js';\nimport {\n  $Eval,\n} from './globals/eval.js';\nimport {\n  $IsFinite,\n} from './globals/is-finite.js';\nimport {\n  $IsNaN,\n} from './globals/is-nan.js';\nimport {\n  $ParseFloat,\n} from './globals/parse-float.js';\nimport {\n  $ParseInt,\n} from './globals/parse-int.js';\nimport {\n  $DecodeURI,\n  $DecodeURIComponent,\n  $EncodeURI,\n  $EncodeURIComponent,\n} from './globals/uri-handling.js';\n\nexport type $True = $Boolean<true>;\nexport type $False = $Boolean<false>;\n\n/**\n * http://www.ecma-international.org/ecma-262/#table-7\n *\n * Intrinsic Name                    Global Name                  ECMAScript Language Association\n * ----------                        ----------                   ----------\n * %Array%                           Array                        The Array constructor (22.1.1)\n * %ArrayBuffer%                     ArrayBuffer                  The ArrayBuffer constructor (24.1.2)\n * %ArrayBufferPrototype%            ArrayBuffer.prototype        The initial value of the prototype data property of %ArrayBuffer%.\n * %ArrayIteratorPrototype%                                       The prototype of Array iterator objects (22.1.5)\n * %ArrayPrototype%                  Array.prototype              The initial value of the prototype data property of %Array% (22.1.3)\n * %ArrayProto_entries%              Array.prototype.entries      The initial value of the entries data property of %ArrayPrototype% (22.1.3.4)\n * %ArrayProto_forEach%              Array.prototype.forEach      The initial value of the forEach data property of %ArrayPrototype% (22.1.3.12)\n * %ArrayProto_keys%                 Array.prototype.keys         The initial value of the keys data property of %ArrayPrototype% (22.1.3.16)\n * %ArrayProto_values%               Array.prototype.values       The initial value of the values data property of %ArrayPrototype% (22.1.3.32)\n * %AsyncFromSyncIteratorPrototype%                               The prototype of async-from-sync iterator objects (25.1.4)\n * %AsyncFunction%                                                The constructor of async function objects (25.7.1)\n * %AsyncFunctionPrototype%                                       The initial value of the prototype data property of %AsyncFunction%\n * %AsyncGenerator%                                               The initial value of the prototype property of %AsyncGeneratorFunction%\n * %AsyncGeneratorFunction%                                       The constructor of async iterator objects (25.3.1)\n * %AsyncGeneratorPrototype%                                      The initial value of the prototype property of %AsyncGenerator%\n * %AsyncIteratorPrototype%                                       An object that all standard built-in async iterator objects indirectly inherit from\n * %Atomics%                         Atomics                      The Atomics object (24.4)\n * %Boolean%                         Boolean                      The Boolean constructor (19.3.1)\n * %BooleanPrototype%                Boolean.prototype            The initial value of the prototype data property of %Boolean% (19.3.3)\n * %DataView%                        DataView                     The DataView constructor (24.3.2)\n * %DataViewPrototype%               DataView.prototype           The initial value of the prototype data property of %DataView%\n * %Date%                            Date                         The Date constructor (20.3.2)\n * %DatePrototype%                   Date.prototype               The initial value of the prototype data property of %Date%.\n * %decodeURI%                       decodeURI                    The decodeURI function (18.2.6.2)\n * %decodeURIComponent%              decodeURIComponent           The decodeURIComponent function (18.2.6.3)\n * %encodeURI%                       encodeURI                    The encodeURI function (18.2.6.4)\n * %encodeURIComponent%              encodeURIComponent           The encodeURIComponent function (18.2.6.5)\n * %Error%                           Error                        The Error constructor (19.5.1)\n * %ErrorPrototype%                  Error.prototype              The initial value of the prototype data property of %Error%\n * %eval%                            eval                         The eval function (18.2.1)\n * %EvalError%                       EvalError                    The EvalError constructor (19.5.5.1)\n * %EvalErrorPrototype%              EvalError.prototype          The initial value of the prototype data property of %EvalError%\n * %Float32Array%                    Float32Array                 The Float32Array constructor (22.2)\n * %Float32ArrayPrototype%           Float32Array.prototype       The initial value of the prototype data property of %Float32Array%\n * %Float64Array%                    Float64Array                 The Float64Array constructor (22.2)\n * %Float64ArrayPrototype%           Float64Array.prototype       The initial value of the prototype data property of %Float64Array%\n * %Function%                        Function                     The Function constructor (19.2.1)\n * %FunctionPrototype%               Function.prototype           The initial value of the prototype data property of %Function%\n * %Generator%                                                    The initial value of the prototype data property of %GeneratorFunction%\n * %GeneratorFunction%                                            The constructor of generator objects (25.2.1)\n * %GeneratorPrototype%                                           The initial value of the prototype data property of %Generator%\n * %Int8Array%                       Int8Array                    The Int8Array constructor (22.2)\n * %Int8ArrayPrototype%              Int8Array.prototype          The initial value of the prototype data property of %Int8Array%\n * %Int16Array%                      Int16Array                   The Int16Array constructor (22.2)\n * %Int16ArrayPrototype%             Int16Array.prototype         The initial value of the prototype data property of %Int16Array%\n * %Int32Array%                      Int32Array                   The Int32Array constructor (22.2)\n * %Int32ArrayPrototype%             Int32Array.prototype         The initial value of the prototype data property of %Int32Array%\n * %isFinite%                        isFinite                     The isFinite function (18.2.2)\n * %isNaN%                           isNaN                        The isNaN function (18.2.3)\n * %IteratorPrototype%                                            An object that all standard built-in iterator objects indirectly inherit from\n * %JSON%                            JSON                         The JSON object (24.5)\n * %JSONParse%                       JSON.parse                   The initial value of the parse data property of %JSON%\n * %JSONStringify%                   JSON.stringify               The initial value of the stringify data property of %JSON%\n * %Map%                             Map                          The Map constructor (23.1.1)\n * %MapIteratorPrototype%                                         The prototype of Map iterator objects (23.1.5)\n * %MapPrototype%                    Map.prototype                The initial value of the prototype data property of %Map%\n * %Math%                            Math                         The Math object (20.2)\n * %Number%                          Number                       The Number constructor (20.1.1)\n * %NumberPrototype%                 Number.prototype             The initial value of the prototype data property of %Number%\n * %Object%                          Object                       The Object constructor (19.1.1)\n * %ObjectPrototype%                 Object.prototype             The initial value of the prototype data property of %Object% (19.1.3)\n * %ObjProto_toString%               Object.prototype.toString    The initial value of the toString data property of %ObjectPrototype% (19.1.3.6)\n * %ObjProto_valueOf%                Object.prototype.valueOf     The initial value of the valueOf data property of %ObjectPrototype% (19.1.3.7)\n * %parseFloat%                      parseFloat                   The parseFloat function (18.2.4)\n * %parseInt%                        parseInt                     The parseInt function (18.2.5)\n * %Promise%                         Promise                      The Promise constructor (25.6.3)\n * %PromisePrototype%                Promise.prototype            The initial value of the prototype data property of %Promise%\n * %PromiseProto_then%               Promise.prototype.then       The initial value of the then data property of %PromisePrototype% (25.6.5.4)\n * %Promise_all%                     Promise.all                  The initial value of the all data property of %Promise% (25.6.4.1)\n * %Promise_reject%                  Promise.reject               The initial value of the reject data property of %Promise% (25.6.4.4)\n * %Promise_resolve%                 Promise.resolve              The initial value of the resolve data property of %Promise% (25.6.4.5)\n * %Proxy%                           Proxy                        The Proxy constructor (26.2.1)\n * %RangeError%                      RangeError                   The RangeError constructor (19.5.5.2)\n * %RangeErrorPrototype%             RangeError.prototype         The initial value of the prototype data property of %RangeError%\n * %ReferenceError%                  ReferenceError               The ReferenceError constructor (19.5.5.3)\n * %ReferenceErrorPrototype%         ReferenceError.prototype     The initial value of the prototype data property of %ReferenceError%\n * %Reflect%                         Reflect                      The Reflect object (26.1)\n * %RegExp%                          RegExp                       The RegExp constructor (21.2.3)\n * %RegExpPrototype%                 RegExp.prototype             The initial value of the prototype data property of %RegExp%\n * %Set%                             Set                          The Set constructor (23.2.1)\n * %SetIteratorPrototype%                                         The prototype of Set iterator objects (23.2.5)\n * %SetPrototype%                    Set.prototype                The initial value of the prototype data property of %Set%\n * %SharedArrayBuffer%               SharedArrayBuffer            The SharedArrayBuffer constructor (24.2.2)\n * %SharedArrayBufferPrototype%      SharedArrayBuffer.prototype  The initial value of the prototype data property of %SharedArrayBuffer%\n * %String%                          String                       The String constructor (21.1.1)\n * %StringIteratorPrototype%                                      The prototype of String iterator objects (21.1.5)\n * %StringPrototype%                 String.prototype             The initial value of the prototype data property of %String%\n * %Symbol%                          Symbol                       The Symbol constructor (19.4.1)\n * %SymbolPrototype%                 Symbol.prototype             The initial value of the prototype data property of %Symbol% (19.4.3)\n * %SyntaxError%                     SyntaxError                  The SyntaxError constructor (19.5.5.4)\n * %SyntaxErrorPrototype%            SyntaxError.prototype        The initial value of the prototype data property of %SyntaxError%\n * %ThrowTypeError%                                               A function object that unconditionally throws a new instance of %TypeError%\n * %TypedArray%                                                   The super class of all typed Array constructors (22.2.1)\n * %TypedArrayPrototype%                                          The initial value of the prototype data property of %TypedArray%\n * %TypeError%                       TypeError                    The TypeError constructor (19.5.5.5)\n * %TypeErrorPrototype%              TypeError.prototype          The initial value of the prototype data property of %TypeError%\n * %Uint8Array%                      Uint8Array                   The Uint8Array constructor (22.2)\n * %Uint8ArrayPrototype%             Uint8Array.prototype         The initial value of the prototype data property of %Uint8Array%\n * %Uint8ClampedArray%               Uint8ClampedArray            The Uint8ClampedArray constructor (22.2)\n * %Uint8ClampedArrayPrototype%      Uint8ClampedArray.prototype  The initial value of the prototype data property of %Uint8ClampedArray%\n * %Uint16Array%                     Uint16Array                  The Uint16Array constructor (22.2)\n * %Uint16ArrayPrototype%            Uint16Array.prototype        The initial value of the prototype data property of %Uint16Array%\n * %Uint32Array%                     Uint32Array                  The Uint32Array constructor (22.2)\n * %Uint32ArrayPrototype%            Uint32Array.prototype        The initial value of the prototype data property of %Uint32Array%\n * %URIError%                        URIError                     The URIError constructor (19.5.5.6)\n * %URIErrorPrototype%               URIError.prototype           The initial value of the prototype data property of %URIError%\n * %WeakMap%                         WeakMap                      The WeakMap constructor (23.3.1)\n * %WeakMapPrototype%                WeakMap.prototype            The initial value of the prototype data property of %WeakMap%\n * %WeakSet%                         WeakSet                      The WeakSet constructor (23.4.1)\n * %WeakSetPrototype%                WeakSet.prototype            The initial value of the prototype data property of %WeakSet%\n */\nexport class Intrinsics implements IDisposable {\n  public readonly 'empty': $Empty;\n  public readonly 'undefined': $Undefined;\n  public readonly 'null': $Null;\n  public readonly 'true': $True;\n  public readonly 'false': $False;\n  public readonly 'NaN': $Number;\n  public readonly 'Infinity': $Number;\n  public readonly '-Infinity': $Number;\n  public readonly '0': $Number<0>;\n  public readonly '-0': $Number<-0>;\n  public readonly '': $String<''>;\n  public readonly '*': $String<'*'>;\n  public readonly '*default*': $String<'*default*'>;\n  public readonly 'default': $String<'default'>;\n  public readonly 'string': $String<'string'>;\n  public readonly 'number': $String<'number'>;\n  public readonly 'length': $String<'length'>;\n  public readonly 'next': $String<'next'>;\n  public readonly 'return': $String<'return'>;\n  public readonly 'throw': $String<'throw'>;\n  public readonly 'call': $String<'call'>;\n  public readonly 'all': $String<'all'>;\n  public readonly 'race': $String<'race'>;\n  public readonly 'reject': $String<'reject'>;\n  public readonly 'resolve': $String<'resolve'>;\n  public readonly 'finally': $String<'finally'>;\n  public readonly 'then': $String<'then'>;\n  public readonly 'catch': $String<'catch'>;\n  public readonly 'message': $String<'message'>;\n  public readonly 'proxy': $String<'proxy'>;\n  public readonly 'revoke': $String<'revoke'>;\n  public readonly 'revocable': $String<'revocable'>;\n  public readonly '$arguments': $String<'arguments'>;\n  public readonly '$callee': $String<'callee'>;\n  public readonly '$constructor': $String<'constructor'>;\n  public readonly '$hasOwnProperty': $String<'hasOwnProperty'>;\n  public readonly '$isPrototypeOf': $String<'isPrototypeOf'>;\n  public readonly '$propertyIsEnumerable': $String<'propertyIsEnumerable'>;\n  public readonly '$toLocaleString': $String<'toLocaleString'>;\n  public readonly '$prototype': $String<'prototype'>;\n  public readonly '$name': $String<'name'>;\n  public readonly '$toString': $String<'toString'>;\n  public readonly '$valueOf': $String<'valueOf'>;\n\n  public readonly '$enumerable': $String<'enumerable'>;\n  public readonly '$configurable': $String<'configurable'>;\n  public readonly '$writable': $String<'writable'>;\n  public readonly '$value': $String<'value'>;\n  public readonly '$return': $String<'return'>;\n  public readonly '$done': $String<'done'>;\n\n  // Reflect\n  public readonly '$getPrototypeOf': $String<'getPrototypeOf'>;\n  public readonly '$setPrototypeOf': $String<'setPrototypeOf'>;\n  public readonly '$isExtensible': $String<'isExtensible'>;\n  public readonly '$preventExtensions': $String<'preventExtensions'>;\n  public readonly '$getOwnPropertyDescriptor': $String<'getOwnPropertyDescriptor'>;\n  public readonly '$defineProperty': $String<'defineProperty'>;\n  public readonly '$has': $String<'has'>;\n  public readonly '$get': $String<'get'>;\n  public readonly '$set': $String<'set'>;\n  public readonly '$deleteProperty': $String<'deleteProperty'>;\n  public readonly '$ownKeys': $String<'ownKeys'>;\n  public readonly '$apply': $String<'apply'>;\n  public readonly '$construct': $String<'construct'>;\n\n  // Function.prototype\n  public readonly '$bind': $String<'bind'>;\n  public readonly '$call': $String<'call'>;\n\n  // Object\n  public readonly '$assign': $String<'assign'>;\n  public readonly '$create': $String<'create'>;\n  public readonly '$defineProperties': $String<'defineProperties'>;\n  // public readonly '$defineProperty': $String<'defineProperty'>;\n  public readonly '$entries': $String<'entries'>;\n  public readonly '$freeze': $String<'freeze'>;\n  public readonly '$fromEntries': $String<'fromEntries'>;\n  // public readonly '$getOwnPropertyDescriptor': $String<'getOwnPropertyDescriptor'>;\n  public readonly '$getOwnPropertyDescriptors': $String<'getOwnPropertyDescriptors'>;\n  public readonly '$getOwnPropertyNames': $String<'getOwnPropertyNames'>;\n  public readonly '$getOwnPropertySymbols': $String<'getOwnPropertySymbols'>;\n  // public readonly '$getPrototypeOf': $String<'getPrototypeOf'>;\n  public readonly '$is': $String<'is'>;\n  // public readonly '$isExtensible': $String<'isExtensible'>;\n  public readonly '$isFrozen': $String<'isFrozen'>;\n  public readonly '$isSealed': $String<'isSealed'>;\n  public readonly '$keys': $String<'keys'>;\n  // public readonly '$preventExtensions': $String<'preventExtensions'>;\n  public readonly '$seal': $String<'seal'>;\n  // public readonly '$setPrototypeOf': $String<'setPrototypeOf'>;\n  public readonly '$values': $String<'values'>;\n\n  public readonly '@@asyncIterator': $Symbol<$String<'Symbol.asyncIterator'>>;\n  public readonly '@@hasInstance': $Symbol<$String<'Symbol.hasInstance'>>;\n  public readonly '@@isConcatSpreadable': $Symbol<$String<'Symbol.isConcatSpreadable'>>;\n  public readonly '@@iterator': $Symbol<$String<'Symbol.iterator'>>;\n  public readonly '@@match': $Symbol<$String<'Symbol.match'>>;\n  public readonly '@@replace': $Symbol<$String<'Symbol.replace'>>;\n  public readonly '@@search': $Symbol<$String<'Symbol.search'>>;\n  public readonly '@@species': $Symbol<$String<'Symbol.species'>>;\n  public readonly '@@split': $Symbol<$String<'Symbol.split'>>;\n  public readonly '@@toPrimitive': $Symbol<$String<'Symbol.toPrimitive'>>;\n  public readonly '@@toStringTag': $Symbol<$String<'Symbol.toStringTag'>>;\n  public readonly '@@unscopables': $Symbol<$String<'Symbol.unscopables'>>;\n\n  public readonly '%ObjectPrototype%': $ObjectPrototype;\n  public readonly '%FunctionPrototype%': $FunctionPrototype;\n\n  public readonly '%Object%': $ObjectConstructor;\n  public readonly '%Function%': $FunctionConstructor;\n\n  public readonly '%ThrowTypeError%': $ThrowTypeError;\n\n  public readonly '%ObjProto_toString%': $ObjProto_toString;\n\n  public readonly '%String%': $StringConstructor;\n  public readonly '%StringPrototype%': $StringPrototype;\n\n  public readonly '%Number%': $NumberConstructor;\n  public readonly '%NumberPrototype%': $NumberPrototype;\n\n  public readonly '%Boolean%': $BooleanConstructor;\n  public readonly '%BooleanPrototype%': $BooleanPrototype;\n\n  public readonly '%Symbol%': $SymbolConstructor;\n  public readonly '%SymbolPrototype%': $SymbolPrototype;\n\n  public readonly '%Error%': $ErrorConstructor;\n  public readonly '%ErrorPrototype%': $ErrorPrototype;\n\n  public readonly '%EvalError%': $EvalErrorConstructor;\n  public readonly '%EvalErrorPrototype%': $EvalErrorPrototype;\n\n  public readonly '%RangeError%': $RangeErrorConstructor;\n  public readonly '%RangeErrorPrototype%': $RangeErrorPrototype;\n\n  public readonly '%ReferenceError%': $ReferenceErrorConstructor;\n  public readonly '%ReferenceErrorPrototype%': $ReferenceErrorPrototype;\n\n  public readonly '%SyntaxError%': $SyntaxErrorConstructor;\n  public readonly '%SyntaxErrorPrototype%': $SyntaxErrorPrototype;\n\n  public readonly '%TypeError%': $TypeErrorConstructor;\n  public readonly '%TypeErrorPrototype%': $TypeErrorPrototype;\n\n  public readonly '%URIError%': $URIErrorConstructor;\n  public readonly '%URIErrorPrototype%': $URIErrorPrototype;\n\n  public readonly '%IteratorPrototype%': $IteratorPrototype;\n\n  public readonly '%GeneratorFunction%': $GeneratorFunctionConstructor;\n  public readonly '%Generator%': $GeneratorFunctionPrototype;\n  public readonly '%GeneratorPrototype%': $GeneratorPrototype;\n\n  public readonly '%Promise%': $PromiseConstructor;\n  public readonly '%PromisePrototype%': $PromisePrototype;\n\n  public readonly '%PromiseProto_then%': $PromiseProto_then;\n  public readonly '%Promise_all%': $Promise_all;\n  public readonly '%Promise_resolve%': $Promise_resolve;\n  public readonly '%Promise_reject%': $Promise_reject;\n\n  public readonly '%AsyncFunction%': $AsyncFunctionConstructor;\n  public readonly '%AsyncFunctionPrototype%': $AsyncFunctionPrototype;\n\n  public readonly '%AsyncIteratorPrototype%': $AsyncIteratorPrototype;\n  public readonly '%AsyncFromSyncIteratorPrototype%': $AsyncFromSyncIteratorPrototype;\n\n  public readonly '%AsyncGeneratorFunction%': $AsyncGeneratorFunctionConstructor;\n  public readonly '%AsyncGenerator%': $AsyncGeneratorFunctionPrototype;\n\n  public readonly '%AsyncGeneratorPrototype%': $AsyncGeneratorPrototype;\n\n  public readonly '%RegExpPrototype%': $Object<'%RegExpPrototype%'>;\n  public readonly '%DatePrototype%': $Object<'%DatePrototype%'>;\n\n  public readonly '%ArrayIteratorPrototype%': $Object<'%ArrayIteratorPrototype%'>;\n  public readonly '%MapIteratorPrototype%': $Object<'%MapIteratorPrototype%'>;\n  public readonly '%SetIteratorPrototype%': $Object<'%SetIteratorPrototype%'>;\n  public readonly '%StringIteratorPrototype%': $Object<'%StringIteratorPrototype%'>;\n\n  public readonly '%ArrayPrototype%': $Object<'%ArrayPrototype%'>;\n  public readonly '%MapPrototype%': $Object<'%MapPrototype%'>;\n  public readonly '%WeakMapPrototype%': $Object<'%WeakMapPrototype%'>;\n  public readonly '%SetPrototype%': $Object<'%SetPrototype%'>;\n  public readonly '%WeakSetPrototype%': $Object<'%WeakSetPrototype%'>;\n  public readonly '%DataViewPrototype%': $Object<'%DataViewPrototype%'>;\n  public readonly '%ArrayBufferPrototype%': $Object<'%ArrayBufferPrototype%'>;\n  public readonly '%SharedArrayBufferPrototype%': $Object<'%SharedArrayBufferPrototype%'>;\n\n  public readonly '%TypedArrayPrototype%': $Object<'%TypedArrayPrototype%'>;\n  public readonly '%Float32ArrayPrototype%': $Object<'%Float32ArrayPrototype%'>;\n  public readonly '%Float64ArrayPrototype%': $Object<'%Float64ArrayPrototype%'>;\n  public readonly '%Int8ArrayPrototype%': $Object<'%Int8ArrayPrototype%'>;\n  public readonly '%Int16ArrayPrototype%': $Object<'%Int16ArrayPrototype%'>;\n  public readonly '%Int32ArrayPrototype%': $Object<'%Int32ArrayPrototype%'>;\n  public readonly '%Uint8ArrayPrototype%': $Object<'%Uint8ArrayPrototype%'>;\n  public readonly '%Uint8ClampedArrayPrototype%': $Object<'%Uint8ClampedArrayPrototype%'>;\n  public readonly '%Uint16ArrayPrototype%': $Object<'%Uint16ArrayPrototype%'>;\n  public readonly '%Uint32ArrayPrototype%': $Object<'%Uint32ArrayPrototype%'>;\n\n  public readonly '%RegExp%': $Object<'%RegExp%'>;\n  public readonly '%Date%': $Object<'%Date%'>;\n\n  public readonly '%Array%': $Object<'%Array%'>;\n  public readonly '%Map%': $Object<'%Map%'>;\n  public readonly '%WeakMap%': $Object<'%WeakMap%'>;\n  public readonly '%Set%': $Object<'%Set%'>;\n  public readonly '%WeakSet%': $Object<'%WeakSet%'>;\n  public readonly '%DataView%': $Object<'%DataView%'>;\n  public readonly '%ArrayBuffer%': $Object<'%ArrayBuffer%'>;\n  public readonly '%SharedArrayBuffer%': $Object<'%SharedArrayBuffer%'>;\n\n  public readonly '%TypedArray%': $Object<'%TypedArray%'>;\n  public readonly '%Float32Array%': $Object<'%Float32Array%'>;\n  public readonly '%Float64Array%': $Object<'%Float64Array%'>;\n  public readonly '%Int8Array%': $Object<'%Int8Array%'>;\n  public readonly '%Int16Array%': $Object<'%Int16Array%'>;\n  public readonly '%Int32Array%': $Object<'%Int32Array%'>;\n  public readonly '%Uint8Array%': $Object<'%Uint8Array%'>;\n  public readonly '%Uint8ClampedArray%': $Object<'%Uint8ClampedArray%'>;\n  public readonly '%Uint16Array%': $Object<'%Uint16Array%'>;\n  public readonly '%Uint32Array%': $Object<'%Uint32Array%'>;\n\n  public readonly '%Atomics%': $Object<'%Atomics%'>;\n  public readonly '%JSON%': $Object<'%JSON%'>;\n  public readonly '%Math%': $Object<'%Math%'>;\n  public readonly '%Reflect%': $Reflect;\n  public readonly '%Proxy%': $ProxyConstructor;\n\n  public readonly '%decodeURI%': $DecodeURI;\n  public readonly '%decodeURIComponent%': $DecodeURIComponent;\n  public readonly '%encodeURI%': $EncodeURI;\n  public readonly '%encodeURIComponent%': $EncodeURIComponent;\n  public readonly '%eval%': $Eval;\n  public readonly '%isFinite%': $IsFinite;\n  public readonly '%isNaN%': $IsNaN;\n  public readonly '%parseFloat%': $ParseFloat;\n  public readonly '%parseInt%': $ParseInt;\n  public readonly '%JSONParse%': $Object<'%JSONParse%'>;\n  public readonly '%JSONStringify%': $Object<'%JSONStringify%'>;\n\n  public readonly '%ArrayProto_entries%': $Object<'%ArrayProto_entries%'>;\n  public readonly '%ArrayProto_forEach%': $Object<'%ArrayProto_forEach%'>;\n  public readonly '%ArrayProto_keys%': $Object<'%ArrayProto_keys%'>;\n  public readonly '%ArrayProto_values%': $Object<'%ArrayProto_values%'>;\n  public readonly '%ObjProto_valueOf%': $Object<'%ObjProto_valueOf%'>;\n\n  // http://www.ecma-international.org/ecma-262/#sec-createintrinsics\n  // 8.2.2 CreateIntrinsics ( realmRec )\n  public constructor(realm: Realm) {\n    realm['[[Intrinsics]]'] = this;\n\n    const empty = this['empty'] = new $Empty(realm);\n    this['undefined'] = new $Undefined(realm);\n    this['null'] = new $Null(realm);\n\n    // Synthetic root context for intrinsics that need the context to be there during initialization.\n    // Creating a valid ExecutionContext requires the null value, which is why we do it right here and neither earlier nor later.\n    const root = new ExecutionContext(realm);\n    root.Function = this['null'];\n    root.ScriptOrModule = this['null'];\n    realm.stack.push(root);\n\n    this['true'] = new $Boolean(realm, true);\n    this['false'] = new $Boolean(realm, false);\n    this['NaN'] = new $Number(realm, NaN);\n    this['Infinity'] = new $Number(realm, Infinity);\n    this['-Infinity'] = new $Number(realm, -Infinity);\n    this['0'] = new $Number(realm, 0);\n    this['-0'] = new $Number(realm, -0);\n    this[''] = new $String(realm, '');\n    this['*'] = new $String(realm, '*');\n    this['*default*'] = new $String(realm, '*default*');\n    this['default'] = new $String(realm, 'default');\n    this['string'] = new $String(realm, 'string');\n    this['number'] = new $String(realm, 'number');\n    this['length'] = new $String(realm, 'length');\n    this['next'] = new $String(realm, 'next');\n    this['return'] = new $String(realm, 'return');\n    this['throw'] = new $String(realm, 'throw');\n    this['call'] = new $String(realm, 'call');\n    this['all'] = new $String(realm, 'all');\n    this['race'] = new $String(realm, 'race');\n    this['reject'] = new $String(realm, 'reject');\n    this['resolve'] = new $String(realm, 'resolve');\n    this['finally'] = new $String(realm, 'finally');\n    this['then'] = new $String(realm, 'then');\n    this['catch'] = new $String(realm, 'catch');\n    this['message'] = new $String(realm, 'message');\n    this['proxy'] = new $String(realm, 'proxy');\n    this['revoke'] = new $String(realm, 'revoke');\n    this['revocable'] = new $String(realm, 'revocable');\n    this['$arguments'] = new $String(realm, 'arguments');\n    this['$callee'] = new $String(realm, 'callee');\n    this['$constructor'] = new $String(realm, 'constructor');\n    this['$hasOwnProperty'] = new $String(realm, 'hasOwnProperty');\n    this['$isPrototypeOf'] = new $String(realm, 'isPrototypeOf');\n    this['$propertyIsEnumerable'] = new $String(realm, 'propertyIsEnumerable');\n    this['$toLocaleString'] = new $String(realm, 'toLocaleString');\n    this['$prototype'] = new $String(realm, 'prototype');\n    this['$name'] = new $String(realm, 'name');\n    this['$toString'] = new $String(realm, 'toString');\n    this['$valueOf'] = new $String(realm, 'valueOf');\n\n    this['$enumerable'] = new $String(realm, 'enumerable');\n    this['$configurable'] = new $String(realm, 'configurable');\n    this['$writable'] = new $String(realm, 'writable');\n    this['$value'] = new $String(realm, 'value');\n    this['$return'] = new $String(realm, 'return');\n    this['$done'] = new $String(realm, 'done');\n\n    this['$getPrototypeOf'] = new $String(realm, 'getPrototypeOf');\n    this['$setPrototypeOf'] = new $String(realm, 'setPrototypeOf');\n    this['$isExtensible'] = new $String(realm, 'isExtensible');\n    this['$preventExtensions'] = new $String(realm, 'preventExtensions');\n    this['$getOwnPropertyDescriptor'] = new $String(realm, 'getOwnPropertyDescriptor');\n    this['$defineProperty'] = new $String(realm, 'defineProperty');\n    this['$has'] = new $String(realm, 'has');\n    this['$get'] = new $String(realm, 'get');\n    this['$set'] = new $String(realm, 'set');\n    this['$deleteProperty'] = new $String(realm, 'deleteProperty');\n    this['$ownKeys'] = new $String(realm, 'ownKeys');\n    this['$apply'] = new $String(realm, 'apply');\n    this['$construct'] = new $String(realm, 'construct');\n\n    this['$bind'] = new $String(realm, 'bind');\n    this['$call'] = new $String(realm, 'call');\n\n    this['$assign'] = new $String(realm, 'assign');\n    this['$create'] = new $String(realm, 'create');\n    this['$defineProperties'] = new $String(realm, 'defineProperties');\n    this['$entries'] = new $String(realm, 'entries');\n    this['$freeze'] = new $String(realm, 'freeze');\n    this['$fromEntries'] = new $String(realm, 'fromEntries');\n    this['$getOwnPropertyDescriptors'] = new $String(realm, 'getOwnPropertyDescriptors');\n    this['$getOwnPropertyNames'] = new $String(realm, 'getOwnPropertyNames');\n    this['$getOwnPropertySymbols'] = new $String(realm, 'getOwnPropertySymbols');\n    this['$is'] = new $String(realm, 'is');\n    this['$isFrozen'] = new $String(realm, 'isFrozen');\n    this['$isSealed'] = new $String(realm, 'isSealed');\n    this['$keys'] = new $String(realm, 'keys');\n    this['$seal'] = new $String(realm, 'seal');\n    this['$values'] = new $String(realm, 'values');\n\n    this['@@asyncIterator'] = new $Symbol(realm, new $String(realm, 'Symbol.asyncIterator'));\n    this['@@hasInstance'] = new $Symbol(realm, new $String(realm, 'Symbol.hasInstance'));\n    this['@@isConcatSpreadable'] = new $Symbol(realm, new $String(realm, 'Symbol.isConcatSpreadable'));\n    this['@@iterator'] = new $Symbol(realm, new $String(realm, 'Symbol.iterator'));\n    this['@@match'] = new $Symbol(realm, new $String(realm, 'Symbol.match'));\n    this['@@replace'] = new $Symbol(realm, new $String(realm, 'Symbol.replace'));\n    this['@@search'] = new $Symbol(realm, new $String(realm, 'Symbol.search'));\n    this['@@species'] = new $Symbol(realm, new $String(realm, 'Symbol.species'));\n    this['@@split'] = new $Symbol(realm, new $String(realm, 'Symbol.split'));\n    this['@@toPrimitive'] = new $Symbol(realm, new $String(realm, 'Symbol.toPrimitive'));\n    this['@@toStringTag'] = new $Symbol(realm, new $String(realm, 'Symbol.toStringTag'));\n    this['@@unscopables'] = new $Symbol(realm, new $String(realm, 'Symbol.unscopables'));\n\n    const objectPrototype = this['%ObjectPrototype%'] = new $ObjectPrototype(realm);\n    const functionPrototype = this['%FunctionPrototype%'] = new $FunctionPrototype(realm, objectPrototype);\n\n    const objectConstructor = this['%Object%'] = new $ObjectConstructor(realm, functionPrototype);\n    (objectConstructor.$prototype = objectPrototype).$constructor = objectConstructor;\n\n    const functionConstructor = this['%Function%'] = new $FunctionConstructor(realm, functionPrototype);\n    (functionConstructor.$prototype = functionPrototype).$constructor = functionConstructor;\n\n    this['%ThrowTypeError%'] = new $ThrowTypeError(realm, '%ThrowTypeError%', functionPrototype);\n\n    objectConstructor.$assign = new $Object_assign(realm, functionPrototype);\n    objectConstructor.$create = new $Object_create(realm, functionPrototype);\n    objectConstructor.$defineProperties = new $Object_defineProperties(realm, functionPrototype);\n    objectConstructor.$defineProperty = new $Object_defineProperty(realm, functionPrototype);\n    objectConstructor.$entries = new $Object_entries(realm, functionPrototype);\n    objectConstructor.$freeze = new $Object_freeze(realm, functionPrototype);\n    objectConstructor.$fromEntries = new $Object_fromEntries(realm, functionPrototype);\n    objectConstructor.$getOwnPropertyDescriptor = new $Object_getOwnPropertyDescriptor(realm, functionPrototype);\n    objectConstructor.$getOwnPropertyDescriptors = new $Object_getOwnPropertyDescriptors(realm, functionPrototype);\n    objectConstructor.$getOwnPropertyNames = new $Object_getOwnPropertyNames(realm, functionPrototype);\n    objectConstructor.$getOwnPropertySymbols = new $Object_getOwnPropertySymbols(realm, functionPrototype);\n    objectConstructor.$getPrototypeOf = new $Object_getPrototypeOf(realm, functionPrototype);\n    objectConstructor.$is = new $Object_is(realm, functionPrototype);\n    objectConstructor.$isExtensible = new $Object_isExtensible(realm, functionPrototype);\n    objectConstructor.$isFrozen = new $Object_isFrozen(realm, functionPrototype);\n    objectConstructor.$isSealed = new $Object_isSealed(realm, functionPrototype);\n    objectConstructor.$keys = new $Object_keys(realm, functionPrototype);\n    objectConstructor.$preventExtensions = new $Object_preventExtensions(realm, functionPrototype);\n    objectConstructor.$seal = new $Object_seal(realm, functionPrototype);\n    objectConstructor.$setPrototypeOf = new $Object_setPrototypeOf(realm, functionPrototype);\n    objectConstructor.$values = new $Object_values(realm, functionPrototype);\n\n    objectPrototype.$hasOwnProperty = new $ObjectPrototype_hasOwnProperty(realm, functionPrototype);\n    objectPrototype.$isPrototypeOf = new $ObjectPrototype_isPrototypeOf(realm, functionPrototype);\n    objectPrototype.$propertyIsEnumerable = new $ObjectPrototype_propertyIsEnumerable(realm, functionPrototype);\n    objectPrototype.$toLocaleString = new $ObjectPrototype_toLocaleString(realm, functionPrototype);\n    objectPrototype.$toString = this['%ObjProto_toString%'] = new $ObjProto_toString(realm, functionPrototype);\n    objectPrototype.$valueOf = this['%ObjProto_valueOf%'] = new $ObjProto_valueOf(realm, functionPrototype);\n\n    functionPrototype.$apply = new $FunctionPrototype_apply(realm, functionPrototype);\n    functionPrototype.$bind = new $FunctionPrototype_bind(realm, functionPrototype);\n    functionPrototype.$call = new $FunctionPrototype_call(realm, functionPrototype);\n    functionPrototype.$toString = new $FunctionPrototype_toString(realm, functionPrototype);\n    functionPrototype['@@hasInstance'] = new $FunctionPrototype_hasInstance(realm, functionPrototype);\n\n    const stringConstructor = this['%String%'] = new $StringConstructor(realm, functionPrototype);\n    const stringPrototype = this['%StringPrototype%'] = new $StringPrototype(realm, objectPrototype);\n    (stringConstructor.$prototype = stringPrototype).$constructor = stringConstructor;\n\n    const numberConstructor = this['%Number%'] = new $NumberConstructor(realm, functionPrototype);\n    const numberPrototype = this['%NumberPrototype%'] = new $NumberPrototype(realm, objectPrototype);\n    (numberConstructor.$prototype = numberPrototype).$constructor = numberConstructor;\n\n    const booleanConstructor = this['%Boolean%'] = new $BooleanConstructor(realm, functionPrototype);\n    const booleanPrototype = this['%BooleanPrototype%'] = new $BooleanPrototype(realm, objectPrototype);\n    (booleanConstructor.$prototype = booleanPrototype).$constructor = booleanConstructor;\n\n    const symbolConstructor = this['%Symbol%'] = new $SymbolConstructor(realm, functionPrototype);\n    const symbolPrototype = this['%SymbolPrototype%'] = new $SymbolPrototype(realm, objectPrototype);\n    (symbolConstructor.$prototype = symbolPrototype).$constructor = symbolConstructor;\n\n    const errorConstructor = this['%Error%'] = new $ErrorConstructor(realm, functionPrototype);\n    const errorPrototype = this['%ErrorPrototype%'] = new $ErrorPrototype(realm, objectPrototype);\n    (errorConstructor.$prototype = errorPrototype).$constructor = errorConstructor;\n    errorPrototype.message = new $String(realm, '');\n    errorPrototype.$name = new $String(realm, 'Error');\n    errorPrototype.$toString = new $ErrorPrototype_toString(realm, 'Error.prototype.toString', functionPrototype);\n\n    const evalErrorConstructor = this['%EvalError%'] = new $EvalErrorConstructor(realm, errorConstructor);\n    const evalErrorPrototype = this['%EvalErrorPrototype%'] = new $EvalErrorPrototype(realm, errorPrototype);\n    (evalErrorConstructor.$prototype = evalErrorPrototype).$constructor = evalErrorConstructor;\n    evalErrorPrototype.message = new $String(realm, '');\n    evalErrorPrototype.$name = new $String(realm, 'EvalError');\n\n    const rangeErrorConstructor = this['%RangeError%'] = new $RangeErrorConstructor(realm, errorConstructor);\n    const rangeErrorPrototype = this['%RangeErrorPrototype%'] = new $RangeErrorPrototype(realm, errorPrototype);\n    (rangeErrorConstructor.$prototype = rangeErrorPrototype).$constructor = rangeErrorConstructor;\n    rangeErrorPrototype.message = new $String(realm, '');\n    rangeErrorPrototype.$name = new $String(realm, 'RangeError');\n\n    const referenceErrorConstructor = this['%ReferenceError%'] = new $ReferenceErrorConstructor(realm, errorConstructor);\n    const referenceErrorPrototype = this['%ReferenceErrorPrototype%'] = new $ReferenceErrorPrototype(realm, errorPrototype);\n    (referenceErrorConstructor.$prototype = referenceErrorPrototype).$constructor = referenceErrorConstructor;\n    referenceErrorPrototype.message = new $String(realm, '');\n    referenceErrorPrototype.$name = new $String(realm, 'ReferenceError');\n\n    const syntaxErrorConstructor = this['%SyntaxError%'] = new $SyntaxErrorConstructor(realm, errorConstructor);\n    const syntaxErrorPrototype = this['%SyntaxErrorPrototype%'] = new $SyntaxErrorPrototype(realm, errorPrototype);\n    (syntaxErrorConstructor.$prototype = syntaxErrorPrototype).$constructor = syntaxErrorConstructor;\n    syntaxErrorPrototype.message = new $String(realm, '');\n    syntaxErrorPrototype.$name = new $String(realm, 'SyntaxError');\n\n    const typeErrorConstructor = this['%TypeError%'] = new $TypeErrorConstructor(realm, errorConstructor);\n    const typeErrorPrototype = this['%TypeErrorPrototype%'] = new $TypeErrorPrototype(realm, errorPrototype);\n    (typeErrorConstructor.$prototype = typeErrorPrototype).$constructor = typeErrorConstructor;\n    typeErrorPrototype.message = new $String(realm, '');\n    typeErrorPrototype.$name = new $String(realm, 'TypeError');\n\n    const URIErrorConstructor = this['%URIError%'] = new $URIErrorConstructor(realm, errorConstructor);\n    const URIErrorPrototype = this['%URIErrorPrototype%'] = new $URIErrorPrototype(realm, errorPrototype);\n    (URIErrorConstructor.$prototype = URIErrorPrototype).$constructor = URIErrorConstructor;\n    URIErrorPrototype.message = new $String(realm, '');\n    URIErrorPrototype.$name = new $String(realm, 'URIError');\n\n    const iteratorPrototype = this['%IteratorPrototype%'] = new $IteratorPrototype(realm, objectPrototype);\n\n    const generatorFunctionConstructor = this['%GeneratorFunction%'] = new $GeneratorFunctionConstructor(realm, functionConstructor);\n    const generatorFunctionPrototype = this['%Generator%'] = new $GeneratorFunctionPrototype(realm, functionPrototype);\n    (generatorFunctionConstructor.$prototype = generatorFunctionPrototype).$constructor = generatorFunctionConstructor;\n    generatorFunctionConstructor.length = new $Number(realm, 1);\n\n    const generatorPrototype = this['%GeneratorPrototype%'] = new $GeneratorPrototype(realm, iteratorPrototype);\n    (generatorFunctionPrototype.$prototype = generatorPrototype).$constructor = generatorFunctionPrototype;\n\n    generatorFunctionPrototype['@@toStringTag'] = new $String(realm, 'GeneratorFunction');\n\n    generatorPrototype.next = new $GeneratorPrototype_next(realm, 'Generator.prototype.next', functionPrototype);\n    generatorPrototype.return = new $GeneratorPrototype_return(realm, 'Generator.prototype.return', functionPrototype);\n    generatorPrototype.throw = new $GeneratorPrototype_throw(realm, 'Generator.prototype.throw', functionPrototype);\n\n    generatorPrototype['@@toStringTag'] = new $String(realm, 'Generator');\n\n    const promiseConstructor = this['%Promise%'] = new $PromiseConstructor(realm, functionPrototype);\n    const promisePrototype = this['%PromisePrototype%'] = new $PromisePrototype(realm, functionPrototype);\n    (promiseConstructor.$prototype = promisePrototype).$constructor = promiseConstructor;\n\n    promisePrototype.then = this['%PromiseProto_then%'] = new $PromiseProto_then(realm, functionPrototype);\n    promisePrototype.catch = new $PromiseProto_catch(realm, functionPrototype);\n    promisePrototype.finally = new $PromiseProto_finally(realm, functionPrototype);\n\n    promisePrototype['@@toStringTag'] = new $String(realm, 'Promise');\n\n    promiseConstructor.all = this['%Promise_all%'] = new $Promise_all(realm, functionPrototype);\n    promiseConstructor.race = new $Promise_race(realm, functionPrototype);\n    promiseConstructor.resolve = this['%Promise_resolve%'] = new $Promise_resolve(realm, functionPrototype);\n    promiseConstructor.reject = this['%Promise_reject%'] = new $Promise_reject(realm, functionPrototype);\n\n    promiseConstructor['@@species'] = new $GetSpecies(realm);\n\n    const asyncFunctionConstructor = this['%AsyncFunction%'] = new $AsyncFunctionConstructor(realm, functionConstructor);\n    const asyncFunctionPrototype = this['%AsyncFunctionPrototype%'] = new $AsyncFunctionPrototype(realm, functionPrototype);\n    (asyncFunctionConstructor.$prototype = asyncFunctionPrototype).$constructor = asyncFunctionConstructor;\n\n    asyncFunctionConstructor.length = new $Number(realm, 1);\n\n    asyncFunctionPrototype['@@toStringTag'] = new $String(realm, 'AsyncFunction');\n\n    const asyncIteratorPrototype = this['%AsyncIteratorPrototype%'] = new $AsyncIteratorPrototype(realm, objectPrototype);\n    const asyncFromSyncIteratorPrototype = this['%AsyncFromSyncIteratorPrototype%'] = new $AsyncFromSyncIteratorPrototype(realm, asyncIteratorPrototype);\n    asyncFromSyncIteratorPrototype.next = new $AsyncFromSyncIteratorPrototype_next(realm, functionPrototype);\n    asyncFromSyncIteratorPrototype.return = new $AsyncFromSyncIteratorPrototype_return(realm, functionPrototype);\n    asyncFromSyncIteratorPrototype.throw = new $AsyncFromSyncIteratorPrototype_throw(realm, functionPrototype);\n\n    asyncFromSyncIteratorPrototype['@@toStringTag'] = new $String(realm, 'Async-from-Sync Iterator');\n\n    const asyncGeneratorFunctionConstructor = this['%AsyncGeneratorFunction%'] = new $AsyncGeneratorFunctionConstructor(realm, functionConstructor);\n    const asyncGeneratorFunctionPrototype = this['%AsyncGenerator%'] = new $AsyncGeneratorFunctionPrototype(realm, functionPrototype);\n    (asyncGeneratorFunctionConstructor.$prototype = asyncGeneratorFunctionPrototype).$constructor = asyncGeneratorFunctionConstructor;\n\n    asyncGeneratorFunctionConstructor.length = new $Number(realm, 1);\n\n    asyncGeneratorFunctionPrototype['@@toStringTag'] = new $String(realm, 'AsyncGeneratorFunction');\n\n    const asyncGeneratorPrototype = this['%AsyncGeneratorPrototype%'] = new $AsyncGeneratorPrototype(realm, iteratorPrototype);\n    (asyncGeneratorFunctionPrototype.$prototype = asyncGeneratorPrototype).$constructor = asyncGeneratorFunctionPrototype;\n    asyncGeneratorPrototype.next = new $AsyncGeneratorPrototype_next(realm, functionPrototype);\n    asyncGeneratorPrototype.return = new $AsyncGeneratorPrototype_return(realm, functionPrototype);\n    asyncGeneratorPrototype.throw = new $AsyncGeneratorPrototype_throw(realm, functionPrototype);\n\n    this['%RegExpPrototype%'] = new $Object(realm, '%RegExpPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%DatePrototype%'] = new $Object(realm, '%DatePrototype%', objectPrototype, CompletionType.normal, empty);\n\n    this['%ArrayIteratorPrototype%'] = new $Object(realm, '%ArrayIteratorPrototype%', this['%IteratorPrototype%'], CompletionType.normal, empty);\n    this['%MapIteratorPrototype%'] = new $Object(realm, '%MapIteratorPrototype%', this['%IteratorPrototype%'], CompletionType.normal, empty);\n    this['%SetIteratorPrototype%'] = new $Object(realm, '%SetIteratorPrototype%', this['%IteratorPrototype%'], CompletionType.normal, empty);\n    this['%StringIteratorPrototype%'] = new $Object(realm, '%StringIteratorPrototype%', this['%IteratorPrototype%'], CompletionType.normal, empty);\n\n    this['%ArrayPrototype%'] = new $Object(realm, '%ArrayPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%MapPrototype%'] = new $Object(realm, '%MapPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%WeakMapPrototype%'] = new $Object(realm, '%WeakMapPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%SetPrototype%'] = new $Object(realm, '%SetPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%WeakSetPrototype%'] = new $Object(realm, '%WeakSetPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%DataViewPrototype%'] = new $Object(realm, '%DataViewPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%ArrayBufferPrototype%'] = new $Object(realm, '%ArrayBufferPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%SharedArrayBufferPrototype%'] = new $Object(realm, '%SharedArrayBufferPrototype%', objectPrototype, CompletionType.normal, empty);\n\n    this['%TypedArrayPrototype%'] = new $Object(realm, '%TypedArrayPrototype%', objectPrototype, CompletionType.normal, empty);\n    this['%Float32ArrayPrototype%'] = new $Object(realm, '%Float32ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Float64ArrayPrototype%'] = new $Object(realm, '%Float64ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Int8ArrayPrototype%'] = new $Object(realm, '%Int8ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Int16ArrayPrototype%'] = new $Object(realm, '%Int16ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Int32ArrayPrototype%'] = new $Object(realm, '%Int32ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Uint8ArrayPrototype%'] = new $Object(realm, '%Uint8ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Uint8ClampedArrayPrototype%'] = new $Object(realm, '%Uint8ClampedArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Uint16ArrayPrototype%'] = new $Object(realm, '%Uint16ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n    this['%Uint32ArrayPrototype%'] = new $Object(realm, '%Uint32ArrayPrototype%', this['%TypedArrayPrototype%'], CompletionType.normal, empty);\n\n    this['%RegExp%'] = new $Object(realm, '%RegExp%', functionPrototype, CompletionType.normal, empty);\n    this['%Date%'] = new $Object(realm, '%Date%', functionPrototype, CompletionType.normal, empty);\n\n    this['%Array%'] = new $Object(realm, '%Array%', functionPrototype, CompletionType.normal, empty);\n    this['%Map%'] = new $Object(realm, '%Map%', functionPrototype, CompletionType.normal, empty);\n    this['%WeakMap%'] = new $Object(realm, '%WeakMap%', functionPrototype, CompletionType.normal, empty);\n    this['%Set%'] = new $Object(realm, '%Set%', functionPrototype, CompletionType.normal, empty);\n    this['%WeakSet%'] = new $Object(realm, '%WeakSet%', functionPrototype, CompletionType.normal, empty);\n    this['%DataView%'] = new $Object(realm, '%DataView%', functionPrototype, CompletionType.normal, empty);\n    this['%ArrayBuffer%'] = new $Object(realm, '%ArrayBuffer%', functionPrototype, CompletionType.normal, empty);\n    this['%SharedArrayBuffer%'] = new $Object(realm, '%SharedArrayBuffer%', functionPrototype, CompletionType.normal, empty);\n\n    this['%TypedArray%'] = new $Object(realm, '%TypedArray%', functionPrototype, CompletionType.normal, empty);\n    this['%Float32Array%'] = new $Object(realm, '%Float32Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Float64Array%'] = new $Object(realm, '%Float64Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Int8Array%'] = new $Object(realm, '%Int8Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Int16Array%'] = new $Object(realm, '%Int16Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Int32Array%'] = new $Object(realm, '%Int32Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Uint8Array%'] = new $Object(realm, '%Uint8Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Uint8ClampedArray%'] = new $Object(realm, '%Uint8ClampedArray%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Uint16Array%'] = new $Object(realm, '%Uint16Array%', this['%TypedArray%'], CompletionType.normal, empty);\n    this['%Uint32Array%'] = new $Object(realm, '%Uint32Array%', this['%TypedArray%'], CompletionType.normal, empty);\n\n    this['%Atomics%'] = new $Object(realm, '%Atomics%', objectPrototype, CompletionType.normal, empty);\n    this['%JSON%'] = new $Object(realm, '%JSON%', objectPrototype, CompletionType.normal, empty);\n    this['%Math%'] = new $Object(realm, '%Math%', objectPrototype, CompletionType.normal, empty);\n\n    const reflect = this['%Reflect%'] = new $Reflect(realm, objectPrototype);\n    reflect.$apply = new $Reflect_apply(realm, functionPrototype);\n    reflect.$construct = new $Reflect_construct(realm, functionPrototype);\n    reflect.$defineProperty = new $Reflect_defineProperty(realm, functionPrototype);\n    reflect.$deleteProperty = new $Reflect_deleteProperty(realm, functionPrototype);\n    reflect.$get = new $Reflect_get(realm, functionPrototype);\n    reflect.$getOwnPropertyDescriptor = new $Reflect_getOwnPropertyDescriptor(realm, functionPrototype);\n    reflect.$getPrototypeOf = new $Reflect_getPrototypeOf(realm, functionPrototype);\n    reflect.$has = new $Reflect_has(realm, functionPrototype);\n    reflect.$isExtensible = new $Reflect_isExtensible(realm, functionPrototype);\n    reflect.$ownKeys = new $Reflect_ownKeys(realm, functionPrototype);\n    reflect.$preventExtensions = new $Reflect_preventExtensions(realm, functionPrototype);\n    reflect.$set = new $Reflect_set(realm, functionPrototype);\n    reflect.$setPrototypeOf = new $Reflect_setPrototypeOf(realm, functionPrototype);\n\n    const proxyConstructor = this['%Proxy%'] = new $ProxyConstructor(realm, functionPrototype);\n    proxyConstructor.revocable = new $Proxy_revocable(realm, functionPrototype);\n\n    this['%decodeURI%'] = new $DecodeURI(realm, functionPrototype);\n    this['%decodeURIComponent%'] = new $DecodeURIComponent(realm, functionPrototype);\n    this['%encodeURI%'] = new $EncodeURI(realm, functionPrototype);\n    this['%encodeURIComponent%'] = new $EncodeURIComponent(realm, functionPrototype);\n\n    this['%eval%'] = new $Eval(realm, functionPrototype);\n    this['%isFinite%'] = new $IsFinite(realm, functionPrototype);\n    this['%isNaN%'] = new $IsNaN(realm, functionPrototype);\n    this['%parseFloat%'] = new $ParseFloat(realm, functionPrototype);\n    this['%parseInt%'] = new $ParseInt(realm, functionPrototype);\n    this['%JSONParse%'] = new $Object(realm, '%JSONParse%', functionPrototype, CompletionType.normal, empty);\n    this['%JSONStringify%'] = new $Object(realm, '%JSONStringify%', functionPrototype, CompletionType.normal, empty);\n\n    this['%ArrayProto_entries%'] = new $Object(realm, '%ArrayProto_entries%', functionPrototype, CompletionType.normal, empty);\n    this['%ArrayProto_forEach%'] = new $Object(realm, '%ArrayProto_forEach%', functionPrototype, CompletionType.normal, empty);\n    this['%ArrayProto_keys%'] = new $Object(realm, '%ArrayProto_keys%', functionPrototype, CompletionType.normal, empty);\n    this['%ArrayProto_values%'] = new $Object(realm, '%ArrayProto_values%', functionPrototype, CompletionType.normal, empty);\n    this['%ObjProto_valueOf%'] = new $Object(realm, '%ObjProto_valueOf%', functionPrototype, CompletionType.normal, empty);\n  }\n\n  public dispose(this: Writable<Partial<Intrinsics>>): void {\n    this['true'] = void 0;\n    this['false'] = void 0;\n    this['NaN'] = void 0;\n    this['Infinity'] = void 0;\n    this['-Infinity'] = void 0;\n    this['0'] = void 0;\n    this['-0'] = void 0;\n    this[''] = void 0;\n    this['*'] = void 0;\n    this['*default*'] = void 0;\n    this['default'] = void 0;\n    this['string'] = void 0;\n    this['number'] = void 0;\n    this['length'] = void 0;\n    this['next'] = void 0;\n    this['return'] = void 0;\n    this['throw'] = void 0;\n    this['call'] = void 0;\n    this['message'] = void 0;\n    this['$arguments'] = void 0;\n    this['$callee'] = void 0;\n    this['$constructor'] = void 0;\n    this['$prototype'] = void 0;\n    this['$name'] = void 0;\n    this['$toString'] = void 0;\n    this['$valueOf'] = void 0;\n\n    this['$enumerable'] = void 0;\n    this['$configurable'] = void 0;\n    this['$writable'] = void 0;\n    this['$value'] = void 0;\n    this['$return'] = void 0;\n    this['$done'] = void 0;\n\n    this['$getPrototypeOf'] = void 0;\n    this['$setPrototypeOf'] = void 0;\n    this['$isExtensible'] = void 0;\n    this['$preventExtensions'] = void 0;\n    this['$getOwnPropertyDescriptor'] = void 0;\n    this['$defineProperty'] = void 0;\n    this['$has'] = void 0;\n    this['$get'] = void 0;\n    this['$set'] = void 0;\n    this['$deleteProperty'] = void 0;\n    this['$ownKeys'] = void 0;\n    this['$apply'] = void 0;\n    this['$construct'] = void 0;\n\n    this['@@asyncIterator'] = void 0;\n    this['@@hasInstance'] = void 0;\n    this['@@isConcatSpreadable'] = void 0;\n    this['@@iterator'] = void 0;\n    this['@@match'] = void 0;\n    this['@@replace'] = void 0;\n    this['@@search'] = void 0;\n    this['@@species'] = void 0;\n    this['@@split'] = void 0;\n    this['@@toPrimitive'] = void 0;\n    this['@@toStringTag'] = void 0;\n    this['@@unscopables'] = void 0;\n\n    this['%ObjectPrototype%']!.dispose();\n    this['%ObjectPrototype%'] = void 0;\n    this['%FunctionPrototype%']!.dispose();\n    this['%FunctionPrototype%'] = void 0;\n\n    this['%Object%']!.dispose();\n    this['%Object%'] = void 0;\n    this['%Function%']!.dispose();\n    this['%Function%'] = void 0;\n\n    this['%ThrowTypeError%']!.dispose();\n    this['%ThrowTypeError%'] = void 0;\n\n    this['%ObjProto_toString%']!.dispose();\n    this['%ObjProto_toString%'] = void 0;\n\n    this['%String%']!.dispose();\n    this['%String%'] = void 0;\n    this['%StringPrototype%']!.dispose();\n    this['%StringPrototype%'] = void 0;\n\n    this['%Number%']!.dispose();\n    this['%Number%'] = void 0;\n    this['%NumberPrototype%']!.dispose();\n    this['%NumberPrototype%'] = void 0;\n\n    this['%Boolean%']!.dispose();\n    this['%Boolean%'] = void 0;\n    this['%BooleanPrototype%']!.dispose();\n    this['%BooleanPrototype%'] = void 0;\n\n    this['%Symbol%']!.dispose();\n    this['%Symbol%'] = void 0;\n    this['%SymbolPrototype%']!.dispose();\n    this['%SymbolPrototype%'] = void 0;\n\n    this['%Error%']!.dispose();\n    this['%Error%'] = void 0;\n    this['%ErrorPrototype%']!.dispose();\n    this['%ErrorPrototype%'] = void 0;\n\n    this['%EvalError%']!.dispose();\n    this['%EvalError%'] = void 0;\n    this['%EvalErrorPrototype%']!.dispose();\n    this['%EvalErrorPrototype%'] = void 0;\n\n    this['%RangeError%']!.dispose();\n    this['%RangeError%'] = void 0;\n    this['%RangeErrorPrototype%']!.dispose();\n    this['%RangeErrorPrototype%'] = void 0;\n\n    this['%ReferenceError%']!.dispose();\n    this['%ReferenceError%'] = void 0;\n    this['%ReferenceErrorPrototype%']!.dispose();\n    this['%ReferenceErrorPrototype%'] = void 0;\n\n    this['%SyntaxError%']!.dispose();\n    this['%SyntaxError%'] = void 0;\n    this['%SyntaxErrorPrototype%']!.dispose();\n    this['%SyntaxErrorPrototype%'] = void 0;\n\n    this['%TypeError%']!.dispose();\n    this['%TypeError%'] = void 0;\n    this['%TypeErrorPrototype%']!.dispose();\n    this['%TypeErrorPrototype%'] = void 0;\n\n    this['%URIError%']!.dispose();\n    this['%URIError%'] = void 0;\n    this['%URIErrorPrototype%']!.dispose();\n    this['%URIErrorPrototype%'] = void 0;\n\n    this['%PromisePrototype%']!.dispose();\n    this['%PromisePrototype%'] = void 0;\n    this['%RegExpPrototype%']!.dispose();\n    this['%RegExpPrototype%'] = void 0;\n    this['%DatePrototype%']!.dispose();\n    this['%DatePrototype%'] = void 0;\n\n    this['%AsyncFunctionPrototype%']!.dispose();\n    this['%AsyncFunctionPrototype%'] = void 0;\n\n    this['%Generator%']!.dispose();\n    this['%Generator%'] = void 0;\n    this['%AsyncGenerator%']!.dispose();\n    this['%AsyncGenerator%'] = void 0;\n\n    this['%IteratorPrototype%']!.dispose();\n    this['%IteratorPrototype%'] = void 0;\n    this['%ArrayIteratorPrototype%']!.dispose();\n    this['%ArrayIteratorPrototype%'] = void 0;\n    this['%MapIteratorPrototype%']!.dispose();\n    this['%MapIteratorPrototype%'] = void 0;\n    this['%SetIteratorPrototype%']!.dispose();\n    this['%SetIteratorPrototype%'] = void 0;\n    this['%StringIteratorPrototype%']!.dispose();\n    this['%StringIteratorPrototype%'] = void 0;\n    this['%GeneratorPrototype%']!.dispose();\n    this['%GeneratorPrototype%'] = void 0;\n\n    this['%AsyncIteratorPrototype%']!.dispose();\n    this['%AsyncIteratorPrototype%'] = void 0;\n    this['%AsyncFromSyncIteratorPrototype%']!.dispose();\n    this['%AsyncFromSyncIteratorPrototype%'] = void 0;\n    this['%AsyncGeneratorPrototype%']!.dispose();\n    this['%AsyncGeneratorPrototype%'] = void 0;\n\n    this['%ArrayPrototype%']!.dispose();\n    this['%ArrayPrototype%'] = void 0;\n    this['%MapPrototype%']!.dispose();\n    this['%MapPrototype%'] = void 0;\n    this['%WeakMapPrototype%']!.dispose();\n    this['%WeakMapPrototype%'] = void 0;\n    this['%SetPrototype%']!.dispose();\n    this['%SetPrototype%'] = void 0;\n    this['%WeakSetPrototype%']!.dispose();\n    this['%WeakSetPrototype%'] = void 0;\n    this['%DataViewPrototype%']!.dispose();\n    this['%DataViewPrototype%'] = void 0;\n    this['%ArrayBufferPrototype%']!.dispose();\n    this['%ArrayBufferPrototype%'] = void 0;\n    this['%SharedArrayBufferPrototype%']!.dispose();\n    this['%SharedArrayBufferPrototype%'] = void 0;\n\n    this['%TypedArrayPrototype%']!.dispose();\n    this['%TypedArrayPrototype%'] = void 0;\n    this['%Float32ArrayPrototype%']!.dispose();\n    this['%Float32ArrayPrototype%'] = void 0;\n    this['%Float64ArrayPrototype%']!.dispose();\n    this['%Float64ArrayPrototype%'] = void 0;\n    this['%Int8ArrayPrototype%']!.dispose();\n    this['%Int8ArrayPrototype%'] = void 0;\n    this['%Int16ArrayPrototype%']!.dispose();\n    this['%Int16ArrayPrototype%'] = void 0;\n    this['%Int32ArrayPrototype%']!.dispose();\n    this['%Int32ArrayPrototype%'] = void 0;\n    this['%Uint8ArrayPrototype%']!.dispose();\n    this['%Uint8ArrayPrototype%'] = void 0;\n    this['%Uint8ClampedArrayPrototype%']!.dispose();\n    this['%Uint8ClampedArrayPrototype%'] = void 0;\n    this['%Uint16ArrayPrototype%']!.dispose();\n    this['%Uint16ArrayPrototype%'] = void 0;\n    this['%Uint32ArrayPrototype%']!.dispose();\n    this['%Uint32ArrayPrototype%'] = void 0;\n\n    this['%Promise%']!.dispose();\n    this['%Promise%'] = void 0;\n    this['%RegExp%']!.dispose();\n    this['%RegExp%'] = void 0;\n    this['%Date%']!.dispose();\n    this['%Date%'] = void 0;\n\n    this['%AsyncFunction%']!.dispose();\n    this['%AsyncFunction%'] = void 0;\n\n    this['%GeneratorFunction%']!.dispose();\n    this['%GeneratorFunction%'] = void 0;\n    this['%AsyncGeneratorFunction%']!.dispose();\n    this['%AsyncGeneratorFunction%'] = void 0;\n\n    this['%Array%']!.dispose();\n    this['%Array%'] = void 0;\n    this['%Map%']!.dispose();\n    this['%Map%'] = void 0;\n    this['%WeakMap%']!.dispose();\n    this['%WeakMap%'] = void 0;\n    this['%Set%']!.dispose();\n    this['%Set%'] = void 0;\n    this['%WeakSet%']!.dispose();\n    this['%WeakSet%'] = void 0;\n    this['%DataView%']!.dispose();\n    this['%DataView%'] = void 0;\n    this['%ArrayBuffer%']!.dispose();\n    this['%ArrayBuffer%'] = void 0;\n    this['%SharedArrayBuffer%']!.dispose();\n    this['%SharedArrayBuffer%'] = void 0;\n\n    this['%TypedArray%']!.dispose();\n    this['%TypedArray%'] = void 0;\n    this['%Float32Array%']!.dispose();\n    this['%Float32Array%'] = void 0;\n    this['%Float64Array%']!.dispose();\n    this['%Float64Array%'] = void 0;\n    this['%Int8Array%']!.dispose();\n    this['%Int8Array%'] = void 0;\n    this['%Int16Array%']!.dispose();\n    this['%Int16Array%'] = void 0;\n    this['%Int32Array%']!.dispose();\n    this['%Int32Array%'] = void 0;\n    this['%Uint8Array%']!.dispose();\n    this['%Uint8Array%'] = void 0;\n    this['%Uint8ClampedArray%']!.dispose();\n    this['%Uint8ClampedArray%'] = void 0;\n    this['%Uint16Array%']!.dispose();\n    this['%Uint16Array%'] = void 0;\n    this['%Uint32Array%']!.dispose();\n    this['%Uint32Array%'] = void 0;\n\n    this['%Atomics%']!.dispose();\n    this['%Atomics%'] = void 0;\n    this['%JSON%']!.dispose();\n    this['%JSON%'] = void 0;\n    this['%Math%']!.dispose();\n    this['%Math%'] = void 0;\n    this['%Reflect%']!.dispose();\n    this['%Reflect%'] = void 0;\n    this['%Proxy%']!.dispose();\n    this['%Proxy%'] = void 0;\n\n    this['%decodeURI%']!.dispose();\n    this['%decodeURI%'] = void 0;\n    this['%decodeURIComponent%']!.dispose();\n    this['%decodeURIComponent%'] = void 0;\n    this['%encodeURI%']!.dispose();\n    this['%encodeURI%'] = void 0;\n    this['%encodeURIComponent%']!.dispose();\n    this['%encodeURIComponent%'] = void 0;\n    this['%eval%']!.dispose();\n    this['%eval%'] = void 0;\n    this['%isFinite%']!.dispose();\n    this['%isFinite%'] = void 0;\n    this['%isNaN%']!.dispose();\n    this['%isNaN%'] = void 0;\n    this['%parseFloat%']!.dispose();\n    this['%parseFloat%'] = void 0;\n    this['%parseInt%']!.dispose();\n    this['%parseInt%'] = void 0;\n    this['%JSONParse%']!.dispose();\n    this['%JSONParse%'] = void 0;\n    this['%JSONStringify%']!.dispose();\n    this['%JSONStringify%'] = void 0;\n\n    this['%ArrayProto_entries%']!.dispose();\n    this['%ArrayProto_entries%'] = void 0;\n    this['%ArrayProto_forEach%']!.dispose();\n    this['%ArrayProto_forEach%'] = void 0;\n    this['%ArrayProto_keys%']!.dispose();\n    this['%ArrayProto_keys%'] = void 0;\n    this['%ArrayProto_values%']!.dispose();\n    this['%ArrayProto_values%'] = void 0;\n    this['%ObjProto_valueOf%']!.dispose();\n    this['%ObjProto_valueOf%'] = void 0;\n    this['%PromiseProto_then%']!.dispose();\n    this['%PromiseProto_then%'] = void 0;\n    this['%Promise_all%']!.dispose();\n    this['%Promise_all%'] = void 0;\n    this['%Promise_reject%']!.dispose();\n    this['%Promise_reject%'] = void 0;\n    this['%Promise_resolve%']!.dispose();\n    this['%Promise_resolve%'] = void 0;\n  }\n}\n\nexport type IntrinsicObjectKey = { [K in keyof Intrinsics]: Intrinsics[K] extends $Object ? K : never }[keyof Intrinsics];\n// export type IntrinsicObjectKey =\n//   { [K in keyof Intrinsics]: Intrinsics[K] extends $Object ? K : never; } extends { [K in keyof Intrinsics]: infer U; }\n//     ? ({} extends U ? never : U)\n//     : never;\n","import {\n  ILogger,\n  IContainer,\n  Writable,\n  IDisposable,\n} from '@aurelia/kernel';\nimport {\n  IFile,\n} from '../system/interfaces.js';\nimport {\n  Intrinsics,\n} from './intrinsics.js';\nimport {\n  $EnvRec,\n  $ModuleEnvRec,\n  $GlobalEnvRec,\n  $FunctionEnvRec,\n  $DeclarativeEnvRec,\n} from './types/environment-record.js';\nimport {\n  $PropertyDescriptor,\n} from './types/property-descriptor.js';\nimport {\n  $DefinePropertyOrThrow,\n} from './operations.js';\nimport {\n  $String,\n} from './types/string.js';\nimport {\n  $Undefined,\n} from './types/undefined.js';\nimport {\n  $Object,\n} from './types/object.js';\nimport {\n  $Reference,\n} from './types/reference.js';\nimport {\n  $AnyNonEmpty,\n} from './types/_shared.js';\nimport {\n  $Function,\n} from './types/function.js';\nimport {\n  $Null,\n} from './types/null.js';\nimport {\n  $Boolean,\n} from './types/boolean.js';\nimport {\n  $Error,\n} from './types/error.js';\nimport {\n  $NamespaceExoticObject,\n} from './exotics/namespace.js';\nimport {\n  $List,\n} from './types/list.js';\nimport {\n  $Number,\n} from './types/number.js';\nimport {\n  $TemplateExpression,\n  $TaggedTemplateExpression,\n} from './ast/expressions.js';\nimport {\n  $$ESModuleOrScript,\n} from './ast/modules.js';\nimport {\n  $GeneratorInstance,\n} from './globals/generator-function.js';\nimport {\n  JobQueue,\n} from './job.js';\nimport {\n  $AsyncGeneratorInstance,\n} from './globals/async-generator-function.js';\n\nexport class ResolveSet {\n  private readonly modules: IModule[] = [];\n  private readonly exportNames: $String[] = [];\n  private count: number = 0;\n\n  public has(mod: IModule, exportName: $String): boolean {\n    const modules = this.modules;\n    const exportNames = this.exportNames;\n    const count = this.count;\n\n    for (let i = 0; i < count; ++i) {\n      if (exportNames[i].is(exportName) && modules[i] === mod) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public add(mod: IModule, exportName: $String): void {\n    const index = this.count;\n    this.modules[index] = mod;\n    this.exportNames[index] = exportName;\n    ++this.count;\n  }\n\n  public forEach(callback: (mod: IModule, exportName: $String) => void): void {\n    const modules = this.modules;\n    const exportNames = this.exportNames;\n    const count = this.count;\n\n    for (let i = 0; i < count; ++i) {\n      callback(modules[i], exportNames[i]);\n    }\n  }\n}\n\nexport class ResolvedBindingRecord {\n  public get isAbrupt(): false { return false; }\n  public get isNull(): false { return false; }\n  public get isAmbiguous(): false { return false; }\n\n  public constructor(\n    public readonly Module: IModule,\n    public readonly BindingName: $String,\n  ) { }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-abstract-module-records\nexport interface IModule extends IDisposable {\n  /** This field is never used. Its only purpose is to help TS distinguish this interface from others. */\n  readonly '<IModule>': unknown;\n\n  readonly isAbrupt: false;\n\n  '[[Environment]]': $ModuleEnvRec | $Undefined;\n  '[[Namespace]]': $NamespaceExoticObject | $Undefined;\n  '[[HostDefined]]': any;\n\n  readonly realm: Realm;\n\n  ResolveExport(ctx: ExecutionContext, exportName: $String, resolveSet: ResolveSet): ResolvedBindingRecord | $Null | $String<'ambiguous'> | $Error;\n  GetExportedNames(ctx: ExecutionContext, exportStarSet: Set<IModule>): $List<$String> | $Error;\n  Instantiate(ctx: ExecutionContext): $Undefined | $Error;\n  /** @internal */\n  _InnerModuleInstantiation(ctx: ExecutionContext, stack: IModule[], index: $Number): $Number | $Error;\n}\n\nexport class DeferredModule implements IModule {\n  public readonly '<IModule>': unknown;\n\n  public '[[Environment]]': $ModuleEnvRec | $Undefined;\n  public '[[Namespace]]': $NamespaceExoticObject | $Undefined;\n  public '[[HostDefined]]': any;\n\n  public get isAbrupt(): false { return false; }\n\n  public constructor(\n    public readonly $file: IFile,\n    public readonly realm: Realm,\n  ) { }\n\n  public ResolveExport(ctx: ExecutionContext, exportName: $String, resolveSet: ResolveSet): ResolvedBindingRecord | $Null | $String<'ambiguous'> | $Error {\n    throw new Error('Method not implemented.');\n  }\n\n  public GetExportedNames(ctx: ExecutionContext, exportStarSet: Set<IModule>): $List<$String> | $Error {\n    throw new Error('Method not implemented.');\n  }\n\n  public Instantiate(ctx: ExecutionContext): $Undefined | $Error {\n    throw new Error('Method not implemented.');\n  }\n\n  public _InnerModuleInstantiation(ctx: ExecutionContext, stack: IModule[], index: $Number): $Number | $Error {\n    throw new Error('Method not implemented.');\n  }\n\n  public dispose(): void {\n    throw new Error('Method not implemented.');\n  }\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-code-realms\nexport class Realm implements IDisposable {\n  public timeout: number = 100;\n  public contextId: number = 0;\n\n  public readonly stack: ExecutionContextStack;\n\n  public '[[Intrinsics]]': Intrinsics;\n  public '[[GlobalObject]]': $Object;\n  public '[[GlobalEnv]]': $GlobalEnvRec;\n  public '[[TemplateMap]]': { '[[Site]]': $TemplateExpression | $TaggedTemplateExpression; '[[Array]]': $Object }[];\n\n  public get isAbrupt(): false { return false; }\n\n  private constructor(\n    public readonly container: IContainer,\n    public readonly logger: ILogger,\n    public readonly PromiseJobs: JobQueue,\n  ) {\n\n    this.stack = new ExecutionContextStack(logger);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-createrealm\n  // 8.2.1 CreateRealm ( )\n  public static Create(\n    container: IContainer,\n    promiseJobs: JobQueue,\n  ): Realm {\n    const logger = container.get(ILogger).root.scopeTo('Realm');\n    logger.debug('Creating new realm');\n\n    // 1. Let realmRec be a new Realm Record.\n    const realm = new Realm(container, logger, promiseJobs);\n\n    // 2. Perform CreateIntrinsics(realmRec).\n    new Intrinsics(realm);\n\n    // 3. Set realmRec.[[GlobalObject]] to undefined.\n    realm['[[GlobalObject]]'] = (void 0)!;\n\n    // 4. Set realmRec.[[GlobalEnv]] to undefined.\n    realm['[[GlobalEnv]]'] = (void 0)!;\n\n    // 5. Set realmRec.[[TemplateMap]] to a new empty List.\n    realm['[[TemplateMap]]'] = [];\n\n    // 6. Return realmRec.\n\n    // http://www.ecma-international.org/ecma-262/#sec-initializehostdefinedrealm\n    // 8.5 InitializeHostDefinedRealm ( )\n\n    // 1. Let realm be CreateRealm().\n    const intrinsics = realm['[[Intrinsics]]'];\n\n    // 2. Let newContext be a new execution context.\n    const newContext = new ExecutionContext(realm);\n\n    // 3. Set the Function of newContext to null.\n    newContext.Function = intrinsics.null;\n\n    // 4. Set the Realm of newContext to realm.\n\n    // 5. Set the ScriptOrModule of newContext to null.\n    newContext.ScriptOrModule = intrinsics.null;\n\n    // 6. Push newContext onto the execution context stack; newContext is now the running execution context.\n    realm.stack.push(newContext);\n\n    // 7. If the host requires use of an exotic object to serve as realm's global object, let global be such an object created in an implementation-defined manner. Otherwise, let global be undefined, indicating that an ordinary object should be created as the global object.\n    const globalObj = $Object.ObjectCreate(newContext, 'GlobalObject', intrinsics['%ObjectPrototype%']);\n\n    // 8. If the host requires that the this binding in realm's global scope return an object other than the global object, let thisValue be such an object created in an implementation-defined manner. Otherwise, let thisValue be undefined, indicating that realm's global this binding should be the global object.\n    const thisValue = globalObj;\n\n    // Note: the two steps above are consolidated with setrealmglobalobject steps\n\n    // 9. Perform SetRealmGlobalObject(realm, global, thisValue).\n\n    // http://www.ecma-international.org/ecma-262/#sec-setrealmglobalobject\n    // 8.2.3 SetRealmGlobalObject ( realmRec , globalObj , thisValue )\n    // 1. If globalObj is undefined, then\n    // 1. a. Let intrinsics be realmRec.[[Intrinsics]].\n    // 1. b. Set globalObj to ObjectCreate(intrinsics.[[%ObjectPrototype%]]).\n    // 2. Assert: Type(globalObj) is Object.\n    // 3. If thisValue is undefined, set thisValue to globalObj.\n    // 4. Set realmRec.[[GlobalObject]] to globalObj.\n    realm['[[GlobalObject]]'] = globalObj as $Object;\n\n    // 5. Let newGlobalEnv be NewGlobalEnvironment(globalObj, thisValue).\n    const newGlobalEnv = new $GlobalEnvRec(logger, realm, globalObj as $Object, thisValue as $Object);\n\n    // 6. Set realmRec.[[GlobalEnv]] to newGlobalEnv.\n    realm['[[GlobalEnv]]'] = newGlobalEnv;\n\n    // 7. Return realmRec.\n\n    // 10. Let globalObj be ? SetDefaultGlobalBindings(realm).\n    // http://www.ecma-international.org/ecma-262/#sec-setdefaultglobalbindings\n    // 8.2.4 SetDefaultGlobalBindings ( realmRec )\n\n    // 1. Let global be realmRec.[[GlobalObject]].\n    const global = realm['[[GlobalObject]]'];\n\n    // 2. For each property of the Global Object specified in clause 18, do\n    // 2. a. Let name be the String value of the property name.\n    // 2. b. Let desc be the fully populated data property descriptor for the property containing the specified attributes for the property. For properties listed in 18.2, 18.3, or 18.4 the value of the [[Value]] attribute is the corresponding intrinsic object from realmRec.\n    // 2. c. Perform ? DefinePropertyOrThrow(global, name, desc).\n    // 3. Return global.\n\n    function def(propertyName: string, intrinsicName: Exclude<keyof Intrinsics, 'dispose'>): void {\n      const name = new $String(realm, propertyName);\n      const desc = new $PropertyDescriptor(realm, name);\n      desc['[[Writable]]'] = intrinsics.false;\n      desc['[[Enumerable]]'] = intrinsics.false;\n      desc['[[Configurable]]'] = intrinsics.false;\n      desc['[[Value]]'] = intrinsics[intrinsicName];\n      $DefinePropertyOrThrow(newContext, global, name, desc);\n    }\n\n    // http://www.ecma-international.org/ecma-262/#sec-value-properties-of-the-global-object\n    // 18.1 Value Properties of the Global Object\n    def('Infinity', 'Infinity');\n    def('NaN', 'NaN');\n    def('undefined', 'undefined');\n\n    // http://www.ecma-international.org/ecma-262/#sec-function-properties-of-the-global-object\n    // 18.2 Function Properties of the Global Object\n    def('eval', '%eval%');\n    def('isFinite', '%isFinite%');\n    def('isNaN', '%isNaN%');\n    def('parseFloat', '%parseFloat%');\n    def('parseInt', '%parseInt%');\n    def('decodeURI', '%decodeURI%');\n    def('decodeURIComponent', '%decodeURIComponent%');\n    def('encodeURI', '%encodeURI%');\n    def('encodeURIComponent', '%encodeURIComponent%');\n\n    // http://www.ecma-international.org/ecma-262/#sec-constructor-properties-of-the-global-object\n    // 18.3 Constructor Properties of the Global Object\n    def('Array', '%Array%');\n    def('ArrayBuffer', '%ArrayBuffer%');\n    def('Boolean', '%Boolean%');\n    def('DataView', '%DataView%');\n    def('Date', '%Date%');\n    def('Error', '%Error%');\n    def('EvalError', '%EvalError%');\n    def('Float32Array', '%Float32Array%');\n    def('Float64Array', '%Float64Array%');\n    def('Function', '%Function%');\n    def('Int8Array', '%Int8Array%');\n    def('Int16Array', '%Int16Array%');\n    def('Int32Array', '%Int32Array%');\n    def('Map', '%Map%');\n    def('Number', '%Number%');\n    def('Object', '%Object%');\n    def('Promise', '%Promise%');\n    def('Proxy', '%Proxy%');\n    def('RangeError', '%RangeError%');\n    def('ReferenceError', '%ReferenceError%');\n    def('RegExp', '%RegExp%');\n    def('Set', '%Set%');\n    def('SharedArrayBuffer', '%SharedArrayBuffer%');\n    def('String', '%String%');\n    def('Symbol', '%Symbol%');\n    def('SyntaxError', '%SyntaxError%');\n    def('TypeError', '%TypeError%');\n    def('Uint8Array', '%Uint8Array%');\n    def('Uint8ClampedArray', '%Uint8ClampedArray%');\n    def('Uint16Array', '%Uint16Array%');\n    def('Uint32Array', '%Uint32Array%');\n    def('URIError', '%URIError%');\n    def('WeakMap', '%WeakMap%');\n    def('WeakSet', '%WeakSet%');\n\n    // http://www.ecma-international.org/ecma-262/#sec-other-properties-of-the-global-object\n    // 18.4 Other Properties of the Global Object\n    def('Atomics', '%Atomics%');\n    def('JSON', '%JSON%');\n    def('Math', '%Math%');\n    def('Reflect', '%Reflect%');\n\n    // 11. Create any implementation-defined global object properties on globalObj.\n    // 12. Return NormalCompletion(empty).\n\n    logger.debug('Finished initializing realm');\n    return realm;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getactivescriptormodule\n  // 8.3.1 GetActiveScriptOrModule ( )\n  public GetActiveScriptOrModule(): $$ESModuleOrScript {\n    const stack = this.stack;\n\n    // 1. If the execution context stack is empty, return null.\n    if (stack.length === 0) {\n      // We're throwing here for now. Not sure in which scenario this could be null that would not throw at some point.\n      throw new Error(`GetActiveScriptOrModule: stack is empty`);\n    }\n\n    // 2. Let ec be the topmost execution context on the execution context stack whose ScriptOrModule component is not null.\n    let ec: ExecutionContext;\n    let i = stack.length;\n    while (i-- > 0) {\n      ec = stack[i];\n      if (!ec.ScriptOrModule.isNull) {\n        return ec.ScriptOrModule;\n      }\n    }\n\n    // 3. If no such execution context exists, return null. Otherwise, return ec's ScriptOrModule component.\n\n    // We're throwing here for now. Not sure in which scenario this could be null that would not throw at some point.\n    throw new Error(`GetActiveScriptOrModule: stack has no execution context with an active module`);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-resolvebinding\n  // 8.3.2 ResolveBinding ( name [ , env ] )\n  public ResolveBinding(name: $String, env?: $EnvRec): $Reference | $Error {\n    // 1. If env is not present or if env is undefined, then\n    if (env === void 0) {\n      // 1. a. Set env to the running execution context's LexicalEnvironment.\n      env = this.stack.top.LexicalEnvironment;\n    }\n\n    // 2. Assert: env is a Lexical Environment.\n    // 3. If the code matching the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false.\n    const strict = this['[[Intrinsics]]'].true; // TODO: pass strict mode from source node\n\n    // 4. Return ? GetIdentifierReference(env, name, strict).\n    return this.GetIdentifierReference(env, name, strict);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getthisenvironment\n  // 8.3.3 GetThisEnvironment ( )\n  public GetThisEnvironment(): $FunctionEnvRec | $GlobalEnvRec | $ModuleEnvRec {\n    // 1. Let lex be the running execution context's LexicalEnvironment.\n    let envRec = this.stack.top.LexicalEnvironment;\n\n    // 2. Repeat,\n    while (true) {\n      // 2. a. Let envRec be lex's EnvironmentRecord.\n      // 2. b. Let exists be envRec.HasThisBinding().\n      if (envRec.HasThisBinding(this.stack.top).isTruthy) {\n        // 2. c. If exists is true, return envRec.\n        return envRec as $FunctionEnvRec | $GlobalEnvRec | $ModuleEnvRec;\n      }\n\n      // 2. d. Let outer be the value of lex's outer environment reference.\n      // 2. e. Assert: outer is not null.\n      // 2. f. Set lex to outer.\n      envRec = envRec.outer as $EnvRec;\n    }\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-resolvethisbinding\n  // 8.3.4 ResolveThisBinding ( )\n  public ResolveThisBinding(): $AnyNonEmpty  {\n    // 1. Let envRec be GetThisEnvironment().\n    const envRec = this.GetThisEnvironment();\n\n    // 2. Return ? envRec.GetThisBinding().\n    return envRec.GetThisBinding(this.stack.top);\n  }\n\n  // #region helper methods\n  public GetCurrentLexicalEnvironment(): $EnvRec {\n    return this.stack.top.LexicalEnvironment;\n  }\n  public SetCurrentLexicalEnvironment(envRec: $EnvRec) {\n    this.stack.top.LexicalEnvironment = envRec;\n  }\n  // #endregion\n\n  public dispose(this: Writable<Partial<Realm>>): void {\n    this.stack!.dispose();\n    this.stack = void 0;\n\n    this['[[Intrinsics]]']!.dispose();\n    this['[[Intrinsics]]'] = void 0;\n    this['[[GlobalObject]]']!.dispose();\n    this['[[GlobalObject]]'] = void 0;\n    this['[[GlobalEnv]]']!.dispose();\n    this['[[GlobalEnv]]'] = void 0;\n\n    this.container = void 0;\n    this.logger = void 0;\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-getidentifierreference\n  // 8.1.2.1 GetIdentifierReference ( lex , name , strict )\n  private GetIdentifierReference(\n    lex: $EnvRec | $Null,\n    name: $String,\n    strict: $Boolean,\n  ): $Reference | $Error {\n    const intrinsics = this['[[Intrinsics]]'];\n\n    // 1. If lex is the value null, then\n    if (lex.isNull) {\n      // 1. a. Return a value of type Reference whose base value component is undefined, whose referenced name component is name, and whose strict reference flag is strict.\n      return new $Reference(this, intrinsics.undefined, name, strict, intrinsics.undefined);\n    }\n\n    // 2. Let envRec be lex's EnvironmentRecord.\n    const envRec = lex;\n\n    // 3. Let exists be ? envRec.HasBinding(name).\n    const exists = envRec.HasBinding(this.stack.top, name);\n    if (exists.isAbrupt) { return exists; }\n\n    // 4. If exists is true, then\n    if (exists.isTruthy) {\n      // 4. a. Return a value of type Reference whose base value component is envRec, whose referenced name component is name, and whose strict reference flag is strict.\n      return new $Reference(this, envRec, name, strict, intrinsics.undefined);\n    }\n    // 5. Else,\n    else {\n      // 5. a. Let outer be the value of lex's outer environment reference.\n      const outer = lex.outer;\n\n      // 5. b. Return ? GetIdentifierReference(outer, name, strict).\n      return this.GetIdentifierReference(outer, name, strict);\n    }\n  }\n}\n\nexport class ExecutionContextStack extends Array<ExecutionContext> implements IDisposable {\n  public constructor(\n    public readonly logger: ILogger,\n  ) {\n    super();\n    this.logger = logger.root.scopeTo('ExecutionContextStack');\n  }\n\n  public get top(): ExecutionContext {\n    return this[this.length - 1];\n  }\n\n  public push(context: ExecutionContext): number {\n    this.logger.debug(`push(#${context.id}) - new stack size: ${this.length + 1}`);\n\n    return super.push(context);\n  }\n\n  public pop(): ExecutionContext {\n    this.logger.debug(`pop(#${this.top.id}) - new stack size: ${this.length - 1}`);\n\n    return super.pop()!;\n  }\n\n  public toString(): string {\n    let str = '';\n    for (let i = 0; i < this.length; ++i) {\n      const fn = this[i].Function;\n      if (fn === void 0 || fn.isNull) {\n        str = `${str}  at NULL\\n`;\n      } else {\n        str = `${str}  at ${fn.toString()}\\n`;\n      }\n    }\n    return str;\n  }\n\n  public dispose(this: Writable<Partial<ExecutionContextStack>>): void {\n    this.forEach!(x => { x.dispose(); });\n    this.length = 0;\n    this.logger = void 0;\n  }\n}\n\nexport class ExecutionContext<TLex extends $EnvRec = $EnvRec, TVar extends ($ModuleEnvRec | $FunctionEnvRec | $DeclarativeEnvRec | $GlobalEnvRec) = ($ModuleEnvRec | $FunctionEnvRec | $DeclarativeEnvRec | $GlobalEnvRec)> implements IDisposable {\n  public readonly id: number;\n\n  public Function!: $Function | $Null;\n  public ScriptOrModule!: $$ESModuleOrScript | $Null;\n  public LexicalEnvironment!: TLex;\n  public VariableEnvironment!: TVar;\n  public Generator: $GeneratorInstance | $AsyncGeneratorInstance | undefined = void 0;\n  public onResume: ((value: $AnyNonEmpty) => $AnyNonEmpty) | undefined = void 0;\n\n  public suspended: boolean = false;\n\n  public readonly logger: ILogger;\n\n  private activityTimestamp: number = Date.now();\n  private activeTime: number = 0;\n  private timeoutCheck: number = 0;\n\n  public constructor(\n    public readonly Realm: Realm,\n  ) {\n    this.id = ++Realm.contextId;\n    this.logger = Realm['logger'].root.scopeTo(`ExecutionContext #${this.id}`);\n    this.logger.debug(`constructor()`);\n  }\n\n  public checkTimeout(): void {\n    if (!this.suspended) {\n      // Reduce the number of calls to the relative expensive Date.now()\n      if (++this.timeoutCheck === 100) {\n        this.timeoutCheck = 0;\n        this.activeTime += (Date.now() - this.activityTimestamp);\n        this.activityTimestamp = Date.now();\n        if (this.activeTime >= this.Realm.timeout) {\n          throw new Error(`Operation timed out`);\n        }\n      }\n    }\n  }\n\n  public resume(): void {\n    this.logger.debug(`resume()`);\n    if (!this.suspended) {\n      throw new Error('ExecutionContext is not suspended');\n    }\n    if (this.Realm.stack.top !== this) {\n      throw new Error('ExecutionContext is not at the top of the stack');\n    }\n    this.suspended = false;\n    this.activityTimestamp = Date.now();\n  }\n\n  public suspend(): void {\n    this.logger.debug(`suspend()`);\n    if (this.suspended) {\n      throw new Error('ExecutionContext is already suspended');\n    }\n    if (this.Realm.stack.top !== this) {\n      throw new Error('ExecutionContext is not at the top of the stack');\n    }\n    this.suspended = true;\n\n    // Timeout on a per-execution context basis, and only count the time that this context was active.\n    // This reduces false positives while still keeping potential infinite loops in deeply nested stacks (with constant popping/pushing) in check.\n    this.activeTime += (Date.now() - this.activityTimestamp);\n  }\n\n  public makeCopy(): this {\n    const ctx = new ExecutionContext(this.Realm);\n    ctx.Function = this.Function;\n    ctx.ScriptOrModule = this.ScriptOrModule;\n    ctx.LexicalEnvironment = this.LexicalEnvironment;\n    ctx.VariableEnvironment = this.VariableEnvironment;\n    ctx.Generator = this.Generator;\n    ctx.onResume = this.onResume;\n    ctx.suspended = this.suspended;\n    return ctx as this;\n  }\n\n  public dispose(this: Writable<Partial<ExecutionContext>>): void {\n    this.Function = void 0;\n\n    (this.ScriptOrModule as IDisposable).dispose();\n    this.ScriptOrModule = void 0;\n    (this.LexicalEnvironment as IDisposable).dispose();\n    this.LexicalEnvironment = void 0;\n    (this.VariableEnvironment as IDisposable).dispose();\n    this.VariableEnvironment = void 0;\n\n    this.Generator = void 0;\n    this.Realm = void 0;\n    this.logger = void 0;\n  }\n}\n","import {\n  JobQueue,\n  Job,\n} from './job.js';\nimport {\n  DI,\n  IContainer,\n  ILogger,\n  IDisposable,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  Realm,\n  ExecutionContext,\n} from './realm.js';\nimport {\n  CompletionType,\n  $Any,\n} from './types/_shared.js';\nimport {\n  $Empty,\n} from './types/empty.js';\nimport {\n  $ESModule,\n  $$ESModuleOrScript,\n  $ESScript,\n} from './ast/modules.js';\n\nexport const ISourceFileProvider = DI.createInterface<ISourceFileProvider>('ISourceFileProvider');\nexport interface ISourceFileProvider {\n  GetSourceFiles(ctx: ExecutionContext): Promise<readonly $$ESModuleOrScript[]>;\n}\n\n// http://www.ecma-international.org/ecma-262/#sec-agents\nexport class Agent implements IDisposable {\n  public readonly ScriptJobs: JobQueue;\n  public readonly PromiseJobs: JobQueue;\n\n  public constructor(\n    public readonly logger: ILogger,\n  ) {\n    this.ScriptJobs = new JobQueue(logger, 'Script');\n    this.PromiseJobs = new JobQueue(logger, 'Promise');\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-runjobs\n  // 8.6 RunJobs ( )\n  public async RunJobs(container: IContainer): Promise<$Any> {\n    // 1. Perform ? InitializeHostDefinedRealm().\n    const realm = Realm.Create(container, this.PromiseJobs);\n    const intrinsics = realm['[[Intrinsics]]'];\n    const stack = realm.stack;\n    // We always have 1 synthetic root context which should not be considered to be a part of the stack.\n    // It's exclusively used for initializing intrinsics, to conform to the method signatures.\n    const rootCtx = stack.top;\n\n    // 2. In an implementation-dependent manner, obtain the ECMAScript source texts (see clause 10) and any associated host-defined values for zero or more ECMAScript scripts and/or ECMAScript modules. For each such sourceText and hostDefined, do\n    const sfProvider = container.get(ISourceFileProvider);\n    const files = await sfProvider.GetSourceFiles(rootCtx);\n    for (const file of files) {\n      // 2. a. If sourceText is the source code of a script, then\n      if (file.isScript) {\n        // 2. a. i. Perform EnqueueJob(\"ScriptJobs\", ScriptEvaluationJob, « sourceText, hostDefined »).\n        this.ScriptJobs.EnqueueJob(rootCtx, new ScriptEvaluationJob(realm, file));\n      }\n      // 2. b. Else sourceText is the source code of a module,\n      else {\n        // 2. b. i. Perform EnqueueJob(\"ScriptJobs\", TopLevelModuleEvaluationJob, « sourceText, hostDefined »).\n        this.ScriptJobs.EnqueueJob(rootCtx, new TopLevelModuleEvaluationJob(realm, file));\n      }\n    }\n\n    const ctx = rootCtx;\n    let lastFile: $$ESModuleOrScript | null = null;\n\n    // 3. Repeat,\n    while (true) {\n      // 3. a. Suspend the running execution context and remove it from the execution context stack.\n      if (ctx !== rootCtx) {\n        ctx.suspend();\n        stack.pop();\n      }\n\n      let nextPending: Job;\n\n      // 3. b. Assert: The execution context stack is now empty.\n      // 3. c. Let nextQueue be a non-empty Job Queue chosen in an implementation-defined manner. If all Job Queues are empty, the result is implementation-defined.\n      if (this.ScriptJobs.isEmpty) {\n        if (this.PromiseJobs.isEmpty) {\n          this.logger.debug(`Finished successfully`);\n          return new $Empty(realm, CompletionType.normal, intrinsics.empty, lastFile);\n        } else {\n          // 3. d. Let nextPending be the PendingJob record at the front of nextQueue. Remove that record from nextQueue.\n          nextPending = this.PromiseJobs.queue.shift()!;\n        }\n      } else {\n        // 3. d. Let nextPending be the PendingJob record at the front of nextQueue. Remove that record from nextQueue.\n        nextPending = this.ScriptJobs.queue.shift()!;\n      }\n\n      // 3. e. Let newContext be a new execution context.\n      const newContext = new ExecutionContext(nextPending['[[Realm]]']);\n\n      // 3. f. Set newContext's Function to null.\n      newContext.Function = intrinsics.null;\n\n      // 3. g. Set newContext's Realm to nextPending.[[Realm]].\n      // 3. h. Set newContext's ScriptOrModule to nextPending.[[ScriptOrModule]].\n      lastFile = newContext.ScriptOrModule = nextPending['[[ScriptOrModule]]'];\n\n      // 3. i. Push newContext onto the execution context stack; newContext is now the running execution context.\n      stack.push(newContext);\n\n      // 3. j. Perform any implementation or host environment defined job initialization using nextPending.\n      // 3. k. Let result be the result of performing the abstract operation named by nextPending.[[Job]] using the elements of nextPending.[[Arguments]] as its arguments.\n      const result = nextPending.Run(newContext);\n\n      // 3. l. If result is an abrupt completion, perform HostReportErrors(« result.[[Value]] »).\n      if (result.isAbrupt) {\n        this.logger.debug(`Job completed with errors`);\n        return result;\n      }\n    }\n  }\n\n  public dispose(this: Writable<Partial<Agent>>): void {\n    this.PromiseJobs!.dispose();\n    this.ScriptJobs!.dispose();\n    this.PromiseJobs = void 0;\n    this.ScriptJobs = void 0;\n    this.logger = void 0;\n  }\n}\n\nexport class TopLevelModuleEvaluationJob extends Job<$ESModule> {\n  public constructor(\n    realm: Realm,\n    mos: $ESModule,\n  ) {\n    super(realm.logger.scopeTo('TopLevelModuleEvaluationJob'), realm, mos);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-toplevelmoduleevaluationjob\n  // 15.2.1.20 Runtime Semantics: TopLevelModuleEvaluationJob ( sourceText , hostDefined )\n  public Run(ctx: ExecutionContext): $Any {\n    this.logger.debug(`Run(#${ctx.id})`);\n\n    const m = this['[[ScriptOrModule]]'];\n\n    // 1. Assert: sourceText is an ECMAScript source text (see clause 10).\n    // 2. Let realm be the current Realm Record.\n    // 3. Let m be ParseModule(sourceText, realm, hostDefined).\n    // 4. If m is a List of errors, then\n      // 4. a. Perform HostReportErrors(m).\n      // 4. b. Return NormalCompletion(undefined).\n\n    // 5. Perform ? m.Instantiate().\n    const result = m.Instantiate(ctx);\n    if (result.isAbrupt) {\n      return result;\n    }\n\n    // 6. Assert: All dependencies of m have been transitively resolved and m is ready for evaluation.\n    // 7. Return ? m.Evaluate().\n    return m.EvaluateModule(ctx);\n  }\n}\n\nexport class ScriptEvaluationJob extends Job<$ESScript> {\n  public constructor(\n    realm: Realm,\n    mos: $ESScript,\n  ) {\n    super(realm.logger.scopeTo('ScriptEvaluationJob'), realm, mos);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-scriptevaluationjob\n  // 15.1.12 Runtime Semantics: ScriptEvaluationJob ( sourceText , hostDefined )\n  public Run(ctx: ExecutionContext): $Any {\n    this.logger.debug(`Run(#${ctx.id})`);\n\n    const m = this['[[ScriptOrModule]]'];\n\n    // 1. Assert: sourceText is an ECMAScript source text (see clause 10).\n    // 2. Let realm be the current Realm Record.\n\n    // 3. Let s be ParseScript(sourceText, realm, hostDefined).\n    // 4. If s is a List of errors, then\n      // 4. a. Perform HostReportErrors(s).\n      // 4. b. Return NormalCompletion(undefined).\n    // 5. Return ? ScriptEvaluation(s).\n    return m.EvaluateScript(ctx);\n  }\n}\n","import {\n  ILogger,\n  emptyArray,\n  IContainer,\n} from '@aurelia/kernel';\nimport {\n  Char,\n} from '@aurelia/runtime';\nimport {\n  IFileSystem,\n  IFile,\n} from './interfaces.js';\nimport {\n  normalizePath,\n  joinPath,\n} from './path-utils.js';\nimport {\n  basename,\n  dirname,\n} from 'path';\nimport {\n  Package,\n} from './package-types.js';\n\nfunction countSlashes(path: string): number {\n  let count = 0;\n  const len = path.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (path.charCodeAt(i) === Char.Slash) {\n      ++count;\n    }\n  }\n\n  return count;\n}\n\nfunction createFileComparer(preferredNames: readonly string[]) {\n  const len = preferredNames.length;\n  let name: string = '';\n\n  return function compareFiles(a: IFile, b: IFile): number {\n    const aName = basename(a.path);\n    const bName = basename(b.path);\n\n    const aDepth = countSlashes(a.path);\n    const bDepth = countSlashes(b.path);\n\n    if (aDepth === bDepth) {\n      /*\n       * If both files are in the same folder, use \"absolute\" priorities between the convention-based\n       * names and fall back to alphabetic sort.\n       * Examples:\n       *\n       * - a = src/foo.js\n       * - b = src/index.js <-- this one wins (the one with the convention wins)\n       *\n       * - a = src/foo.js\n       * - b = src/startup.js <-- this one wins (the one with the convention wins)\n       *\n       * - a = src/startup.js\n       * - b = src/index.js <-- this one wins (the one with the higher priority convention wins)\n       *\n       * - a = src/foo.js\n       * - b = src/bar.js <-- this one wins (none match a convention, so sort alphabetically)\n       */\n      for (let i = 0; i < len; ++i) {\n        name = preferredNames[i];\n        if (aName === name) {\n          return -1;\n        }\n\n        if (bName === name) {\n          return 1;\n        }\n      }\n\n      return aName < bName ? -1 : aName > bName ? 1 : 0;\n    }\n\n    if (aName === bName) {\n      /*\n      * The directory depth is different but the names are the same, so sort according to depth.\n      * Examples:\n      *\n      * - a = src/foo.js <-- this one wins (the higher level path wins, even if it alphabetically comes last)\n      * - b = src/bar/foo.js\n      *\n      * - a = src/foobarbazqux.js <-- this one wins (the higher level path wins, path length or other factors have no effect)\n      * - b = src/a/b.js\n      */\n      return aDepth - bDepth;\n    }\n\n    /*\n     * Depth is different and so are the names. Here, we group the different conventions together\n     * so that they each have the same effective priority.\n     * Examples:\n     *\n     * - a = src/foo.js\n     * - b = src/bar/index.js <-- this one wins (the one with the convention wins, even if it is deeper level)\n     *\n     * - a = src/index.js <-- this one wins (both match same convention, so highest level wins)\n     * - b = src/bar/index.js\n     *\n     * - a = src/startup.js <-- this one wins (both match any convention, so highest level wins)\n     * - b = src/bar/index.js\n     *\n     * - a = src/foo.js <-- this one wins (none match a convention, so highest level wins)\n     * - b = src/bar/baz.js\n     */\n    if (preferredNames.includes(aName)) {\n      if (preferredNames.includes(bName)) {\n        return aDepth - bDepth;\n      }\n\n      return -1;\n    }\n\n    if (preferredNames.includes(bName)) {\n      return 1;\n    }\n\n    return aDepth - bDepth;\n  };\n}\n\n// Node conventions\nconst compareExternalModuleEntryFile = createFileComparer([\n  'index.js',\n  'app.js',\n  'server.js',\n]);\n\n// Aurelia conventions (TODO: make this configurable)\nconst compareApplicationEntryFile = createFileComparer([\n  'index.ts',\n  'index.js',\n  'startup.ts',\n  'startup.js',\n  'main.ts',\n  'main.js',\n]);\n\nfunction determineEntryFileByConvention(\n  files: readonly IFile[],\n  isPrimaryEntryPoint: boolean,\n): IFile {\n  if (isPrimaryEntryPoint) {\n    return files.slice().sort(compareApplicationEntryFile)[0];\n  }\n\n  return files.slice().sort(compareExternalModuleEntryFile)[0];\n}\n\nexport class NPMPackageLoader {\n  private readonly pkgCache: Map<string, NPMPackage> = new Map();\n  private readonly pkgPromiseCache: Map<string, Promise<NPMPackage>> = new Map();\n\n  private readonly pkgResolveCache: Map<string, string> = new Map();\n  private readonly pkgResolvePromiseCache: Map<string, Promise<string>> = new Map();\n\n  public static get inject() { return [IContainer, ILogger, IFileSystem]; }\n\n  public constructor(\n    public readonly container: IContainer,\n    public readonly logger: ILogger,\n    public readonly fs: IFileSystem,\n  ) {\n    this.logger = logger.root.scopeTo('NPMPackageLoader');\n  }\n\n  public async loadEntryPackage(\n    projectDir: string,\n  ): Promise<NPMPackage> {\n    const start = Date.now();\n\n    this.logger.info(`load()`);\n\n    projectDir = normalizePath(projectDir);\n\n    const entryPkg = await this.loadPackageCore(projectDir, null);\n    await entryPkg.loadDependencies();\n\n    this.pkgPromiseCache.clear();\n\n    const end = Date.now();\n\n    const packages = Array.from(this.pkgCache.values());\n    const pkgCount = packages.length;\n    const fileCount = packages.reduce((count, pkg) => count + pkg.files.length, 0);\n\n    this.logger.info(`Discovered ${fileCount} files across ${pkgCount} packages in ${Math.round(end - start)}ms`);\n    for (const pkg of packages) {\n      this.logger.info(`- ${pkg.pkgName}: ${pkg.files.length} files`);\n    }\n\n    return entryPkg;\n  }\n\n  public getCachedPackage(refName: string): NPMPackage {\n    const pkg = this.pkgCache.get(refName);\n    if (pkg === void 0) {\n      throw new Error(`Cannot resolve package ${refName}`);\n    }\n    return pkg;\n  }\n\n  /** @internal */\n  public async loadPackage(issuer: NPMPackageDependency): Promise<NPMPackage> {\n    const pkgPromiseCache = this.pkgPromiseCache;\n\n    let pkgPromise = pkgPromiseCache.get(issuer.refName);\n    if (pkgPromise === void 0) {\n      pkgPromise = this.loadPackageCore(null, issuer);\n      // Multiple deps may request the same package to load before one of them finished\n      // so we store the promise to ensure the action is only invoked once.\n      pkgPromiseCache.set(issuer.refName, pkgPromise);\n    }\n\n    return pkgPromise;\n  }\n\n  private async loadPackageCore(dir: null, issuer: NPMPackageDependency): Promise<NPMPackage>;\n  private async loadPackageCore(dir: string, issuer: null): Promise<NPMPackage>;\n  private async loadPackageCore(dir: string | null, issuer: NPMPackageDependency | null): Promise<NPMPackage> {\n    this.logger.info(`loadPackageCore(\\n  dir: ${dir},\\n  issuer: ${issuer === null ? 'null' : issuer.issuer.pkgName}\\n)`);\n\n    const fs = this.fs;\n    const pkgCache = this.pkgCache;\n\n    const refName = dir === null ? issuer!.refName : dir;\n    let pkg = pkgCache.get(refName);\n    if (pkg === void 0) {\n      if (dir === null) {\n        dir = await this.resolvePackagePath(issuer!);\n      }\n      const pkgPath = joinPath(dir, 'package.json');\n      const files = await fs.getFiles(dir);\n\n      const pkgJsonFile = files.find(x => x.path === pkgPath);\n      if (pkgJsonFile === void 0) {\n        throw new Error(`No package.json found at \"${pkgPath}\"`);\n      }\n\n      const pkgJsonFileContent = await pkgJsonFile.getContent();\n      pkg = new NPMPackage(this, files, issuer, pkgJsonFile, dir, pkgJsonFileContent);\n      pkgCache.set(refName, pkg);\n    }\n\n    return pkg;\n  }\n\n  private async resolvePackagePath(dep: NPMPackageDependency): Promise<string> {\n    const pkgResolvePromiseCache = this.pkgResolvePromiseCache;\n    const refName = dep.refName;\n\n    let resolvePromise = pkgResolvePromiseCache.get(refName);\n    if (resolvePromise === void 0) {\n      resolvePromise = this.resolvePackagePathCore(dep);\n\n      // Multiple deps may request the same refName to be resolved before one of them finished\n      // so we store the promise to ensure the action is only invoked once.\n      pkgResolvePromiseCache.set(refName, resolvePromise);\n    }\n\n    return resolvePromise;\n  }\n\n  private async resolvePackagePathCore(dep: NPMPackageDependency): Promise<string> {\n    const fs = this.fs;\n    const pkgResolveCache = this.pkgResolveCache;\n    const refName = dep.refName;\n\n    let resolvedPath = pkgResolveCache.get(refName);\n    if (resolvedPath === void 0) {\n      let dir = dep.issuer.dir;\n      while (true) {\n        resolvedPath = joinPath(dir, 'node_modules', refName, 'package.json');\n        // eslint-disable-next-line no-await-in-loop\n        if (await fs.isReadable(resolvedPath)) {\n          break;\n        }\n\n        const parent = normalizePath(dirname(dir));\n        if (parent === dir) {\n          throw new Error(`Unable to resolve npm dependency \"${refName}\"`);\n        }\n\n        dir = parent;\n      }\n\n      const realPath = normalizePath(await fs.getRealPath(resolvedPath));\n      if (realPath === resolvedPath) {\n        this.logger.debug(`resolved \"${refName}\" directly to \"${dirname(realPath)}\"`);\n      } else {\n        this.logger.debug(`resolved \"${refName}\" to \"${dirname(realPath)}\" via symlink \"${dirname(resolvedPath)}\"`);\n\n      }\n      resolvedPath = normalizePath(dirname(realPath));\n      pkgResolveCache.set(refName, resolvedPath);\n    }\n\n    return resolvedPath;\n  }\n}\n\nexport class NPMPackage {\n  public readonly pkgJson: Package;\n  public readonly pkgName: string;\n  public readonly isAureliaPkg: boolean;\n  public readonly isEntryPoint: boolean;\n  public readonly entryFile: IFile;\n  public readonly deps: readonly NPMPackageDependency[];\n\n  public readonly container: IContainer;\n\n  public constructor(\n    public readonly loader: NPMPackageLoader,\n    public readonly files: readonly IFile[],\n    public readonly issuer: NPMPackageDependency | null,\n    public readonly pkgJsonFile: IFile,\n    public readonly dir: string,\n    pkgJsonFileContent: string,\n  ) {\n    this.container = loader.container;\n\n    const pkgJson = this.pkgJson = JSON.parse(pkgJsonFileContent) as Package;\n    const pkgName = this.pkgName = typeof pkgJson.name === 'string' ? pkgJson.name : dir.slice(dir.lastIndexOf('/') + 1);\n    const pkgModuleOrMain = typeof pkgJson.module === 'string' ? pkgJson.module : pkgJson.main;\n    const isAureliaPkg = this.isAureliaPkg = pkgName.startsWith('@aurelia');\n    const isEntryPoint = this.isEntryPoint = issuer === null;\n\n    let entryFilePath = isAureliaPkg ? 'src/index.ts' : pkgModuleOrMain;\n    let entryFile: IFile | undefined;\n    if (entryFilePath === void 0) {\n      entryFile = determineEntryFileByConvention(files, isEntryPoint);\n    } else {\n      if (entryFilePath.startsWith('.')) {\n        entryFilePath = entryFilePath.slice(1);\n      }\n      entryFile = files.find(x => x.path.endsWith(entryFilePath!));\n      if (entryFile === void 0) {\n        const withJs = `${entryFilePath}.js`;\n        entryFile = files.find(x => x.path.endsWith(withJs));\n        if (entryFile === void 0) {\n          const withIndexJs = joinPath(entryFilePath, 'index.js');\n          entryFile = files.find(x => x.path.endsWith(withIndexJs));\n        }\n      }\n    }\n\n    if (entryFile === void 0) {\n      throw new Error(`No entry file could be located for package ${pkgName}`);\n    }\n\n    this.entryFile = entryFile;\n\n    if (pkgJson.dependencies instanceof Object) {\n      this.deps = Object.keys(pkgJson.dependencies).map(name => new NPMPackageDependency(this, name));\n    } else {\n      this.deps = emptyArray;\n    }\n  }\n\n  /** @internal */\n  public async loadDependencies(): Promise<void> {\n    await Promise.all(this.deps.map(loadDependency));\n  }\n}\n\nasync function loadDependency(dep: NPMPackageDependency): Promise<void> {\n  await dep.load();\n  await dep.pkg.loadDependencies();\n}\n\nexport class NPMPackageDependency {\n  public get pkg(): NPMPackage {\n    const pkg = this._pkg;\n    if (pkg === void 0) {\n      throw new Error(`Package ${this.refName} is not yet loaded`);\n    }\n    return pkg;\n  }\n\n  private _pkg: NPMPackage | undefined = void 0;\n  private loadPromise: Promise<void> | undefined = void 0;\n\n  public constructor(\n    public readonly issuer: NPMPackage,\n    public readonly refName: string,\n  ) {}\n\n  /** @internal */\n  public async load(): Promise<void> {\n    if (this._pkg === void 0) {\n      if (this.loadPromise === void 0) {\n        // Multiple deps may request the same package to load before one of them finished\n        // so we store the promise to ensure the action is only invoked once.\n        this.loadPromise = this.loadCore();\n      }\n\n      return this.loadPromise;\n    }\n  }\n\n  private async loadCore(): Promise<void> {\n    this._pkg = await this.issuer.loader.loadPackage(this);\n\n    this.loadPromise = void 0;\n\n    // Freeze it as an extra measure to prove that we're not getting race conditions\n    Object.freeze(this);\n  }\n}\n","import {\n  ILogger,\n  IContainer,\n} from '@aurelia/kernel';\nimport {\n  joinPath,\n  resolvePath,\n} from './path-utils.js';\nimport {\n  IFile,\n  $CompilerOptions,\n} from './interfaces.js';\n\nconst lookup: WeakMap<$CompilerOptions, PatternMatcher | null> = new WeakMap();\n\nexport class PatternMatcher {\n  public readonly basePath: string;\n  public readonly sources: readonly PatternSource[];\n  public readonly rootDir: string;\n\n  private constructor(\n    private readonly logger: ILogger,\n    public readonly compilerOptions: $CompilerOptions,\n  ) {\n    this.logger = logger.scopeTo(this.constructor.name);\n\n    this.rootDir = resolvePath(compilerOptions.__dirname);\n    this.basePath = joinPath(this.rootDir, compilerOptions.baseUrl!);\n    this.sources = Object.keys(compilerOptions.paths!).map(x => new PatternSource(this.logger, this, x));\n  }\n\n  public findMatch(files: readonly IFile[], specifier: string): IFile {\n    const sources = this.sources;\n    const len = sources.length;\n    let match: IFile | null;\n\n    for (let i = 0; i < len; ++i) {\n      match = sources[i].findMatch(files, specifier);\n      if (match === null) {\n        this.logger.trace(`Source pattern \"${sources[i].pattern}\" (path \"${sources[i].patternPath}\") is NOT a match for specifier \"${specifier}\"`);\n      } else {\n        this.logger.debug(`Source pattern \"${sources[i].pattern}\" is a match for specifier \"${specifier}\"`);\n        return match;\n      }\n    }\n\n    throw new Error(`Cannot resolve \"${specifier}:`);\n  }\n\n  public static getOrCreate(\n    compilerOptions: $CompilerOptions,\n    container: IContainer,\n  ): PatternMatcher | null {\n    let matcher = lookup.get(compilerOptions);\n    if (matcher === void 0) {\n      if (compilerOptions.baseUrl !== void 0 && compilerOptions.paths !== void 0) {\n        const logger = container.get(ILogger);\n        matcher = new PatternMatcher(logger, compilerOptions);\n      } else {\n        matcher = null;\n      }\n\n      lookup.set(compilerOptions, matcher);\n    }\n\n    return matcher;\n  }\n}\n\nclass PatternSource {\n  public readonly patternPath: string;\n  public readonly hasWildcard: boolean;\n  public readonly isWildcard: boolean;\n  public readonly targets: readonly PatternTarget[];\n\n  public constructor(\n    private readonly logger: ILogger,\n    public readonly matcher: PatternMatcher,\n    public readonly pattern: string,\n  ) {\n    this.logger = logger.scopeTo(this.constructor.name);\n\n    if (pattern.endsWith('*')) {\n      this.hasWildcard = true;\n      this.patternPath = pattern.slice(0, -1);\n    } else {\n      this.hasWildcard = false;\n      this.patternPath = pattern;\n    }\n\n    this.isWildcard = pattern === '*';\n\n    this.targets = matcher.compilerOptions.paths![pattern].map(x => new PatternTarget(this.logger, this, x));\n  }\n\n  public findMatch(files: readonly IFile[], specifier: string): IFile | null {\n    if (this.isWildcard) {\n      return this.findMatchCore(files, specifier);\n    }\n\n    if (this.hasWildcard) {\n      if (specifier.startsWith(this.patternPath)) {\n        return this.findMatchCore(files, specifier.replace(this.patternPath, ''));\n      }\n\n      return null;\n    }\n\n    if (this.patternPath === specifier) {\n      return this.findMatchCore(files, specifier);\n    }\n\n    return null;\n  }\n\n  private findMatchCore(files: readonly IFile[], specifier: string): IFile | null {\n    const targets = this.targets;\n    const len = targets.length;\n    let target: PatternTarget;\n    let match: IFile | null = null;\n\n    for (let i = 0; i < len; ++i) {\n      target = targets[i];\n      match = target.findMatch(files, specifier);\n      if (match !== null) {\n        return match;\n      }\n    }\n\n    return null;\n  }\n}\n\nclass PatternTarget {\n  public readonly patternPath: string;\n  public readonly hasWildcard: boolean;\n\n  public constructor(\n    private readonly logger: ILogger,\n    public readonly source: PatternSource,\n    public readonly pattern: string,\n  ) {\n    this.logger = logger.scopeTo(this.constructor.name);\n\n    if (pattern.endsWith('*')) {\n      this.hasWildcard = true;\n      this.patternPath = joinPath(source.matcher.basePath, pattern.slice(0, -1));\n    } else {\n      this.hasWildcard = false;\n      this.patternPath = joinPath(source.matcher.basePath, pattern);\n    }\n  }\n\n  public findMatch(files: readonly IFile[], specifier: string): IFile | null {\n    const targetPath = this.hasWildcard ? joinPath(this.patternPath, specifier) : this.patternPath;\n    const len = files.length;\n    let file: IFile;\n\n    for (let i = 0; i < len; ++i) {\n      file = files[i];\n      if (file.shortPath === targetPath || file.path === targetPath) {\n        return file;\n      }\n    }\n\n    return null;\n  }\n}\n","import {\n  IContainer,\n  ILogger,\n  Writable,\n  Registration,\n  IDisposable,\n} from '@aurelia/kernel';\n\nimport {\n  basename,\n  dirname,\n} from 'path';\nimport {\n  createSourceFile,\n  ScriptTarget,\n} from 'typescript';\nimport {\n  JSDOM,\n} from 'jsdom';\n\nimport {\n  IFileSystem,\n  IFile,\n  FileKind,\n  $CompilerOptions,\n} from './system/interfaces.js';\nimport {\n  normalizePath,\n  isRelativeModulePath,\n  joinPath,\n  resolvePath,\n} from './system/path-utils.js';\nimport {\n  NPMPackage,\n  NPMPackageLoader,\n} from './system/npm-package-loader.js';\nimport {\n  File,\n} from './system/file-system.js';\n\nimport {\n  IModule,\n  DeferredModule,\n  ExecutionContext,\n} from './vm/realm.js';\nimport {\n  $ESModule,\n  $DocumentFragment,\n  $ESScript,\n  $$ESModuleOrScript,\n} from './vm/ast/modules.js';\nimport {\n  $String,\n} from './vm/types/string.js';\nimport {\n  PatternMatcher,\n} from './system/pattern-matcher.js';\nimport {\n  ISourceFileProvider,\n  Agent,\n} from './vm/agent.js';\nimport {\n  $Any,\n} from './vm/types/_shared.js';\nimport {\n  $Error,\n} from './vm/types/error.js';\n\nfunction comparePathLength(a: { path: { length: number } }, b: { path: { length: number } }): number {\n  return a.path.length - b.path.length;\n}\n\nexport interface IModuleResolver {\n  ResolveImportedModule(\n    ctx: ExecutionContext,\n    referencingModule: $ESModule,\n    $specifier: $String,\n  ): IModule | $Error;\n}\n\nexport interface IServiceHost extends IModuleResolver, IDisposable {\n  executeEntryFile(dir: string): Promise<$Any>;\n  executeSpecificFile(file: IFile, mode: 'script' | 'module'): Promise<$Any>;\n  executeProvider(provider: ISourceFileProvider): Promise<$Any>;\n  loadEntryFile(ctx: ExecutionContext, dir: string): Promise<$ESModule>;\n  loadSpecificFile(ctx: ExecutionContext, file: IFile, mode: 'script' | 'module'): Promise<$$ESModuleOrScript>;\n}\n\nexport class SpecificSourceFileProvider implements ISourceFileProvider {\n  public constructor(\n    private readonly host: ServiceHost,\n    private readonly file: IFile,\n    private readonly mode: 'script' | 'module',\n  ) {}\n\n  public async GetSourceFiles(ctx: ExecutionContext): Promise<readonly $$ESModuleOrScript[]> {\n    return [\n      await this.host.loadSpecificFile(ctx, this.file, this.mode),\n    ];\n  }\n}\n\nexport class EntrySourceFileProvider implements ISourceFileProvider {\n  public constructor(\n    private readonly host: ServiceHost,\n    private readonly dir: string,\n  ) {}\n\n  public async GetSourceFiles(ctx: ExecutionContext): Promise<readonly $ESModule[]> {\n    return [\n      await this.host.loadEntryFile(ctx, this.dir),\n    ];\n  }\n}\n\nexport class ServiceHost implements IServiceHost {\n  private _jsdom: JSDOM | null = null;\n  public get jsdom(): JSDOM {\n    let jsdom = this._jsdom;\n    if (jsdom === null) {\n      jsdom = this._jsdom = new JSDOM('');\n    }\n    return jsdom;\n  }\n  public readonly agent: Agent;\n\n  public readonly compilerOptionsCache: Map<string, $CompilerOptions> = new Map();\n  public readonly moduleCache: Map<string, IModule> = new Map();\n  public readonly scriptCache: Map<string, $ESScript> = new Map();\n\n  public constructor(\n    public readonly container: IContainer,\n    public readonly logger: ILogger = container.get(ILogger),\n    public readonly fs: IFileSystem = container.get(IFileSystem),\n  ) {\n    this.agent = new Agent(logger);\n  }\n\n  public async loadEntryFile(ctx: ExecutionContext, dir: string): Promise<$ESModule> {\n    this.logger.info(`Loading entry file at: ${dir}`);\n\n    const pkg = await this.loadEntryPackage(dir);\n\n    this.logger.info(`Finished loading entry file`);\n\n    return this.getESModule(ctx, pkg.entryFile, pkg);\n  }\n\n  public async loadSpecificFile(ctx: ExecutionContext, file: IFile, mode: 'script' | 'module'): Promise<$$ESModuleOrScript> {\n    if (mode === 'module') {\n      return this.getESModule(ctx, file, null);\n    } else {\n      return this.getESScript(ctx, file);\n    }\n  }\n\n  public executeEntryFile(dir: string): Promise<$Any> {\n    const container = this.container.createChild();\n    container.register(Registration.instance(ISourceFileProvider, new EntrySourceFileProvider(this, dir)));\n\n    return this.agent.RunJobs(container);\n  }\n\n  public executeSpecificFile(file: IFile, mode: 'script' | 'module'): Promise<$Any> {\n    const container = this.container.createChild();\n    container.register(Registration.instance(ISourceFileProvider, new SpecificSourceFileProvider(this, file, mode)));\n\n    return this.agent.RunJobs(container);\n  }\n\n  public executeProvider(provider: ISourceFileProvider): Promise<$Any> {\n    const container = this.container.createChild();\n    container.register(Registration.instance(ISourceFileProvider, provider));\n\n    return this.agent.RunJobs(container);\n  }\n\n  // http://www.ecma-international.org/ecma-262/#sec-hostresolveimportedmodule\n  public ResolveImportedModule(\n    ctx: ExecutionContext,\n    referencingModule: $ESModule,\n    $specifier: $String,\n  ): IModule | $Error {\n    const specifier = normalizePath($specifier['[[Value]]']);\n    const isRelative = isRelativeModulePath(specifier);\n    const pkg = referencingModule.pkg;\n\n    // Single file scenario; lazily resolve the import\n    if (pkg === null) {\n      if (!isRelative) {\n        throw new Error(`Absolute module resolution not yet implemented for single-file scenario.`);\n      }\n      // TODO: this is currently just for the 262 test suite but we need to resolve the other stuff properly too for end users that don't want to use the package eager load mechanism\n      const dir = referencingModule.$file.dir;\n      const ext = '.js';\n      const name = basename(specifier);\n      const shortName = name.slice(0, -3);\n      const path = joinPath(dir, name);\n      const file = new File(this.fs, path, dir, specifier, name, shortName, ext);\n      return this.getESModule(ctx, file, null);\n    }\n\n    if (isRelative) {\n      this.logger.debug(`[ResolveImport] resolving internal relative module: '${$specifier['[[Value]]']}' for ${referencingModule.$file.name}`);\n\n      const filePath = resolvePath(dirname(referencingModule.$file.path), specifier);\n      const files = pkg.files.filter(x => x.shortPath === filePath || x.path === filePath).sort(comparePathLength);\n      if (files.length === 0) {\n        throw new Error(`Cannot find file \"${filePath}\" (imported as \"${specifier}\" by \"${referencingModule.$file.name}\")`);\n      }\n\n      let file = files.find(x => x.kind === FileKind.Script);\n      if (file === void 0) {\n        // TODO: make this less messy/patchy\n        file = files.find(x => x.kind === FileKind.Markup);\n        if (file === void 0) {\n          file = files[0];\n          let deferred = this.moduleCache.get(file.path);\n          if (deferred === void 0) {\n            deferred = new DeferredModule(file, ctx.Realm);\n            this.moduleCache.set(file.path, deferred);\n          }\n\n          return deferred;\n        }\n\n        return this.getHTMLModule(ctx, file, pkg);\n      }\n\n      return this.getESModule(ctx, file, pkg);\n    } else {\n      const pkgDep = pkg.deps.find(n => n.refName === specifier || specifier.startsWith(`${n.refName}/`));\n      if (pkgDep === void 0) {\n        this.logger.debug(`[ResolveImport] resolving internal absolute module: '${$specifier['[[Value]]']}' for ${referencingModule.$file.name}`);\n\n        const matcher = PatternMatcher.getOrCreate(referencingModule.compilerOptions, this.container);\n        if (matcher !== null) {\n          const file = matcher.findMatch(pkg.files, specifier);\n          return this.getESModule(ctx, file, pkg);\n        } else {\n          throw new Error(`Cannot resolve absolute file path without path mappings in tsconfig`);\n        }\n      } else {\n        this.logger.debug(`[ResolveImport] resolving external absolute module: '${$specifier['[[Value]]']}' for ${referencingModule.$file.name}`);\n\n        const externalPkg = pkg.loader.getCachedPackage(pkgDep.refName);\n        if (pkgDep.refName !== specifier) {\n          if (externalPkg.entryFile.shortName === specifier) {\n            return this.getESModule(ctx, externalPkg.entryFile, externalPkg);\n          }\n\n          let file = externalPkg.files.find(x => x.shortPath === externalPkg.dir && x.ext === '.js');\n          if (file === void 0) {\n            const indexModulePath = joinPath(externalPkg.dir, 'index');\n            file = externalPkg.files.find(f => f.shortPath === indexModulePath && f.ext === '.js');\n            if (file === void 0) {\n              const partialAbsolutePath = joinPath('node_modules', specifier);\n              file = externalPkg.files.find(f => f.shortPath.endsWith(partialAbsolutePath) && f.ext === '.js');\n              if (file === void 0) {\n                throw new Error(`Unable to resolve file \"${externalPkg.dir}\" or \"${indexModulePath}\" (refName=\"${pkgDep.refName}\", entryFile=\"${externalPkg.entryFile.shortPath}\", specifier=${specifier})`);\n              }\n            }\n          }\n\n          return this.getESModule(ctx, file, externalPkg);\n        } else {\n          return this.getESModule(ctx, externalPkg.entryFile, externalPkg);\n        }\n      }\n    }\n  }\n\n  public dispose(this: Writable<Partial<ServiceHost>>): void {\n    this.agent!.dispose();\n    this.agent = void 0;\n    this.compilerOptionsCache!.clear();\n    this.compilerOptionsCache = void 0;\n    for (const mod of this.moduleCache!.values()) {\n      mod.dispose();\n    }\n    this.moduleCache!.clear();\n    this.moduleCache = void 0;\n    this.container = void 0;\n  }\n\n  private loadEntryPackage(dir: string): Promise<NPMPackage> {\n    this.logger.trace(`loadEntryPackage(${dir})`);\n\n    const loader = this.container.get(NPMPackageLoader);\n\n    return loader.loadEntryPackage(dir);\n  }\n\n  private getHTMLModule(ctx: ExecutionContext, file: IFile, pkg: NPMPackage): $DocumentFragment {\n    let hm = this.moduleCache.get(file.path);\n    if (hm === void 0) {\n      const sourceText = file.getContentSync();\n      const template = this.jsdom.window.document.createElement('template');\n      template.innerHTML = sourceText;\n      hm = new $DocumentFragment(this.logger, file, template.content, ctx.Realm, pkg);\n\n      this.moduleCache.set(file.path, hm);\n    }\n\n    return hm as $DocumentFragment;\n  }\n\n  private getESScript(ctx: ExecutionContext, file: IFile): $ESScript {\n    let script = this.scriptCache.get(file.path);\n    if (script === void 0) {\n      const sourceText = file.getContentSync();\n      const sf = createSourceFile(file.path, sourceText, ScriptTarget.Latest, false);\n      script = new $ESScript(this.logger, file, sf, ctx.Realm);\n\n      this.scriptCache.set(file.path, script);\n    }\n\n    return script as $ESScript;\n  }\n\n  private getESModule(ctx: ExecutionContext, file: IFile, pkg: NPMPackage | null): $ESModule {\n    let esm = this.moduleCache.get(file.path);\n    if (esm === void 0) {\n      const compilerOptions = this.getCompilerOptions(file.path, pkg);\n      const sourceText = file.getContentSync();\n      const sf = createSourceFile(file.path, sourceText, ScriptTarget.Latest, false);\n      esm = new $ESModule(this.logger, file, sf, ctx.Realm, pkg, this, compilerOptions);\n\n      this.moduleCache.set(file.path, esm);\n    }\n\n    return esm as $ESModule;\n  }\n\n  private getCompilerOptions(path: string, pkg: NPMPackage | null): $CompilerOptions {\n    // TODO: this is a very simple/naive impl, needs more work for inheritance etc\n    path = normalizePath(path);\n\n    let compilerOptions = this.compilerOptionsCache.get(path);\n    if (compilerOptions === void 0) {\n      const dir = normalizePath(dirname(path));\n      if (dir === path || pkg === null/* TODO: maybe still try to find tsconfig? */) {\n        compilerOptions = {\n          __dirname: '',\n        };\n      } else {\n        const tsConfigPath = joinPath(path, 'tsconfig.json');\n        const tsConfigFile = pkg.files.find(x => x.path === tsConfigPath);\n        if (tsConfigFile === void 0) {\n          compilerOptions = this.getCompilerOptions(dir, pkg);\n        } else {\n          const tsConfigText = tsConfigFile.getContentSync();\n          // tsconfig allows some stuff that's not valid JSON, so parse it as a JS object instead\n          // eslint-disable-next-line no-new-func,@typescript-eslint/no-implied-eval\n          const tsConfigObj = new Function(`return ${tsConfigText}`)();\n          compilerOptions = tsConfigObj.compilerOptions;\n          if (compilerOptions === null || typeof compilerOptions !== 'object') {\n            compilerOptions = {\n              __dirname: tsConfigFile.dir,\n            };\n          } else {\n            (compilerOptions as Writable<$CompilerOptions>).__dirname = tsConfigFile.dir;\n          }\n        }\n      }\n\n      this.compilerOptionsCache.set(path, compilerOptions);\n    }\n\n    return compilerOptions;\n  }\n}\n"],"names":[],"mappings":"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"}